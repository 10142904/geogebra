/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.app;import java.awt.Color;import java.awt.Graphics;import com.quantimegroup.solutions.archimedean.utils.Axes;import com.quantimegroup.solutions.archimedean.utils.IntList;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;import com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix;import com.quantimegroup.solutions.archimedean.utils.Rotater;public class SpacePoly {	ObjectList points, originalPoints, sides, vectors, originalVectors;	Archimedean gui;	Axes personalAxes;	boolean dirtyPoints = true;	ObjectList rotaters = new ObjectList(5);	ObjectList drawChain;	OrderedTriple lightSource = new OrderedTriple(20000, -100000, 20000);	int type;	boolean showBackSides = false;	private boolean drawLine;	private static Color frontColor = Color.white, backColor = Color.gray, inColor = Color.lightGray;	ObjectList lines = new ObjectList(0, 10);	double minRad, maxRad;	boolean highlightCorners = false;	boolean[] cornersToShow;	IntList cornerIndexes = new IntList(0);	Color edgeColor = Color.black;	ArchiBuilder builder;	static boolean correctAxes = true;	private boolean showCircumscribedSphere;	private boolean showInscribedSphere;	private SpacePoly() {	};	public SpacePoly(Archimedean g, ArchiBuilder b, Axes a) {		this(g, b.points, b.sides, b.vectors, a);		builder = b;	}	public SpacePoly(Archimedean g, ArchiBuilder b) {		this(g, b.points, b.sides, b.vectors);		builder = b;	}	private SpacePoly(Archimedean g, ObjectList abpoints, ObjectList absides, ObjectList abvectors) {		this(g, abpoints, absides, abvectors, new Axes());	}	private SpacePoly(Archimedean g, ObjectList abpoints, ObjectList absides, ObjectList abvectors, Axes a) {		originalPoints = abpoints;		points = new ObjectList(originalPoints.num);		for (int i = 0; i < originalPoints.num; ++i) {			points.add(new SpacePoint((OrderedTriple) originalPoints.get(i)));		}		originalVectors = abvectors;		vectors = new ObjectList(originalVectors.num);		for (int i = 0; i < originalVectors.num; ++i) {			vectors.add(((OrderedTriple) originalVectors.get(i)).copy());		}		sides = absides.copy();		for (int i = 0; i < absides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			s.setOwner(this);			s.setPoints(points);			s.setVectors(vectors);		}		drawChain = new ObjectList(sides.num);		this.gui = g;		personalAxes = a;		cornersToShow = new boolean[points.num];		gui.repaint();	}	public void sizeToFit(int width, int height) {		personalAxes.sizeFactor = Math.min(width, height) * 0.9 / (builder.getMaxRadius() * 2);	}	public void update() {		for (int i = 0; i < points.num; ++i) {			SpacePoint p = (SpacePoint) points.get(i);			p.become((OrderedTriple) originalPoints.get(i));			personalAxes.transformPoint(p);		}		for (int i = 0; i < vectors.num; ++i) {			OrderedTriple v = (OrderedTriple) vectors.get(i);			v.become((OrderedTriple) originalVectors.get(i));			personalAxes.transformVector(v);		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				l.outs[j].become(l.originalOuts[j]);				personalAxes.transformPoint(l.outs[j]);				l.sects[j].become(l.originalSects[j]);				personalAxes.transformPoint(l.sects[j]);			}		}	}	public void toScreenCoord() {		update();		for (int i = 0; i < points.num; ++i) {			((SpacePoint) points.get(i)).toScreenCoord();		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				l.outs[j].toScreenCoord();				l.sects[j].toScreenCoord();			}		}		dirtyPoints = false;	}	public void draw(Graphics g) {		ObjectList frontSides = new ObjectList(sides.num);		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				if (!l.visible(j))					drawLine(l.sects[j], l.outs[j], g, backColor);			}		}		for (int i = 0; i < points.num; ++i) {			cornersToShow[i] = false;		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			if (s == null) {				continue;			}			s.update();			if (s.visible()) {				frontSides.add(s);				for (int j = 0; j < s.numPoints(); ++j) {					cornersToShow[s.getIndex(j)] = true;				}			} else {				s.draw(g, true);			}		}		if (highlightCorners) {			for (int i = 0; i < cornerIndexes.num; ++i) {				int j = cornerIndexes.get(i);				if (!cornersToShow[j])					fillCircle(g, (SpacePoint) points.get(j), 4, backColor);			}		}		if (showInscribedSphere){			minRad = getMinRadius();			drawSphere(g, minRad, inColor);		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			drawLine(l.sects[0], l.sects[1], g, inColor);		}		for (int i = 0; i < frontSides.num; ++i) {			SpaceSide s = (SpaceSide) frontSides.get(i);			s.draw(g, true);		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				if (l.visible(j))					drawLine(l.sects[j], l.outs[j], g, frontColor);			}		}		if (showCircumscribedSphere){			maxRad = getMaxRadius();			drawSphere(g, maxRad, frontColor);		}		if (highlightCorners) {			for (int i = 0; i < cornerIndexes.num; ++i) {				int j = cornerIndexes.get(i);				if (cornersToShow[j])					fillCircle(g, (SpacePoint) points.get(j), 4, frontColor);			}		}	}	void fillCircle(Graphics g, SpacePoint center, int radius, Color c) {		g.setColor(c);		double a = SpacePoint.viewer.y;		double b = center.y;		int r = (int) (a * radius / (a - b));		g.fillOval(center.screenx - r + 1, center.screeny - r + 1, r * 2, r * 2);	}	void drawLine(SpacePoint p1, SpacePoint p2, Graphics g, Color color) {		g.setColor(color);		g.drawLine(p1.screenx + 1, p1.screeny + 1, p2.screenx + 1, p2.screeny + 1);	}	void drawSphereOld(Graphics g, double r, Color c) {		double D = SpacePoint.viewer.length();		r *= personalAxes.sizeFactor;		double d = Math.sqrt(D * D - r * r);		double x = r * d / D;		double y = r * r / D;		SpacePoint p = new SpacePoint(-x, -y, 0);		p.toScreenCoord();		int w = gui.viewerCanvas.size().width - p.screenx * 2;		int h = gui.viewerCanvas.size().height - p.screenx * 2;		g.setColor(c);		g.drawOval(p.screenx, p.screenx, w + 1, h + 1);	}	void drawSphere(Graphics g, double r, Color c) {		double D = SpacePoint.viewer.length();		double C = Math.sqrt(D * D - r * r);		double B = r * D / C;		// r *= personalAxes.sizeFactor;		double d = Math.sqrt(D * D - r * r);		double x = r * d / D;		double y = r * r / D;		SpacePoint p = new SpacePoint(-B, 0, B);		p.toScreenCoord();		int w = gui.viewerCanvas.size().width - p.screenx * 2;		int h = gui.viewerCanvas.size().height - p.screeny * 2;		g.setColor(c);		g.drawOval(p.screenx, p.screeny, w + 1, h + 1);	}	public void render(Graphics g) {		for (int i = 0; i < points.num; ++i) {			cornersToShow[i] = false;		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			s.setDrawn(false);			s.update();		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				if (!l.visible(j))					drawLine(l.sects[j], l.outs[j], g, backColor);			}		}		if (showBackSides) {			ObjectList frontSides = new ObjectList(sides.num);			for (int i = 0; i < sides.num; ++i) {				SpaceSide s = (SpaceSide) sides.get(i);				if (s.visible()) {					frontSides.add(s);					for (int j = 0; j < s.numPoints(); ++j) {						cornersToShow[s.getIndex(j)] = true;					}				} else {					drawChain.num = 0;					s.render(g);				}			}			if (highlightCorners) {				for (int i = 0; i < cornerIndexes.num; ++i) {					int j = cornerIndexes.get(i);					if (!cornersToShow[j])						fillCircle(g, (SpacePoint) points.get(j), 4, backColor);				}			}			if (showCircumscribedSphere) {				maxRad = getMaxRadius();				drawSphere(g, maxRad, frontColor);			}			for (int i = 0; i < lines.num; ++i) {				Line l = (Line) lines.get(i);				drawLine(l.sects[0], l.sects[1], g, inColor);			}			for (int i = 0; i < frontSides.num; ++i) {				SpaceSide s = (SpaceSide) frontSides.get(i);				drawChain.num = 0;				s.render(g);			}			if (showInscribedSphere) {				minRad = getMinRadius();				drawSphere(g, minRad, backColor);			}		} else {			if (showCircumscribedSphere) {				maxRad = getMaxRadius();				drawSphere(g, maxRad, frontColor);			}			for (int i = 0; i < sides.num; ++i) {				SpaceSide s = (SpaceSide) sides.get(i);				if (s.visible()) {					drawChain.num = 0;					s.render(g);					for (int j = 0; j < s.numPoints(); ++j) {						cornersToShow[s.getIndex(j)] = true;					}				}			}			if (showInscribedSphere) {				minRad = getMinRadius();				drawSphere(g, minRad, backColor);			}		}		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				if (l.visible(j))					drawLine(l.sects[j], l.outs[j], g, frontColor);			}		}		if (highlightCorners) {			for (int i = 0; i < cornerIndexes.num; ++i) {				int j = cornerIndexes.get(i);				if (cornersToShow[j])					fillCircle(g, (SpacePoint) points.get(j), 4, frontColor);			}		}	}	public void rotate(OrderedTriple p0, OrderedTriple n0, OrderedTriple p1, OrderedTriple n1) {		// rotate around origin to bring p0 -> n0 and p1 -> n1		Quick3X3Matrix M = Quick3X3Matrix.findRotationMatrix(p0, n0, p1, n1);		personalAxes.timesEquals(M);		if (correctAxes)			personalAxes.correct();		for (int i = 0; i < rotaters.num; ++i) {			Rotater ri = (Rotater) rotaters.objects[i];			ri.update(M);		}		dirtyPoints = true;	}	public void rotate(OrderedTriple p0, OrderedTriple n0) {		// rotate around origin to bring p0 -> n0		Quick3X3Matrix M = Quick3X3Matrix.findRotationMatrix(p0, n0);		personalAxes.timesEquals(M);		if (correctAxes)			personalAxes.correct();		for (int i = 0; i < rotaters.num; ++i) {			Rotater ri = (Rotater) rotaters.objects[i];			ri.update(M);		}		dirtyPoints = true;	}	public void translate() {		personalAxes.origin.plusEquals(new OrderedTriple(1, 0, 0));		dirtyPoints = true;	}	public ObjectList getPoints() {		return points;	}	void addLine(OrderedTriple p1, OrderedTriple p2, double length) {		lines.add(new Line(p1, p2, this, length));	}	void sizeLinesProportionally(double factor) {		for (int i = 0; i < lines.num; ++i) {			Line l = (Line) lines.get(i);			for (int j = 0; j < 2; ++j) {				l.originalSects[j].timesEquals(factor);				l.originalOuts[j].timesEquals(factor);			}		}	}	double getMaxRadius() {		double max = 0;		for (int i = 0; i < points.num; ++i) {			OrderedTriple p = (OrderedTriple) points.get(i);			max = Math.max(max, p.length());		}		return max;	}	double getMinRadius() {		double minRad = Double.MAX_VALUE;		OrderedTriple origin = OrderedTriple.origin();		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			OrderedTriple[] p = s.threeDistinctPoints();			try {				double rad = OrderedTriple.pointPlaneDistance(origin, p[0], p[1], p[2]);				if (rad < minRad) {					minRad = rad;				}			} catch (Exception ignore) {			}		}		return minRad;	}	SpacePoint getPoint(int i) {		return (SpacePoint) points.wrapget(i);	}	OrderedTriple getOriginalPoint(int i) {		return (OrderedTriple) originalPoints.wrapget(i);	}	SpacePoint getBoundaryPoint(int whichBoundary, int i) {		return getPoint(((IntList) builder.multipleBoundary.get(whichBoundary)).wrapget(i));	}	OrderedTriple getOriginalBoundaryPoint(int whichBoundary, int i) {		return getOriginalPoint(((IntList) builder.multipleBoundary.get(whichBoundary)).wrapget(i));	}	SpaceSide getSide(int i) {		return (SpaceSide) sides.get(i);	}	public void toggleCircumscribedSphere() {		showCircumscribedSphere = !showCircumscribedSphere;	}	public void toggleInscribedSphere() {		showInscribedSphere = !showInscribedSphere;	}	public boolean isShowCircumscribedSphere() {		return showCircumscribedSphere;	}	public void setShowCircumscribedSphere(boolean showCircumscribedSphere) {		this.showCircumscribedSphere = showCircumscribedSphere;	}	public boolean isShowInscribedSphere() {		return showInscribedSphere;	}	public void setShowInscribedSphere(boolean showInscribedSphere) {		this.showInscribedSphere = showInscribedSphere;	}}