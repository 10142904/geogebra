/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.app;import java.util.List;import com.quantimegroup.solutions.archimedean.common.SolidDefinition;import com.quantimegroup.solutions.archimedean.utils.IntList;import com.quantimegroup.solutions.archimedean.utils.Misc;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;public class ArchiBuilder {	ObjectList firstSides, points, sides, corners, vectors, nonUpdatingPoints;	boolean ambiguous = false;	int ambiguousPoly = 0;	double edgeLength = 100;	int type;	int[] signature;	private static double maxError = 0;	private boolean untwist = true;	private ObjectList boundaries;	private IntList boundary;	ObjectList multipleBoundary;	private static final boolean VERBOSE = false;	// original	private static double REGISTER_POINT_EPSILON = 1e-8;	private static double COMMIT_EPSILON = 1e-5;	private static double FIND_APPROX_POINT_EPSILON = 1e-2;	static ArchiBuilder manualArchiBuilder(int[] polyTypes, int numPolys) {		ArchiBuilder starter = new ArchiBuilder();		starter.maxError = 0;		starter.type = ExtendedSolidDefinition.getSolidType(polyTypes, numPolys);		starter.points = new ObjectList(10000);		starter.corners = new ObjectList(10000);		starter.vectors = new ObjectList(10000);		starter.sides = new ObjectList(10000);		try {			starter.createFirstSides(polyTypes, numPolys);			starter.getAmbiguous();			double poleTheta = ArchiCorner.init(starter.firstSides, starter.edgeLength);			ArchiCorner.createFirstCorner(starter.firstSides, starter.edgeLength, numPolys, poleTheta, starter, false);			ArchiCorner c = starter.getCorner(0);			OrderedTriple P1 = c.getHubPoint().mid(c.getSpoke(0));			OrderedTriple n = c.getHubPoint().minus(c.getSpoke(0));			OrderedTriple perp = n.arbitraryPerpendicular();			OrderedTriple P2 = P1.plus(perp);			OrderedTriple P3 = P1.plus(perp.cross(n));			OrderedTriple L1 = new OrderedTriple(0, 100, 0);			OrderedTriple L2 = OrderedTriple.origin();			OrderedTriple center = OrderedTriple.sectPlaneLine(P1, P2, P3, L1, L2);			for (int i = 0; i < starter.points.num; ++i) {				OrderedTriple p = starter.getPoint(i);				p.minusEquals(center);				if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))					p.x = 0;				if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))					p.y = 0;				if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))					p.z = 0;			}			starter.calcBoundary();		} catch (java.lang.Exception e) {			starter.center();			starter.type = ExtendedSolidDefinition.UNDEFINED;			System.out.println(e.getMessage());		}		return starter;	}	// TODO Need to design a better data converter between archimedean and	// geogebra	public void getPoints(List<OrderedTriple> pointList) {		for (int i = 0; i < points.num; ++i) {			pointList.add(new OrderedTriple((OrderedTriple) points.get(i)));		}	}	// TODO Need to design a better data converter between archimedean and	// geogebra	public void getSides(List<SpaceSide> sideList) {		for (int i = 0; i < sides.num; ++i) {			sideList.add((SpaceSide) sides.get(i));		}	}	boolean calcBoundary() {		multipleBoundary = new ObjectList(0, 1);		IntList edges1 = new IntList(0, 10);		IntList edges2 = new IntList(0, 10);		for (int a = 0; a < sides.num; ++a) {// for every side			SpaceSide sa = getSide(a);			for (int b = 0; b < sa.numPoints(); ++b) {// for every clockwize edge of				// that side				int i1 = sa.getIndex(b);				int i2 = sa.wrapgetIndex(b + 1);				boolean found = false;				for (int c = 0; c < sides.num; ++c) {// for every other side					if (c == a)						continue;// not the first side					SpaceSide sc = getSide(c);					if (sc.findIndex(i1) != -1 && sc.findIndex(i2) != -1) {// if it has						// this edge						found = true;						break;					}				}				if (!found) {					edges1.add(i1);					edges2.add(i2);				}			}		}		if (edges1.num == 0)			return false;		do {			IntList curBoundary = new IntList(10, 5);			int p = edges1.get(0);			do {				curBoundary.add(p);				int i = edges1.find(p);				p = edges2.get(i);				edges1.removeIndex(i);				edges2.removeIndex(i);			} while (p != curBoundary.get(0));			multipleBoundary.add(curBoundary);		} while (edges1.num > 0);		// boundary = (IntList)multipleBoundary.get( 0 );		return true;	}	public ArchiBuilder() {	}	public ArchiBuilder(int[] polyTypes) {		this(polyTypes, polyTypes.length);	}	public ArchiBuilder(int[] polyTypes, int numPolys) {		this(polyTypes, numPolys, true);	}	public ArchiBuilder(int[] polyTypes, int numPolys, boolean untwist) {		this.untwist = untwist;		maxError = 0;		type = ExtendedSolidDefinition.getSolidType(polyTypes, numPolys);		points = new ObjectList(10000);		corners = new ObjectList(10000);		vectors = new ObjectList(10000);		sides = new ObjectList(10000);		try {			createFirstSides(polyTypes, numPolys);			getAmbiguous();			double poleTheta = ArchiCorner.init(firstSides, edgeLength);			ArchiCorner.createFirstCorner(firstSides, edgeLength, numPolys, poleTheta, this);			if (ambiguous && !isComplete()) {				recurse(numPolys, poleTheta);			}			if (corners.num != points.num)				type = ExtendedSolidDefinition.RATIONAL;			// center();		} catch (java.lang.Exception e) {			// center();			type = ExtendedSolidDefinition.UNDEFINED;			System.out.println(e.getMessage());		}		center();		if (VERBOSE) {			System.out.println("corners: " + corners.num + ", points: " + points.num + ", ratio: " + ((double) corners.num) / points.num);		}		signature = getCorner(0).getSignature();		// print();	}	public void recurse(int numSpokes, double poleTheta) throws Exception {		SpaceSide s1 = null, s2 = null;		OrderedTriple newHub = null;		int hubIndex, s1index, s2index;		for (int c = 0; c < corners.num; ++c) {// these two loops find the first			// uncompleted corner			ArchiCorner curCorner = (ArchiCorner) corners.get(c);			for (int s = 0; s < curCorner.getSpokes().num; ++s) {				newHub = (OrderedTriple) curCorner.getSpoke(s);				hubIndex = curCorner.getSpokes().get(s);				s1 = curCorner.wrapgetSide(s);				s1index = curCorner.getSides().get(s);				s2 = curCorner.wrapgetSide(s - 1);				s2index = curCorner.getSides().wrapget(s - 1);				if (cornerIsBuilt(hubIndex, s1index, s2index) == -1) {					s = curCorner.getSpokes().num;					c = corners.num;					break;				}			}		}		ArchiCorner c = ArchiCorner.simpleCorner(newHub, s1, s2, numSpokes, poleTheta, this);// hub,		// 3		// spokes,		// pole		State state = getState();		for (int nextPosition = c.getFirstSides(s1, s2, 0, numSpokes);; nextPosition = c.getFirstSides(s1, s2, nextPosition, numSpokes)) {			try {				c.complete(numSpokes, poleTheta, 0);				if (isComplete())					break;				recurse(numSpokes, poleTheta);				if (isComplete())					break;			} catch (Exception e) {				setState(state);				c.getSpokes().num = 3;				c.getSides().num = 0;				continue;			}		}	}	public boolean isComplete() throws Exception {		if (points.num == corners.num)			return true;		if (untwist == true) {			int[] sign = getCorner(0).getSignature();			int[] bug = {					3, 4, 4, 4 };			if (Misc.arrayCompare(sign, bug) != 0)				return false;			// if( any square has only 1 triangle )			int numNeighbors = 0;			int numTriangles = 0;			for (int i = 0; i < sides.num; ++i) {				SpaceSide si = getSide(i);				if (si.numPoints() != 4)					continue;				numNeighbors = 0;				numTriangles = 0;				for (int j = 0; j < sides.num; ++j) {					if (j == i)						continue;					SpaceSide sj = getSide(j);					if (si.isAdjacent(sj)) {						++numNeighbors;						if (sj.numPoints() == 3)							numTriangles++;					}				}				if (numNeighbors == 4 && numTriangles == 1)					throw new Exception("3444 exception");			}		}		return false;	}	void getAmbiguous() {		ambiguous = false;		ambiguousPoly = 0;		int p1, p2, p3, curPoly;		p1 = p2 = p3 = curPoly = 0;		for (int i = 0; i < firstSides.num + 2; ++i) {			ObjectList s = (ObjectList) firstSides.wrapget(i);			p3 = s.num;			if (p3 == p2 && p3 == p1) {				ambiguousPoly = p3;				ambiguous = true;				break;			} else {				p1 = p2;				p2 = p3;				curPoly = p1;			}		}		if (ambiguous) {			for (int i = 0; i < firstSides.num; ++i) {				ObjectList s = (ObjectList) firstSides.get(i);				if (s.num != ambiguousPoly) {					return;				}			}			ambiguous = false;		}	}	void createFirstSides(int[] polyTypes, int numPolys) throws Exception {		firstSides = new ObjectList(numPolys);		for (int i = 0; i < numPolys; ++i) {			ObjectList s = SpaceSide.createPoly(polyTypes[i], edgeLength);			firstSides.add(s);		}	}	int registerPointExactMatch(OrderedTriple p) {// adds point if it isn't		// already there, returns it or		// the one it found		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = getPoint(i);			if (curp.getClass() == pClass && p.equals(curp))				return i;		}		return points.add(p);	}	int registerPoint(OrderedTriple p) throws Exception {// adds point if it		// isn't already there,		// returns it or the one		// it found		if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))			p.x = 0;		if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))			p.y = 0;		if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))			p.z = 0;		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = (OrderedTriple) points.get(i);			if (curp.getClass() == pClass) {				if (p.distanceSquared(curp) < REGISTER_POINT_EPSILON) {// if it's					// extremely					// close to a					// point					double error = p.distance(curp);					if (error > maxError)						maxError = error;					return i;				}				if (ambiguous && p.distance(curp) < edgeLength * 0.99)// if it's too far					// to be the same					// but too close					// to be					// legitimate					throw new Exception("EXCEPTION: overlapping sides.");			}		}		return points.add(p);	}	static int findApproxPoint(OrderedTriple p, ObjectList l) {		for (int i = 0; i < l.num; ++i) {			OrderedTriple curp = (OrderedTriple) l.get(i);			if (curp.isApprox(p, FIND_APPROX_POINT_EPSILON))				return i;		}		return -1;	}	int registerCorner(ArchiCorner c) {		return corners.add(c);	}	int registerSide(SpaceSide s) {		OrderedTriple n = s.calcNormal();		s.setNormal(vectors.add(n));		return sides.add(s);	}	int cornerIsBuilt(int p, int s1i, int s2i) {		SpaceSide s1 = getSide(s1i);		SpaceSide s2 = getSide(s2i);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = (ArchiCorner) corners.get(i);			if (c.getHub() == p) {				for (int j = 0; j < c.getSides().num; ++j) {					if (c.getSide(j) == s1 && c.wrapgetSide(j + 1) == s2)						return 1;				}			}		}		return -1;	}	int sideIsBuilt(OrderedTriple p1, OrderedTriple p2, OrderedTriple p3) {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			int index = s.findPoint(p1);			if (index != -1 && s.wrapgetPoint(index + 1) == p2 && s.wrapgetPoint(index + 2) == p3)				return i;		}		return -1;	}	ArchiCorner findCorner(OrderedTriple h) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (h == c.getHubPoint())				return c;		}		return null;	}	void center() {		ArchiCorner c = (ArchiCorner) corners.get(0);		OrderedTriple p1 = c.getHubPoint();		OrderedTriple p2 = p1.plus(c.getPole());		c = (ArchiCorner) corners.get(1);		OrderedTriple p3 = c.getHubPoint();		OrderedTriple p4 = p3.plus(c.getPole());		OrderedTriple center = OrderedTriple.sectLines(p1, p2, p3, p4);		for (int i = 0; i < points.num; ++i) {			OrderedTriple p = (OrderedTriple) points.get(i);			p.minusEquals(center);			if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))				p.x = 0;			if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))				p.y = 0;			if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))				p.z = 0;		}	}	SpaceSide getSide(int i) {		return (SpaceSide) sides.get(i);	}	SpaceSide wrapgetSide(int i) {		return (SpaceSide) sides.wrapget(i);	}	ArchiCorner getCorner(int i) {		return (ArchiCorner) corners.get(i);	}	ArchiCorner wrapgetCorner(int i) {		return (ArchiCorner) corners.wrapget(i);	}	OrderedTriple getPoint(int i) {		return (OrderedTriple) points.get(i);	}	OrderedTriple wrapgetPoint(int i) {		return (OrderedTriple) points.wrapget(i);	}	void print() {		System.out.println("points.num = " + (points == null ? "null" : String.valueOf(points.num)));		System.out.println("corners.num = " + (corners == null ? "null" : String.valueOf(corners.num)));		System.out.println("sides.num = " + (sides == null ? "null" : String.valueOf(sides.num)));		System.out.println("vectors.num = " + (vectors == null ? "null" : String.valueOf(vectors.num)));		System.out.println("edgeLength = " + edgeLength);		// System.out.println( "maxEdgeLength = " + maxEdgeLength );		System.out.println();	}	double truncStage1() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide s = c.getSide(0);		double l = s.getEdgeLength();		double theta = ArchiCorner.polyAngle(s.numPoints());		double x = l / (2 * Math.sin(theta / 2) + 2);// distance along a spoke		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).unit().times(x);// vector		// with		// length		// x		return pole.comp(v) / radius * 100;	}	double truncStage2() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).dividedBy(2);		return pole.comp(v) / radius * 100;	}	double truncStage3() {		// double radius = getRadius();		double radius = getMinRadius();		ArchiCorner corner = getCorner(0);		OrderedTriple pole = corner.getPole();		SpaceSide s0 = corner.getSide(0);		SpaceSide s1 = corner.getSide(1);		OrderedTriple a, b, c, d, e, f, g, x, y, z, S, T, U;		double K, A, B, C, roots[];		a = corner.getHubPoint().mid(corner.getSpoke(0));		b = corner.getHubPoint().mid(corner.getSpoke(1));		c = s0.getCenter();		d = s1.getCenter();		x = c.minus(a);		y = c.minus(b);		z = d.minus(b);		S = b.minus(a);		T = y.minus(x);		U = y.minus(z);		A = T.lengthSquared() - U.lengthSquared();		B = 2 * S.dot(T);		C = S.lengthSquared();		try {			roots = OrderedTriple.solveQuadratic(A, B, C);		} catch (Exception exc) {			return 0;		}		if (roots.length == 1)			K = roots[0];		else if (roots.length == 3)			K = roots[2];		else if (roots[0] > 0 && roots[0] < 1)			K = roots[0];		else			K = roots[1];		OrderedTriple p = a.plus(x.times(K));		OrderedTriple v = p.minus(corner.getHubPoint());		return pole.comp(v) / radius * 100;	}	double truncStage4() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide s = c.getSide(0);		OrderedTriple center = s.getCenter();		OrderedTriple v = center.minus(c.getHubPoint());		return pole.comp(v) / radius * 100;	}	double[] calcEdgeTruncStages() {		double ts[] = new double[5];		ts[0] = 0;		int numStages = 1;		// double radius = getPoint( 0 ).length();		ArchiCorner c = getCorner(0);		OrderedTriple truncVector;		SpaceSide minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				SpaceSide s = c.getSide(i);				if (s.numPoints() > lastMinPoints && (minSide == null || s.numPoints() < minSide.numPoints())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple p1 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()));			OrderedTriple p2 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()) + 1);			OrderedTriple mid = p1.mid(p2);			truncVector = mid.negative();			double radius = mid.length();			OrderedTriple center = minSide.getCenter();			OrderedTriple v = center.minus(mid);			ts[numStages] = truncVector.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.numPoints();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	double[] calcArchiTruncStages(int[] polys, int numPolys) {		double ts[] = new double[5];		ts[0] = 0;		ts[1] = truncStage2();		int numStages = 2;		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				SpaceSide s = c.getSide(i);				if (s.numPoints() > lastMinPoints && (minSide == null || s.numPoints() < minSide.numPoints())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple center = minSide.getCenter();			OrderedTriple v = center.minus(c.getHubPoint());			ts[numStages] = pole.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.numPoints();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	double[] calcTruncStages() {		double[] result = null;		ArchiCorner c = getCorner(0);		int[] polys = new int[c.getSpokes().num];		for (int i = 0; i < polys.length; ++i) {			polys[i] = c.getSide(i).numPoints();		}		switch (ExtendedSolidDefinition.getSolidType(polys)) {		case ExtendedSolidDefinition.PLATONIC:			double[] temp1 = {					0, truncStage1(), truncStage2(), truncStage3(), truncStage4() };			result = temp1;			break;		case ExtendedSolidDefinition.ARCHIMEDEAN:			result = calcArchiTruncStages(polys, polys.length);			break;		}		return result;	}	int findCornerByHub(int h) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (c.getHub() == h)				return i;		}		return -1;	}	void prepareGoals(ArchiBuilder trunc, IntList starts, int[][] mids, IntList centers, int numSpokes) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			int h = c.getHub();			OrderedTriple hp = c.getHubPoint().copy();			starts.add(trunc.nonUpdatingPoints.add(hp));			for (int j = 0; j < numSpokes; ++j) {				int s = c.getSpokes().get(j);				if (s > h) {					ArchiCorner c2 = getCorner(findCornerByHub(s));					int j2 = c2.getSpokes().find(h);					mids[h][j] = mids[s][j2] = trunc.nonUpdatingPoints.add(hp.mid(c.getSpoke(j)));				}			}		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			centers.add(trunc.nonUpdatingPoints.add(s.getCenter()));		}	}	ArchiBuilder prepareCornerTrunc() {		int numSpokes = getCorner(0).getSpokes().num;		ArchiBuilder trunc = new ArchiBuilder();		trunc.type = type;		trunc.points = new ObjectList(corners.num * numSpokes * 2);		trunc.nonUpdatingPoints = new ObjectList(corners.num + (corners.num * numSpokes) / 2 + sides.num + 1);		trunc.sides = new ObjectList(sides.num + corners.num);		trunc.vectors = new ObjectList(sides.num + corners.num);		TruncablePoint.init(trunc);		IntList starts = new IntList(corners.num);		int[][] mids = new int[corners.num][numSpokes];		IntList centers = new IntList(sides.num);		prepareGoals(trunc, starts, mids, centers, numSpokes);		OrderedTriple[] goals = new OrderedTriple[3];		int[] g = new int[3];		goals[2] = new OrderedTriple(0, 0, 0);		g[2] = trunc.nonUpdatingPoints.add(goals[2]);		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			TruncableSpaceSide truncSide = new TruncableSpaceSide(s.numPoints() * 2);			truncSide.cornerSide = false;			truncSide.getIndex().num = s.numPoints() * 2;			trunc.sides.add(truncSide);			truncSide.setNormal(trunc.vectors.add(s.getNormal()));		}		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			TruncableSpaceSide truncSide = new TruncableSpaceSide(c.getSpokes().num * 2);			truncSide.cornerSide = true;			int h = starts.get(i);			OrderedTriple hp = (OrderedTriple) trunc.nonUpdatingPoints.get(h);			for (int j = 0; j < c.getSpokes().num; ++j) {				TruncablePoint tp = new TruncablePoint(hp, h);				g[0] = mids[c.getHub()][j];				goals[0] = (OrderedTriple) trunc.nonUpdatingPoints.get(g[0]);				g[1] = centers.get(c.getSides().wrapget(j - 1));				goals[1] = (OrderedTriple) trunc.nonUpdatingPoints.get(g[1]);				tp.setGoals(goals, g);				int tpIndex1 = trunc.points.add(tp);				truncSide.getIndex().add(tpIndex1);				tp = new TruncablePoint(hp, h);				g[1] = centers.get(c.getSides().get(j));				goals[1] = (OrderedTriple) trunc.nonUpdatingPoints.get(g[1]);				tp.setGoals(goals, g);				int tpIndex2 = trunc.points.add(tp);				truncSide.getIndex().add(tpIndex2);				SpaceSide flankSide = c.wrapgetSide(j - 1);				int flankSideIndex = c.getSides().wrapget(j - 1);				SpaceSide truncSide2 = trunc.getSide(flankSideIndex);				int foundHubIndex = flankSide.getIndex().find(c.getHub());				truncSide2.getIndex().set(foundHubIndex * 2, tpIndex1);				flankSideIndex = c.getSides().get(j);				flankSide = c.getSide(j);				foundHubIndex = flankSide.getIndex().find(c.getHub());				truncSide2 = trunc.getSide(flankSideIndex);				truncSide2.getIndex().set(foundHubIndex * 2 + 1, tpIndex2);			}			truncSide.setNormal(trunc.vectors.add(new OrderedTriple(hp)));			trunc.sides.add(truncSide);		}		trunc.reclaim();		trunc.signature = signature;		return trunc;	}	ArchiBuilder dual() {		ArchiBuilder dual = new ArchiBuilder();		dual.sides = new ObjectList(corners.num);		dual.points = new ObjectList(sides.num);		dual.points.num = sides.num;		dual.vectors = new ObjectList(corners.num);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			OrderedTriple pole = c.getPole();			OrderedTriple h = c.getHubPoint();			for (int j = 0; j < c.getSides().num; ++j) {				int s = c.getSides().get(j);				if (dual.getPoint(s) != null)					continue;				OrderedTriple spoke1 = c.getSpoke(j);				OrderedTriple spoke2 = c.wrapgetSpoke(j + 1);				OrderedTriple spokev1 = spoke1.minus(h);				OrderedTriple spokev2 = spoke2.minus(h);				OrderedTriple v1 = spokev1.cross(pole);				OrderedTriple v2 = spokev2.cross(pole);				OrderedTriple m1 = h.mid(spoke1);				OrderedTriple m2 = h.mid(spoke2);				dual.points.set(s, OrderedTriple.sectLines(m1, m1.plus(v1), m2, m2.plus(v2)));			}			TruncableSpaceSide s = new TruncableSpaceSide(c.getSpokes().num);			s.setIndex(c.getSides().copy());			s.setPoints(dual.points);			s.setVectors(dual.vectors);			s.setNormal(dual.vectors.add(s.calcNormal()));			s.cornerSide = true;			dual.sides.add(s);		}		if (type == ExtendedSolidDefinition.PLATONIC)			dual.type = ExtendedSolidDefinition.PLATONIC;		else			dual.type = ExtendedSolidDefinition.DUAL;		dual.signature = signature;		return dual;	}	ArchiBuilder antiDual() {		ArchiBuilder antiDual = new ArchiBuilder();		antiDual.sides = new ObjectList(corners.num);		antiDual.points = new ObjectList(sides.num);		antiDual.vectors = new ObjectList(corners.num);		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			antiDual.points.add(SpaceSide.getIncenter(s.getPoint(0), s.getPoint(1), s.getPoint(2), s.wrapgetPoint(3)));		}		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			TruncableSpaceSide s = new TruncableSpaceSide(c.getSpokes().num);			s.setIndex(c.getSides().copy());			s.setPoints(antiDual.points);			s.setVectors(antiDual.vectors);			s.setNormal(antiDual.vectors.add(s.calcNormal()));			s.cornerSide = true;			antiDual.sides.add(s);		}		ArchiCorner c = getCorner(0);		IntList spokes = c.getSpokes();		OrderedTriple p1 = c.getHubPoint();		OrderedTriple p2 = c.getSpoke(1);		int s1 = c.getSides().get(0);		OrderedTriple p3 = antiDual.getPoint(s1);		int s2 = c.getSides().get(1);		OrderedTriple p4 = antiDual.getPoint(s2);		OrderedTriple origin = new OrderedTriple(0, 0, 0);		double dist = OrderedTriple.sectPlaneLine(p3, p4, origin, p1, p2).length();		double dualDist = OrderedTriple.sectPlaneLine(p1, p2, origin, p3, p4).length();		double ratio = dist / dualDist;		for (int i = 0; i < antiDual.points.num; ++i) {			antiDual.getPoint(i).timesEquals(ratio);		}		antiDual.signature = signature;		antiDual.type = ExtendedSolidDefinition.ARCHIMEDEAN;// sometimes it will be		// GUI.PLATONIC		return antiDual;	}	ArchiBuilder prepareEdgeTrunc() {		int numSpokes = getCorner(0).getSpokes().num;		// set up trunc		ArchiBuilder trunc = new ArchiBuilder();		trunc.type = type;		int numPoints = points.num;		int numSides = 0;		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			numPoints += s.numPoints();			numSides += s.numPoints();		}		numSides = numSides / 2 + sides.num;		trunc.points = new ObjectList(numPoints);		trunc.sides = new ObjectList(numSides);		trunc.vectors = new ObjectList(numSides);		trunc.nonUpdatingPoints = new ObjectList(1 + sides.num + points.num);		EdgeTruncablePoint.init(trunc);		// fill in the non-updating points		for (int i = 0; i < points.num; ++i) {			trunc.nonUpdatingPoints.add(new OrderedTriple(getPoint(i)));		}		int origin = trunc.nonUpdatingPoints.add(new OrderedTriple(0, 0, 0));		IntList centers = new IntList(sides.num);		for (int i = 0; i < sides.num; ++i) {			centers.add(trunc.nonUpdatingPoints.add(getSide(i).getCenter()));		}		// calculate cornerSpeed and create the corner truncing points		ArchiCorner corner = getCorner(0);		OrderedTriple edgev = corner.getHubPoint().mid(corner.getSpoke(0)).negative();		OrderedTriple cornerv = corner.getHubPoint().negative();		// double cornerSpeed = 1/edgev.cos( cornerv );		double totalDist = edgev.length();		for (int i = 0; i < points.num; ++i) {			// trunc.points.add( new EdgeTruncablePoint( getPoint( i ), i, origin,			// cornerSpeed ) );			trunc.points.add(new EdgeTruncablePoint(getPoint(i), i, origin));		}		// create the side-sides		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			TruncableSpaceSide truncSide = new TruncableSpaceSide(s.numPoints());			truncSide.cornerSide = false;			OrderedTriple center = s.getCenter();			OrderedTriple sidev1 = center.minus(s.getPoint(0));			OrderedTriple sidev2 = center.negative();			edgev = s.getPoint(0).mid(s.getPoint(1)).negative();			double[] speeds = {					1 / edgev.cos(sidev1), 1 / edgev.cos(sidev2) };			for (int j = 0; j < s.numPoints(); ++j) {				EdgeTruncablePoint p = new EdgeTruncablePoint(s.getPoint(j), s.getIndex(j), centers.get(i), origin, speeds, totalDist);				truncSide.getIndex().add(trunc.points.add(p));			}			truncSide.setNormal(trunc.vectors.add(s.getNormal()));			trunc.sides.add(truncSide);		}		// create the edge-sides		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			for (int j = 0; j < numSpokes; ++j) {				OrderedTriple spoke = c.getSpoke(j);				if (c.getHubPoint().sortOrder(spoke) == 1) {					TruncableSpaceSide truncSide = new TruncableSpaceSide(6);					truncSide.setPoints(trunc.points);					truncSide.setVectors(trunc.points);					truncSide.cornerSide = true;					int hub = c.getHub();					truncSide.getIndex().add(hub);					SpaceSide s1 = c.wrapgetSide(j - 1);					int sindex = sides.find(s1);					int pindex = s1.getIndex().find(hub);					truncSide.getIndex().add(trunc.getSide(sindex).getIndex(pindex));					truncSide.getIndex().add(trunc.getSide(sindex).wrapgetIndex(pindex - 1));					pindex = points.find(spoke);					truncSide.getIndex().add(pindex);					SpaceSide s2 = c.wrapgetSide(j);					sindex = sides.find(s2);					pindex = s2.findPoint(spoke);					truncSide.getIndex().add(trunc.getSide(sindex).getIndex(pindex));					truncSide.getIndex().add(trunc.getSide(sindex).wrapgetIndex(pindex - 1));					truncSide.neighbors[0] = 0;					truncSide.neighbors[1] = 6;					truncSide.neighbors[2] = 6;					truncSide.neighbors[3] = 6;					IntList ranks = new IntList(signature, signature.length);					ranks.removeDuplicates();					ranks.sort();					for (int x = 0; x < ranks.num; ++x) {						if (s1.numPoints() <= ranks.get(x))							--truncSide.neighbors[x + 1];						if (s2.numPoints() <= ranks.get(x))							--truncSide.neighbors[x + 1];					}					OrderedTriple normal = truncSide.getPoint(0).mid(truncSide.getPoint(3));					truncSide.setNormal(trunc.vectors.add(normal));					trunc.sides.add(truncSide);				}			}		}		trunc.signature = signature;		return trunc;	}	void sizeProportionally(double factor) {		for (int i = 0; i < points.num; ++i) {			getPoint(i).timesEquals(factor);		}		if (nonUpdatingPoints != null) {			for (int i = 0; i < nonUpdatingPoints.num; ++i) {				((OrderedTriple) nonUpdatingPoints.get(i)).timesEquals(factor);			}		}		edgeLength *= factor;	}	// public void sizeToFit(double width) {	// sizeProportionally(width / (getMaxRadius() * 2));	// }	double getMinRadius() {		double cur, min = Double.POSITIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur < min)				min = cur;		}		return min;	}	double getMaxRadius() {		double cur, max = Double.NEGATIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur > max)				max = cur;		}		return max;	}	ArchiBuilder commit(SpacePoly poly) {		return commit(poly, true, null);	}	ArchiBuilder commit(SpacePoly poly, boolean doCorners) {		return commit(poly, doCorners, null);	}	ArchiBuilder commit(SpacePoly poly, IntList oldSideList) {		return commit(poly, true, oldSideList);	}	ArchiBuilder commit(SpacePoly poly, boolean doCorners, IntList oldSideList) {		if (oldSideList == null)			oldSideList = new IntList(sides.num);		else {			oldSideList.num = 0;			oldSideList.setSize(sides.num);		}		// set up committed		ArchiBuilder committed = new ArchiBuilder();		int[] newIndexes = new int[points.num];		committed.points = new ObjectList(0, 100);		committed.sides = new ObjectList(0, 100);		committed.vectors = new ObjectList(0, 100);		// consolidate points		int[] usage = getPointUsage();		for (int i = 0; i < points.num; ++i) {			if (usage[i] == 0)				continue;			boolean found = false;			OrderedTriple pi = getPoint(i);			for (int j = 0; j < committed.points.num; ++j) {				OrderedTriple pj = committed.getPoint(j);				if (pj.isApprox(pi, COMMIT_EPSILON)) {					found = true;					newIndexes[i] = j;					break;				}			}			if (!found)				newIndexes[i] = committed.points.add(new OrderedTriple(pi));		}		// consolidate sides		TruncableSpacePoly tPoly = null;		double tStage = -1;		boolean isEdgeTrunc = false;		int numStages = 0;		if (getPoint(0) instanceof TruncablePoint || getPoint(0) instanceof EdgeTruncablePoint) {			tPoly = (TruncableSpacePoly) poly;			tStage = tPoly.getTruncStage();			numStages = tPoly.truncStages.length;			isEdgeTrunc = getPoint(0) instanceof EdgeTruncablePoint;		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			IntList index = s.getIndex().copy();			for (int j = 0; j < index.num; ++j) {				index.set(j, newIndexes[index.get(j)]);			}			index.orderedRemoveDuplicates();			if (index.num >= 3) {				oldSideList.add(i);				SpaceSide committedSide = new SpaceSide(index.num);				// figure out regular or irregular				if (tPoly != null) {					if (isEdgeTrunc) {						committedSide.isREGULAR = !(((TruncableSpaceSide) s).cornerSide && ExtendedSolidDefinition.findSolidDefinition(signature) != ExtendedSolidDefinition.TETRAHEDRON);					} else {						if (type == ExtendedSolidDefinition.PLATONIC) {							if (((TruncableSpaceSide) s).cornerSide) {								committedSide.isREGULAR = !((tStage > 2 && tStage < 3) || (tStage > 3 && tStage < 4));							} else {								committedSide.isREGULAR = !((tStage >= 0 && tStage < 1) || (tStage > 1 && tStage < 2));							}						} else if (type == ExtendedSolidDefinition.ARCHIMEDEAN) {							if (((TruncableSpaceSide) s).cornerSide) {								committedSide.isREGULAR = false;							} else {								committedSide.isREGULAR = !(tStage >= 0 && tStage < 1);							}						}					}				} else					committedSide.isREGULAR = type != ExtendedSolidDefinition.DUAL;				committedSide.setIndex(index.shrink());				committed.sides.add(committedSide);				committedSide.setNormal(committed.vectors.add(new OrderedTriple((OrderedTriple) vectors.get(s.normal))));			}		}		if (doCorners) {			committed.completeCorners();			for (int i = 0; i < committed.corners.num; ++i) {				committed.getCorner(i).setBoss(committed);			}		}		committed.reclaim();		committed.edgeLength = edgeLength;		if (type == ExtendedSolidDefinition.OTHER) {			for (int i = 0; i < committed.sides.num; ++i) {				SpaceSide s = committed.getSide(i);				s.isREGULAR = s.calcRegular();			}		}		if (!doCorners)			return committed;		if (poly instanceof TruncableSpacePoly) {			committed.type = ExtendedSolidDefinition.OTHER;			double truncStage = ((TruncableSpacePoly) poly).getTruncStage();			boolean edgeTrunc = getPoint(0) instanceof EdgeTruncablePoint;			if (edgeTrunc) {				if (truncStage == 0) {					committed.type = type;				} else if (truncStage == (double) ((TruncableSpacePoly) poly).truncStages.length - 1) {					SolidDefinition sd = ExtendedSolidDefinition.findSolidDefinition(signature);					if (sd == ExtendedSolidDefinition.TETRAHEDRON)						committed.type = ExtendedSolidDefinition.PLATONIC;					else if (type == ExtendedSolidDefinition.PLATONIC) {						committed.type = ExtendedSolidDefinition.DUAL;						if (sd == ExtendedSolidDefinition.CUBE || sd == ExtendedSolidDefinition.TETRAHEDRON)							committed.signature = ExtendedSolidDefinition.RHOMBIC_DODECAHEDRON.getSignature();						else if (sd == ExtendedSolidDefinition.DODECAHEDRON || sd == ExtendedSolidDefinition.ICOSAHEDRON)							committed.signature = ExtendedSolidDefinition.RHOMBIC_TRIACONTAHEDRON.getSignature();					}				}			} else {				if (truncStage == 0) {					committed.type = type;				} else if (truncStage == (double) ((TruncableSpacePoly) poly).truncStages.length - 1) {					if (type == ExtendedSolidDefinition.PLATONIC)						committed.type = ExtendedSolidDefinition.PLATONIC;					else if (type == ExtendedSolidDefinition.ARCHIMEDEAN)						committed.type = ExtendedSolidDefinition.DUAL;				} else if (type == ExtendedSolidDefinition.PLATONIC) {					if (truncStage == 1 || truncStage == 2 || truncStage == 3)						committed.type = ExtendedSolidDefinition.ARCHIMEDEAN;					if (truncStage == 2 && ExtendedSolidDefinition.findSolidDefinition(signature) == ExtendedSolidDefinition.TETRAHEDRON)						committed.type = ExtendedSolidDefinition.PLATONIC;				}			}		} else			committed.type = type;		if (committed.signature == null) {			switch (committed.type) {			case ExtendedSolidDefinition.PLATONIC:			case ExtendedSolidDefinition.ARCHIMEDEAN:				committed.signature = committed.getCorner(0).getSignature();				break;			case ExtendedSolidDefinition.DUAL:				committed.signature = signature;				break;			default:				committed.signature = new int[0];			}		}		return committed;	}	int[] getPointUsage() {		int[] table = new int[points.num];		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			for (int j = 0; j < s.numPoints(); ++j) {				table[s.getIndex(j)]++;			}		}		return table;	}	public void completeCorners() {		corners = new ObjectList(points.num);		IntList[] table = new IntList[points.num];		for (int i = 0; i < points.num; ++i) {			table[i] = new IntList(10, 5);		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			for (int j = 0; j < s.numPoints(); ++j) {				table[s.getIndex(j)].add(i);			}		}		for (int i = 0; i < points.num; ++i) {			ArchiCorner c = new ArchiCorner();			c.setHub(i);			if (table[i].num == 0) {				Exception e = new Exception();				e.printStackTrace();			}			c.setSpokes(new IntList(table[i].num));			c.setSides(new IntList(table[i].num));			int sideIndex = table[i].get(0);			c.getSides().add(sideIndex);			SpaceSide s = getSide(sideIndex);			int find = s.findIndex(i);			int spoke = s.wrapgetIndex(find + 1);			c.getSpokes().add(spoke);			spoke = s.wrapgetIndex(find - 1);			table[i].removeIndex(0);			while (table[i].num > 0) {				for (int j = 0; j < table[i].num; ++j) {					sideIndex = table[i].get(j);					s = getSide(sideIndex);					find = s.findIndex(spoke);					if (find != -1) {						c.getSides().add(sideIndex);						c.getSpokes().add(spoke);						spoke = s.wrapgetIndex(find - 2);						table[i].removeIndex(j);						--j;						break;					}				}			}			corners.add(c);		}		return;	}	void reclaim() {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.setPoints(points);			s.setVectors(vectors);		}	}	void assign(SpacePoly p) {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.setPoints(p.points);			s.setVectors(p.vectors);		}	}	void printType() {		System.out.println(ExtendedSolidDefinition.typeToString(type));	}	int numEdges() {		int numEdges = 0;		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			numEdges += s.numPoints();		}		return numEdges / 2;	}	void reflect() {		for (int i = 0; i < points.num; ++i) {			getPoint(i).timesEquals(-1);		}		for (int i = 0; i < vectors.num; ++i) {			((OrderedTriple) vectors.get(i)).timesEquals(-1);		}		if (nonUpdatingPoints != null) {			for (int i = 0; i < nonUpdatingPoints.num; ++i) {				((OrderedTriple) nonUpdatingPoints.get(i)).timesEquals(-1);			}		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.getIndex().reverse();		}		if (corners != null) {			for (int i = 0; i < corners.num; ++i) {				ArchiCorner c = getCorner(i);				c.getSpokes().reverse();				c.setSides(c.getSides().wrapCopy(-2, -1));				c.setPole(null);			}		}	}	void sectLine(OrderedTriple L1, OrderedTriple L2, SpaceSide[] sideArray, OrderedTriple[] sects) {		int n = 0;		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			OrderedTriple[] p = s.threeDistinctPoints();			OrderedTriple sect = OrderedTriple.sectPlaneLine(p[0], p[1], p[2], L1, L2);			if (sect == null)				continue;			if (n > 0 && sect.isApprox(sects[0], COMMIT_EPSILON))				continue;			if (s.inside(sect)) {				sects[n] = sect;				sideArray[n] = s;				n++;				if (n == 2)					break;			}		}	}	public State getState() {		State s = new State();		s.numCorners = corners.num;		s.numVectors = vectors.num;		s.numPoints = points.num;		s.numSides = sides.num;		return s;	}	public void setState(State s) {		corners.num = s.numCorners;		vectors.num = s.numVectors;		points.num = s.numPoints;		sides.num = s.numSides;	}}class State {	int numCorners, numPoints, numSides, numVectors;	void print() {		System.out.println("numCorners = " + numCorners);		System.out.println("numPoints = " + numPoints);		System.out.println("numSides = " + numSides);		System.out.println("numVectors = " + numSides);		System.out.println();	}}