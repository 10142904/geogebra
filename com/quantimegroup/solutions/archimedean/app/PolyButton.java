/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.app;import java.awt.Color;import java.awt.Component;import java.awt.Graphics;import java.awt.Polygon;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.Icon;import com.quantimegroup.solutions.archimedean.gui.FramedButton;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;public class PolyButton extends FramedButton {	private Polygon poly;	private Archimedean gui;	private double polyTheta;	private int numEdges;	private int width = 50;	private int height = 50;	public PolyButton(int numPolys, Archimedean a) {		super();		addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				handleAction();			}		});		setPoly(numPolys);		gui = a;		setFrameThickness(4);		setIcon(new Icon() {			public int getIconHeight() {				return height;			}			public int getIconWidth() {				return width;			}			public void paintIcon(Component c, Graphics g, int x, int y) {				paintTop(g);			}		});	}	private void paintTop(Graphics g) {		if (gui.draw){			g.setColor(gui.color1);			g.drawPolygon(poly);		}else{			g.setColor(gui.getColor(numEdges));			g.fillPolygon(poly);			if (gui.drawEdges){				g.setColor(gui.edgeColor);				g.drawPolygon(poly);			}		}	}	private void setPoly(int numEdges) {		this.numEdges = numEdges;		poly = new Polygon();		int w = width - getFrameThickness() * 2, h = height - getFrameThickness() * 2;		int centerx = width / 2, centery = height / 2;		double radius = w < h ? w / 2 - 4 : h / 2 - 4;		double dtheta = Math.PI * 2 / numEdges;		double theta = -Math.PI / 2 + dtheta / 2;		for (int i = 0; i < numEdges; ++i, theta += dtheta){			int x = (int) (Math.cos(theta) * radius + centerx);			int y = (int) (-Math.sin(theta) * radius + centery);			poly.addPoint(x, y);		}		poly.ypoints[poly.npoints - 1] = poly.ypoints[0];//to ensure a true horizontal bottom edge		poly.addPoint(poly.xpoints[0], poly.ypoints[0]);		polyTheta = Math.PI * (1 - 2.0 / numEdges);	}	private boolean handleAction() {		gui.statusLabel.setText("");		if (gui.manualMode && gui.builder != null){			ObjectList s = SpaceSide.createPoly(numEdges, gui.builder.edgeLength);			double r = gui.builder.getMaxRadius();			OrderedTriple[] p = new OrderedTriple[s.num];			for (int i = 0; i < s.num; ++i){				p[i] = (OrderedTriple) s.get(i);				p[i].y = -Math.sqrt(r * r - p[i].x * p[i].x - p[i].z * p[i].z);			}			try{				if (gui.looseBuilder == null) gui.createLooseBuilder();				gui.looseBuilder.sides.num = 0;				gui.looseBuilder.points.num = 0;				gui.looseBuilder.vectors.num = 0;				gui.looseSide = new SpaceSide(p[0], p[1], p[2], s, gui.looseBuilder);				gui.looseSide.setPoints(gui.looseBuilder.points);				gui.looseSide.setVectors(gui.looseBuilder.vectors);				gui.looseSide.setNormal(gui.looseBuilder.vectors.add(gui.looseSide.calcNormal()));				gui.looseBuilder.sides.add(gui.looseSide);				gui.loosePoly = new SpacePoly(gui, gui.looseBuilder);				gui.loosePoly.showBackSides = true;				gui.loosePoly.edgeColor = Color.white;				gui.viewerCanvas.stuckLoose = gui.viewerCanvas.stickyLoose = false;				gui.viewerCanvas.repaint();			}catch (Exception ex){				System.out.println("PolyButton.action");				System.out.println(ex.getMessage());				ex.printStackTrace();			}		}else{			gui.addEntry(poly.npoints - 1);			gui.checkCreateKeypad();			gui.newButton.setEnabled(true);		}		return true;	}	public void check() {		if (gui.sumTheta + polyTheta >= 2 * Math.PI){			setEnabled(false);		}	}}