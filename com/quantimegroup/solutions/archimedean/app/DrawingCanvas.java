/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.app;import java.awt.Color;import java.awt.Event;import java.awt.Frame;import java.awt.Graphics;import java.awt.Point;import java.awt.Polygon;import java.awt.event.MouseEvent;import javax.swing.BorderFactory;import javax.swing.JPanel;import javax.swing.event.MouseInputListener;import com.quantimegroup.solutions.archimedean.utils.IntList;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedDouble;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;import com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix;public class DrawingCanvas extends JPanel implements MouseInputListener {	Archimedean gui;	boolean buildMode = true;	private OrderedTriple lastCoord = null;	private double lastRadius;	private static boolean backSide, dragMode;	private SpacePoly selectedPoly;	boolean mating = false, stickyLoose, stuckLoose;	private int matingLooseIndex1, matingLooseIndex2, matingBoundaryIndex1, matingBoundaryIndex2, matingBoundary1, matingBoundary2,			stuckLooseIndex, stuckMainIndex, stuckMainBoundary;	private int axisConstraint = 0;	private boolean inBounds;	private double yrotRadius = 100;	private OrderedTriple cursorVector;	private int frontCursor = Frame.HAND_CURSOR, backCursor = Frame.CROSSHAIR_CURSOR;	private int defaultCursor = Frame.DEFAULT_CURSOR;	private int cursor = Frame.DEFAULT_CURSOR;	public DrawingCanvas() {		addMouseListener(this);		addMouseMotionListener(this);		this.setBorder(BorderFactory.createRaisedBevelBorder());	}	public void paintComponent(Graphics g) {		if (buildMode){			paintBuildMode(g);		}else{			paint3DMode(g);		}	}	public void paint3DMode(Graphics g) {		g.setColor(Color.black);		g.fillRect(0, 0, getWidth(), getHeight());		if(gui.loosePoly != null){			gui.loosePoly.personalAxes.sizeFactor = gui.poly.personalAxes.sizeFactor;		}		if (gui.loosePoly != null && !gui.loosePoly.getSide(0).visible()){			gui.loosePoly.toScreenCoord();			gui.loosePoly.render(g);		}		if (gui.poly != null){			if (gui.poly.dirtyPoints == true){				gui.poly.toScreenCoord();			}			if (gui.draw) gui.poly.draw(g);			else gui.poly.render(g);		}		if (gui.loosePoly != null && gui.loosePoly.getSide(0).visible()){			gui.loosePoly.toScreenCoord();			gui.loosePoly.render(g);		}	}	public void paintBuildMode(Graphics g) {		if (gui == null) return;		g.setColor(Color.black);		g.fillRect(0, 0, getWidth(), getHeight());		int length = size().width / 7;		OrderedDouble center = new OrderedDouble(size().width / 2, size().height / 2);		double theta = 0;		OrderedDouble p = new OrderedDouble(center.x + length, center.y);		for (int i = 0; i < gui.numEntries; ++i){			int numEdges = gui.polys[i];			double polyTheta = Math.PI - Archimedean.polyAngle(numEdges);			Polygon poly = new Polygon();			poly.addPoint((int) center.x, (int) center.y);			poly.addPoint((int) p.x, (int) p.y);			OrderedDouble v1 = new OrderedDouble(Math.cos(theta), Math.sin(theta)).times(length);			for (int j = 2; j < numEdges; ++j){				OrderedDouble v2 = OrderedDouble.findSecondVector(v1, polyTheta, v1.cross());				p.plusEquals(v2);				v1 = v2;				poly.addPoint((int) p.x, (int) p.y);			}			poly.addPoint((int) center.x, (int) center.y);			if (gui.draw){				g.setColor(gui.color1);				g.drawPolygon(poly);			}else{				g.setColor(gui.getColor(numEdges));				g.fillPolygon(poly);				if (gui.drawEdges){					g.setColor(gui.edgeColor);					g.drawPolygon(poly);				}			}			theta += Archimedean.polyAngle(numEdges);		}	}	public void update(Graphics g) {		g.setColor(getBackground());		g.fillRect(0, 0, size().width, size().height);		paint(g);	}	public void setGUI(Archimedean g) {		gui = g;	}	public synchronized void reshapeOld(int x, int y, int width, int height) {		int oldWidth = getWidth();		super.reshape(x, y, width, height);		SpacePoint.init(width, height);		if (gui.poly != null){			gui.poly.personalAxes.sizeFactor *= ((double) width) / oldWidth;			gui.poly.dirtyPoints = true;		}	}	public synchronized void reshape(int x, int y, int width, int height) {		int oldMin = Math.min(getWidth(), getHeight());		int newMin = Math.min(width, height);		super.reshape(x, y, width, height);		SpacePoint.init(width, height);		if (gui.poly != null){			gui.poly.personalAxes.sizeFactor *= ((double) newMin) / oldMin;			gui.poly.dirtyPoints = true;		}	}	int findSide(int X, int Y, SpacePoly poly) {		IntList backIndexes = new IntList(poly.sides.num);		for (int i = 0; i < poly.sides.num; ++i){			SpaceSide s = (SpaceSide) poly.sides.get(i);			if (s.visible()){				if (s.inside(X, Y)){					return i;				}			}else{				backIndexes.add(i);			}		}		for (int i = 0; i < backIndexes.num; ++i){			int index = backIndexes.get(i);			SpaceSide s = poly.getSide(index);			if (s.counterClockwizeInside(X, Y)){				return index;			}		}		return -1;	}	OrderedTriple toSurfaceCoord(int X, int Y, SpacePoly poly, boolean allowOutOfBounds) {		ObjectList backSides = new ObjectList(poly.sides.num);		SpacePoint cursorPoint = new SpacePoint(X, Y);		OrderedTriple surfacePoint = null;		for (int i = 0; i < poly.sides.num; ++i){			SpaceSide s = (SpaceSide) poly.sides.get(i);			if (s.visible()){				if (s.inside(X, Y)){					inBounds = true;					surfacePoint = s.sectLine(cursorPoint, SpacePoint.viewer);					lastRadius = surfacePoint.length();					dragMode = true;					double R = lastRadius;					double d = R * R / SpacePoint.viewer.y;//the largest visible cross section is located on the plane y = d					backSide = surfacePoint.y > d;					cursor = backSide ? backCursor : frontCursor;					gui.setCursor(cursor);					return surfacePoint;				}			}else{				backSides.add(s);			}		}		for (int i = 0; i < backSides.num; ++i){			SpaceSide s = (SpaceSide) backSides.get(i);			if (s.inside(X, Y)){				inBounds = true;				surfacePoint = s.sectLine(cursorPoint, SpacePoint.viewer);				lastRadius = surfacePoint.length();				dragMode = true;				double R = lastRadius;				double d = R * R / SpacePoint.viewer.y;//the largest visible cross section is located on the plane y = d				backSide = surfacePoint.y > d;				cursor = backSide ? backCursor : frontCursor;				gui.setCursor(cursor);				return surfacePoint;			}		}		inBounds = false;		if (allowOutOfBounds){			axisConstraint = 'y';			backSide = false;			cursor = backSide ? backCursor : frontCursor;			gui.setCursor(cursor);			return outOfBoundsMouseDown(cursorPoint);		}		backSide = false;		cursor = backSide ? backCursor : frontCursor;		gui.setCursor(cursor);		return null;	}	OrderedTriple outOfBoundsMouseDown(OrderedTriple cursorPoint) {		double m = cursorPoint.length();		if (m == 0) return null;		lastRadius = yrotRadius;		return cursorPoint.times(lastRadius / m);	}	OrderedTriple toSphericalCoord(int X, int Y, double R) {		SpacePoint screenPoint = new SpacePoint(X, Y);		OrderedTriple[] sects = OrderedTriple.sectSphereLine(OrderedTriple.origin(), R, screenPoint, SpacePoint.viewer);		if (sects == null){			if (inBounds){				backSide = !backSide;				inBounds = false;				cursor = backSide ? backCursor : frontCursor;				gui.setCursor(cursor);			}			return outOfBoundsMouseDrag(screenPoint, R);		}else{			if (!inBounds){				inBounds = true;			}			OrderedTriple back, front;			if (sects[0].y > sects[1].y){				back = sects[0];				front = sects[1];			}else{				front = sects[0];				back = sects[1];			}			return backSide ? back : front;		}	}	OrderedTriple outOfBoundsMouseDrag(OrderedTriple cursorPoint, double R) {		//cursorPoint is the 3d coordinate of the cursors screen location and R is the radius 		//of the circle of influence		//the largest visible cross section is located on the plane y = d		double d = R * R / SpacePoint.viewer.y;		//the radius of the largest visible cross section				double r = Math.sqrt(R * R - d * d);		double m = cursorPoint.length();//cursor's distance from the y axis		//what we will return as the cursor's 3D location		OrderedTriple inBoundsPoint;		inBoundsPoint = cursorPoint.times(r / m);		inBoundsPoint.y = d;		return inBoundsPoint;	}	public void mousePressed(MouseEvent event) {		dragMode = true;		axisConstraint = 0;		Point mousePoint = event.getPoint();		if (gui.poly == null) return;		Analyzer.gui.analyzeList.pauseDemo();		//gui.poly.suspend();		if (gui.manualMode && (event.getModifiers() & Event.META_MASK) != 0){			if (gui.loosePoly != null && toSurfaceCoord(mousePoint.x, mousePoint.y, gui.loosePoly, false) != null){				gui.loosePoly = null;				repaint();				return;			}			if (gui.poly.sides.num <= 1) return;			int s = findSide(mousePoint.x, mousePoint.y, gui.poly);			if (s != -1){				gui.poly.sides.removeIndex(s);				gui.builder.sides.removeIndex(s);				gui.builder = gui.builder.commit(gui.poly, false);				if (gui.builder.calcBoundary()){					gui.transformRadioButton.hide();					gui.analyzeRadioButton.hide();				}else{					gui.transformRadioButton.show();					gui.analyzeRadioButton.show();				}				gui.poly = new SpacePoly(gui, gui.builder, gui.poly.personalAxes);				gui.poly.showBackSides = true;				repaint();				return;			}		}		if (gui.loosePoly != null){			lastCoord = toSurfaceCoord(mousePoint.x, mousePoint.y, gui.loosePoly, false);			if (lastCoord != null && stuckLoose){				OrderedTriple stay = gui.loosePoly.getPoint(stuckLooseIndex);				computeLooseCoord(stay, mousePoint.x, mousePoint.y);			}			selectedPoly = gui.loosePoly;			if (lastCoord == null){				lastCoord = toSurfaceCoord(mousePoint.x, mousePoint.y, gui.poly, true);				selectedPoly = gui.poly;			}		}else{			lastCoord = toSurfaceCoord(mousePoint.x, mousePoint.y, gui.poly, true);			selectedPoly = gui.poly;		}		if (gui.showCoordinates) showStatus(lastCoord);	}	public void showStatus(OrderedTriple p) {		String status = "";		status += "(" + Math.round(p.x) + ", " + Math.round(p.y) + ", " + Math.round(p.z) + ")";		gui.copyrightLabel.setText(status);	}	void computeLooseCoord(OrderedTriple stay, int X, int Y) {		//remember cursors direction vector from screen mapping of stay		SpacePoint stayPoint = new SpacePoint(stay);		stayPoint.toScreenCoord();		stayPoint = new SpacePoint(stayPoint.screenx, stayPoint.screeny);		SpacePoint cursor = new SpacePoint(X, Y);		cursorVector = cursor.minus(stayPoint);	}	OrderedTriple looseCoord(OrderedTriple stay, int X, int Y) {		//find the matrix that rotates old cursor to lastCoord and yaxis to normal		OrderedTriple n = stay;		OrderedTriple p = lastCoord;		double a = n.x;		double b = n.y;		double c = n.z;		double d = n.dot(p);		double K = (n.dot(p)) / (n.dot(n));		SpacePoint center = new SpacePoint(n.times(K));		OrderedTriple ov1 = cursorVector;		OrderedTriple nv1 = lastCoord.minus(center);		OrderedTriple ov2 = new OrderedTriple(0, -1, 0);		OrderedTriple nv2 = n.minus(center);		if (stay.y > 0){			nv2 = nv2.negative();		}		Quick3X3Matrix M = Quick3X3Matrix.findRotationMatrix(ov1.unit(), nv1.unit(), ov2.unit(), nv2.unit());		//multiply new cursor by M		SpacePoint stayPoint = new SpacePoint(stay);		stayPoint.toScreenCoord();		stayPoint = new SpacePoint(stayPoint.screenx, stayPoint.screeny);		SpacePoint cursor = new SpacePoint(X, Y);		cursorVector = cursor.minus(stayPoint);		return M.times(cursorVector).unit().times(nv1.length()).plus(center);	}	void shiftConstrainAxis(Point mousePoint) {		if (axisConstraint == 0){			SpacePoint p = new SpacePoint(lastCoord);			p.toScreenCoord();			int dx = mousePoint.x - p.screenx;			int dz = mousePoint.y - p.screeny;			axisConstraint = dx * dx > dz * dz ? 'z' : 'x';		}		if (axisConstraint == 'z'){			lastCoord.z = 0;			lastRadius = lastCoord.length();			mousePoint.y = SpacePoint.originy;		}else if (axisConstraint == 'x'){			lastCoord.x = 0;			lastRadius = lastCoord.length();			mousePoint.x = SpacePoint.originx;		}	}	public void mouseDragged(MouseEvent event) {		if (!dragMode) return;		Analyzer.gui.analyzeList.pauseDemo();		if (gui.poly == null) return;		//gui.poly.suspend();		Point mousePoint = event.getPoint();		OrderedTriple newCoord = null;		if (selectedPoly == gui.loosePoly && stuckLoose){			OrderedTriple stay = gui.loosePoly.getPoint(stuckLooseIndex);			newCoord = looseCoord(stay, mousePoint.x, mousePoint.y);			if (newCoord == null) newCoord = lastCoord;			gui.loosePoly.rotate(stay, stay, lastCoord, newCoord);		}else{			if (axisConstraint == 'y'){				newCoord = new SpacePoint(mousePoint.x, mousePoint.y);				if (newCoord.x == 0 && newCoord.z == 0) return;				newCoord = newCoord.unit().times(lastRadius);			}else{				if ((event.getModifiers() & Event.SHIFT_MASK) != 0){					if (!(selectedPoly == gui.loosePoly && stuckLoose)){						shiftConstrainAxis(mousePoint);					}				}				newCoord = toSphericalCoord(mousePoint.x, mousePoint.y, lastRadius);			}			selectedPoly.rotate(lastCoord, newCoord);			if (selectedPoly == gui.poly && stuckLoose && gui.loosePoly != null){				gui.loosePoly.rotate(lastCoord, newCoord);			}		}		lastCoord = newCoord;		repaint();		if (selectedPoly == gui.loosePoly){			checkConnections(gui.loosePoly, gui.poly);		}		if (gui.showCoordinates) showStatus(lastCoord);	}	public void mouseReleased(MouseEvent event) {		dragMode = false;		gui.setCursor(defaultCursor);		gui.copyrightLabel.setText(gui.copyrightString);		if (gui.poly == null) return;		Analyzer.gui.analyzeList.resumeDemo();		//gui.poly.resume();		if (mating) mate();		if (stickyLoose){			stuckLooseIndex = matingLooseIndex1;			stuckMainIndex = matingBoundaryIndex1;			stuckMainBoundary = matingBoundary1;			OrderedTriple from = gui.loosePoly.getPoint(stuckLooseIndex);			OrderedTriple to = gui.poly.getBoundaryPoint(stuckMainBoundary, stuckMainIndex);			gui.loosePoly.rotate(from, to);			repaint();			stuckLoose = true;			stickyLoose = false;		}	}	void mate() {		SpacePoly loose = gui.loosePoly;		SpacePoly main = gui.poly;		loose.personalAxes.unrotate();		loose.personalAxes.sizeFactor = 1;		OrderedTriple p0 = loose.getOriginalPoint(matingLooseIndex1);		OrderedTriple n0 = main.getOriginalBoundaryPoint(matingBoundary1, matingBoundaryIndex1);		OrderedTriple p1 = loose.getOriginalPoint(matingLooseIndex1 + 1);		OrderedTriple n1 = main.getOriginalBoundaryPoint(matingBoundary1, matingBoundaryIndex1 - 1);		loose.rotate(p0, n0, p1, n1);		loose.update();		SpaceSide looseSide = (SpaceSide) loose.sides.get(0);		for (int k = 0; k < looseSide.numPoints(); ++k){			OrderedTriple curp = new OrderedTriple(looseSide.getPoint(k));			try{				looseSide.getIndex().set(k, main.builder.registerPoint(curp));			}catch (Exception e){				System.out.println(e.getMessage());			}		}		looseSide.setPoints(main.builder.points);		looseSide.setVectors(main.builder.vectors);		main.builder.registerSide(looseSide);		main.builder.reclaim();		if (!main.builder.calcBoundary()){			gui.analyzeRadioButton.show();			gui.transformRadioButton.show();			gui.builder = main.builder.commit(main);			gui.createButton.enable(false);			gui.polyButton1.enable(false);			gui.polyButton2.enable(false);			gui.polyButton3.enable(false);			gui.polyButton4.enable(false);			gui.polyButton5.enable(false);			gui.polyButton6.enable(false);			gui.otherButton.enable(false);		}		gui.poly = new SpacePoly(gui, main.builder, gui.poly.personalAxes);		gui.poly.showBackSides = true;		gui.looseSide = null;		gui.loosePoly = null;		repaint();		mating = false;		stuckLoose = stickyLoose = false;	}	void checkConnections(SpacePoly loose, SpacePoly main) {		mating = false;		stickyLoose = false;		main.cornerIndexes = new IntList(loose.points.num);		main.cornersToShow = new boolean[main.points.num];		loose.cornerIndexes = new IntList(loose.points.num);		loose.cornersToShow = new boolean[loose.points.num];		for (int i = 0; i < loose.points.num; ++i){			OrderedTriple pi = loose.getPoint(i);			for (int m = 0; m < main.builder.multipleBoundary.num; ++m){				IntList boundary = (IntList) main.builder.multipleBoundary.get(m);				for (int j = 0; j < boundary.num; ++j){					OrderedTriple pj = main.getBoundaryPoint(m, j);					int curIndex = boundary.get(j);					if (pi.isApprox(pj, 10)){						if (loose.cornerIndexes.find(i) == -1){							main.cornerIndexes.add(curIndex);							loose.cornerIndexes.add(i);						}						if (!mating){							matingLooseIndex1 = i;							matingBoundaryIndex1 = j;							matingBoundary1 = m;							OrderedTriple pi2 = loose.getPoint(i + 1);							OrderedTriple pj2 = main.getBoundaryPoint(m, j - 1);							if (pi2.isApprox(pj2, 10)){								matingLooseIndex2 = i + 1;								matingBoundaryIndex2 = j - 1;								matingBoundary2 = m;								mating = true;							}						}					}				}			}		}		stickyLoose = loose.cornerIndexes.num == 1;		loose.highlightCorners = main.highlightCorners = loose.cornerIndexes.num > 0;		if (loose.highlightCorners) repaint();	}	void mouseEnter(MouseEvent event) {		gui.setCursor(cursor);	}	void mouseExit(MouseEvent event) {		gui.setCursor(defaultCursor);	}	public void mouseClicked(MouseEvent e) {		// TODO Auto-generated method stub	}	public void mouseEntered(MouseEvent e) {		// TODO Auto-generated method stub	}	public void mouseExited(MouseEvent e) {		// TODO Auto-generated method stub	}	public void mouseMoved(MouseEvent e) {		// TODO Auto-generated method stub	}}