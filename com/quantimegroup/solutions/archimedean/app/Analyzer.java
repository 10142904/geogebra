/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.app;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.util.Vector;import javax.swing.JList;import javax.swing.event.ListSelectionEvent;import javax.swing.event.ListSelectionListener;import com.quantimegroup.solutions.archimedean.common.SolidDefinition;import com.quantimegroup.solutions.archimedean.utils.Axes;import com.quantimegroup.solutions.archimedean.utils.IntList;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;import com.quantimegroup.solutions.archimedean.utils.Rotater;public class Analyzer extends JList {	static Archimedean gui;	private ObjectList cornerAxes, sideAxes, edgeAxes, cornerTabulation, sideTabulation, savePolySides;	private double surfaceArea, volume, surfaceVolumeQuotient;	private int numAxesOfSymmetry = 0;	private AxisDemonstrator demoThread;	private ArchiBuilder committed;	private double minRad, maxRad;	private int lastIndex;	private IntList sideList, cornerList;	private int firstSidesIndex, lastSidesIndex, firstCornersIndex, lastCornersIndex;	private IntList oldSideList = new IntList(0);	public Analyzer() {		super();		addListSelectionListener(new ListSelectionListener() {			public void valueChanged(ListSelectionEvent e) {				if (!e.getValueIsAdjusting()) {					analyzer_ListSelect();				}			}		});		addMouseListener(new MouseAdapter() {			public void mouseReleased(MouseEvent e) {				Analyzer.this.clearSelection();			}		});	}	static boolean isAxisOfSymmetry(OrderedTriple p, int fold, ArchiBuilder b) {		ObjectList points = new ObjectList(b.points.num);		for (int i = 0; i < b.points.num; ++i) {			points.add(new OrderedTriple(b.getPoint(i)));		}		Rotater r = new Rotater(p, Math.PI * 2 / fold);		Axes a = new Axes();		a.timesEquals(r);		ObjectList copiedPoints = b.points.copy();		for (int i = 0; i < points.num; ++i) {			OrderedTriple pi = (OrderedTriple) points.get(i);			a.transformPoint(pi);			int found = ArchiBuilder.findApproxPoint(pi, copiedPoints);			if (found == -1)				return false;			else				copiedPoints.removeIndex(found);		}		return copiedPoints.num == 0;	}	static IntList[] getSideData(ArchiBuilder b) {		IntList irregularSides = new IntList(0, 10);		IntList regularSides = new IntList(0, 10);		for (int i = 0; i < b.sides.num; ++i) {			SpaceSide s = b.getSide(i);			IntList curTable = s.isREGULAR ? regularSides : irregularSides;			int n = s.numPoints();			if (n >= curTable.length()) {				curTable.setSize(n + 1);				curTable.num = n + 1;			}			curTable.set(n, curTable.get(n) + 1);		}		IntList[] table = {				regularSides, irregularSides };		return table;	}	static IntList getCornerData(ArchiBuilder b) {		IntList table = new IntList(0, 10);		for (int i = 0; i < b.corners.num; ++i) {			ArchiCorner c = b.getCorner(i);			int n = c.getSpokes().num;			if (n >= table.length()) {				table.setSize(n + 1);				table.num = n + 1;			}			table.set(n, table.get(n) + 1);		}		return table;	}	static int[] getSideSignature(SpaceSide s, ArchiBuilder b) {		ObjectList adjacentSides = new ObjectList(s.numPoints());		for (int i = 0; i < b.sides.num; ++i) {			SpaceSide si = b.getSide(i);			if (si == s)				continue;			if (si.isAdjacent(s))				adjacentSides.add(si);		}		int[] sign = new int[s.numPoints()];		int index = 0;		while (adjacentSides.num > 0) {			for (int i = 0; i < adjacentSides.num; ++i) {				SpaceSide si = (SpaceSide) adjacentSides.get(i);				if (si.findIndex(s.getIndex(index)) != -1 && si.findIndex(s.wrapgetIndex(index + 1)) != -1) {					sign[index] = si.numPoints();					index++;					adjacentSides.removeIndex(i);					break;				}			}		}		return sign;	}	static boolean pat(int[] sign, int patLen) {		for (int i = 0; i < patLen; ++i) {			for (int j = 0; i + (j + 1) * patLen < sign.length; ++j) {				if (sign[i + j * patLen] != sign[i + (j + 1) * patLen])					return false;			}		}		return true;	}	static int getPattern(int[] sign) {		for (int i = 1; i <= (sign.length + 1) / 2; ++i) {			if (sign.length % i == 0 && pat(sign, i))				return i;		}		return -1;	}	void findRotationalAxes(ArchiBuilder b) {		numAxesOfSymmetry = 0;		cornerAxes = new ObjectList(b.corners.num);		sideAxes = new ObjectList(b.sides.num);		edgeAxes = new ObjectList(b.numEdges());		ObjectList cornerUnits = new ObjectList(b.corners.num);		ObjectList sideUnits = new ObjectList(b.sides.num);		ObjectList edgeUnits = new ObjectList(b.numEdges());		ObjectList badUnits = new ObjectList(0, 10);		for (int i = 0; i < b.corners.num; ++i) {			ArchiCorner c = b.getCorner(i);			OrderedTriple p = c.getHubPoint();			if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)				continue;			int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);			if (foundCorner != -1) {				getAxis(cornerAxes, foundCorner).point2 = p;				continue;			}			int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);			if (foundSide != -1) {				AxisData foundAxis = getAxis(sideAxes, foundSide);				cornerAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				cornerUnits.add(p.unit());				continue;			}			int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);			if (foundEdge != -1) {				AxisData foundAxis = getAxis(edgeAxes, foundEdge);				cornerAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				cornerUnits.add(p.unit());				continue;			}			for (int fold = c.getSpokes().num; fold >= 2; --fold) {				if (c.getSpokes().num % fold != 0)					continue;				if (isAxisOfSymmetry(p, fold, b)) {					cornerAxes.add(new AxisData(p, null, fold));					cornerUnits.add(p.unit());					numAxesOfSymmetry++;					break;				} else {					badUnits.add(p.unit());				}			}		}		for (int i = 0; i < b.sides.num; ++i) {			double epsilon = 1e-2;			SpaceSide s = b.getSide(i);			OrderedTriple p = s.getIncenter();			if (p.length() < epsilon) {				continue;			}			if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)				continue;			int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);			if (foundSide != -1) {				getAxis(sideAxes, foundSide).point2 = p;				continue;			}			int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);			if (foundCorner != -1) {				AxisData foundAxis = getAxis(cornerAxes, foundCorner);				sideAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				sideUnits.add(p.unit());				continue;			}			int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);			if (foundEdge != -1) {				AxisData foundAxis = getAxis(edgeAxes, foundEdge);				sideAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));				foundAxis.point2 = p;				sideUnits.add(p.unit());				continue;			}			for (int fold = s.numPoints(); fold >= 2; --fold) {				if (s.numPoints() % fold != 0)					continue;				if (isAxisOfSymmetry(p, fold, b)) {					sideAxes.add(new AxisData(p, null, fold));					sideUnits.add(p.unit());					numAxesOfSymmetry++;					break;				} else {					badUnits.add(p.unit());				}			}		}		for (int i = 0; i < b.corners.num; ++i) {			ArchiCorner c = b.getCorner(i);			for (int j = 0; j < c.getSpokes().num; ++j) {				if (c.getSpokes().get(j) < c.getHub())					continue;				OrderedTriple p = c.getHubPoint().mid(c.getSpoke(j));				if (ArchiBuilder.findApproxPoint(p.unit(), badUnits) != -1)					continue;				int foundEdge = ArchiBuilder.findApproxPoint(p.unit().negative(), edgeUnits);				if (foundEdge != -1) {					getAxis(edgeAxes, foundEdge).point2 = p;					continue;				}				int foundCorner = ArchiBuilder.findApproxPoint(p.unit().negative(), cornerUnits);				if (foundCorner != -1) {					AxisData foundAxis = getAxis(cornerAxes, foundCorner);					edgeAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));					foundAxis.point2 = p;					edgeUnits.add(p.unit());					continue;				}				int foundSide = ArchiBuilder.findApproxPoint(p.unit().negative(), sideUnits);				if (foundSide != -1) {					AxisData foundAxis = getAxis(sideAxes, foundSide);					edgeAxes.add(new AxisData(p, foundAxis.point1, foundAxis.fold));					foundAxis.point2 = p;					edgeUnits.add(p.unit());					continue;				}				if (isAxisOfSymmetry(p, 2, b)) {					edgeAxes.add(new AxisData(p, null, 2));					edgeUnits.add(p.unit());					numAxesOfSymmetry++;				} else {					badUnits.add(p.unit());				}			}		}		cornerTabulation = new ObjectList(100);		tabulateAxes(cornerAxes, cornerTabulation);		sideTabulation = new ObjectList(100);		tabulateAxes(sideAxes, sideTabulation);	}	void tabulateAxes(ObjectList theAxes, ObjectList theTabs) {		int[] tab = new int[100];		int maxFold = 0;		for (int i = 0; i < theAxes.num; ++i) {			int fold = getAxis(theAxes, i).fold;			tab[fold]++;			if (fold > maxFold)				maxFold = fold;		}		for (int i = 0; i < maxFold + 1; ++i) {			if (tab[i] > 0) {				int[] item = {						i, tab[i] };				theTabs.add(item);			}		}	}	double getSurfaceArea(ArchiBuilder b) {		if (surfaceArea != 0)			return surfaceArea;		for (int i = 0; i < b.sides.num; ++i) {			surfaceArea += b.getSide(i).getArea() * gui.poly.personalAxes.sizeFactor * gui.poly.personalAxes.sizeFactor;		}		return surfaceArea;	}	double getPyramidVolume(SpaceSide s, OrderedTriple tip) {		OrderedTriple[] p = s.threeDistinctPoints();		return OrderedTriple.pointPlaneDistance(tip, p[0], p[1], p[2]) * s.getArea() / 3;	}	double getVolume(ArchiBuilder b) {		if (volume != 0)			return volume;		for (int i = 0; i < b.sides.num; ++i) {			volume += getPyramidVolume(b.getSide(i), OrderedTriple.origin());		}		return volume * gui.poly.personalAxes.sizeFactor * gui.poly.personalAxes.sizeFactor * gui.poly.personalAxes.sizeFactor;	}	double getSurfaceVolumeQuotient(ArchiBuilder b) {		if (surfaceVolumeQuotient == 0) {			double r = Math.sqrt(getSurfaceArea(b) / (4 * Math.PI));			surfaceVolumeQuotient = (getSurfaceArea(b) * r) / (getVolume(b) * 3);		}		return surfaceVolumeQuotient;	}	void showAllCorners() {		gui.poly.cornerIndexes = makeCornerList();		gui.poly.highlightCorners = true;		gui.poly.dirtyPoints = true;		gui.viewerCanvas.repaint();	}	void showCorners() {		int which = lastIndex - firstCornersIndex;		int numSpokes = cornerList.get(which);		gui.poly.cornerIndexes = makeCornerList(committed.corners, numSpokes);		gui.poly.highlightCorners = true;		gui.poly.dirtyPoints = true;		gui.viewerCanvas.repaint();	}	void showSides() {		int which = lastIndex - firstSidesIndex;		int code = sideList.get(which);		boolean regular = code > 0;		int numPoints = Math.abs(code);		gui.poly.sides = makeSideList(committed.sides, numPoints, regular);		gui.poly.dirtyPoints = true;		gui.poly.showBackSides = true;		gui.viewerCanvas.repaint();	}	public void stopDemo() {		if (demoThread != null) {			demoThread.stopMe();		}	}	public void pauseDemo() {		if (demoThread != null) {			demoThread.pauseMe();		}	}	public void resumeDemo() {		if (demoThread != null) {			demoThread.resumeMe();		}	}	void analyzer_ListSelect() {		// if (getSelectedIndex() == lastIndex) return;		String s = (String) getSelectedValue();		if (s == null || "".equals(s.trim())) {			return;		}		if (!s.endsWith("Symmetry:") && getSelectedIndex() == lastIndex) {			return;		}		lastIndex = getSelectedIndex();		// gui.poly.stop();		// stopDemo();		if (lastIndex >= firstSidesIndex && lastIndex <= lastSidesIndex) {			showSides();			return;		}		if (lastIndex >= firstCornersIndex && lastIndex <= lastCornersIndex) {			showCorners();			return;		}		SpacePoly tempPoly;		if (s.endsWith("Sides:")) {			gui.poly.sides = savePolySides;			gui.poly.dirtyPoints = true;			gui.viewerCanvas.repaint();		}		if (s.endsWith("Corners:")) {			gui.poly.highlightCorners = !gui.poly.highlightCorners;			if (gui.poly.highlightCorners)				showAllCorners();			gui.poly.dirtyPoints = true;			gui.viewerCanvas.repaint();		} else if (s.equalsIgnoreCase("Show Reflection...")) {			gui.builder.reclaim();			gui.builder.reflect();			if (gui.poly instanceof TruncableSpacePoly) {				tempPoly = new TruncableSpacePoly(gui, gui.builder, gui.poly.personalAxes);				((TruncableSpacePoly) tempPoly).truncStages = ((TruncableSpacePoly) gui.poly).truncStages;				((TruncableSpacePoly) tempPoly).truncPercent = ((TruncableSpacePoly) gui.poly).truncPercent;				((TruncableSpacePoly) tempPoly).ranks = ((TruncableSpacePoly) gui.poly).ranks;				((TruncableSpacePoly) tempPoly).type = ((TruncableSpacePoly) gui.poly).type;			} else				tempPoly = new SpacePoly(gui, gui.builder, gui.poly.personalAxes);			gui.poly = tempPoly;			gui.viewerCanvas.repaint();		} else if (s.equalsIgnoreCase("Show Alternate Form...")) {			gui.builder = new ArchiBuilder(SolidDefinition.SMALL_RHOMBICUBOCTAHEDRON.getSignature(),					SolidDefinition.SMALL_RHOMBICUBOCTAHEDRON.getSignature().length, false);			// gui.builder.sizeToFit(gui.viewerCanvas.size().width * .9);			gui.poly = new SpacePoly(gui, gui.builder, gui.poly.personalAxes);			gui.poly.sizeToFit(gui.viewerCanvas.getWidth(), gui.viewerCanvas.getHeight());			init();			gui.viewerCanvas.repaint();		} else if (s.endsWith("Symmetry:")) {			if (gui.poly.lines.num != 0) {				gui.poly.lines.num = 0;				stopDemo();			} else {				gui.poly.lines.num = 0;				for (int i = 0; i < cornerAxes.num; ++i) {					AxisData a = getAxis(cornerAxes, i);					gui.poly.addLine(a.point1, a.point2, gui.builder.getMaxRadius() * 3);				}				for (int i = 0; i < sideAxes.num; ++i) {					AxisData a = getAxis(sideAxes, i);					gui.poly.addLine(a.point1, a.point2, gui.builder.getMaxRadius() * 3);				}				for (int i = 0; i < edgeAxes.num; ++i) {					AxisData a = getAxis(edgeAxes, i);					gui.poly.addLine(a.point1, a.point2, gui.builder.getMaxRadius() * 3);				}			}			gui.poly.dirtyPoints = true;			gui.viewerCanvas.repaint();		} else if (s.endsWith("(corner)")) {			demoAxis(s, cornerAxes);		} else if (s.endsWith("(side)")) {			demoAxis(s, sideAxes);		} else if (s.endsWith("(edge)")) {			demoAxis(s, edgeAxes);		} else if (s.startsWith("Inscribed radius")) {			gui.poly.toggleInscribedSphere();			gui.viewerCanvas.repaint();		} else if (s.startsWith("Circumscribed radius")) {			gui.poly.toggleCircumscribedSphere();			gui.viewerCanvas.repaint();		}	}	void demoAxis(String s, ObjectList axes) {		stopDemo();		int fold = getFold(s);		/*		 * if (demoThread != null && demoThread.isAlive()){ //demoThread.stop();		 * demoThread.interrupt(); }		 */		demoThread = new AxisDemonstrator(gui, axes, fold);		demoThread.start();	}	int getFold(String s) {		int dashi = s.indexOf('-');		int tens = 1;		char c;		int fold = 0;		while (--dashi >= 0) {			c = s.charAt(dashi);			if (Character.isDigit(c)) {				fold += tens * (c - '0');				tens *= 10;			} else				break;		}		return fold;	}	ObjectList makeSideList(ObjectList sides, int numPoints, boolean regular) {		ObjectList newSides = new ObjectList(sides.num);		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			if (s.isREGULAR == regular && s.numPoints() == numPoints) {				// newSides.add( savePolySides.get( i ) );				newSides.add(savePolySides.get(oldSideList.get(i)));			}		}		return newSides;	}	IntList makeCornerList(ObjectList corners, int numSpokes) {		IntList newCorners = new IntList(corners.num);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = (ArchiCorner) corners.get(i);			if (c.getSpokes().num == numSpokes) {				int found = ArchiBuilder.findApproxPoint(c.getHubPoint(), gui.builder.points);				if (found == -1)					System.out.println("makeCornerList");				else					newCorners.add(found);			}		}		return newCorners;	}	IntList makeCornerList() {		IntList newCorners = new IntList(gui.builder.points.num);		for (int i = 0; i < gui.builder.points.num; ++i) {			newCorners.add(i);		}		return newCorners;	}	void init() {		Vector listData = new Vector();		if (gui.builder == null || gui.poly == null)			return;		sideList = new IntList(10);		cornerList = new IntList(10);		savePolySides = gui.poly.sides;		// clear();		lastIndex = -1;		gui.builder.reclaim();		committed = gui.builder;		if (gui.builder.type != ExtendedSolidDefinition.RATIONAL) {			committed = gui.builder.commit(gui.poly, oldSideList);		}		gui.builder.assign(gui.poly);		surfaceArea = volume = surfaceVolumeQuotient = 0;		String tab = "     ";		String s = ExtendedSolidDefinition.typeToString(committed.type).toUpperCase();		SolidDefinition sd = SolidDefinition.findSolidDefinition(committed.signature, committed.type == SolidDefinition.DUAL);		if (committed.type == SolidDefinition.OTHER) {			OrderedTriple p = gui.builder.getPoint(0);			if (p instanceof TruncablePoint) {				s = "Corner Truncated";				sd = SolidDefinition.findSolidDefinition(gui.builder.signature);			} else if (p instanceof EdgeTruncablePoint) {				s = "Edge Truncated";				sd = SolidDefinition.findSolidDefinition(gui.builder.signature);			}		}		listData.add(s);		if (sd != null) {			listData.add(" ");			listData.add(sd.getName());		}		if (committed.type == ExtendedSolidDefinition.RATIONAL) {			listData.add("Ratio: " + committed.corners.num / committed.points.num);		}		listData.add(" ");		listData.add("" + committed.points.num + " Corners:");		// firstCornersIndex = countItems();		firstCornersIndex = listData.size();		IntList table = Analyzer.getCornerData(committed);		for (int i = 0; i < table.num; ++i) {			int n = table.get(i);			if (n > 0) {				listData.add(tab + n + " " + i + "-spoke");				cornerList.add(i);			}		}		// lastCornersIndex = countItems() - 1;		lastCornersIndex = listData.size() - 1;		listData.add(" ");		listData.add("" + committed.sides.num + " Sides:");		// firstSidesIndex = countItems();		firstSidesIndex = listData.size();		IntList[] tableArray = Analyzer.getSideData(committed);		IntList regularSides = tableArray[0];		IntList irregularSides = tableArray[1];		for (int i = 0; i < regularSides.num; ++i) {			int n = regularSides.get(i);			if (n > 0) {				listData.add(tab + n + " " + polygonName(i, true).toLowerCase() + "s");				sideList.add(i);			}		}		for (int i = 0; i < irregularSides.num; ++i) {			int n = irregularSides.get(i);			if (n > 0) {				listData.add(tab + n + " " + polygonName(i, false).toLowerCase() + "s");				sideList.add(-i);			}		}		// lastSidesIndex = countItems() - 1;		lastSidesIndex = listData.size() - 1;		listData.add(" ");		listData.add("" + committed.numEdges() + " Edges");		if (sd == SolidDefinition.SNUB_CUBE || sd == SolidDefinition.SNUB_DODECAHEDRON || sd == SolidDefinition.PENTAGONAL_ICOSITETRAHEDRON				|| sd == SolidDefinition.PENTAGONAL_HEXECONTAHEDRON) {			listData.add(" ");			listData.add("Show Reflection...");		} else if (sd == SolidDefinition.SMALL_RHOMBICUBOCTAHEDRON) {			listData.add(" ");			listData.add("Show Alternate Form...");		}		findRotationalAxes(committed);		listData.add(" ");		listData.add("" + numAxesOfSymmetry + " Axes of Symmetry:");		if (cornerAxes.num > 0) {			for (int i = 0; i < cornerTabulation.num; ++i) {				int fold = ((int[]) cornerTabulation.get(i))[0];				int num = ((int[]) cornerTabulation.get(i))[1];				listData.add(tab + num + " " + fold + "-fold (corner)");			}		}		if (sideAxes.num > 0) {			for (int i = 0; i < sideTabulation.num; ++i) {				int fold = ((int[]) sideTabulation.get(i))[0];				int num = ((int[]) sideTabulation.get(i))[1];				listData.add(tab + num + " " + fold + "-fold (side)");			}		}		if (edgeAxes.num > 0) {			listData.add(tab + edgeAxes.num + " 2-fold (edge)");		}		if (false) {			listData.add(" ");			listData.add("Surface Area: " + getSurfaceArea(committed));			listData.add(" ");			listData.add("Volume: " + getVolume(committed));			listData.add(" ");			listData.add("Surface to Volume quotient: ");			listData.add("" + getSurfaceVolumeQuotient(committed));			listData.add("The sphere has a minimum");			listData.add("surface to volume quotient");			listData.add("of 1.0");			minRad = getInscribedRadius(committed);			maxRad = getCircumscribedRadius(committed);		}		listData.add(" ");		// listData.add("Inscribed radius: " + (getInscribedRadius(committed) *		// gui.poly.personalAxes.sizeFactor));		// listData.add("Circumscribed radius: " +		// (getCircumscribedRadius(committed)));		listData.add("Inscribed radius");		listData.add("Circumscribed radius");		this.setListData(listData);	}	static String polygonName(int i, boolean regular) {		String[] polygonNames = {				"", "", "", "Triangle", "Square", "Pentagon", "Hexagon", "Heptagon", "Octagon", "Nonagon", "Decagon", "Undecagon", "Dodecagon" };		if (i == 3) {			if (regular)				return "Equilateral " + polygonNames[3];			else				return polygonNames[3];		} else if (i == 4) {			if (regular)				return "Square";			else				return "Quadrilateral";		}		String s = regular ? "Regular " : "Irregular ";		if (i > 12)			return s + i + "-gon";		return s + polygonNames[i];	}	static double getCircumscribedRadius(ArchiBuilder b) {		return gui.poly.getMaxRadius();	}	static double getInscribedRadius(ArchiBuilder b) {		return gui.poly.getMinRadius();	}	static AxisData getAxis(ObjectList l, int i) {		return (AxisData) l.get(i);	}}class AxisData {	OrderedTriple point1, point2;	int fold;	AxisData() {	}	AxisData(OrderedTriple p1, OrderedTriple p2, int f) {		point1 = p1;		point2 = p2;		fold = f;	}}class AxisDemonstrator extends Thread {	Archimedean gui;	ObjectList axes;	int fold;	private volatile boolean stopped = false;	private volatile boolean paused = false;	AxisDemonstrator(Archimedean g, ObjectList a, int f) {		gui = g;		axes = a;		fold = f;		setName("AxisDemonstrator");	}	public void run() {		gui.poly.lines.num = 0;		for (int i = 0; i < axes.num; ++i) {			AxisData a = (AxisData) axes.get(i);			if (a.fold == fold)				gui.poly.addLine(a.point1, a.point2, gui.builder.getMaxRadius() * 3);		}		gui.poly.dirtyPoints = true;		gui.viewerCanvas.repaint();		if (true) {// don't do this until you understand threads better			try {				sleep(2000);			} catch (InterruptedException e) {				System.out.println("interrupted");				// stop();				return;			}			AxisData a = null;			for (int i = 0; i < axes.num; ++i) {				a = (AxisData) axes.get(i);				if (a.fold == fold)					break;			}			gui.poly.lines.num = 0;			gui.poly.addLine(a.point1, a.point2, gui.builder.getMaxRadius() * 3);			OrderedTriple v = a.point1.minus(a.point2);			Rotater r = new Rotater(v, .01);			gui.poly.rotaters = new ObjectList(1);			gui.poly.rotaters.add(r);			gui.poly.personalAxes.unrotate();			OrderedTriple p1 = a.point1;			OrderedTriple p2 = OrderedTriple.yAxis().times(p1.length());			gui.poly.rotate(p1, p2);			while (!stopped) {				for (int i = 0; i < gui.poly.rotaters.num; ++i) {					if (!paused) {						Rotater ri = (Rotater) gui.poly.rotaters.objects[i];						gui.poly.personalAxes.timesEquals(ri);						if (gui.poly.correctAxes) {							gui.poly.personalAxes.correct();						}						gui.poly.dirtyPoints = true;						gui.viewerCanvas.repaint();					}					try {						Thread.sleep(5);					} catch (InterruptedException e) {						gui.poly.rotaters.num = 0;						return;					}				}			}		}	}	public void pauseMe() {		paused = true;	}	public void resumeMe() {		paused = false;	}	public void stopMe() {		System.out.println("You stopped me.");		stopped = true;	}}