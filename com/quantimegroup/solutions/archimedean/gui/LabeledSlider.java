/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.gui;import java.awt.Color;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Point;import java.awt.Rectangle;import java.awt.event.MouseEvent;import javax.swing.JComponent;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import javax.swing.event.MouseInputListener;public class LabeledSlider extends JComponent implements MouseInputListener {	private int redLabel = 0;	private Rectangle barRect;	private String[] labels;	private int[] thumbVals;	private double[] values;	private Rectangle[] stringRects;	private int thumbVal;	private double originalRange;	private double lowestValue;	private int thumbHeight = 5;	public LabeledSlider() {		super();		addMouseListener(this);		addMouseMotionListener(this);	}	public void setLabels(String[] theLabels) {		labels = new String[theLabels.length];		for (int i = 0; i < labels.length; ++i){			labels[i] = new String(theLabels[i]);		}	}	public void setValues(double[] values) {		setValues(values, values[0]);	}	void spaceRects() {		for (int i = 1; i < thumbVals.length - 1; ++i){			stringRects[i].y = Math.max(stringRects[i].y, stringRects[i - 1].y + stringRects[i - 1].height);		}		for (int i = thumbVals.length - 2; i > 0; --i){			stringRects[i].y = Math.min(stringRects[i].y, stringRects[i + 1].y - stringRects[i].height);		}	}	public void setValues(double[] values, double startValue) {		thumbVals = new int[values.length];		this.values = values;		originalRange = values[values.length - 1] - values[0];		lowestValue = values[0];		for (int i = 0; i < values.length; ++i){			thumbVals[i] = (int) (valueToVal(values[i]));		}		setValue(valueToVal(startValue));		stringRects = new Rectangle[values.length];		FontMetrics fm = getGraphics().getFontMetrics();		int ascent = fm.getAscent();		int descent = fm.getDescent();		int fontHeight = ascent + descent;		for (int i = 0; i < thumbVals.length; ++i){			stringRects[i] = new Rectangle(25, thumbVals[i] - (fontHeight + 1) / 2 + descent, fm.stringWidth(labels[i]), fontHeight);		}		spaceRects();		redLabel = -1;		for (int i = 0; i < values.length; ++i){			if (startValue == values[i]) redLabel = i;		}	}	void drawLabel(Graphics g, int i) {		if (i == redLabel) g.setColor(Color.red);		else g.setColor(getForeground());		FontMetrics fm = g.getFontMetrics();		int ascent = fm.getAscent();		int descent = fm.getDescent();		int fontHeight = ascent + descent;		g.drawString(labels[i], stringRects[i].x, stringRects[i].y + fontHeight - descent);	}	public double valueToVal(double theValue) {		float range = barRect.height - thumbHeight;		return (theValue - lowestValue) * range / originalRange + barRect.y;	}	public double valToValue(double theVal) {		for (int i = 0; i < thumbVals.length; ++i){			if (theVal == thumbVals[i]) return values[i];		}		float range = barRect.height - thumbHeight;		return lowestValue + originalRange / range * (thumbVal - barRect.y);	}	public double getValue() {		return valToValue(thumbVal);	}	void handleAction() {		notifyListeners();	}	protected void setValue(double value) {		thumbVal = (int) value;		if (thumbVal < thumbVals[0]) thumbVal = thumbVals[0];		if (thumbVal > thumbVals[thumbVals.length - 1]) thumbVal = thumbVals[thumbVals.length - 1];		repaint();	}	private void notifyListeners() {		ChangeListener[] listeners = (ChangeListener[]) getListeners(ChangeListener.class);		for (int i = 0; i < listeners.length; ++i){			listeners[i].stateChanged(new ChangeEvent(this));		}	}	public void paintComponent(Graphics g) {		g.setColor(getBackground());		g.fillRect(0, 0, size().width, size().height);		g.setColor(getForeground());		g.fillRect(barRect.x, barRect.y, barRect.width, barRect.height);		g.setColor(getForeground());		g.fillRect(barRect.x, thumbVal, barRect.width, thumbHeight);		if (thumbVal < thumbVals[0]) thumbVal = thumbVals[0];		if (thumbVal > thumbVals[thumbVals.length - 1]) thumbVal = thumbVals[thumbVals.length - 1];		g.setColor(Color.red);		g.fillRect(barRect.x, thumbVal, barRect.width, thumbHeight);		setValue(thumbVal);		for (int i = 0; i < thumbVals.length; ++i){			drawLabel(g, i);		}	}	public synchronized void reshape(int x, int y, int width, int height) {		barRect = new Rectangle(10, 10, 10, height - 20);		super.reshape(x, y, width, height);	}	public void mouseClicked(MouseEvent e) {	}	public void mouseEntered(MouseEvent e) {	}	public void mouseExited(MouseEvent e) {	}	public void mousePressed(MouseEvent e) {		Point mousePoint = e.getPoint();		Graphics g = getGraphics();		if (!barRect.inside(mousePoint.x, mousePoint.y)){			for (int i = 0; i < stringRects.length; ++i){				if (stringRects[i].inside(mousePoint.x, mousePoint.y)){					setValue(thumbVals[i]);					int oldRedLabel = redLabel;					redLabel = i;					if (oldRedLabel != -1) drawLabel(g, oldRedLabel);					drawLabel(g, redLabel);					break;				}			}			handleAction();			return;		}		int oldRedLabel = redLabel;		redLabel = -1;		if (mousePoint.y <= thumbVals[0]){			redLabel = 0;			drawLabel(g, 0);			setValue(thumbVals[0]);		}else if (mousePoint.y >= thumbVals[thumbVals.length - 1]){			redLabel = thumbVals.length - 1;			drawLabel(g, redLabel);			setValue(thumbVals[thumbVals.length - 1]);		}else{			for (int i = 1; i < thumbVals.length - 1; ++i){				if (mousePoint.y == thumbVals[i]){					redLabel = i;					drawLabel(g, i);				}			}		}		if (oldRedLabel != -1) drawLabel(g, oldRedLabel);		setValue(mousePoint.y);		handleAction();	}	public void mouseReleased(MouseEvent e) {	}	public void mouseDragged(MouseEvent e) {		Point mousePoint = e.getPoint();		Graphics g = getGraphics();		int oldRedLabel = redLabel;		redLabel = -1;		if (mousePoint.y <= thumbVals[0]){			redLabel = 0;			drawLabel(g, 0);			setValue(thumbVals[0]);		}else if (mousePoint.y >= thumbVals[thumbVals.length - 1]){			redLabel = thumbVals.length - 1;			drawLabel(g, redLabel);			setValue(thumbVals[thumbVals.length - 1]);		}else{			for (int i = 1; i < thumbVals.length - 1; ++i){				if (mousePoint.y == thumbVals[i]){					redLabel = i;					drawLabel(g, i);				}			}		}		if (oldRedLabel != -1) drawLabel(g, oldRedLabel);		setValue(mousePoint.y);		handleAction();	}	public void mouseMoved(MouseEvent e) {	}	public void addChangeListener(ChangeListener cl) {		listenerList.add(ChangeListener.class, cl);	}	public void removeChangeListener(ChangeListener cl) {		listenerList.remove(ChangeListener.class, cl);	}	public double getThumbVal() {		return thumbVal;	}}