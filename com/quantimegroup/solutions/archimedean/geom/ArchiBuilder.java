/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.geom;import com.quantimegroup.solutions.archimedean.common.SolidDefinition;import com.quantimegroup.solutions.archimedean.scene.ISpaceObject;import com.quantimegroup.solutions.archimedean.scene.SpaceSide;import com.quantimegroup.solutions.archimedean.scene.TruncableSpaceSide;import com.quantimegroup.solutions.archimedean.utils.IntList;import com.quantimegroup.solutions.archimedean.utils.Misc;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;public class ArchiBuilder {	ObjectList<OrderedTriple> points;	ObjectList<OrderedTriple> vectors;	ObjectList<ArchiCorner> corners;	ObjectList<OrderedTriple> nonUpdatingPoints;	private ObjectList<SpaceSide> sides;	ObjectList<ObjectList<OrderedTriple>> firstSides;	boolean ambiguous = false;	int ambiguousPoly = 0;	public static final double edgeLength = 100;	private int type;	int[] signature;	private static double maxError = 0;	private boolean untwist = true;	private ObjectList<IntList> multipleBoundary;	private static final boolean VERBOSE = false;	// original	private static double REGISTER_POINT_EPSILON = 1e-8;	private static double COMMIT_EPSILON = 1e-5;	private static double FIND_APPROX_POINT_EPSILON = 1e-2;	public int getType() {		return type;	}	public static ArchiBuilder manualArchiBuilder(int[] polyTypes, int numPolys) {		ArchiBuilder starter = new ArchiBuilder();		starter.maxError = 0;		starter.type = SolidDefinition.getSolidType(polyTypes, numPolys);		starter.points = new ObjectList<OrderedTriple>(10000);		starter.corners = new ObjectList<ArchiCorner>(10000);		starter.vectors = new ObjectList<OrderedTriple>(10000);		starter.sides = new ObjectList<SpaceSide>(10000);		try {			starter.createFirstSides(polyTypes, numPolys);			starter.getAmbiguous();			double poleTheta = ArchiCorner.init(starter.firstSides, starter.edgeLength);			ArchiCorner.createFirstCorner(starter.firstSides, starter.edgeLength, numPolys, poleTheta, starter, false);			ArchiCorner c = starter.getCorner(0);			OrderedTriple P1 = c.getHubPoint().mid(c.getSpoke(0));			OrderedTriple n = c.getHubPoint().minus(c.getSpoke(0));			OrderedTriple perp = n.arbitraryPerpendicular();			OrderedTriple P2 = P1.plus(perp);			OrderedTriple P3 = P1.plus(perp.cross(n));			OrderedTriple L1 = new OrderedTriple(0, 100, 0);			OrderedTriple L2 = OrderedTriple.origin();			OrderedTriple center = OrderedTriple.sectPlaneLine(P1, P2, P3, L1, L2);			for (int i = 0; i < starter.points.num; ++i) {				OrderedTriple p = starter.getPoint(i);				p.minusEquals(center);				if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))					p.x = 0;				if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))					p.y = 0;				if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))					p.z = 0;			}			starter.calcBoundary();		} catch (java.lang.Exception e) {			starter.center();			starter.type = SolidDefinition.UNDEFINED;			System.out.println(e.getMessage());		}		return starter;	}	public boolean calcBoundary() {		multipleBoundary = new ObjectList<IntList>(0, 1);		IntList edges1 = new IntList(0, 10);		IntList edges2 = new IntList(0, 10);		for (int a = 0; a < sides.num; ++a) {// for every side			SpaceSide sa = getSide(a);			for (int b = 0; b < sa.getVertexCount(); ++b) {// for every clockwize				// edge of				// that side				int i1 = sa.getIndex(b);				int i2 = sa.wrapgetIndex(b + 1);				boolean found = false;				for (int c = 0; c < sides.num; ++c) {// for every other side					if (c == a)						continue;// not the first side					SpaceSide sc = getSide(c);					if (sc.findIndex(i1) != -1 && sc.findIndex(i2) != -1) {// if it has						// this edge						found = true;						break;					}				}				if (!found) {					edges1.add(i1);					edges2.add(i2);				}			}		}		if (edges1.num == 0)			return false;		do {			IntList curBoundary = new IntList(10, 5);			int p = edges1.get(0);			do {				curBoundary.add(p);				int i = edges1.find(p);				p = edges2.get(i);				edges1.removeIndex(i);				edges2.removeIndex(i);			} while (p != curBoundary.get(0));			multipleBoundary.add(curBoundary);		} while (edges1.num > 0);		// boundary = (IntList)multipleBoundary.get( 0 );		return true;	}	public ArchiBuilder() {	}	public ArchiBuilder(int[] polyTypes) {		this(polyTypes, polyTypes.length);	}	public ArchiBuilder(int[] polyTypes, int numPolys) {		this(polyTypes, numPolys, true);	}	public ArchiBuilder(int[] polyTypes, int numPolys, boolean untwist) {		this.untwist = untwist;		maxError = 0;		type = SolidDefinition.getSolidType(polyTypes, numPolys);		points = new ObjectList<OrderedTriple>(10000);		corners = new ObjectList<ArchiCorner>(10000);		vectors = new ObjectList<OrderedTriple>(10000);		sides = new ObjectList<SpaceSide>(10000);		try {			createFirstSides(polyTypes, numPolys);			getAmbiguous();			double poleTheta = ArchiCorner.init(firstSides, edgeLength);			ArchiCorner.createFirstCorner(firstSides, edgeLength, numPolys, poleTheta, this);			if (ambiguous && !isComplete()) {				recurse(numPolys, poleTheta);			}			if (corners.num != points.num) {				type = SolidDefinition.RATIONAL;			}		} catch (java.lang.Exception e) {			// center();			type = SolidDefinition.UNDEFINED;			System.out.println(e.getMessage());		}		center();		if (VERBOSE) {			System.out.println("corners: " + corners.num + ", points: " + points.num + ", ratio: " + ((double) corners.num) / points.num);		}		signature = getCorner(0).getSignature();		// print();	}	public void recurse(int numSpokes, double poleTheta) throws Exception {		SpaceSide s1 = null, s2 = null;		OrderedTriple newHub = null;		int hubIndex, s1index, s2index;		for (int c = 0; c < corners.num; ++c) {// these two loops find the first			// uncompleted corner			ArchiCorner curCorner = (ArchiCorner) corners.get(c);			for (int s = 0; s < curCorner.getSpokes().num; ++s) {				newHub = (OrderedTriple) curCorner.getSpoke(s);				hubIndex = curCorner.getSpokes().get(s);				s1 = curCorner.wrapgetSide(s);				s1index = curCorner.getSides().get(s);				s2 = curCorner.wrapgetSide(s - 1);				s2index = curCorner.getSides().wrapget(s - 1);				if (cornerIsBuilt(hubIndex, s1index, s2index) == -1) {					s = curCorner.getSpokes().num;					c = corners.num;					break;				}			}		}		ArchiCorner c = ArchiCorner.simpleCorner(newHub, s1, s2, numSpokes, poleTheta, this);// hub,		// 3		// spokes,		// pole		State state = getState();		for (int nextPosition = c.getFirstSides(s1, s2, 0, numSpokes);; nextPosition = c.getFirstSides(s1, s2, nextPosition, numSpokes)) {			try {				c.complete(numSpokes, poleTheta, 0);				if (isComplete())					break;				recurse(numSpokes, poleTheta);				if (isComplete())					break;			} catch (Exception e) {				setState(state);				c.getSpokes().num = 3;				c.getSides().num = 0;				continue;			}		}	}	public boolean isComplete() throws Exception {		if (points.num == corners.num)			return true;		if (untwist == true) {			int[] sign = getCorner(0).getSignature();			int[] bug = {					3, 4, 4, 4 };			if (Misc.arrayCompare(sign, bug) != 0)				return false;			// if( any square has only 1 triangle )			int numNeighbors = 0;			int numTriangles = 0;			for (int i = 0; i < sides.num; ++i) {				SpaceSide si = getSide(i);				if (si.getVertexCount() != 4)					continue;				numNeighbors = 0;				numTriangles = 0;				for (int j = 0; j < sides.num; ++j) {					if (j == i)						continue;					SpaceSide sj = getSide(j);					if (si.isAdjacent(sj)) {						++numNeighbors;						if (sj.getVertexCount() == 3)							numTriangles++;					}				}				if (numNeighbors == 4 && numTriangles == 1)					throw new Exception("3444 exception");			}		}		return false;	}	void getAmbiguous() {		ambiguous = false;		ambiguousPoly = 0;		int p1, p2, p3, curPoly;		p1 = p2 = p3 = curPoly = 0;		for (int i = 0; i < firstSides.num + 2; ++i) {			ObjectList<OrderedTriple> s = firstSides.wrapget(i);			p3 = s.num;			if (p3 == p2 && p3 == p1) {				ambiguousPoly = p3;				ambiguous = true;				break;			} else {				p1 = p2;				p2 = p3;				curPoly = p1;			}		}		if (ambiguous) {			for (int i = 0; i < firstSides.num; ++i) {				ObjectList<OrderedTriple> s = firstSides.get(i);				if (s.num != ambiguousPoly) {					return;				}			}			ambiguous = false;		}	}	void createFirstSides(int[] polyTypes, int numPolys) throws Exception {		firstSides = new ObjectList<ObjectList<OrderedTriple>>(numPolys);		for (int i = 0; i < numPolys; ++i) {			ObjectList<OrderedTriple> s = GeometryUtils.createPoly(polyTypes[i], edgeLength);			firstSides.add(s);		}	}	int registerPointExactMatch(OrderedTriple p) {// adds point if it isn't		// already there, returns it or		// the one it found		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = getPoint(i);			if (curp.getClass() == pClass && p.equals(curp))				return i;		}		return points.addReturnIndex(p);	}	public int registerPoint(OrderedTriple p) throws Exception {// adds point if		// it		// isn't already there,		// returns it or the one		// it found		if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))			p.x = 0;		if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))			p.y = 0;		if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))			p.z = 0;		Class pClass = p.getClass();		for (int i = 0; i < points.num; ++i) {			OrderedTriple curp = (OrderedTriple) points.get(i);			if (curp.getClass() == pClass) {				if (p.distanceSquared(curp) < REGISTER_POINT_EPSILON) {// if it's					// extremely					// close to a					// point					double error = p.distance(curp);					if (error > maxError)						maxError = error;					return i;				}				if (ambiguous && p.distance(curp) < edgeLength * 0.99)// if it's too far					// to be the same					// but too close					// to be					// legitimate					throw new Exception("EXCEPTION: overlapping sides.");			}		}		return points.addReturnIndex(p);	}	static public int findApproxPoint(OrderedTriple p, ObjectList<OrderedTriple> l) {		for (int i = 0; i < l.num; ++i) {			OrderedTriple curp = l.get(i);			if (curp.isApprox(p, FIND_APPROX_POINT_EPSILON))				return i;		}		return -1;	}	int registerCorner(ArchiCorner c) {		return corners.addReturnIndex(c);	}	public int registerSide(SpaceSide s) {		OrderedTriple n = s.calcNormal();		s.setNormal(vectors.addReturnIndex(n));		return sides.addReturnIndex(s);	}	int cornerIsBuilt(int p, int s1i, int s2i) {		SpaceSide s1 = getSide(s1i);		SpaceSide s2 = getSide(s2i);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = (ArchiCorner) corners.get(i);			if (c.getHub() == p) {				for (int j = 0; j < c.getSides().num; ++j) {					if (c.getSide(j) == s1 && c.wrapgetSide(j + 1) == s2)						return 1;				}			}		}		return -1;	}	int sideIsBuilt(OrderedTriple p1, OrderedTriple p2, OrderedTriple p3) {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = (SpaceSide) sides.get(i);			int index = s.findPoint(p1);			if (index != -1 && s.wrapgetPoint(index + 1) == p2 && s.wrapgetPoint(index + 2) == p3)				return i;		}		return -1;	}	ArchiCorner findCorner(OrderedTriple h) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (h == c.getHubPoint())				return c;		}		return null;	}	void center() {		ArchiCorner c = (ArchiCorner) corners.get(0);		OrderedTriple p1 = c.getHubPoint();		OrderedTriple p2 = p1.plus(c.getPole());		c = (ArchiCorner) corners.get(1);		OrderedTriple p3 = c.getHubPoint();		OrderedTriple p4 = p3.plus(c.getPole());		OrderedTriple center = OrderedTriple.sectLines(p1, p2, p3, p4);		for (int i = 0; i < points.num; ++i) {			OrderedTriple p = (OrderedTriple) points.get(i);			p.minusEquals(center);			if (OrderedTriple.isApprox(p.x, 0, REGISTER_POINT_EPSILON))				p.x = 0;			if (OrderedTriple.isApprox(p.y, 0, REGISTER_POINT_EPSILON))				p.y = 0;			if (OrderedTriple.isApprox(p.z, 0, REGISTER_POINT_EPSILON))				p.z = 0;		}	}	public SpaceSide getSide(int i) {		return (SpaceSide) sides.get(i);	}	SpaceSide wrapgetSide(int i) {		return (SpaceSide) sides.wrapget(i);	}	public ArchiCorner getCorner(int i) {		return (ArchiCorner) corners.get(i);	}	public IntList getMultipleBoundary(int i) {		return (IntList) multipleBoundary.get(i);	}	ArchiCorner wrapgetCorner(int i) {		return (ArchiCorner) corners.wrapget(i);	}	public OrderedTriple getPoint(int i) {		return (OrderedTriple) points.get(i);	}	OrderedTriple wrapgetPoint(int i) {		return (OrderedTriple) points.wrapget(i);	}	public void setPoints(ObjectList<OrderedTriple> points) {		this.points = points;	}	public void setSides(ObjectList<SpaceSide> sides) {		this.sides = sides;	}	public void setVectors(ObjectList<OrderedTriple> vectors) {		this.vectors = vectors;	}	public void clearPoints() {		points.num = 0;	}	public void clearVectors() {		vectors.num = 0;	}	public void clearSides() {		sides.num = 0;	}	void print() {		System.out.println("points.num = " + (points == null ? "null" : String.valueOf(points.num)));		System.out.println("corners.num = " + (corners == null ? "null" : String.valueOf(corners.num)));		System.out.println("sides.num = " + (sides == null ? "null" : String.valueOf(sides.num)));		System.out.println("vectors.num = " + (vectors == null ? "null" : String.valueOf(vectors.num)));		System.out.println("edgeLength = " + edgeLength);		// System.out.println( "maxEdgeLength = " + maxEdgeLength );		System.out.println();	}	double truncStage1() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide s = c.getSide(0);		double l = s.getEdgeLength();		double theta = ArchiCorner.polyAngle(s.getVertexCount());		double x = l / (2 * Math.sin(theta / 2) + 2);// distance along a spoke		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).unit().times(x);// vector		// with		// length		// x		return pole.comp(v) / radius * 100;	}	double truncStage2() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		OrderedTriple v = c.getSpoke(0).minus(c.getHubPoint()).dividedBy(2);		return pole.comp(v) / radius * 100;	}	double truncStage3() {		double radius = getMinRadius();		ArchiCorner corner = getCorner(0);		OrderedTriple pole = corner.getPole();		SpaceSide s0 = corner.getSide(0);		SpaceSide s1 = corner.getSide(1);		OrderedTriple a, b, c, d, e, f, g, x, y, z, S, T, U;		double K, A, B, C, roots[];		a = corner.getHubPoint().mid(corner.getSpoke(0));		b = corner.getHubPoint().mid(corner.getSpoke(1));		c = s0.getCenter();		d = s1.getCenter();		x = c.minus(a);		y = c.minus(b);		z = d.minus(b);		S = b.minus(a);		T = y.minus(x);		U = y.minus(z);		A = T.lengthSquared() - U.lengthSquared();		B = 2 * S.dot(T);		C = S.lengthSquared();		try {			roots = OrderedTriple.solveQuadratic(A, B, C);		} catch (Exception exc) {			return 0;		}		if (roots.length == 1)			K = roots[0];		else if (roots.length == 3)			K = roots[2];		else if (roots[0] > 0 && roots[0] < 1)			K = roots[0];		else			K = roots[1];		OrderedTriple p = a.plus(x.times(K));		OrderedTriple v = p.minus(corner.getHubPoint());		return pole.comp(v) / radius * 100;	}	double truncStage4() {		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide s = c.getSide(0);		OrderedTriple center = s.getCenter();		OrderedTriple v = center.minus(c.getHubPoint());		return pole.comp(v) / radius * 100;	}	public double[] calcEdgeTruncStages() {		double ts[] = new double[5];		ts[0] = 0;		int numStages = 1;		// double radius = getPoint( 0 ).length();		ArchiCorner c = getCorner(0);		OrderedTriple truncVector;		SpaceSide minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				SpaceSide s = c.getSide(i);				if (s.getVertexCount() > lastMinPoints && (minSide == null || s.getVertexCount() < minSide.getVertexCount())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple p1 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()));			OrderedTriple p2 = minSide.wrapgetPoint(minSide.findIndex(c.getHub()) + 1);			OrderedTriple mid = p1.mid(p2);			truncVector = mid.negative();			double radius = mid.length();			OrderedTriple center = minSide.getCenter();			OrderedTriple v = center.minus(mid);			ts[numStages] = truncVector.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.getVertexCount();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	double[] calcArchiTruncStages(int[] polys, int numPolys) {		double ts[] = new double[5];		ts[0] = 0;		ts[1] = truncStage2();		int numStages = 2;		double radius = getPoint(0).length();		ArchiCorner c = getCorner(0);		OrderedTriple pole = c.getPole();		SpaceSide minSide = null;		int lastMinPoints = 0;		do {			minSide = null;			for (int i = 0; i < c.getSides().num; ++i) {				SpaceSide s = c.getSide(i);				if (s.getVertexCount() > lastMinPoints && (minSide == null || s.getVertexCount() < minSide.getVertexCount())) {					minSide = s;				}			}			if (minSide == null)				break;			OrderedTriple center = minSide.getCenter();			OrderedTriple v = center.minus(c.getHubPoint());			ts[numStages] = pole.comp(v) / radius * 100;			++numStages;			lastMinPoints = minSide.getVertexCount();		} while (minSide != null);		double[] result = new double[numStages];		System.arraycopy(ts, 0, result, 0, numStages);		return result;	}	public double[] calcTruncStages() {		double[] result = null;		ArchiCorner c = getCorner(0);		int[] polys = new int[c.getSpokes().num];		for (int i = 0; i < polys.length; ++i) {			polys[i] = c.getSide(i).getVertexCount();		}		switch (SolidDefinition.getSolidType(polys)) {		case SolidDefinition.PLATONIC:			double[] temp1 = {					0, truncStage1(), truncStage2(), truncStage3(), truncStage4() };			result = temp1;			break;		case SolidDefinition.ARCHIMEDEAN:			result = calcArchiTruncStages(polys, polys.length);			break;		}		return result;	}	int findCornerByHub(int h) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			if (c.getHub() == h)				return i;		}		return -1;	}	void prepareGoals(ArchiBuilder trunc, IntList starts, int[][] mids, IntList centers, int numSpokes) {		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			int h = c.getHub();			OrderedTriple hp = c.getHubPoint().copy();			starts.add(trunc.nonUpdatingPoints.addReturnIndex(hp));			for (int j = 0; j < numSpokes; ++j) {				int s = c.getSpokes().get(j);				if (s > h) {					ArchiCorner c2 = getCorner(findCornerByHub(s));					int j2 = c2.getSpokes().find(h);					mids[h][j] = mids[s][j2] = trunc.nonUpdatingPoints.addReturnIndex(hp.mid(c.getSpoke(j)));				}			}		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			centers.add(trunc.nonUpdatingPoints.addReturnIndex(s.getCenter()));		}	}	public ArchiBuilder prepareCornerTrunc() {		return null;	}	public ArchiBuilder dual() {		ArchiBuilder dual = new ArchiBuilder();		dual.sides = new ObjectList<SpaceSide>(corners.num);		dual.points = new ObjectList<OrderedTriple>(sides.num);		dual.points.num = sides.num;		dual.vectors = new ObjectList<OrderedTriple>(corners.num);		for (int i = 0; i < corners.num; ++i) {			ArchiCorner c = getCorner(i);			OrderedTriple pole = c.getPole();			OrderedTriple h = c.getHubPoint();			for (int j = 0; j < c.getSides().num; ++j) {				int s = c.getSides().get(j);				if (dual.getPoint(s) != null)					continue;				OrderedTriple spoke1 = c.getSpoke(j);				OrderedTriple spoke2 = c.wrapgetSpoke(j + 1);				OrderedTriple spokev1 = spoke1.minus(h);				OrderedTriple spokev2 = spoke2.minus(h);				OrderedTriple v1 = spokev1.cross(pole);				OrderedTriple v2 = spokev2.cross(pole);				OrderedTriple m1 = h.mid(spoke1);				OrderedTriple m2 = h.mid(spoke2);				dual.points.set(s, OrderedTriple.sectLines(m1, m1.plus(v1), m2, m2.plus(v2)));			}			TruncableSpaceSide s = new TruncableSpaceSide(c.getSpokes().num);			s.setIndex(c.getSides().copy());			s.setPoints(dual.points);			s.setVectors(dual.vectors);			s.setNormal(dual.vectors.addReturnIndex(s.calcNormal()));			s.setCornerSide(true);			dual.sides.add(s);		}		if (type == SolidDefinition.PLATONIC)			dual.type = SolidDefinition.PLATONIC;		else			dual.type = SolidDefinition.DUAL;		dual.signature = signature;		return dual;	}	public ArchiBuilder antiDual() {		return null;	}	public ArchiBuilder prepareEdgeTrunc() {		return null;	}	double getMinRadius() {		double cur, min = Double.POSITIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur < min)				min = cur;		}		return min;	}	public double getMaxRadius() {		double cur, max = Double.NEGATIVE_INFINITY;		for (int i = 0; i < points.num; ++i) {			cur = getPoint(i).length();			if (cur > max)				max = cur;		}		return max;	}	public ArchiBuilder commit(ISpaceObject poly) {		return commit(poly, true, null);	}	public ArchiBuilder commit(ISpaceObject poly, boolean doCorners) {		return commit(poly, doCorners, null);	}	public ArchiBuilder commit(ISpaceObject poly, IntList oldSideList) {		return commit(poly, true, oldSideList);	}	private ArchiBuilder commit(ISpaceObject poly, boolean doCorners, IntList oldSideList) {		return null;	}	int[] getPointUsage() {		int[] table = new int[points.num];		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			for (int j = 0; j < s.getVertexCount(); ++j) {				table[s.getIndex(j)]++;			}		}		return table;	}	public void completeCorners() {		corners = new ObjectList<ArchiCorner>(points.num);		IntList[] table = new IntList[points.num];		for (int i = 0; i < points.num; ++i) {			table[i] = new IntList(10, 5);		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			for (int j = 0; j < s.getVertexCount(); ++j) {				table[s.getIndex(j)].add(i);			}		}		for (int i = 0; i < points.num; ++i) {			ArchiCorner c = new ArchiCorner();			c.setHub(i);			if (table[i].num == 0) {				Exception e = new Exception();				e.printStackTrace();			}			c.setSpokes(new IntList(table[i].num));			c.setSides(new IntList(table[i].num));			int sideIndex = table[i].get(0);			c.getSides().add(sideIndex);			SpaceSide s = getSide(sideIndex);			int find = s.findIndex(i);			int spoke = s.wrapgetIndex(find + 1);			c.getSpokes().add(spoke);			spoke = s.wrapgetIndex(find - 1);			table[i].removeIndex(0);			while (table[i].num > 0) {				for (int j = 0; j < table[i].num; ++j) {					sideIndex = table[i].get(j);					s = getSide(sideIndex);					find = s.findIndex(spoke);					if (find != -1) {						c.getSides().add(sideIndex);						c.getSpokes().add(spoke);						spoke = s.wrapgetIndex(find - 2);						table[i].removeIndex(j);						--j;						break;					}				}			}			corners.add(c);		}		return;	}	public void reclaim() {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.setPoints(points);			s.setVectors(vectors);		}	}	public void assign(ISpaceObject p) {		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.setPoints(p.getPoints());			s.setVectors(p.getVectors());		}	}	void printType() {		System.out.println(SolidDefinition.typeToString(type));	}	public int numEdges() {		int numEdges = 0;		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			numEdges += s.getVertexCount();		}		return numEdges / 2;	}	public void reflect() {		for (int i = 0; i < points.num; ++i) {			getPoint(i).timesEquals(-1);		}		for (int i = 0; i < vectors.num; ++i) {			((OrderedTriple) vectors.get(i)).timesEquals(-1);		}		if (nonUpdatingPoints != null) {			for (int i = 0; i < nonUpdatingPoints.num; ++i) {				((OrderedTriple) nonUpdatingPoints.get(i)).timesEquals(-1);			}		}		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			s.getIndex().reverse();		}		if (corners != null) {			for (int i = 0; i < corners.num; ++i) {				ArchiCorner c = getCorner(i);				c.getSpokes().reverse();				c.setSides(c.getSides().wrapCopy(-2, -1));				c.setPole(null);			}		}	}	public int getCornerCount() {		return corners.num;	}	public int getMultipleBoundaryCount() {		return multipleBoundary.num;	}	public int getPointCount() {		return points.num;	}	public int getSideCount() {		return sides.num;	}	void sectLine(OrderedTriple L1, OrderedTriple L2, SpaceSide[] sideArray, OrderedTriple[] sects) {		int n = 0;		for (int i = 0; i < sides.num; ++i) {			SpaceSide s = getSide(i);			OrderedTriple[] p = s.threeDistinctPoints();			OrderedTriple sect = OrderedTriple.sectPlaneLine(p[0], p[1], p[2], L1, L2);			if (sect == null)				continue;			if (n > 0 && sect.isApprox(sects[0], COMMIT_EPSILON))				continue;			if (s.inside(sect)) {				sects[n] = sect;				sideArray[n] = s;				n++;				if (n == 2)					break;			}		}	}	public State getState() {		State s = new State();		s.numCorners = corners.num;		s.numVectors = vectors.num;		s.numPoints = points.num;		s.numSides = sides.num;		return s;	}	public void setState(State s) {		corners.num = s.numCorners;		vectors.num = s.numVectors;		points.num = s.numPoints;		sides.num = s.numSides;	}	public ObjectList<ArchiCorner> getCorners() {		return corners;	}	public ObjectList<OrderedTriple> getPoints() {		return points;	}	public ObjectList<OrderedTriple> getVectors() {		return vectors;	}	public ObjectList<SpaceSide> getSides() {		return sides;	}	public int[] getSignature() {		return signature;	}}class State {	int numCorners, numPoints, numSides, numVectors;	void print() {		System.out.println("numCorners = " + numCorners);		System.out.println("numPoints = " + numPoints);		System.out.println("numSides = " + numSides);		System.out.println("numVectors = " + numSides);		System.out.println();	}}