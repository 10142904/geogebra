/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.scene;import java.awt.Color;import java.awt.Graphics;import java.util.ArrayList;import java.util.List;import com.quantimegroup.solutions.archimedean.geom.ArchiBuilder;import com.quantimegroup.solutions.archimedean.utils.Axes;import com.quantimegroup.solutions.archimedean.utils.ObjectList;import com.quantimegroup.solutions.archimedean.utils.OrderedTriple;import com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix;import com.quantimegroup.solutions.archimedean.utils.Rotater;public class SpacePoly implements Geometry.Listener {	private Surface surface;	private List<SpacePoint> spacePoints;	private List<SpaceFacet> spaceFacets;	private final Axes personalAxes = new Axes();	private final List<Rotater> rotaters = new ArrayList<Rotater>(5);	private boolean[] cornersToShow;	private List<Line> lines = new ArrayList<Line>();	private static Color frontColor = Color.white, backColor = Color.gray, inColor = Color.lightGray;	private boolean highlightCorners = false;	private boolean showBackSides = true;	private static Surface createSurface(ArchiBuilder b) {		ObjectList<OrderedTriple> points = b.getPoints();		Surface surface = new Surface((OrderedTriple[]) points.toArray(new OrderedTriple[0]));		ObjectList<SpaceSide> sides = b.getSides();		for (SpaceSide side : sides) {			int[] pointIndices = side.getIndex().ints;			OrderedTriple normal = side.getNormal();			Facet facet = new Facet(surface, pointIndices, normal);			surface.addFacet(facet);		}		return surface;	}	public static SpacePoly create(ArchiBuilder b) {		SpacePoly spacePoly = new SpacePoly();		Surface surface = createSurface(b);		spacePoly.initSurface(surface);		return spacePoly;	}	public void setBuilder(ArchiBuilder b) {		Surface surface = createSurface(b);		initSurface(surface);	}	private SpacePoly() {	}	public void initSurface(Surface surface) {		this.surface = surface;		spacePoints = new ObjectList<SpacePoint>(surface.getPointCount());		for (OrderedTriple p : surface.getPoints()) {			spacePoints.add(new SpacePoint(p));		}		spaceFacets = new ObjectList<SpaceFacet>(surface.getFacetCount());		for (Facet facet : surface.getFacets()) {			SpaceFacet spaceFacet = new SpaceFacet(spacePoints, facet.getPointIndices().ints);			spaceFacets.add(spaceFacet);		}		cornersToShow = new boolean[spacePoints.size()];	}	public void geometryChanged() {		initSurface(surface);	}	public double getSizeFactor() {		return personalAxes.sizeFactor;	}	public void setSizeFactor(double sizeFactor) {		personalAxes.sizeFactor = sizeFactor;	}	public void update() {		for (int i = 0; i < spacePoints.size(); ++i) {			SpacePoint p = spacePoints.get(i);			p.become(surface.getPoint(i));			personalAxes.transformPoint(p);			p.toScreenCoord();		}		for (int i = 0; i < surface.getFacets().size(); ++i) {			OrderedTriple normal = spaceFacets.get(i).getNormal();			normal.become(surface.getFacet(i).getNormal());			personalAxes.transformVector(normal);		}		for (SpaceFacet spaceFacet : spaceFacets) {			spaceFacet.update();		}	}	public void sizeToFit(int width, int height) {		personalAxes.sizeFactor = Math.min(width, height) * 0.9 / (surface.getMaxRadius() * 2);	}	public void render(Graphics g, IScenePrefs scenePrefs) {		update();		for (int i = 0; i < spacePoints.size(); ++i) {			cornersToShow[i] = false;		}		for (SpaceFacet s : spaceFacets) {			s.update();		}		for (Line l : lines) {			for (int j = 0; j < 2; ++j) {				if (!l.visible(j))					drawLine(l.sects[j], l.outs[j], g, backColor);			}		}		if (showBackSides) {			List<SpaceFacet> frontSides = new ArrayList<SpaceFacet>();			for (SpaceFacet s : spaceFacets) {				if (s.visible()) {					frontSides.add(s);					for (int j = 0; j < s.getVertexCount(); ++j) {						cornersToShow[s.getPointIndex(j)] = true;					}				} else {					s.render(g, scenePrefs);				}			}			if (highlightCorners) {			}			for (Line l : lines) {				drawLine(l.sects[0], l.sects[1], g, inColor);			}			for (SpaceFacet s : frontSides) {				s.render(g, scenePrefs);			}		} else {			for (SpaceFacet s : spaceFacets) {				if (s.visible()) {					s.render(g, scenePrefs);					for (int j = 0; j < s.getVertexCount(); ++j) {						cornersToShow[s.getPointIndex(j)] = true;					}				}			}		}		for (Line l : lines) {			for (int j = 0; j < 2; ++j) {				if (l.visible(j))					drawLine(l.sects[j], l.outs[j], g, frontColor);			}		}		if (highlightCorners) {		}	}	public void toScreenCoord() {		update();		for (SpacePoint p : spacePoints) {			p.toScreenCoord();		}	}	public SpaceFacet getSide(int i) {		return spaceFacets.get(i);	}	public List<SpaceFacet> getSides() {		return spaceFacets;	}	public SpacePoint getPoint(int i) {		return spacePoints.get(i);	}	public void rotate(OrderedTriple p0, OrderedTriple n0, OrderedTriple p1, OrderedTriple n1) {		// rotate around origin to bring p0 -> n0 and p1 -> n1		Quick3X3Matrix M = Quick3X3Matrix.findRotationMatrix(p0, n0, p1, n1);		personalAxes.timesEquals(M);		personalAxes.correct();		for (Rotater ri : rotaters) {			ri.update(M);		}		// dirtyPoints = true;	}	public void rotate(OrderedTriple p0, OrderedTriple n0) {		// rotate around origin to bring p0 -> n0		Quick3X3Matrix M = Quick3X3Matrix.findRotationMatrix(p0, n0);		personalAxes.timesEquals(M);		personalAxes.correct();		for (Rotater ri : rotaters) {			ri.update(M);		}		// dirtyPoints = true;	}	void drawLine(SpacePoint p1, SpacePoint p2, Graphics g, Color color) {		g.setColor(color);		g.drawLine(p1.screenx + 1, p1.screeny + 1, p2.screenx + 1, p2.screeny + 1);	}	public String toString() {		int count;		StringBuilder sb = new StringBuilder();		sb.append("\nSpacePoly dump\n");		sb.append("Points:\n");		count = 0;		for (SpacePoint sp : spacePoints) {			sb.append("\t" + count++ + sp + "\n");		}		sb.append("Facets:\n");		count = 0;		for (SpaceFacet sf : spaceFacets) {			sb.append("\t" + count++ + "" + sf.getPointIndices() + "\n");			sb.append("\tnormal: " + sf.getNormal() + "\n");		}		return sb.toString();	}}