/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.quantimegroup.solutions.archimedean.utils;import java.awt.Polygon;
public class SmartPolygon extends Polygon {	// This class's raison d'etre is to have a mathematically precise inside	// function. The SmartPolygon must be convex for it to work.	private static long time = 0;	static void startTimer() {		time = System.currentTimeMillis();	}	static long stopTimer() {		return System.currentTimeMillis() - time;	}	public SmartPolygon(Polygon p) {		this.xpoints = p.xpoints;		this.ypoints = p.ypoints;		this.npoints = p.npoints;	}	// Assumes that the SmartPolygon is "closed". This means that its last point	// equals its first point.	// Also assumes that the SmartPolygon is convex.	public boolean inside(OrderedDouble p) {		return inside(this, p);	}	public boolean inside(int x, int y) {		return SmartPolygon.inside(this, x, y);	}	static public boolean inside(Polygon p, int x, int y) {		// guarantee that the first edge we test doesn't start at y or that all		// edges start and end on y		int start = 0;		for (int i = 0; i < p.npoints; ++i) {			if (p.ypoints[i] != y) {				start = i;				break;			}		}		int prevdir = 0, postdir = 0, crossings = 0;		int p1x, p1y, p2x, p2y;// edge endpoints		p2x = p.xpoints[start];		p2y = p.ypoints[start];		start++;		for (int i = start; i < start + p.npoints; ++i) {// for every edge (p1x,																											// p1y) -> (p2x, p2y)			p1x = p2x;			p1y = p2y;			p2x = p.xpoints[i % p.npoints];			p2y = p.ypoints[i % p.npoints];			if (p1x == p2x && p1y == p2y)				continue;// that is real			else if (p1y == y && p2y == y) {// if horizontal at y				if ((p1x <= x && p2x >= x) || (p1x >= x && p2x <= x)) {// and x is																																// between the																																// endpoints					return true;// on edge				}			} else if (p1y == y) {// if it starts at y				postdir = p2y < y ? '+' : '-';				if (prevdir == postdir && // and continues in the same direction as the																	// edge ending on y						p1x < x) {// and crosses y to the left of x					crossings++;				}			} else if (p2y == y) {// if it ends on y				if (p2x == x) {// and x					return true;// on point				}				prevdir = p1y < y ? '-' : '+';// remember what direction the line is																			// going			} else if ((p1y < y && p2y > y) || (p1y > y && p2y < y)) {// if it crosses																																// from above to																																// below or																																// below to																																// above				// find the intesection				double dx = p2x - p1x;				double dy = p2y - p1y;				double intersect = p1x + (y - p1y) * dx / dy;				if (Math.round(intersect) == x)					return true;// on edge				if (intersect < x)					crossings++;			}		}		return crossings % 2 == 1;// the point is inside if it crossed an odd number															// of edges on its way out	}	static public boolean inside(Polygon poly, OrderedDouble p, boolean clockwise) {		OrderedDouble P1 = null;		OrderedDouble P2 = new OrderedDouble(poly.xpoints[0], poly.ypoints[0]);		int numRealSides = 0;		for (int i = 1; i < poly.npoints; ++i) {			// for every pair of consecutive points P1 and P2			P1 = P2;			P2 = new OrderedDouble(poly.xpoints[i], poly.ypoints[i]);			if (P1.equals(P2))				continue;			++numRealSides;			if (clockwise) {				if (p.minus(P1).dot(OrderedDouble.clockwise90(P2.minus(P1))) < 0) {					return false;				}			} else {				if (p.minus(P1).dot(OrderedDouble.clockwise90(P2.minus(P1))) > 0) {					return false;				}			}		}		return numRealSides >= 3;	}	static public boolean inside(Polygon poly, OrderedDouble p) {		return inside(poly, p, isClockwise(poly));	}	static public boolean isClockwise(Polygon poly) {		// Assumes that the SmartPolygon is convex and that it has at least 3		// points.		OrderedDouble p1 = new OrderedDouble(poly.xpoints[0], poly.ypoints[0]);		OrderedDouble p2 = new OrderedDouble(poly.xpoints[1], poly.ypoints[1]);		OrderedDouble p3 = new OrderedDouble(poly.xpoints[2], poly.ypoints[2]);		return p3.minus(p2).dot(OrderedDouble.clockwise90(p2.minus(p1))) > 0;	}	public boolean isClockwise() {		// Assumes that the SmartPolygon is convex and that it has at least 3		// points.		return isClockwise(this);	}}