au.com.bytecode.opencsv.CSVParser -> a.a.a.a.a:
    char separator -> a
    char quotechar -> b
    char escape -> c
    boolean strictQuotes -> a
    java.lang.String pending -> a
    boolean inField -> d
    boolean ignoreLeadingWhiteSpace -> b
    boolean ignoreQuotations -> c
    boolean anyCharactersAreTheSame(char,char,char) -> a
    boolean isSameCharacter(char,char) -> a
    java.lang.String[] parseLineMulti(java.lang.String) -> a
    java.lang.String[] parseLine(java.lang.String,boolean) -> a
    boolean isNextCharacterEscapedQuote(java.lang.String,boolean,int) -> b
    boolean isNextCharacterEscapable(java.lang.String,boolean,int) -> a
    boolean isAllWhiteSpace(java.lang.CharSequence) -> a
ccsd.ti.ExperimentConfig -> ccsd.ti.a:
    long swigCPtr -> a
    boolean swigCMemOwn -> a
    void finalize() -> finalize
    void delete() -> a
    long getCPtr(ccsd.ti.ExperimentConfig) -> a
    boolean isValid() -> isValid
    boolean getExactPeriod() -> getExactPeriod
    org.concord.sensor.SensorConfig[] getSensorConfigs() -> getSensorConfigs
    short getValid() -> a
    java.lang.String getInvalidReason() -> getInvalidReason
    void setPeriod(float) -> a
    float getPeriod() -> getPeriod
    short getExactPeriodUChar() -> b
    void setNumberOfSamples(int) -> a
    float getDataReadPeriod() -> getDataReadPeriod
    java.lang.String getDeviceName() -> getDeviceName
    void setNumSensorConfigs(int) -> b
    int getNumSensorConfigs() -> a
    ccsd.ti.SensorConfig getSensorConfig(int) -> a
    void createSensorConfigArray(int) -> c
    void setSensorConfig(ccsd.ti.SensorConfig,int) -> a
ccsd.ti.NativeBridge -> ccsd.ti.b:
    ccsd.ti.SWIGTYPE_p_void SensDev_open(java.lang.String) -> a
    int SensDev_close(ccsd.ti.SWIGTYPE_p_void) -> a
    int SensDev_isAttached(ccsd.ti.SWIGTYPE_p_void) -> b
    int SensDev_start(ccsd.ti.SWIGTYPE_p_void) -> c
    int SensDev_stop(ccsd.ti.SWIGTYPE_p_void) -> d
    int SensDev_read(ccsd.ti.SWIGTYPE_p_void,ccsd.ti.SWIGTYPE_p_float,ccsd.ti.SWIGTYPE_p_float,int) -> a
    ccsd.ti.ExperimentConfig configureHelper(ccsd.ti.SWIGTYPE_p_void,ccsd.ti.ExperimentConfig) -> a
    ccsd.ti.SWIGTYPE_p_float new_floatArray(int) -> a
    float floatArray_getitem(ccsd.ti.SWIGTYPE_p_float,int) -> a
ccsd.ti.NativeBridgeJNI -> ccsd.ti.NativeBridgeJNI:
    short get_SensorConfig_confirmed(long) -> get_SensorConfig_confirmed
    void set_SensorConfig_type(long,int) -> set_SensorConfig_type
    int get_SensorConfig_type(long) -> get_SensorConfig_type
    void set_SensorConfig_stepSize(long,float) -> set_SensorConfig_stepSize
    float get_SensorConfig_stepSize(long) -> get_SensorConfig_stepSize
    void set_SensorConfig_requiredMax(long,float) -> set_SensorConfig_requiredMax
    void set_SensorConfig_requiredMin(long,float) -> set_SensorConfig_requiredMin
    void set_SensorConfig_port(long,int) -> set_SensorConfig_port
    int get_SensorConfig_port(long) -> get_SensorConfig_port
    java.lang.String get_SensorConfig_portName(long) -> get_SensorConfig_portName
    java.lang.String get_SensorConfig_name(long) -> get_SensorConfig_name
    void set_SensorConfig_unitStr(long,java.lang.String) -> set_SensorConfig_unitStr
    java.lang.String get_SensorConfig_unitStr(long) -> get_SensorConfig_unitStr
    java.lang.String SensorConfig_getSensorParam(long,java.lang.String) -> SensorConfig_getSensorParam
    long new_SensorConfig() -> new_SensorConfig
    void delete_SensorConfig(long) -> delete_SensorConfig
    short get_ExperimentConfig_valid(long) -> get_ExperimentConfig_valid
    java.lang.String get_ExperimentConfig_invalidReason(long) -> get_ExperimentConfig_invalidReason
    void set_ExperimentConfig_period(long,float) -> set_ExperimentConfig_period
    float get_ExperimentConfig_period(long) -> get_ExperimentConfig_period
    short get_ExperimentConfig_exactPeriodUChar(long) -> get_ExperimentConfig_exactPeriodUChar
    void set_ExperimentConfig_numberOfSamples(long,int) -> set_ExperimentConfig_numberOfSamples
    float get_ExperimentConfig_dataReadPeriod(long) -> get_ExperimentConfig_dataReadPeriod
    java.lang.String get_ExperimentConfig_deviceName(long) -> get_ExperimentConfig_deviceName
    void set_ExperimentConfig_numSensorConfigs(long,int) -> set_ExperimentConfig_numSensorConfigs
    int get_ExperimentConfig_numSensorConfigs(long) -> get_ExperimentConfig_numSensorConfigs
    long ExperimentConfig_getSensorConfig(long,int) -> ExperimentConfig_getSensorConfig
    void ExperimentConfig_createSensorConfigArray(long,int) -> ExperimentConfig_createSensorConfigArray
    void ExperimentConfig_setSensorConfig(long,long,int) -> ExperimentConfig_setSensorConfig
    long new_ExperimentConfig() -> new_ExperimentConfig
    void delete_ExperimentConfig(long) -> delete_ExperimentConfig
    long SensDev_open(java.lang.String) -> SensDev_open
    int SensDev_close(long) -> SensDev_close
    int SensDev_isAttached(long) -> SensDev_isAttached
    int SensDev_start(long) -> SensDev_start
    int SensDev_stop(long) -> SensDev_stop
    int SensDev_read(long,long,long,int) -> SensDev_read
    long configureHelper(long,long) -> configureHelper
    long new_floatArray(int) -> new_floatArray
    float floatArray_getitem(long,int) -> floatArray_getitem
ccsd.ti.SWIGTYPE_p_float -> ccsd.ti.c:
    long swigCPtr -> a
    long getCPtr(ccsd.ti.SWIGTYPE_p_float) -> a
ccsd.ti.SWIGTYPE_p_void -> ccsd.ti.d:
    long swigCPtr -> a
    long getCPtr(ccsd.ti.SWIGTYPE_p_void) -> a
ccsd.ti.SensorConfig -> ccsd.ti.e:
    long swigCPtr -> a
    boolean swigCMemOwn -> a
    void finalize() -> finalize
    void delete() -> a
    long getCPtr(ccsd.ti.SensorConfig) -> a
    boolean isConfirmed() -> isConfirmed
    org.concord.framework.data.DataDimension getUnit() -> getUnit
    short getConfirmed() -> a
    void setType(int) -> a
    int getType() -> getType
    void setStepSize(float) -> a
    float getStepSize() -> getStepSize
    void setRequiredMax(float) -> b
    void setRequiredMin(float) -> c
    void setPort(int) -> b
    int getPort() -> getPort
    java.lang.String getPortName() -> getPortName
    java.lang.String getName() -> getName
    void setUnitStr(java.lang.String) -> a
    java.lang.String getUnitStr() -> a
    java.lang.String getSensorParam(java.lang.String) -> getSensorParam
ccsd.vernier.ExperimentConfig -> ccsd.vernier.ExperimentConfig:
    long swigCPtr -> a
    boolean swigCMemOwn -> a
    void finalize() -> finalize
    void delete() -> delete
    long getCPtr(ccsd.vernier.ExperimentConfig) -> getCPtr
    boolean isValid() -> isValid
    boolean getExactPeriod() -> getExactPeriod
    org.concord.sensor.SensorConfig[] getSensorConfigs() -> getSensorConfigs
    void setValid(short) -> setValid
    short getValid() -> getValid
    void setInvalidReason(java.lang.String) -> setInvalidReason
    java.lang.String getInvalidReason() -> getInvalidReason
    void setPeriod(float) -> setPeriod
    float getPeriod() -> getPeriod
    void setExactPeriodUChar(short) -> setExactPeriodUChar
    short getExactPeriodUChar() -> getExactPeriodUChar
    void setNumberOfSamples(int) -> setNumberOfSamples
    int getNumberOfSamples() -> getNumberOfSamples
    void setDataReadPeriod(float) -> setDataReadPeriod
    float getDataReadPeriod() -> getDataReadPeriod
    void setDeviceName(java.lang.String) -> setDeviceName
    java.lang.String getDeviceName() -> getDeviceName
    void setNumSensorConfigs(int) -> setNumSensorConfigs
    int getNumSensorConfigs() -> getNumSensorConfigs
    void setSensorConfigArray(ccsd.vernier.SensorConfig) -> setSensorConfigArray
    ccsd.vernier.SensorConfig getSensorConfigArray() -> getSensorConfigArray
    ccsd.vernier.SensorConfig getSensorConfig(int) -> getSensorConfig
    void createSensorConfigArray(int) -> createSensorConfigArray
    void setSensorConfig(ccsd.vernier.SensorConfig,int) -> setSensorConfig
ccsd.vernier.NativeBridge -> ccsd.vernier.NativeBridge:
    ccsd.vernier.SWIGTYPE_p_void SensDev_open(java.lang.String) -> SensDev_open
    int SensDev_close(ccsd.vernier.SWIGTYPE_p_void) -> SensDev_close
    int SensDev_isAttached(ccsd.vernier.SWIGTYPE_p_void) -> SensDev_isAttached
    int SensDev_configure(ccsd.vernier.SWIGTYPE_p_void,ccsd.vernier.ExperimentConfig,ccsd.vernier.SWIGTYPE_p_p_ExperimentConfig) -> SensDev_configure
    int SensDev_canDetectSensors(ccsd.vernier.SWIGTYPE_p_void) -> SensDev_canDetectSensors
    int SensDev_getCurrentConfig(ccsd.vernier.SWIGTYPE_p_void,ccsd.vernier.SWIGTYPE_p_p_ExperimentConfig) -> SensDev_getCurrentConfig
    int SensDev_start(ccsd.vernier.SWIGTYPE_p_void) -> SensDev_start
    int SensDev_stop(ccsd.vernier.SWIGTYPE_p_void) -> SensDev_stop
    int SensDev_read(ccsd.vernier.SWIGTYPE_p_void,ccsd.vernier.SWIGTYPE_p_float,ccsd.vernier.SWIGTYPE_p_float,int) -> SensDev_read
    ccsd.vernier.ExperimentConfig getCurrentConfigHelper(ccsd.vernier.SWIGTYPE_p_void) -> getCurrentConfigHelper
    ccsd.vernier.ExperimentConfig configureHelper(ccsd.vernier.SWIGTYPE_p_void,ccsd.vernier.ExperimentConfig) -> configureHelper
    ccsd.vernier.SWIGTYPE_p_float new_floatArray(int) -> new_floatArray
    void delete_floatArray(ccsd.vernier.SWIGTYPE_p_float) -> delete_floatArray
    float floatArray_getitem(ccsd.vernier.SWIGTYPE_p_float,int) -> floatArray_getitem
    void floatArray_setitem(ccsd.vernier.SWIGTYPE_p_float,int,float) -> floatArray_setitem
ccsd.vernier.NativeBridgeConstants -> ccsd.vernier.NativeBridgeConstants:
    int QUANTITY_UNKNOWN -> a
    int QUANTITY_TEMPERATURE -> b
    int QUANTITY_TEMPERATURE_WAND -> c
    int QUANTITY_LIGHT -> d
    int QUANTITY_GAS_PRESSURE -> e
    int QUANTITY_VOLTAGE -> f
    int QUANTITY_FORCE -> g
    int QUANTITY_VELOCITY -> h
    int QUANTITY_RELATIVE_HUMIDITY -> i
    int QUANTITY_ACCELERATION -> j
    int QUANTITY_PULSE_RATE -> k
    int QUANTITY_CURRENT -> l
    int QUANTITY_POWER -> m
    int QUANTITY_ENERGY -> n
    int QUANTITY_DISTANCE -> o
    int QUANTITY_SOUND_INTENSITY -> p
    int QUANTITY_COMPASS -> q
    int QUANTITY_ANGULAR_VELOCITY -> r
    int QUANTITY_WIND_SPEED -> s
ccsd.vernier.NativeBridgeJNI -> ccsd.vernier.NativeBridgeJNI:
    void set_SensorParam_key(long,java.lang.String) -> set_SensorParam_key
    java.lang.String get_SensorParam_key(long) -> get_SensorParam_key
    void set_SensorParam_value(long,java.lang.String) -> set_SensorParam_value
    java.lang.String get_SensorParam_value(long) -> get_SensorParam_value
    long new_SensorParam() -> new_SensorParam
    void delete_SensorParam(long) -> delete_SensorParam
    void set_SensorConfig_confirmed(long,short) -> set_SensorConfig_confirmed
    short get_SensorConfig_confirmed(long) -> get_SensorConfig_confirmed
    void set_SensorConfig_type(long,int) -> set_SensorConfig_type
    int get_SensorConfig_type(long) -> get_SensorConfig_type
    void set_SensorConfig_stepSize(long,float) -> set_SensorConfig_stepSize
    float get_SensorConfig_stepSize(long) -> get_SensorConfig_stepSize
    void set_SensorConfig_requiredMax(long,float) -> set_SensorConfig_requiredMax
    float get_SensorConfig_requiredMax(long) -> get_SensorConfig_requiredMax
    void set_SensorConfig_requiredMin(long,float) -> set_SensorConfig_requiredMin
    float get_SensorConfig_requiredMin(long) -> get_SensorConfig_requiredMin
    void set_SensorConfig_port(long,int) -> set_SensorConfig_port
    int get_SensorConfig_port(long) -> get_SensorConfig_port
    void set_SensorConfig_portName(long,java.lang.String) -> set_SensorConfig_portName
    java.lang.String get_SensorConfig_portName(long) -> get_SensorConfig_portName
    void set_SensorConfig_name(long,java.lang.String) -> set_SensorConfig_name
    java.lang.String get_SensorConfig_name(long) -> get_SensorConfig_name
    void set_SensorConfig_unitStr(long,java.lang.String) -> set_SensorConfig_unitStr
    java.lang.String get_SensorConfig_unitStr(long) -> get_SensorConfig_unitStr
    void set_SensorConfig_numSensorParams(long,int) -> set_SensorConfig_numSensorParams
    int get_SensorConfig_numSensorParams(long) -> get_SensorConfig_numSensorParams
    void set_SensorConfig_sensorParams(long,long) -> set_SensorConfig_sensorParams
    long get_SensorConfig_sensorParams(long) -> get_SensorConfig_sensorParams
    java.lang.String SensorConfig_getSensorParam(long,java.lang.String) -> SensorConfig_getSensorParam
    long new_SensorConfig() -> new_SensorConfig
    void delete_SensorConfig(long) -> delete_SensorConfig
    void set_ExperimentConfig_valid(long,short) -> set_ExperimentConfig_valid
    short get_ExperimentConfig_valid(long) -> get_ExperimentConfig_valid
    void set_ExperimentConfig_invalidReason(long,java.lang.String) -> set_ExperimentConfig_invalidReason
    java.lang.String get_ExperimentConfig_invalidReason(long) -> get_ExperimentConfig_invalidReason
    void set_ExperimentConfig_period(long,float) -> set_ExperimentConfig_period
    float get_ExperimentConfig_period(long) -> get_ExperimentConfig_period
    void set_ExperimentConfig_exactPeriodUChar(long,short) -> set_ExperimentConfig_exactPeriodUChar
    short get_ExperimentConfig_exactPeriodUChar(long) -> get_ExperimentConfig_exactPeriodUChar
    void set_ExperimentConfig_numberOfSamples(long,int) -> set_ExperimentConfig_numberOfSamples
    int get_ExperimentConfig_numberOfSamples(long) -> get_ExperimentConfig_numberOfSamples
    void set_ExperimentConfig_dataReadPeriod(long,float) -> set_ExperimentConfig_dataReadPeriod
    float get_ExperimentConfig_dataReadPeriod(long) -> get_ExperimentConfig_dataReadPeriod
    void set_ExperimentConfig_deviceName(long,java.lang.String) -> set_ExperimentConfig_deviceName
    java.lang.String get_ExperimentConfig_deviceName(long) -> get_ExperimentConfig_deviceName
    void set_ExperimentConfig_numSensorConfigs(long,int) -> set_ExperimentConfig_numSensorConfigs
    int get_ExperimentConfig_numSensorConfigs(long) -> get_ExperimentConfig_numSensorConfigs
    void set_ExperimentConfig_sensorConfigArray(long,long) -> set_ExperimentConfig_sensorConfigArray
    long get_ExperimentConfig_sensorConfigArray(long) -> get_ExperimentConfig_sensorConfigArray
    long ExperimentConfig_getSensorConfig(long,int) -> ExperimentConfig_getSensorConfig
    void ExperimentConfig_createSensorConfigArray(long,int) -> ExperimentConfig_createSensorConfigArray
    void ExperimentConfig_setSensorConfig(long,long,int) -> ExperimentConfig_setSensorConfig
    long new_ExperimentConfig() -> new_ExperimentConfig
    void delete_ExperimentConfig(long) -> delete_ExperimentConfig
    int get_QUANTITY_UNKNOWN() -> get_QUANTITY_UNKNOWN
    int get_QUANTITY_TEMPERATURE() -> get_QUANTITY_TEMPERATURE
    int get_QUANTITY_TEMPERATURE_WAND() -> get_QUANTITY_TEMPERATURE_WAND
    int get_QUANTITY_LIGHT() -> get_QUANTITY_LIGHT
    int get_QUANTITY_GAS_PRESSURE() -> get_QUANTITY_GAS_PRESSURE
    int get_QUANTITY_VOLTAGE() -> get_QUANTITY_VOLTAGE
    int get_QUANTITY_FORCE() -> get_QUANTITY_FORCE
    int get_QUANTITY_VELOCITY() -> get_QUANTITY_VELOCITY
    int get_QUANTITY_RELATIVE_HUMIDITY() -> get_QUANTITY_RELATIVE_HUMIDITY
    int get_QUANTITY_ACCELERATION() -> get_QUANTITY_ACCELERATION
    int get_QUANTITY_PULSE_RATE() -> get_QUANTITY_PULSE_RATE
    int get_QUANTITY_CURRENT() -> get_QUANTITY_CURRENT
    int get_QUANTITY_POWER() -> get_QUANTITY_POWER
    int get_QUANTITY_ENERGY() -> get_QUANTITY_ENERGY
    int get_QUANTITY_DISTANCE() -> get_QUANTITY_DISTANCE
    int get_QUANTITY_SOUND_INTENSITY() -> get_QUANTITY_SOUND_INTENSITY
    int get_QUANTITY_COMPASS() -> get_QUANTITY_COMPASS
    int get_QUANTITY_ANGULAR_VELOCITY() -> get_QUANTITY_ANGULAR_VELOCITY
    int get_QUANTITY_WIND_SPEED() -> get_QUANTITY_WIND_SPEED
    long SensDev_open(java.lang.String) -> SensDev_open
    int SensDev_close(long) -> SensDev_close
    int SensDev_isAttached(long) -> SensDev_isAttached
    int SensDev_configure(long,long,long) -> SensDev_configure
    int SensDev_canDetectSensors(long) -> SensDev_canDetectSensors
    int SensDev_getCurrentConfig(long,long) -> SensDev_getCurrentConfig
    int SensDev_start(long) -> SensDev_start
    int SensDev_stop(long) -> SensDev_stop
    int SensDev_read(long,long,long,int) -> SensDev_read
    long getCurrentConfigHelper(long) -> getCurrentConfigHelper
    long configureHelper(long,long) -> configureHelper
    long new_floatArray(int) -> new_floatArray
    void delete_floatArray(long) -> delete_floatArray
    float floatArray_getitem(long,int) -> floatArray_getitem
    void floatArray_setitem(long,int,float) -> floatArray_setitem
ccsd.vernier.SWIGTYPE_p_SensorParam -> ccsd.vernier.SWIGTYPE_p_SensorParam:
    long swigCPtr -> a
    long getCPtr(ccsd.vernier.SWIGTYPE_p_SensorParam) -> getCPtr
ccsd.vernier.SWIGTYPE_p_float -> ccsd.vernier.SWIGTYPE_p_float:
    long swigCPtr -> a
    long getCPtr(ccsd.vernier.SWIGTYPE_p_float) -> getCPtr
ccsd.vernier.SWIGTYPE_p_p_ExperimentConfig -> ccsd.vernier.SWIGTYPE_p_p_ExperimentConfig:
    long swigCPtr -> a
    long getCPtr(ccsd.vernier.SWIGTYPE_p_p_ExperimentConfig) -> getCPtr
ccsd.vernier.SWIGTYPE_p_void -> ccsd.vernier.SWIGTYPE_p_void:
    long swigCPtr -> a
    long getCPtr(ccsd.vernier.SWIGTYPE_p_void) -> getCPtr
ccsd.vernier.SensorConfig -> ccsd.vernier.SensorConfig:
    long swigCPtr -> a
    boolean swigCMemOwn -> a
    void finalize() -> finalize
    void delete() -> delete
    long getCPtr(ccsd.vernier.SensorConfig) -> getCPtr
    boolean isConfirmed() -> isConfirmed
    org.concord.framework.data.DataDimension getUnit() -> getUnit
    void setConfirmed(short) -> setConfirmed
    short getConfirmed() -> getConfirmed
    void setType(int) -> setType
    int getType() -> getType
    void setStepSize(float) -> setStepSize
    float getStepSize() -> getStepSize
    void setRequiredMax(float) -> setRequiredMax
    float getRequiredMax() -> getRequiredMax
    void setRequiredMin(float) -> setRequiredMin
    float getRequiredMin() -> getRequiredMin
    void setPort(int) -> setPort
    int getPort() -> getPort
    void setPortName(java.lang.String) -> setPortName
    java.lang.String getPortName() -> getPortName
    void setName(java.lang.String) -> setName
    java.lang.String getName() -> getName
    void setUnitStr(java.lang.String) -> setUnitStr
    java.lang.String getUnitStr() -> getUnitStr
    void setNumSensorParams(int) -> setNumSensorParams
    int getNumSensorParams() -> getNumSensorParams
    void setSensorParams(ccsd.vernier.SensorParam) -> setSensorParams
    ccsd.vernier.SensorParam getSensorParams() -> getSensorParams
    java.lang.String getSensorParam(java.lang.String) -> getSensorParam
ccsd.vernier.SensorParam -> ccsd.vernier.SensorParam:
    long swigCPtr -> a
    boolean swigCMemOwn -> a
    void finalize() -> finalize
    void delete() -> delete
    long getCPtr(ccsd.vernier.SensorParam) -> getCPtr
    void setKey(java.lang.String) -> setKey
    java.lang.String getKey() -> getKey
    void setValue(java.lang.String) -> setValue
    java.lang.String getValue() -> getValue
com.google.gwt.regexp.shared.MatchResult -> b.a.a.a.a.a:
    java.util.List groups -> a
    int index -> a
    java.lang.String input -> a
    java.lang.String getGroup(int) -> a
com.google.gwt.regexp.shared.RegExp -> b.a.a.a.a.b:
    java.util.regex.Pattern REPLACEMENT_BACKSLASH -> a
    java.util.regex.Pattern REPLACEMENT_DOLLAR_AMPERSAND -> b
    java.util.regex.Pattern REPLACEMENT_DOLLAR_APOSTROPHE -> c
    java.util.regex.Pattern REPLACEMENT_DOLLAR_DOLLAR -> d
    boolean globalFlag -> a
    int lastIndex -> a
    java.util.regex.Pattern pattern -> e
    java.lang.String source -> a
    com.google.gwt.regexp.shared.RegExp compile(java.lang.String) -> a
    com.google.gwt.regexp.shared.RegExp compile(java.lang.String,java.lang.String) -> a
    java.util.Set parseFlags(java.lang.String) -> a
    com.google.gwt.regexp.shared.MatchResult exec(java.lang.String) -> a
    java.lang.String replace(java.lang.String,java.lang.String) -> a
com.google.zxing.BarcodeFormat -> b.a.b.a:
    com.google.zxing.BarcodeFormat AZTEC -> a
    com.google.zxing.BarcodeFormat CODABAR -> b
    com.google.zxing.BarcodeFormat CODE_39 -> c
    com.google.zxing.BarcodeFormat CODE_93 -> d
    com.google.zxing.BarcodeFormat CODE_128 -> e
    com.google.zxing.BarcodeFormat DATA_MATRIX -> f
    com.google.zxing.BarcodeFormat EAN_8 -> g
    com.google.zxing.BarcodeFormat EAN_13 -> h
    com.google.zxing.BarcodeFormat ITF -> i
    com.google.zxing.BarcodeFormat MAXICODE -> j
    com.google.zxing.BarcodeFormat PDF_417 -> k
    com.google.zxing.BarcodeFormat QR_CODE -> l
    com.google.zxing.BarcodeFormat RSS_14 -> m
    com.google.zxing.BarcodeFormat RSS_EXPANDED -> n
    com.google.zxing.BarcodeFormat UPC_A -> o
    com.google.zxing.BarcodeFormat UPC_E -> p
    com.google.zxing.BarcodeFormat UPC_EAN_EXTENSION -> q
    com.google.zxing.BarcodeFormat[] ENUM$VALUES -> a
    com.google.zxing.BarcodeFormat[] values() -> values
    com.google.zxing.BarcodeFormat valueOf(java.lang.String) -> valueOf
com.google.zxing.Binarizer -> b.a.b.b:
    com.google.zxing.LuminanceSource source -> a
    com.google.zxing.LuminanceSource getLuminanceSource() -> a
    com.google.zxing.common.BitArray getBlackRow(int,com.google.zxing.common.BitArray) -> a
    com.google.zxing.common.BitMatrix getBlackMatrix() -> a
    com.google.zxing.Binarizer createBinarizer(com.google.zxing.LuminanceSource) -> a
    int getWidth() -> a
    int getHeight() -> b
com.google.zxing.BinaryBitmap -> b.a.b.c:
    com.google.zxing.Binarizer binarizer -> a
    com.google.zxing.common.BitMatrix matrix -> a
    int getWidth() -> a
    int getHeight() -> b
    com.google.zxing.common.BitArray getBlackRow(int,com.google.zxing.common.BitArray) -> a
    com.google.zxing.common.BitMatrix getBlackMatrix() -> a
    boolean isRotateSupported() -> a
    com.google.zxing.BinaryBitmap rotateCounterClockwise() -> a
com.google.zxing.ChecksumException -> b.a.b.d:
    com.google.zxing.ChecksumException instance -> a
    com.google.zxing.ChecksumException getChecksumInstance() -> a
com.google.zxing.DecodeHintType -> b.a.b.e:
    com.google.zxing.DecodeHintType OTHER -> a
    com.google.zxing.DecodeHintType PURE_BARCODE -> b
    com.google.zxing.DecodeHintType POSSIBLE_FORMATS -> c
    com.google.zxing.DecodeHintType TRY_HARDER -> d
    com.google.zxing.DecodeHintType CHARACTER_SET -> e
    com.google.zxing.DecodeHintType ALLOWED_LENGTHS -> f
    com.google.zxing.DecodeHintType ASSUME_CODE_39_CHECK_DIGIT -> g
    com.google.zxing.DecodeHintType NEED_RESULT_POINT_CALLBACK -> h
    com.google.zxing.DecodeHintType[] ENUM$VALUES -> a
    com.google.zxing.DecodeHintType[] values() -> values
    com.google.zxing.DecodeHintType valueOf(java.lang.String) -> valueOf
com.google.zxing.EncodeHintType -> b.a.b.f:
    com.google.zxing.EncodeHintType ERROR_CORRECTION -> a
    com.google.zxing.EncodeHintType CHARACTER_SET -> b
    com.google.zxing.EncodeHintType[] ENUM$VALUES -> a
    com.google.zxing.EncodeHintType[] values() -> values
    com.google.zxing.EncodeHintType valueOf(java.lang.String) -> valueOf
com.google.zxing.FormatException -> b.a.b.g:
    com.google.zxing.FormatException instance -> a
    com.google.zxing.FormatException getFormatInstance() -> a
com.google.zxing.LuminanceSource -> b.a.b.h:
    int width -> a
    int height -> b
    byte[] getRow(int,byte[]) -> a
    byte[] getMatrix() -> a
    int getWidth() -> a
    int getHeight() -> b
    boolean isRotateSupported() -> a
    com.google.zxing.LuminanceSource rotateCounterClockwise() -> a
    java.lang.String toString() -> toString
com.google.zxing.MultiFormatReader -> b.a.b.i:
    java.util.Map hints -> a
    com.google.zxing.Reader[] readers -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void setHints(java.util.Map) -> a
    void reset() -> a
    com.google.zxing.Result decodeInternal(com.google.zxing.BinaryBitmap) -> a
com.google.zxing.MultiFormatWriter -> b.a.b.j:
    int[] $SWITCH_TABLE$com$google$zxing$BarcodeFormat -> a
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    int[] $SWITCH_TABLE$com$google$zxing$BarcodeFormat() -> a
com.google.zxing.NotFoundException -> b.a.b.k:
    com.google.zxing.NotFoundException instance -> a
    com.google.zxing.NotFoundException getNotFoundInstance() -> a
com.google.zxing.Reader -> b.a.b.l:
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
com.google.zxing.ReaderException -> b.a.b.m:
    java.lang.Throwable fillInStackTrace() -> fillInStackTrace
com.google.zxing.Result -> b.a.b.n:
    java.lang.String text -> a
    byte[] rawBytes -> a
    com.google.zxing.ResultPoint[] resultPoints -> a
    com.google.zxing.BarcodeFormat format -> a
    java.util.Map resultMetadata -> a
    long timestamp -> a
    java.lang.String getText() -> a
    com.google.zxing.ResultPoint[] getResultPoints() -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
    java.util.Map getResultMetadata() -> a
    void putMetadata(com.google.zxing.ResultMetadataType,java.lang.Object) -> a
    void putAllMetadata(java.util.Map) -> a
    void addResultPoints(com.google.zxing.ResultPoint[]) -> a
    java.lang.String toString() -> toString
com.google.zxing.ResultMetadataType -> b.a.b.o:
    com.google.zxing.ResultMetadataType OTHER -> a
    com.google.zxing.ResultMetadataType ORIENTATION -> b
    com.google.zxing.ResultMetadataType BYTE_SEGMENTS -> c
    com.google.zxing.ResultMetadataType ERROR_CORRECTION_LEVEL -> d
    com.google.zxing.ResultMetadataType ISSUE_NUMBER -> e
    com.google.zxing.ResultMetadataType SUGGESTED_PRICE -> f
    com.google.zxing.ResultMetadataType POSSIBLE_COUNTRY -> g
    com.google.zxing.ResultMetadataType[] ENUM$VALUES -> a
    com.google.zxing.ResultMetadataType[] values() -> values
    com.google.zxing.ResultMetadataType valueOf(java.lang.String) -> valueOf
com.google.zxing.ResultPoint -> b.a.b.p:
    float x -> a
    float y -> b
    float getX() -> a
    float getY() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void orderBestPatterns(com.google.zxing.ResultPoint[]) -> a
    float distance(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    float crossProductZ(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
com.google.zxing.ResultPointCallback -> b.a.b.q:
    void foundPossibleResultPoint(com.google.zxing.ResultPoint) -> a
com.google.zxing.Writer -> b.a.b.r:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
com.google.zxing.WriterException -> b.a.b.s:
com.google.zxing.aztec.AztecDetectorResult -> b.a.b.a.a:
    boolean compact -> a
    int nbDatablocks -> a
    int nbLayers -> b
    int getNbLayers() -> a
    int getNbDatablocks() -> b
    boolean isCompact() -> a
com.google.zxing.aztec.AztecReader -> b.a.b.a.b:
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
com.google.zxing.aztec.decoder.Decoder -> b.a.b.a.a.a:
    int[] NB_BITS_COMPACT -> a
    int[] NB_BITS -> b
    int[] NB_DATABLOCK_COMPACT -> c
    int[] NB_DATABLOCK -> d
    java.lang.String[] UPPER_TABLE -> a
    java.lang.String[] LOWER_TABLE -> b
    java.lang.String[] MIXED_TABLE -> c
    java.lang.String[] PUNCT_TABLE -> d
    java.lang.String[] DIGIT_TABLE -> e
    int numCodewords -> a
    int codewordSize -> b
    com.google.zxing.aztec.AztecDetectorResult ddata -> a
    int invertedBitCount -> c
    int[] $SWITCH_TABLE$com$google$zxing$aztec$decoder$Decoder$Table -> e
    com.google.zxing.common.DecoderResult decode(com.google.zxing.aztec.AztecDetectorResult) -> a
    java.lang.String getEncodedData(boolean[]) -> a
    com.google.zxing.aztec.decoder.Decoder$Table getTable(char) -> a
    java.lang.String getCharacter(com.google.zxing.aztec.decoder.Decoder$Table,int) -> a
    boolean[] correctBits(boolean[]) -> a
    boolean[] extractBits(com.google.zxing.common.BitMatrix) -> a
    com.google.zxing.common.BitMatrix removeDashedLines(com.google.zxing.common.BitMatrix) -> a
    int readCode(boolean[],int,int) -> a
    int[] $SWITCH_TABLE$com$google$zxing$aztec$decoder$Decoder$Table() -> a
com.google.zxing.aztec.decoder.Decoder$Table -> b.a.b.a.a.a$a:
    com.google.zxing.aztec.decoder.Decoder$Table UPPER -> a
    com.google.zxing.aztec.decoder.Decoder$Table LOWER -> b
    com.google.zxing.aztec.decoder.Decoder$Table MIXED -> c
    com.google.zxing.aztec.decoder.Decoder$Table DIGIT -> d
    com.google.zxing.aztec.decoder.Decoder$Table PUNCT -> e
    com.google.zxing.aztec.decoder.Decoder$Table BINARY -> f
    com.google.zxing.aztec.decoder.Decoder$Table[] ENUM$VALUES -> a
    com.google.zxing.aztec.decoder.Decoder$Table[] values() -> values
    com.google.zxing.aztec.decoder.Decoder$Table valueOf(java.lang.String) -> valueOf
com.google.zxing.aztec.detector.Detector -> b.a.b.a.b.a:
    com.google.zxing.common.BitMatrix image -> a
    boolean compact -> a
    int nbLayers -> a
    int nbDataBlocks -> b
    int nbCenterLayers -> c
    int shift -> d
    com.google.zxing.aztec.AztecDetectorResult detect() -> a
    void extractParameters(com.google.zxing.aztec.detector.Detector$Point[]) -> a
    com.google.zxing.ResultPoint[] getMatrixCornerPoints(com.google.zxing.aztec.detector.Detector$Point[]) -> a
    void correctParameterData(boolean[],boolean) -> a
    com.google.zxing.aztec.detector.Detector$Point[] getBullEyeCornerPoints(com.google.zxing.aztec.detector.Detector$Point) -> a
    com.google.zxing.aztec.detector.Detector$Point getMatrixCenter() -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    void getParameters(boolean[]) -> a
    boolean[] sampleLine(com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point,int) -> a
    boolean isWhiteOrBlackRectangle(com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point) -> a
    int getColor(com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point) -> a
    com.google.zxing.aztec.detector.Detector$Point getFirstDifferent(com.google.zxing.aztec.detector.Detector$Point,boolean,int,int) -> a
    boolean isValid(int,int) -> a
    int round(float) -> a
    float distance(com.google.zxing.aztec.detector.Detector$Point,com.google.zxing.aztec.detector.Detector$Point) -> a
com.google.zxing.aztec.detector.Detector$Point -> b.a.b.a.b.a$a:
    int x -> a
    int y -> b
    com.google.zxing.ResultPoint toResultPoint() -> a
com.google.zxing.client.j2se.BufferedImageLuminanceSource -> b.a.b.b.a.a:
    java.awt.image.BufferedImage image -> a
    int left -> a
    int top -> b
    byte[] getRow(int,byte[]) -> a
    byte[] getMatrix() -> a
    boolean isRotateSupported() -> a
    com.google.zxing.LuminanceSource rotateCounterClockwise() -> a
com.google.zxing.client.j2se.MatrixToImageWriter -> b.a.b.b.a.b:
    java.awt.image.BufferedImage toBufferedImage(com.google.zxing.common.BitMatrix) -> a
com.google.zxing.common.BitArray -> b.a.b.c.a:
    int[] bits -> a
    int size -> a
    int getSize() -> a
    int getSizeInBytes() -> b
    void ensureCapacity(int) -> b
    boolean get(int) -> a
    void set(int) -> a
    int getNextSet(int) -> a
    int getNextUnset(int) -> b
    void clear() -> a
    boolean isRange(int,int,boolean) -> a
    void appendBit(boolean) -> a
    void appendBits(int,int) -> a
    void appendBitArray(com.google.zxing.common.BitArray) -> a
    void xor(com.google.zxing.common.BitArray) -> b
    void toBytes(int,byte[],int,int) -> a
    void reverse() -> b
    int[] makeArray(int) -> a
    java.lang.String toString() -> toString
com.google.zxing.common.BitMatrix -> b.a.b.c.b:
    int width -> a
    int height -> b
    int rowSize -> c
    int[] bits -> a
    boolean get(int,int) -> a
    void set(int,int) -> a
    void flip(int,int) -> b
    void clear() -> a
    void setRegion(int,int,int,int) -> a
    int[] getEnclosingRectangle() -> a
    int[] getTopLeftOnBit() -> b
    int[] getBottomRightOnBit() -> c
    int getWidth() -> a
    int getHeight() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
com.google.zxing.common.BitSource -> b.a.b.c.c:
    byte[] bytes -> a
    int byteOffset -> a
    int bitOffset -> b
    int getByteOffset() -> a
    int readBits(int) -> a
    int available() -> b
com.google.zxing.common.CharacterSetECI -> b.a.b.c.d:
    com.google.zxing.common.CharacterSetECI Cp437 -> a
    com.google.zxing.common.CharacterSetECI ISO8859_1 -> b
    com.google.zxing.common.CharacterSetECI ISO8859_2 -> c
    com.google.zxing.common.CharacterSetECI ISO8859_3 -> d
    com.google.zxing.common.CharacterSetECI ISO8859_4 -> e
    com.google.zxing.common.CharacterSetECI ISO8859_5 -> f
    com.google.zxing.common.CharacterSetECI ISO8859_6 -> g
    com.google.zxing.common.CharacterSetECI ISO8859_7 -> h
    com.google.zxing.common.CharacterSetECI ISO8859_8 -> i
    com.google.zxing.common.CharacterSetECI ISO8859_9 -> j
    com.google.zxing.common.CharacterSetECI ISO8859_10 -> k
    com.google.zxing.common.CharacterSetECI ISO8859_11 -> l
    com.google.zxing.common.CharacterSetECI ISO8859_13 -> m
    com.google.zxing.common.CharacterSetECI ISO8859_14 -> n
    com.google.zxing.common.CharacterSetECI ISO8859_15 -> o
    com.google.zxing.common.CharacterSetECI ISO8859_16 -> p
    com.google.zxing.common.CharacterSetECI SJIS -> q
    com.google.zxing.common.CharacterSetECI Cp1250 -> r
    com.google.zxing.common.CharacterSetECI Cp1251 -> s
    com.google.zxing.common.CharacterSetECI Cp1252 -> t
    com.google.zxing.common.CharacterSetECI Cp1256 -> u
    com.google.zxing.common.CharacterSetECI UnicodeBigUnmarked -> v
    com.google.zxing.common.CharacterSetECI UTF8 -> w
    com.google.zxing.common.CharacterSetECI ASCII -> x
    com.google.zxing.common.CharacterSetECI Big5 -> y
    com.google.zxing.common.CharacterSetECI GB18030 -> z
    com.google.zxing.common.CharacterSetECI EUC_KR -> A
    java.util.Map VALUE_TO_ECI -> a
    java.util.Map NAME_TO_ECI -> b
    int[] values -> a
    java.lang.String[] otherEncodingNames -> a
    com.google.zxing.common.CharacterSetECI[] ENUM$VALUES -> a
    int getValue() -> a
    com.google.zxing.common.CharacterSetECI getCharacterSetECIByValue(int) -> a
    com.google.zxing.common.CharacterSetECI getCharacterSetECIByName(java.lang.String) -> a
    com.google.zxing.common.CharacterSetECI[] values() -> values
    com.google.zxing.common.CharacterSetECI valueOf(java.lang.String) -> valueOf
com.google.zxing.common.DecoderResult -> b.a.b.c.e:
    byte[] rawBytes -> a
    java.lang.String text -> a
    java.util.List byteSegments -> a
    java.lang.String ecLevel -> b
    byte[] getRawBytes() -> a
    java.lang.String getText() -> a
    java.util.List getByteSegments() -> a
    java.lang.String getECLevel() -> b
com.google.zxing.common.DefaultGridSampler -> b.a.b.c.f:
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,int,int,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float) -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,int,int,com.google.zxing.common.PerspectiveTransform) -> a
com.google.zxing.common.DetectorResult -> b.a.b.c.g:
    com.google.zxing.common.BitMatrix bits -> a
    com.google.zxing.ResultPoint[] points -> a
    com.google.zxing.common.BitMatrix getBits() -> a
    com.google.zxing.ResultPoint[] getPoints() -> a
com.google.zxing.common.GlobalHistogramBinarizer -> b.a.b.c.h:
    byte[] luminances -> a
    int[] buckets -> a
    com.google.zxing.common.BitArray getBlackRow(int,com.google.zxing.common.BitArray) -> a
    com.google.zxing.common.BitMatrix getBlackMatrix() -> a
    com.google.zxing.Binarizer createBinarizer(com.google.zxing.LuminanceSource) -> a
    void initArrays(int) -> a
    int estimateBlackPoint(int[]) -> a
com.google.zxing.common.GridSampler -> b.a.b.c.i:
    com.google.zxing.common.GridSampler gridSampler -> a
    com.google.zxing.common.GridSampler getInstance() -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,int,int,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float) -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,int,int,com.google.zxing.common.PerspectiveTransform) -> a
    void checkAndNudgePoints(com.google.zxing.common.BitMatrix,float[]) -> a
com.google.zxing.common.HybridBinarizer -> b.a.b.c.j:
    com.google.zxing.common.BitMatrix matrix -> a
    com.google.zxing.common.BitMatrix getBlackMatrix() -> a
    com.google.zxing.Binarizer createBinarizer(com.google.zxing.LuminanceSource) -> a
    void calculateThresholdForBlock(byte[],int,int,int,int,int[][],com.google.zxing.common.BitMatrix) -> a
    void threshold8x8Block(byte[],int,int,int,int,com.google.zxing.common.BitMatrix) -> a
    int[][] calculateBlackPoints(byte[],int,int,int,int) -> a
com.google.zxing.common.PerspectiveTransform -> b.a.b.c.k:
    float a11 -> a
    float a12 -> b
    float a13 -> c
    float a21 -> d
    float a22 -> e
    float a23 -> f
    float a31 -> g
    float a32 -> h
    float a33 -> i
    com.google.zxing.common.PerspectiveTransform quadrilateralToQuadrilateral(float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float) -> a
    void transformPoints(float[]) -> a
    com.google.zxing.common.PerspectiveTransform squareToQuadrilateral(float,float,float,float,float,float,float,float) -> a
    com.google.zxing.common.PerspectiveTransform quadrilateralToSquare(float,float,float,float,float,float,float,float) -> b
    com.google.zxing.common.PerspectiveTransform buildAdjoint() -> a
    com.google.zxing.common.PerspectiveTransform times(com.google.zxing.common.PerspectiveTransform) -> a
com.google.zxing.common.StringUtils -> b.a.b.c.l:
    java.lang.String PLATFORM_DEFAULT_ENCODING -> a
    boolean ASSUME_SHIFT_JIS -> a
    java.lang.String guessEncoding(byte[],java.util.Map) -> a
com.google.zxing.common.detector.WhiteRectangleDetector -> b.a.b.c.a.a:
    com.google.zxing.common.BitMatrix image -> a
    int height -> a
    int width -> b
    int leftInit -> c
    int rightInit -> d
    int downInit -> e
    int upInit -> f
    com.google.zxing.ResultPoint[] detect() -> a
    int round(float) -> a
    com.google.zxing.ResultPoint getBlackPointOnSegment(float,float,float,float) -> a
    int distanceL2(float,float,float,float) -> a
    com.google.zxing.ResultPoint[] centerEdges(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    boolean containsBlackPoint(int,int,int,boolean) -> a
com.google.zxing.common.reedsolomon.GenericGF -> b.a.b.c.b.a:
    com.google.zxing.common.reedsolomon.GenericGF AZTEC_DATA_12 -> a
    com.google.zxing.common.reedsolomon.GenericGF AZTEC_DATA_10 -> b
    com.google.zxing.common.reedsolomon.GenericGF AZTEC_DATA_6 -> c
    com.google.zxing.common.reedsolomon.GenericGF AZTEC_PARAM -> d
    com.google.zxing.common.reedsolomon.GenericGF QR_CODE_FIELD_256 -> e
    com.google.zxing.common.reedsolomon.GenericGF DATA_MATRIX_FIELD_256 -> f
    com.google.zxing.common.reedsolomon.GenericGF AZTEC_DATA_8 -> g
    com.google.zxing.common.reedsolomon.GenericGF MAXICODE_FIELD_64 -> h
    int[] expTable -> a
    int[] logTable -> b
    com.google.zxing.common.reedsolomon.GenericGFPoly zero -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly one -> b
    int size -> a
    int primitive -> b
    boolean initialized -> a
    void initialize() -> a
    void checkInit() -> b
    com.google.zxing.common.reedsolomon.GenericGFPoly getZero() -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly getOne() -> b
    com.google.zxing.common.reedsolomon.GenericGFPoly buildMonomial(int,int) -> a
    int addOrSubtract(int,int) -> a
    int exp(int) -> a
    int log(int) -> b
    int inverse(int) -> c
    int multiply(int,int) -> b
    int getSize() -> a
com.google.zxing.common.reedsolomon.GenericGFPoly -> b.a.b.c.b.b:
    com.google.zxing.common.reedsolomon.GenericGF field -> a
    int[] coefficients -> a
    int[] getCoefficients() -> a
    int getDegree() -> a
    boolean isZero() -> a
    int getCoefficient(int) -> a
    int evaluateAt(int) -> b
    com.google.zxing.common.reedsolomon.GenericGFPoly addOrSubtract(com.google.zxing.common.reedsolomon.GenericGFPoly) -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly multiply(com.google.zxing.common.reedsolomon.GenericGFPoly) -> b
    com.google.zxing.common.reedsolomon.GenericGFPoly multiply(int) -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly multiplyByMonomial(int,int) -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly[] divide(com.google.zxing.common.reedsolomon.GenericGFPoly) -> a
    java.lang.String toString() -> toString
com.google.zxing.common.reedsolomon.ReedSolomonDecoder -> b.a.b.c.b.c:
    com.google.zxing.common.reedsolomon.GenericGF field -> a
    void decode(int[],int) -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly[] runEuclideanAlgorithm(com.google.zxing.common.reedsolomon.GenericGFPoly,com.google.zxing.common.reedsolomon.GenericGFPoly,int) -> a
    int[] findErrorLocations(com.google.zxing.common.reedsolomon.GenericGFPoly) -> a
    int[] findErrorMagnitudes(com.google.zxing.common.reedsolomon.GenericGFPoly,int[],boolean) -> a
com.google.zxing.common.reedsolomon.ReedSolomonEncoder -> b.a.b.c.b.d:
    com.google.zxing.common.reedsolomon.GenericGF field -> a
    java.util.List cachedGenerators -> a
    com.google.zxing.common.reedsolomon.GenericGFPoly buildGenerator(int) -> a
    void encode(int[],int) -> a
com.google.zxing.common.reedsolomon.ReedSolomonException -> b.a.b.c.b.e:
com.google.zxing.datamatrix.DataMatrixReader -> b.a.b.d.a:
    com.google.zxing.ResultPoint[] NO_POINTS -> a
    com.google.zxing.datamatrix.decoder.Decoder decoder -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
    com.google.zxing.common.BitMatrix extractPureBits(com.google.zxing.common.BitMatrix) -> a
    int moduleSize(int[],com.google.zxing.common.BitMatrix) -> a
com.google.zxing.datamatrix.decoder.BitMatrixParser -> b.a.b.d.a.a:
    com.google.zxing.common.BitMatrix mappingBitMatrix -> a
    com.google.zxing.common.BitMatrix readMappingMatrix -> b
    com.google.zxing.datamatrix.decoder.Version version -> a
    com.google.zxing.datamatrix.decoder.Version getVersion() -> a
    com.google.zxing.datamatrix.decoder.Version readVersion(com.google.zxing.common.BitMatrix) -> a
    byte[] readCodewords() -> a
    boolean readModule(int,int,int,int) -> a
    int readUtah(int,int,int,int) -> a
    int readCorner1(int,int) -> a
    int readCorner2(int,int) -> b
    int readCorner3(int,int) -> c
    int readCorner4(int,int) -> d
    com.google.zxing.common.BitMatrix extractDataRegion(com.google.zxing.common.BitMatrix) -> a
com.google.zxing.datamatrix.decoder.DataBlock -> b.a.b.d.a.b:
    int numDataCodewords -> a
    byte[] codewords -> a
    com.google.zxing.datamatrix.decoder.DataBlock[] getDataBlocks(byte[],com.google.zxing.datamatrix.decoder.Version) -> a
    int getNumDataCodewords() -> a
    byte[] getCodewords() -> a
com.google.zxing.datamatrix.decoder.DecodedBitStreamParser -> b.a.b.d.a.c:
    char[] C40_BASIC_SET_CHARS -> a
    char[] C40_SHIFT2_SET_CHARS -> b
    char[] TEXT_BASIC_SET_CHARS -> c
    char[] TEXT_SHIFT3_SET_CHARS -> d
    int[] $SWITCH_TABLE$com$google$zxing$datamatrix$decoder$DecodedBitStreamParser$Mode -> a
    com.google.zxing.common.DecoderResult decode(byte[]) -> a
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode decodeAsciiSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,java.lang.StringBuilder) -> a
    void decodeC40Segment(com.google.zxing.common.BitSource,java.lang.StringBuilder) -> a
    void decodeTextSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder) -> b
    void decodeAnsiX12Segment(com.google.zxing.common.BitSource,java.lang.StringBuilder) -> c
    void parseTwoBytes(int,int,int[]) -> a
    void decodeEdifactSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder) -> d
    void decodeBase256Segment(com.google.zxing.common.BitSource,java.lang.StringBuilder,java.util.Collection) -> a
    int unrandomize255State(int,int) -> a
    int[] $SWITCH_TABLE$com$google$zxing$datamatrix$decoder$DecodedBitStreamParser$Mode() -> a
com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode -> b.a.b.d.a.c$a:
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode PAD_ENCODE -> a
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode ASCII_ENCODE -> b
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode C40_ENCODE -> c
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode TEXT_ENCODE -> d
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode ANSIX12_ENCODE -> e
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode EDIFACT_ENCODE -> f
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode BASE256_ENCODE -> g
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode[] ENUM$VALUES -> a
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode[] values() -> values
    com.google.zxing.datamatrix.decoder.DecodedBitStreamParser$Mode valueOf(java.lang.String) -> valueOf
com.google.zxing.datamatrix.decoder.Decoder -> b.a.b.d.a.d:
    com.google.zxing.common.reedsolomon.ReedSolomonDecoder rsDecoder -> a
    com.google.zxing.common.DecoderResult decode(com.google.zxing.common.BitMatrix) -> a
    void correctErrors(byte[],int) -> a
com.google.zxing.datamatrix.decoder.Version -> b.a.b.d.a.e:
    com.google.zxing.datamatrix.decoder.Version[] VERSIONS -> a
    int versionNumber -> a
    int symbolSizeRows -> b
    int symbolSizeColumns -> c
    int dataRegionSizeRows -> d
    int dataRegionSizeColumns -> e
    com.google.zxing.datamatrix.decoder.Version$ECBlocks ecBlocks -> a
    int totalCodewords -> f
    int getVersionNumber() -> a
    int getSymbolSizeRows() -> b
    int getSymbolSizeColumns() -> c
    int getDataRegionSizeRows() -> d
    int getDataRegionSizeColumns() -> e
    int getTotalCodewords() -> f
    com.google.zxing.datamatrix.decoder.Version$ECBlocks getECBlocks() -> a
    com.google.zxing.datamatrix.decoder.Version getVersionForDimensions(int,int) -> a
    java.lang.String toString() -> toString
    com.google.zxing.datamatrix.decoder.Version[] buildVersions() -> a
com.google.zxing.datamatrix.decoder.Version$ECB -> b.a.b.d.a.e$a:
    int count -> a
    int dataCodewords -> b
    int getCount() -> a
    int getDataCodewords() -> b
com.google.zxing.datamatrix.decoder.Version$ECBlocks -> b.a.b.d.a.e$b:
    int ecCodewords -> a
    com.google.zxing.datamatrix.decoder.Version$ECB[] ecBlocks -> a
    int getECCodewords() -> a
    com.google.zxing.datamatrix.decoder.Version$ECB[] getECBlocks() -> a
com.google.zxing.datamatrix.detector.Detector -> b.a.b.d.b.a:
    com.google.zxing.common.BitMatrix image -> a
    com.google.zxing.common.detector.WhiteRectangleDetector rectangleDetector -> a
    com.google.zxing.common.DetectorResult detect() -> a
    com.google.zxing.ResultPoint correctTopRightRectangular(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,int,int) -> a
    com.google.zxing.ResultPoint correctTopRight(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,int) -> a
    boolean isValid(com.google.zxing.ResultPoint) -> a
    int round(float) -> a
    int distance(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    void increment(java.util.Map,com.google.zxing.ResultPoint) -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,int,int) -> a
    com.google.zxing.datamatrix.detector.Detector$ResultPointsAndTransitions transitionsBetween(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
com.google.zxing.datamatrix.detector.Detector$ResultPointsAndTransitions -> b.a.b.d.b.a$a:
    com.google.zxing.ResultPoint from -> a
    com.google.zxing.ResultPoint to -> b
    int transitions -> a
    com.google.zxing.ResultPoint getFrom() -> a
    com.google.zxing.ResultPoint getTo() -> b
    int getTransitions() -> a
    java.lang.String toString() -> toString
com.google.zxing.datamatrix.detector.Detector$ResultPointsAndTransitionsComparator -> b.a.b.d.b.a$b:
    int compare(com.google.zxing.datamatrix.detector.Detector$ResultPointsAndTransitions,com.google.zxing.datamatrix.detector.Detector$ResultPointsAndTransitions) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.zxing.maxicode.MaxiCodeReader -> b.a.b.e.a:
    com.google.zxing.ResultPoint[] NO_POINTS -> a
    com.google.zxing.maxicode.decoder.Decoder decoder -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
    com.google.zxing.common.BitMatrix extractPureBits(com.google.zxing.common.BitMatrix) -> a
com.google.zxing.maxicode.decoder.BitMatrixParser -> b.a.b.e.a.a:
    int[][] BITNR -> a
    com.google.zxing.common.BitMatrix bitMatrix -> a
    byte[] readCodewords() -> a
com.google.zxing.maxicode.decoder.DecodedBitStreamParser -> b.a.b.e.a.b:
    java.text.NumberFormat NINE_DIGITS -> a
    java.text.NumberFormat THREE_DIGITS -> b
    java.lang.String[] SETS -> a
    com.google.zxing.common.DecoderResult decode(byte[],int) -> a
    int getBit(int,byte[]) -> a
    int getInt(byte[],byte[]) -> a
    int getCountry(byte[]) -> a
    int getServiceClass(byte[]) -> b
    int getPostCode2Length(byte[]) -> c
    int getPostCode2(byte[]) -> d
    java.lang.String getPostCode3(byte[]) -> a
    java.lang.String getMessage(byte[],int,int) -> a
com.google.zxing.maxicode.decoder.Decoder -> b.a.b.e.a.c:
    com.google.zxing.common.reedsolomon.ReedSolomonDecoder rsDecoder -> a
    com.google.zxing.common.DecoderResult decode(com.google.zxing.common.BitMatrix,java.util.Map) -> a
    void correctErrors(byte[],int,int,int,int) -> a
com.google.zxing.oned.CodaBarReader -> b.a.b.f.a:
    char[] ALPHABET -> a
    int[] CHARACTER_ENCODINGS -> a
    char[] STARTEND_ENCODING -> b
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    int[] findAsteriskPattern(com.google.zxing.common.BitArray) -> a
    boolean arrayContains(char[],char) -> a
    char toNarrowWidePattern(int[]) -> a
com.google.zxing.oned.CodaBarWriter -> b.a.b.f.b:
    byte[] encode(java.lang.String) -> a
com.google.zxing.oned.Code128Reader -> b.a.b.f.c:
    int[][] CODE_PATTERNS -> a
    int[] findStartPattern(com.google.zxing.common.BitArray) -> a
    int decodeCode(com.google.zxing.common.BitArray,int[],int) -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
com.google.zxing.oned.Code128Writer -> b.a.b.f.d:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    byte[] encode(java.lang.String) -> a
    boolean isDigits(java.lang.CharSequence,int,int) -> a
com.google.zxing.oned.Code39Reader -> b.a.b.f.e:
    char[] ALPHABET -> a
    int[] CHARACTER_ENCODINGS -> a
    int ASTERISK_ENCODING -> a
    boolean usingCheckDigit -> a
    boolean extendedMode -> b
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    int[] findAsteriskPattern(com.google.zxing.common.BitArray,int[]) -> a
    int toNarrowWidePattern(int[]) -> a
    char patternToChar(int) -> a
    java.lang.String decodeExtended(java.lang.CharSequence) -> a
com.google.zxing.oned.Code39Writer -> b.a.b.f.f:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    byte[] encode(java.lang.String) -> a
    void toIntArray(int,int[]) -> a
com.google.zxing.oned.Code93Reader -> b.a.b.f.g:
    char[] ALPHABET -> a
    int[] CHARACTER_ENCODINGS -> a
    int ASTERISK_ENCODING -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    int[] findAsteriskPattern(com.google.zxing.common.BitArray) -> a
    int toPattern(int[]) -> a
    char patternToChar(int) -> a
    java.lang.String decodeExtended(java.lang.CharSequence) -> a
    void checkChecksums(java.lang.CharSequence) -> a
    void checkOneChecksum(java.lang.CharSequence,int,int) -> a
com.google.zxing.oned.EAN13Reader -> b.a.b.f.h:
    int[] FIRST_DIGIT_ENCODINGS -> a
    int[] decodeMiddleCounters -> d
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
    void determineFirstDigit(java.lang.StringBuilder,int) -> a
com.google.zxing.oned.EAN13Writer -> b.a.b.f.i:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    byte[] encode(java.lang.String) -> a
com.google.zxing.oned.EAN8Reader -> b.a.b.f.j:
    int[] decodeMiddleCounters -> a
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
com.google.zxing.oned.EAN8Writer -> b.a.b.f.k:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    byte[] encode(java.lang.String) -> a
com.google.zxing.oned.EANManufacturerOrgSupport -> b.a.b.f.l:
    java.util.List ranges -> a
    java.util.List countryIdentifiers -> b
    java.lang.String lookupCountryIdentifier(java.lang.String) -> a
    void add(int[],java.lang.String) -> a
    void initIfNeeded() -> a
com.google.zxing.oned.ITFReader -> b.a.b.f.m:
    int[] DEFAULT_ALLOWED_LENGTHS -> a
    int narrowLineWidth -> a
    int[] START_PATTERN -> b
    int[] END_PATTERN_REVERSED -> c
    int[][] PATTERNS -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    void decodeMiddle(com.google.zxing.common.BitArray,int,int,java.lang.StringBuilder) -> a
    int[] decodeStart(com.google.zxing.common.BitArray) -> a
    void validateQuietZone(com.google.zxing.common.BitArray,int) -> a
    int skipWhiteSpace(com.google.zxing.common.BitArray) -> a
    int[] decodeEnd(com.google.zxing.common.BitArray) -> b
    int[] findGuardPattern(com.google.zxing.common.BitArray,int,int[]) -> a
    int decodeDigit(int[]) -> a
com.google.zxing.oned.ITFWriter -> b.a.b.f.n:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    byte[] encode(java.lang.String) -> a
com.google.zxing.oned.MultiFormatOneDReader -> b.a.b.f.o:
    com.google.zxing.oned.OneDReader[] readers -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    void reset() -> a
com.google.zxing.oned.MultiFormatUPCEANReader -> b.a.b.f.p:
    com.google.zxing.oned.UPCEANReader[] readers -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    void reset() -> a
com.google.zxing.oned.OneDReader -> b.a.b.f.q:
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
    com.google.zxing.Result doDecode(com.google.zxing.BinaryBitmap,java.util.Map) -> b
    void recordPattern(com.google.zxing.common.BitArray,int,int[]) -> a
    void recordPatternInReverse(com.google.zxing.common.BitArray,int,int[]) -> b
    int patternMatchVariance(int[],int[],int) -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
com.google.zxing.oned.OneDimensionalCodeWriter -> b.a.b.f.r:
    int sidesMargin -> a
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    com.google.zxing.common.BitMatrix renderResult(byte[],int,int) -> a
    int appendPattern(byte[],int,int[],int) -> a
    byte[] encode(java.lang.String) -> a
com.google.zxing.oned.UPCAReader -> b.a.b.f.s:
    com.google.zxing.oned.UPCEANReader ean13Reader -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,int[],java.util.Map) -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
    com.google.zxing.Result maybeReturnResult(com.google.zxing.Result) -> a
com.google.zxing.oned.UPCAWriter -> b.a.b.f.t:
    com.google.zxing.oned.EAN13Writer subWriter -> a
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    java.lang.String preencode(java.lang.String) -> a
com.google.zxing.oned.UPCEANExtensionSupport -> b.a.b.f.u:
    int[] EXTENSION_START_PATTERN -> a
    int[] CHECK_DIGIT_ENCODINGS -> b
    int[] decodeMiddleCounters -> c
    java.lang.StringBuilder decodeRowStringBuffer -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,int) -> a
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
    int extensionChecksum(java.lang.CharSequence) -> a
    int determineCheckDigit(int) -> a
    java.util.Map parseExtensionString(java.lang.String) -> a
    java.lang.Integer parseExtension2String(java.lang.String) -> a
    java.lang.String parseExtension5String(java.lang.String) -> a
com.google.zxing.oned.UPCEANReader -> b.a.b.f.v:
    int[] START_END_PATTERN -> b
    int[] MIDDLE_PATTERN -> c
    int[][] L_PATTERNS -> a
    int[][] L_AND_G_PATTERNS -> b
    java.lang.StringBuilder decodeRowStringBuffer -> a
    com.google.zxing.oned.UPCEANExtensionSupport extensionReader -> a
    com.google.zxing.oned.EANManufacturerOrgSupport eanManSupport -> a
    int[] findStartGuardPattern(com.google.zxing.common.BitArray) -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,int[],java.util.Map) -> a
    boolean checkChecksum(java.lang.String) -> a
    boolean checkStandardUPCEANChecksum(java.lang.CharSequence) -> a
    int[] decodeEnd(com.google.zxing.common.BitArray,int) -> a
    int[] findGuardPattern(com.google.zxing.common.BitArray,int,boolean,int[]) -> a
    int[] findGuardPattern(com.google.zxing.common.BitArray,int,boolean,int[],int[]) -> a
    int decodeDigit(com.google.zxing.common.BitArray,int[],int,int[][]) -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
com.google.zxing.oned.UPCEANWriter -> b.a.b.f.w:
com.google.zxing.oned.UPCEReader -> b.a.b.f.x:
    int[] MIDDLE_END_PATTERN -> a
    int[][] NUMSYS_AND_CHECK_DIGIT_PATTERNS -> c
    int[] decodeMiddleCounters -> d
    int decodeMiddle(com.google.zxing.common.BitArray,int[],java.lang.StringBuilder) -> a
    int[] decodeEnd(com.google.zxing.common.BitArray,int) -> a
    boolean checkChecksum(java.lang.String) -> a
    void determineNumSysAndCheckDigit(java.lang.StringBuilder,int) -> a
    com.google.zxing.BarcodeFormat getBarcodeFormat() -> a
    java.lang.String convertUPCEtoUPCA(java.lang.String) -> a
com.google.zxing.oned.rss.AbstractRSSReader -> b.a.b.f.a.a:
    int[] decodeFinderCounters -> a
    int[] dataCharacterCounters -> b
    float[] oddRoundingErrors -> a
    float[] evenRoundingErrors -> b
    int[] oddCounts -> c
    int[] evenCounts -> d
    int[] getDecodeFinderCounters() -> a
    int[] getDataCharacterCounters() -> b
    float[] getOddRoundingErrors() -> a
    float[] getEvenRoundingErrors() -> b
    int[] getOddCounts() -> c
    int[] getEvenCounts() -> d
    int parseFinderValue(int[],int[][]) -> a
    int count(int[]) -> a
    void increment(int[],float[]) -> a
    void decrement(int[],float[]) -> b
    boolean isFinderPattern(int[]) -> a
com.google.zxing.oned.rss.DataCharacter -> b.a.b.f.a.b:
    int value -> a
    int checksumPortion -> b
    int getValue() -> a
    int getChecksumPortion() -> b
com.google.zxing.oned.rss.FinderPattern -> b.a.b.f.a.c:
    int value -> a
    int[] startEnd -> a
    com.google.zxing.ResultPoint[] resultPoints -> a
    int getValue() -> a
    int[] getStartEnd() -> a
    com.google.zxing.ResultPoint[] getResultPoints() -> a
com.google.zxing.oned.rss.Pair -> b.a.b.f.a.d:
    com.google.zxing.oned.rss.FinderPattern finderPattern -> a
    int count -> a
    com.google.zxing.oned.rss.FinderPattern getFinderPattern() -> a
    int getCount() -> c
    void incrementCount() -> a
com.google.zxing.oned.rss.RSS14Reader -> b.a.b.f.a.e:
    int[] OUTSIDE_EVEN_TOTAL_SUBSET -> a
    int[] INSIDE_ODD_TOTAL_SUBSET -> b
    int[] OUTSIDE_GSUM -> c
    int[] INSIDE_GSUM -> d
    int[] OUTSIDE_ODD_WIDEST -> e
    int[] INSIDE_ODD_WIDEST -> f
    int[][] FINDER_PATTERNS -> a
    java.util.List possibleLeftPairs -> a
    java.util.List possibleRightPairs -> b
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    void addOrTally(java.util.Collection,com.google.zxing.oned.rss.Pair) -> a
    void reset() -> a
    com.google.zxing.Result constructResult(com.google.zxing.oned.rss.Pair,com.google.zxing.oned.rss.Pair) -> a
    boolean checkChecksum(com.google.zxing.oned.rss.Pair,com.google.zxing.oned.rss.Pair) -> a
    com.google.zxing.oned.rss.Pair decodePair(com.google.zxing.common.BitArray,boolean,int,java.util.Map) -> a
    com.google.zxing.oned.rss.DataCharacter decodeDataCharacter(com.google.zxing.common.BitArray,com.google.zxing.oned.rss.FinderPattern,boolean) -> a
    int[] findFinderPattern(com.google.zxing.common.BitArray,int,boolean) -> a
    com.google.zxing.oned.rss.FinderPattern parseFoundFinderPattern(com.google.zxing.common.BitArray,int,boolean,int[]) -> a
    void adjustOddEvenCounts(boolean,int) -> a
com.google.zxing.oned.rss.RSSUtils -> b.a.b.f.a.f:
    int getRSSvalue(int[],int,boolean) -> a
    int combins(int,int) -> a
com.google.zxing.oned.rss.expanded.BitArrayBuilder -> b.a.b.f.a.a.a:
    com.google.zxing.common.BitArray buildBitArray(java.util.List) -> a
com.google.zxing.oned.rss.expanded.ExpandedPair -> b.a.b.f.a.a.b:
    boolean mayBeLast -> a
    com.google.zxing.oned.rss.DataCharacter leftChar -> a
    com.google.zxing.oned.rss.DataCharacter rightChar -> b
    com.google.zxing.oned.rss.FinderPattern finderPattern -> a
    boolean mayBeLast() -> a
    com.google.zxing.oned.rss.DataCharacter getLeftChar() -> a
    com.google.zxing.oned.rss.DataCharacter getRightChar() -> b
    com.google.zxing.oned.rss.FinderPattern getFinderPattern() -> a
    boolean mustBeLast() -> b
com.google.zxing.oned.rss.expanded.RSSExpandedReader -> b.a.b.f.a.a.c:
    int[] SYMBOL_WIDEST -> a
    int[] EVEN_TOTAL_SUBSET -> b
    int[] GSUM -> c
    int[][] FINDER_PATTERNS -> a
    int[][] WEIGHTS -> b
    int[][] FINDER_PATTERN_SEQUENCES -> c
    int LONGEST_SEQUENCE_SIZE -> a
    java.util.List pairs -> a
    int[] startEnd -> d
    int[] currentSequence -> e
    com.google.zxing.Result decodeRow(int,com.google.zxing.common.BitArray,java.util.Map) -> a
    void reset() -> a
    java.util.List decodeRow2pairs(int,com.google.zxing.common.BitArray) -> a
    com.google.zxing.Result constructResult(java.util.List) -> a
    boolean checkChecksum() -> a
    int getNextSecondBar(com.google.zxing.common.BitArray,int) -> a
    com.google.zxing.oned.rss.expanded.ExpandedPair retrieveNextPair(com.google.zxing.common.BitArray,java.util.List,int) -> a
    boolean checkPairSequence(java.util.List,com.google.zxing.oned.rss.FinderPattern) -> a
    void findNextPair(com.google.zxing.common.BitArray,java.util.List,int) -> a
    void reverseCounters(int[]) -> a
    com.google.zxing.oned.rss.FinderPattern parseFoundFinderPattern(com.google.zxing.common.BitArray,int,boolean) -> a
    com.google.zxing.oned.rss.DataCharacter decodeDataCharacter(com.google.zxing.common.BitArray,com.google.zxing.oned.rss.FinderPattern,boolean,boolean) -> a
    boolean isNotA1left(com.google.zxing.oned.rss.FinderPattern,boolean,boolean) -> a
    void adjustOddEvenCounts(int) -> a
com.google.zxing.oned.rss.expanded.decoders.AI013103decoder -> b.a.b.f.a.a.a.a:
    void addWeightCode(java.lang.StringBuilder,int) -> a
    int checkWeight(int) -> a
com.google.zxing.oned.rss.expanded.decoders.AI01320xDecoder -> b.a.b.f.a.a.a.b:
    void addWeightCode(java.lang.StringBuilder,int) -> a
    int checkWeight(int) -> a
com.google.zxing.oned.rss.expanded.decoders.AI01392xDecoder -> b.a.b.f.a.a.a.c:
    java.lang.String parseInformation() -> a
com.google.zxing.oned.rss.expanded.decoders.AI01393xDecoder -> b.a.b.f.a.a.a.d:
    java.lang.String parseInformation() -> a
com.google.zxing.oned.rss.expanded.decoders.AI013x0x1xDecoder -> b.a.b.f.a.a.a.e:
    java.lang.String dateCode -> a
    java.lang.String firstAIdigits -> b
    java.lang.String parseInformation() -> a
    void encodeCompressedDate(java.lang.StringBuilder,int) -> c
    void addWeightCode(java.lang.StringBuilder,int) -> a
    int checkWeight(int) -> a
com.google.zxing.oned.rss.expanded.decoders.AI013x0xDecoder -> b.a.b.f.a.a.a.f:
    java.lang.String parseInformation() -> a
com.google.zxing.oned.rss.expanded.decoders.AI01AndOtherAIs -> b.a.b.f.a.a.a.g:
    java.lang.String parseInformation() -> a
com.google.zxing.oned.rss.expanded.decoders.AI01decoder -> b.a.b.f.a.a.a.h:
    void encodeCompressedGtin(java.lang.StringBuilder,int) -> b
    void encodeCompressedGtinWithoutAI(java.lang.StringBuilder,int,int) -> a
    void appendCheckDigit(java.lang.StringBuilder,int) -> a
com.google.zxing.oned.rss.expanded.decoders.AI01weightDecoder -> b.a.b.f.a.a.a.i:
    void encodeCompressedWeight(java.lang.StringBuilder,int,int) -> b
    void addWeightCode(java.lang.StringBuilder,int) -> a
    int checkWeight(int) -> a
com.google.zxing.oned.rss.expanded.decoders.AbstractExpandedDecoder -> b.a.b.f.a.a.a.j:
    com.google.zxing.common.BitArray information -> a
    com.google.zxing.oned.rss.expanded.decoders.GeneralAppIdDecoder generalDecoder -> a
    com.google.zxing.common.BitArray getInformation() -> a
    com.google.zxing.oned.rss.expanded.decoders.GeneralAppIdDecoder getGeneralDecoder() -> a
    java.lang.String parseInformation() -> a
    com.google.zxing.oned.rss.expanded.decoders.AbstractExpandedDecoder createDecoder(com.google.zxing.common.BitArray) -> a
com.google.zxing.oned.rss.expanded.decoders.AnyAIDecoder -> b.a.b.f.a.a.a.k:
    java.lang.String parseInformation() -> a
com.google.zxing.oned.rss.expanded.decoders.BlockParsedResult -> b.a.b.f.a.a.a.l:
    com.google.zxing.oned.rss.expanded.decoders.DecodedInformation decodedInformation -> a
    boolean finished -> a
    com.google.zxing.oned.rss.expanded.decoders.DecodedInformation getDecodedInformation() -> a
    boolean isFinished() -> a
com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState -> b.a.b.f.a.a.a.m:
    int position -> a
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State encoding -> a
    int getPosition() -> a
    void setPosition(int) -> a
    void incrementPosition(int) -> b
    boolean isAlpha() -> a
    boolean isIsoIec646() -> b
    void setNumeric() -> a
    void setAlpha() -> b
    void setIsoIec646() -> c
com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State -> b.a.b.f.a.a.a.m$a:
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State NUMERIC -> a
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State ALPHA -> b
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State ISO_IEC_646 -> c
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State[] ENUM$VALUES -> a
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State[] values() -> values
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState$State valueOf(java.lang.String) -> valueOf
com.google.zxing.oned.rss.expanded.decoders.DecodedChar -> b.a.b.f.a.a.a.n:
    char value -> a
    char getValue() -> a
    boolean isFNC1() -> a
com.google.zxing.oned.rss.expanded.decoders.DecodedInformation -> b.a.b.f.a.a.a.o:
    java.lang.String newString -> a
    int remainingValue -> a
    boolean remaining -> a
    java.lang.String getNewString() -> a
    boolean isRemaining() -> a
    int getRemainingValue() -> a
com.google.zxing.oned.rss.expanded.decoders.DecodedNumeric -> b.a.b.f.a.a.a.p:
    int firstDigit -> a
    int secondDigit -> b
    int getFirstDigit() -> a
    int getSecondDigit() -> b
    boolean isFirstDigitFNC1() -> a
    boolean isSecondDigitFNC1() -> b
com.google.zxing.oned.rss.expanded.decoders.DecodedObject -> b.a.b.f.a.a.a.q:
    int newPosition -> a
    int getNewPosition() -> c
com.google.zxing.oned.rss.expanded.decoders.FieldParser -> b.a.b.f.a.a.a.r:
    java.lang.Object VARIABLE_LENGTH -> a
    java.lang.Object[][] TWO_DIGIT_DATA_LENGTH -> a
    java.lang.Object[][] THREE_DIGIT_DATA_LENGTH -> b
    java.lang.Object[][] THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH -> c
    java.lang.Object[][] FOUR_DIGIT_DATA_LENGTH -> d
    java.lang.String parseFieldsInGeneralPurpose(java.lang.String) -> a
    java.lang.String processFixedAI(int,int,java.lang.String) -> a
    java.lang.String processVariableAI(int,int,java.lang.String) -> b
com.google.zxing.oned.rss.expanded.decoders.GeneralAppIdDecoder -> b.a.b.f.a.a.a.s:
    com.google.zxing.common.BitArray information -> a
    com.google.zxing.oned.rss.expanded.decoders.CurrentParsingState current -> a
    java.lang.StringBuilder buffer -> a
    java.lang.String decodeAllCodes(java.lang.StringBuilder,int) -> a
    boolean isStillNumeric(int) -> a
    com.google.zxing.oned.rss.expanded.decoders.DecodedNumeric decodeNumeric(int) -> a
    int extractNumericValueFromBitArray(int,int) -> a
    int extractNumericValueFromBitArray(com.google.zxing.common.BitArray,int,int) -> a
    com.google.zxing.oned.rss.expanded.decoders.DecodedInformation decodeGeneralPurposeField(int,java.lang.String) -> a
    com.google.zxing.oned.rss.expanded.decoders.DecodedInformation parseBlocks() -> a
    com.google.zxing.oned.rss.expanded.decoders.BlockParsedResult parseNumericBlock() -> a
    com.google.zxing.oned.rss.expanded.decoders.BlockParsedResult parseIsoIec646Block() -> b
    com.google.zxing.oned.rss.expanded.decoders.BlockParsedResult parseAlphaBlock() -> c
    boolean isStillIsoIec646(int) -> b
    com.google.zxing.oned.rss.expanded.decoders.DecodedChar decodeIsoIec646(int) -> a
    boolean isStillAlpha(int) -> c
    com.google.zxing.oned.rss.expanded.decoders.DecodedChar decodeAlphanumeric(int) -> b
    boolean isAlphaTo646ToAlphaLatch(int) -> d
    boolean isAlphaOr646ToNumericLatch(int) -> e
    boolean isNumericToAlphaNumericLatch(int) -> f
com.google.zxing.pdf417.PDF417Reader -> b.a.b.g.a:
    com.google.zxing.ResultPoint[] NO_POINTS -> a
    com.google.zxing.pdf417.decoder.Decoder decoder -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
    com.google.zxing.common.BitMatrix extractPureBits(com.google.zxing.common.BitMatrix) -> a
    int moduleSize(int[],com.google.zxing.common.BitMatrix) -> a
    int findPatternStart(int,int,com.google.zxing.common.BitMatrix) -> a
    int findPatternEnd(int,int,com.google.zxing.common.BitMatrix) -> b
com.google.zxing.pdf417.decoder.BitMatrixParser -> b.a.b.g.a.a:
    int[] NO_ERRORS -> a
    com.google.zxing.common.BitMatrix bitMatrix -> a
    int rows -> a
    int leftColumnECData -> b
    int rightColumnECData -> c
    int eraseCount -> d
    int[] erasures -> b
    int ecLevel -> e
    int[] SYMBOL_TABLE -> c
    int[] CODEWORD_TABLE -> d
    int[] readCodewords() -> a
    int[] trimArray(int[],int) -> a
    int processRow(int[],int,int,int[],int) -> a
    int getCodeword(long) -> a
    int findCodewordIndex(long) -> b
    int[] getErasures() -> b
    int getECLevel() -> a
com.google.zxing.pdf417.decoder.DecodedBitStreamParser -> b.a.b.g.a.b:
    char[] PUNCT_CHARS -> a
    char[] MIXED_CHARS -> b
    java.math.BigInteger[] EXP900 -> a
    int[] $SWITCH_TABLE$com$google$zxing$pdf417$decoder$DecodedBitStreamParser$Mode -> a
    com.google.zxing.common.DecoderResult decode(int[]) -> a
    int textCompaction(int[],int,java.lang.StringBuilder) -> a
    void decodeTextCompaction(int[],int[],int,java.lang.StringBuilder) -> a
    int byteCompaction(int,int[],int,java.lang.StringBuilder) -> a
    int numericCompaction(int[],int,java.lang.StringBuilder) -> b
    java.lang.String decodeBase900toBase10(int[],int) -> a
    int[] $SWITCH_TABLE$com$google$zxing$pdf417$decoder$DecodedBitStreamParser$Mode() -> a
com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode -> b.a.b.g.a.b$a:
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode ALPHA -> a
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode LOWER -> b
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode MIXED -> c
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode PUNCT -> d
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode ALPHA_SHIFT -> e
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode PUNCT_SHIFT -> f
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode[] ENUM$VALUES -> a
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode[] values() -> values
    com.google.zxing.pdf417.decoder.DecodedBitStreamParser$Mode valueOf(java.lang.String) -> valueOf
com.google.zxing.pdf417.decoder.Decoder -> b.a.b.g.a.c:
    com.google.zxing.common.DecoderResult decode(com.google.zxing.common.BitMatrix) -> a
    void verifyCodewordCount(int[],int) -> a
    int correctErrors(int[],int[],int) -> a
com.google.zxing.pdf417.detector.Detector -> b.a.b.g.b.a:
    int[] START_PATTERN -> a
    int[] START_PATTERN_REVERSE -> b
    int[] STOP_PATTERN -> c
    int[] STOP_PATTERN_REVERSE -> d
    com.google.zxing.BinaryBitmap image -> a
    com.google.zxing.common.DetectorResult detect() -> a
    com.google.zxing.common.DetectorResult detect(java.util.Map) -> a
    com.google.zxing.ResultPoint[] findVertices(com.google.zxing.common.BitMatrix) -> a
    com.google.zxing.ResultPoint[] findVertices180(com.google.zxing.common.BitMatrix) -> b
    void correctCodeWordVertices(com.google.zxing.ResultPoint[],boolean) -> a
    float computeModuleWidth(com.google.zxing.ResultPoint[]) -> a
    int computeDimension(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,float) -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,int) -> a
    int round(float) -> a
    int[] findGuardPattern(com.google.zxing.common.BitMatrix,int,int,int,boolean,int[],int[]) -> a
    int patternMatchVariance(int[],int[],int) -> a
com.google.zxing.pdf417.encoder.BarcodeMatrix -> b.a.b.g.c.a:
    com.google.zxing.pdf417.encoder.BarcodeRow[] matrix -> a
    int currentRow -> a
    int height -> b
    int width -> c
    void startRow() -> a
    com.google.zxing.pdf417.encoder.BarcodeRow getCurrentRow() -> a
    byte[][] getScaledMatrix(int,int) -> a
com.google.zxing.pdf417.encoder.BarcodeRow -> b.a.b.g.c.b:
    byte[] row -> a
    int currentLocation -> a
    void set(int,boolean) -> a
    void addBar(boolean,int) -> a
    byte[] getScaledRow(int) -> a
com.google.zxing.pdf417.encoder.Compaction -> b.a.b.g.c.c:
    com.google.zxing.pdf417.encoder.Compaction AUTO -> a
    com.google.zxing.pdf417.encoder.Compaction TEXT -> b
    com.google.zxing.pdf417.encoder.Compaction BYTE -> c
    com.google.zxing.pdf417.encoder.Compaction NUMERIC -> d
    com.google.zxing.pdf417.encoder.Compaction[] ENUM$VALUES -> a
    com.google.zxing.pdf417.encoder.Compaction[] values() -> values
    com.google.zxing.pdf417.encoder.Compaction valueOf(java.lang.String) -> valueOf
com.google.zxing.pdf417.encoder.PDF417 -> b.a.b.g.c.d:
    int[][] CODEWORD_TABLE -> a
    com.google.zxing.pdf417.encoder.BarcodeMatrix barcodeMatrix -> a
    boolean compact -> a
    com.google.zxing.pdf417.encoder.Compaction compaction -> a
    int minCols -> a
    int maxCols -> b
    int maxRows -> c
    int minRows -> d
    com.google.zxing.pdf417.encoder.BarcodeMatrix getBarcodeMatrix() -> a
    int calculateNumberOfRows(int,int,int) -> a
    int getNumberOfPadCodewords(int,int,int,int) -> a
    void encodeChar(int,int,com.google.zxing.pdf417.encoder.BarcodeRow) -> a
    void encodeLowLevel(java.lang.CharSequence,int,int,int,com.google.zxing.pdf417.encoder.BarcodeMatrix) -> a
    void generateBarcodeLogic(java.lang.String,int) -> a
    int[] determineDimensions(int,int) -> a
    void setCompact(boolean) -> a
com.google.zxing.pdf417.encoder.PDF417ErrorCorrection -> b.a.b.g.c.e:
    int[][] EC_COEFFICIENTS -> a
    int getErrorCorrectionCodewordCount(int) -> a
    java.lang.String generateErrorCorrection(java.lang.CharSequence,int) -> a
com.google.zxing.pdf417.encoder.PDF417HighLevelEncoder -> b.a.b.g.c.f:
    byte[] TEXT_MIXED_RAW -> a
    byte[] TEXT_PUNCTUATION_RAW -> b
    byte[] MIXED -> c
    byte[] PUNCTUATION -> d
    byte[] getBytesForMessage(java.lang.String) -> a
    java.lang.String encodeHighLevel(java.lang.String,com.google.zxing.pdf417.encoder.Compaction) -> a
    int encodeText(java.lang.CharSequence,int,int,java.lang.StringBuilder,int) -> a
    void encodeBinary(byte[],int,int,int,java.lang.StringBuilder) -> a
    void encodeNumeric(java.lang.String,int,int,java.lang.StringBuilder) -> a
    boolean isDigit(char) -> a
    boolean isAlphaUpper(char) -> b
    boolean isAlphaLower(char) -> c
    boolean isMixed(char) -> d
    boolean isPunctuation(char) -> e
    boolean isText(char) -> f
    int determineConsecutiveDigitCount(java.lang.CharSequence,int) -> a
    int determineConsecutiveTextCount(java.lang.CharSequence,int) -> b
    int determineConsecutiveBinaryCount(java.lang.CharSequence,byte[],int) -> a
com.google.zxing.pdf417.encoder.PDF417Writer -> b.a.b.g.c.g:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int) -> a
    com.google.zxing.pdf417.encoder.PDF417 initializeEncoder(com.google.zxing.BarcodeFormat,boolean) -> a
    com.google.zxing.common.BitMatrix bitMatrixFromEncoder(com.google.zxing.pdf417.encoder.PDF417,java.lang.String,int,int) -> a
    com.google.zxing.common.BitMatrix bitMatrixFrombitArray(byte[][]) -> a
    byte[][] rotateArray(byte[][]) -> a
com.google.zxing.qrcode.QRCodeReader -> b.a.b.h.a:
    com.google.zxing.ResultPoint[] NO_POINTS -> a
    com.google.zxing.qrcode.decoder.Decoder decoder -> a
    com.google.zxing.Result decode(com.google.zxing.BinaryBitmap,java.util.Map) -> a
    void reset() -> a
    com.google.zxing.common.BitMatrix extractPureBits(com.google.zxing.common.BitMatrix) -> a
    float moduleSize(int[],com.google.zxing.common.BitMatrix) -> a
com.google.zxing.qrcode.QRCodeWriter -> b.a.b.h.b:
    com.google.zxing.common.BitMatrix encode(java.lang.String,com.google.zxing.BarcodeFormat,int,int,java.util.Map) -> a
    com.google.zxing.common.BitMatrix renderResult(com.google.zxing.qrcode.encoder.QRCode,int,int) -> a
com.google.zxing.qrcode.decoder.BitMatrixParser -> b.a.b.h.a.a:
    com.google.zxing.common.BitMatrix bitMatrix -> a
    com.google.zxing.qrcode.decoder.Version parsedVersion -> a
    com.google.zxing.qrcode.decoder.FormatInformation parsedFormatInfo -> a
    com.google.zxing.qrcode.decoder.FormatInformation readFormatInformation() -> a
    com.google.zxing.qrcode.decoder.Version readVersion() -> a
    int copyBit(int,int,int) -> a
    byte[] readCodewords() -> a
com.google.zxing.qrcode.decoder.DataBlock -> b.a.b.h.a.b:
    int numDataCodewords -> a
    byte[] codewords -> a
    com.google.zxing.qrcode.decoder.DataBlock[] getDataBlocks(byte[],com.google.zxing.qrcode.decoder.Version,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel) -> a
    int getNumDataCodewords() -> a
    byte[] getCodewords() -> a
com.google.zxing.qrcode.decoder.DataMask -> b.a.b.h.a.c:
    com.google.zxing.qrcode.decoder.DataMask[] DATA_MASKS -> a
    void unmaskBitMatrix(com.google.zxing.common.BitMatrix,int) -> a
    boolean isMasked(int,int) -> a
    com.google.zxing.qrcode.decoder.DataMask forReference(int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask000 -> b.a.b.h.a.c$a:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask001 -> b.a.b.h.a.c$b:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask010 -> b.a.b.h.a.c$c:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask011 -> b.a.b.h.a.c$d:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask100 -> b.a.b.h.a.c$e:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask101 -> b.a.b.h.a.c$f:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask110 -> b.a.b.h.a.c$g:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DataMask$DataMask111 -> b.a.b.h.a.c$h:
    boolean isMasked(int,int) -> a
com.google.zxing.qrcode.decoder.DecodedBitStreamParser -> b.a.b.h.a.d:
    char[] ALPHANUMERIC_CHARS -> a
    com.google.zxing.common.DecoderResult decode(byte[],com.google.zxing.qrcode.decoder.Version,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,java.util.Map) -> a
    void decodeHanziSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,int) -> a
    void decodeKanjiSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,int) -> b
    void decodeByteSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,int,com.google.zxing.common.CharacterSetECI,java.util.Collection,java.util.Map) -> a
    char toAlphaNumericChar(int) -> a
    void decodeAlphanumericSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,int,boolean) -> a
    void decodeNumericSegment(com.google.zxing.common.BitSource,java.lang.StringBuilder,int) -> c
    int parseECIValue(com.google.zxing.common.BitSource) -> a
com.google.zxing.qrcode.decoder.Decoder -> b.a.b.h.a.e:
    com.google.zxing.common.reedsolomon.ReedSolomonDecoder rsDecoder -> a
    com.google.zxing.common.DecoderResult decode(com.google.zxing.common.BitMatrix,java.util.Map) -> a
    void correctErrors(byte[],int) -> a
com.google.zxing.qrcode.decoder.ErrorCorrectionLevel -> b.a.b.h.a.f:
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel L -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel M -> b
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel Q -> c
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel H -> d
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel[] FOR_BITS -> a
    int bits -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel[] ENUM$VALUES -> b
    int getBits() -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel forBits(int) -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel[] values() -> values
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel valueOf(java.lang.String) -> valueOf
com.google.zxing.qrcode.decoder.FormatInformation -> b.a.b.h.a.g:
    int[][] FORMAT_INFO_DECODE_LOOKUP -> a
    int[] BITS_SET_IN_HALF_BYTE -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel errorCorrectionLevel -> a
    byte dataMask -> a
    int numBitsDiffering(int,int) -> a
    com.google.zxing.qrcode.decoder.FormatInformation decodeFormatInformation(int,int) -> a
    com.google.zxing.qrcode.decoder.FormatInformation doDecodeFormatInformation(int,int) -> b
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel getErrorCorrectionLevel() -> a
    byte getDataMask() -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
com.google.zxing.qrcode.decoder.Mode -> b.a.b.h.a.h:
    com.google.zxing.qrcode.decoder.Mode TERMINATOR -> a
    com.google.zxing.qrcode.decoder.Mode NUMERIC -> b
    com.google.zxing.qrcode.decoder.Mode ALPHANUMERIC -> c
    com.google.zxing.qrcode.decoder.Mode STRUCTURED_APPEND -> d
    com.google.zxing.qrcode.decoder.Mode BYTE -> e
    com.google.zxing.qrcode.decoder.Mode ECI -> f
    com.google.zxing.qrcode.decoder.Mode KANJI -> g
    com.google.zxing.qrcode.decoder.Mode FNC1_FIRST_POSITION -> h
    com.google.zxing.qrcode.decoder.Mode FNC1_SECOND_POSITION -> i
    com.google.zxing.qrcode.decoder.Mode HANZI -> j
    int[] characterCountBitsForVersions -> a
    int bits -> a
    com.google.zxing.qrcode.decoder.Mode[] ENUM$VALUES -> a
    com.google.zxing.qrcode.decoder.Mode forBits(int) -> a
    int getCharacterCountBits(com.google.zxing.qrcode.decoder.Version) -> a
    int getBits() -> a
    com.google.zxing.qrcode.decoder.Mode[] values() -> values
    com.google.zxing.qrcode.decoder.Mode valueOf(java.lang.String) -> valueOf
com.google.zxing.qrcode.decoder.Version -> b.a.b.h.a.i:
    int[] VERSION_DECODE_INFO -> a
    com.google.zxing.qrcode.decoder.Version[] VERSIONS -> a
    int versionNumber -> a
    int[] alignmentPatternCenters -> b
    com.google.zxing.qrcode.decoder.Version$ECBlocks[] ecBlocks -> a
    int totalCodewords -> b
    int getVersionNumber() -> a
    int[] getAlignmentPatternCenters() -> a
    int getTotalCodewords() -> b
    int getDimensionForVersion() -> c
    com.google.zxing.qrcode.decoder.Version$ECBlocks getECBlocksForLevel(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel) -> a
    com.google.zxing.qrcode.decoder.Version getProvisionalVersionForDimension(int) -> a
    com.google.zxing.qrcode.decoder.Version getVersionForNumber(int) -> b
    com.google.zxing.qrcode.decoder.Version decodeVersionInformation(int) -> c
    com.google.zxing.common.BitMatrix buildFunctionPattern() -> a
    java.lang.String toString() -> toString
    com.google.zxing.qrcode.decoder.Version[] buildVersions() -> a
com.google.zxing.qrcode.decoder.Version$ECB -> b.a.b.h.a.i$a:
    int count -> a
    int dataCodewords -> b
    int getCount() -> a
    int getDataCodewords() -> b
com.google.zxing.qrcode.decoder.Version$ECBlocks -> b.a.b.h.a.i$b:
    int ecCodewordsPerBlock -> a
    com.google.zxing.qrcode.decoder.Version$ECB[] ecBlocks -> a
    int getECCodewordsPerBlock() -> a
    int getNumBlocks() -> b
    int getTotalECCodewords() -> c
    com.google.zxing.qrcode.decoder.Version$ECB[] getECBlocks() -> a
com.google.zxing.qrcode.detector.AlignmentPattern -> b.a.b.h.b.a:
    float estimatedModuleSize -> a
    boolean aboutEquals(float,float,float) -> a
    com.google.zxing.qrcode.detector.AlignmentPattern combineEstimate(float,float,float) -> a
com.google.zxing.qrcode.detector.AlignmentPatternFinder -> b.a.b.h.b.b:
    com.google.zxing.common.BitMatrix image -> a
    java.util.List possibleCenters -> a
    int startX -> a
    int startY -> b
    int width -> c
    int height -> d
    float moduleSize -> a
    int[] crossCheckStateCount -> a
    com.google.zxing.ResultPointCallback resultPointCallback -> a
    com.google.zxing.qrcode.detector.AlignmentPattern find() -> a
    float centerFromEnd(int[],int) -> a
    boolean foundPatternCross(int[]) -> a
    float crossCheckVertical(int,int,int,int) -> a
    com.google.zxing.qrcode.detector.AlignmentPattern handlePossibleCenter(int[],int,int) -> a
com.google.zxing.qrcode.detector.Detector -> b.a.b.h.b.c:
    com.google.zxing.common.BitMatrix image -> a
    com.google.zxing.ResultPointCallback resultPointCallback -> a
    com.google.zxing.common.DetectorResult detect(java.util.Map) -> a
    com.google.zxing.common.DetectorResult processFinderPatternInfo(com.google.zxing.qrcode.detector.FinderPatternInfo) -> a
    com.google.zxing.common.PerspectiveTransform createTransform(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,int) -> a
    com.google.zxing.common.BitMatrix sampleGrid(com.google.zxing.common.BitMatrix,com.google.zxing.common.PerspectiveTransform,int) -> a
    int computeDimension(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,float) -> a
    float calculateModuleSize(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    float calculateModuleSizeOneWay(com.google.zxing.ResultPoint,com.google.zxing.ResultPoint) -> a
    float sizeOfBlackWhiteBlackRunBothWays(int,int,int,int) -> a
    float sizeOfBlackWhiteBlackRun(int,int,int,int) -> b
    com.google.zxing.qrcode.detector.AlignmentPattern findAlignmentInRegion(float,int,int,float) -> a
    int round(float) -> a
com.google.zxing.qrcode.detector.FinderPattern -> b.a.b.h.b.d:
    float estimatedModuleSize -> a
    int count -> a
    float getEstimatedModuleSize() -> c
    int getCount() -> a
    boolean aboutEquals(float,float,float) -> a
    com.google.zxing.qrcode.detector.FinderPattern combineEstimate(float,float,float) -> a
com.google.zxing.qrcode.detector.FinderPatternFinder -> b.a.b.h.b.e:
    com.google.zxing.common.BitMatrix image -> a
    java.util.List possibleCenters -> a
    boolean hasSkipped -> a
    int[] crossCheckStateCount -> a
    com.google.zxing.ResultPointCallback resultPointCallback -> a
    com.google.zxing.qrcode.detector.FinderPatternInfo find(java.util.Map) -> a
    float centerFromEnd(int[],int) -> a
    boolean foundPatternCross(int[]) -> a
    int[] getCrossCheckStateCount() -> a
    float crossCheckVertical(int,int,int,int) -> a
    float crossCheckHorizontal(int,int,int,int) -> b
    boolean handlePossibleCenter(int[],int,int) -> a
    int findRowSkip() -> a
    boolean haveMultiplyConfirmedCenters() -> a
    com.google.zxing.qrcode.detector.FinderPattern[] selectBestPatterns() -> a
com.google.zxing.qrcode.detector.FinderPatternFinder$CenterComparator -> b.a.b.h.b.e$a:
    float average -> a
    int compare(com.google.zxing.qrcode.detector.FinderPattern,com.google.zxing.qrcode.detector.FinderPattern) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.zxing.qrcode.detector.FinderPatternFinder$FurthestFromAverageComparator -> b.a.b.h.b.e$b:
    float average -> a
    int compare(com.google.zxing.qrcode.detector.FinderPattern,com.google.zxing.qrcode.detector.FinderPattern) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.google.zxing.qrcode.detector.FinderPatternInfo -> b.a.b.h.b.f:
    com.google.zxing.qrcode.detector.FinderPattern bottomLeft -> a
    com.google.zxing.qrcode.detector.FinderPattern topLeft -> b
    com.google.zxing.qrcode.detector.FinderPattern topRight -> c
    com.google.zxing.qrcode.detector.FinderPattern getBottomLeft() -> a
    com.google.zxing.qrcode.detector.FinderPattern getTopLeft() -> b
    com.google.zxing.qrcode.detector.FinderPattern getTopRight() -> c
com.google.zxing.qrcode.encoder.BlockPair -> b.a.b.h.c.a:
    byte[] dataBytes -> a
    byte[] errorCorrectionBytes -> b
    byte[] getDataBytes() -> a
    byte[] getErrorCorrectionBytes() -> b
com.google.zxing.qrcode.encoder.ByteMatrix -> b.a.b.h.c.b:
    byte[][] bytes -> a
    int width -> a
    int height -> b
    int getHeight() -> a
    int getWidth() -> b
    byte get(int,int) -> a
    byte[][] getArray() -> a
    void set(int,int,int) -> a
    void set(int,int,boolean) -> a
    void clear(byte) -> a
    java.lang.String toString() -> toString
com.google.zxing.qrcode.encoder.Encoder -> b.a.b.h.c.c:
    int[] ALPHANUMERIC_TABLE -> a
    int[] $SWITCH_TABLE$com$google$zxing$qrcode$decoder$Mode -> b
    int calculateMaskPenalty(com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void encode(java.lang.String,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,java.util.Map,com.google.zxing.qrcode.encoder.QRCode) -> a
    int getAlphanumericCode(int) -> a
    com.google.zxing.qrcode.decoder.Mode chooseMode(java.lang.String,java.lang.String) -> a
    boolean isOnlyDoubleByteKanji(java.lang.String) -> a
    int chooseMaskPattern(com.google.zxing.common.BitArray,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void initQRCode(int,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,com.google.zxing.qrcode.decoder.Mode,com.google.zxing.qrcode.encoder.QRCode) -> a
    int getTotalInputBytes(int,com.google.zxing.qrcode.decoder.Version,com.google.zxing.qrcode.decoder.Mode) -> a
    void terminateBits(int,com.google.zxing.common.BitArray) -> a
    void getNumDataBytesAndNumECBytesForBlockID(int,int,int,int,int[],int[]) -> a
    void interleaveWithECBytes(com.google.zxing.common.BitArray,int,int,int,com.google.zxing.common.BitArray) -> a
    byte[] generateECBytes(byte[],int) -> a
    void appendModeInfo(com.google.zxing.qrcode.decoder.Mode,com.google.zxing.common.BitArray) -> a
    void appendLengthInfo(int,int,com.google.zxing.qrcode.decoder.Mode,com.google.zxing.common.BitArray) -> a
    void appendBytes(java.lang.String,com.google.zxing.qrcode.decoder.Mode,com.google.zxing.common.BitArray,java.lang.String) -> a
    void appendNumericBytes(java.lang.CharSequence,com.google.zxing.common.BitArray) -> a
    void appendAlphanumericBytes(java.lang.CharSequence,com.google.zxing.common.BitArray) -> b
    void append8BitBytes(java.lang.String,com.google.zxing.common.BitArray,java.lang.String) -> a
    void appendKanjiBytes(java.lang.String,com.google.zxing.common.BitArray) -> a
    void appendECI(com.google.zxing.common.CharacterSetECI,com.google.zxing.common.BitArray) -> a
    int[] $SWITCH_TABLE$com$google$zxing$qrcode$decoder$Mode() -> a
com.google.zxing.qrcode.encoder.MaskUtil -> b.a.b.h.c.d:
    int applyMaskPenaltyRule1(com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    int applyMaskPenaltyRule2(com.google.zxing.qrcode.encoder.ByteMatrix) -> b
    int applyMaskPenaltyRule3(com.google.zxing.qrcode.encoder.ByteMatrix) -> c
    int applyMaskPenaltyRule4(com.google.zxing.qrcode.encoder.ByteMatrix) -> d
    boolean getDataMaskBit(int,int,int) -> a
    int applyMaskPenaltyRule1Internal(com.google.zxing.qrcode.encoder.ByteMatrix,boolean) -> a
com.google.zxing.qrcode.encoder.MatrixUtil -> b.a.b.h.c.e:
    int[][] POSITION_DETECTION_PATTERN -> a
    int[][] HORIZONTAL_SEPARATION_PATTERN -> b
    int[][] VERTICAL_SEPARATION_PATTERN -> c
    int[][] POSITION_ADJUSTMENT_PATTERN -> d
    int[][] POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE -> e
    int[][] TYPE_INFO_COORDINATES -> f
    void clearMatrix(com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void buildMatrix(com.google.zxing.common.BitArray,com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,int,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void embedBasicPatterns(int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void embedTypeInfo(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void maybeEmbedVersionInfo(int,com.google.zxing.qrcode.encoder.ByteMatrix) -> b
    void embedDataBits(com.google.zxing.common.BitArray,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    int findMSBSet(int) -> a
    int calculateBCHCode(int,int) -> a
    void makeTypeInfoBits(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel,int,com.google.zxing.common.BitArray) -> a
    void makeVersionInfoBits(int,com.google.zxing.common.BitArray) -> a
    boolean isEmpty(int) -> a
    boolean isValidValue(int) -> b
    void embedTimingPatterns(com.google.zxing.qrcode.encoder.ByteMatrix) -> b
    void embedDarkDotAtLeftBottomCorner(com.google.zxing.qrcode.encoder.ByteMatrix) -> c
    void embedHorizontalSeparationPattern(int,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    void embedVerticalSeparationPattern(int,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> b
    void embedPositionAdjustmentPattern(int,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> c
    void embedPositionDetectionPattern(int,int,com.google.zxing.qrcode.encoder.ByteMatrix) -> d
    void embedPositionDetectionPatternsAndSeparators(com.google.zxing.qrcode.encoder.ByteMatrix) -> d
    void maybeEmbedPositionAdjustmentPatterns(int,com.google.zxing.qrcode.encoder.ByteMatrix) -> c
com.google.zxing.qrcode.encoder.QRCode -> b.a.b.h.c.f:
    com.google.zxing.qrcode.decoder.Mode mode -> a
    com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ecLevel -> a
    int version -> a
    int matrixWidth -> b
    int maskPattern -> c
    int numTotalBytes -> d
    int numDataBytes -> e
    int numECBytes -> f
    int numRSBlocks -> g
    com.google.zxing.qrcode.encoder.ByteMatrix matrix -> a
    int getVersion() -> a
    int getMatrixWidth() -> b
    int getMaskPattern() -> c
    int getNumTotalBytes() -> d
    int getNumDataBytes() -> e
    int getNumRSBlocks() -> f
    com.google.zxing.qrcode.encoder.ByteMatrix getMatrix() -> a
    boolean isValid() -> a
    java.lang.String toString() -> toString
    void setMode(com.google.zxing.qrcode.decoder.Mode) -> a
    void setECLevel(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel) -> a
    void setVersion(int) -> a
    void setMatrixWidth(int) -> b
    void setMaskPattern(int) -> c
    void setNumTotalBytes(int) -> d
    void setNumDataBytes(int) -> e
    void setNumECBytes(int) -> f
    void setNumRSBlocks(int) -> g
    void setMatrix(com.google.zxing.qrcode.encoder.ByteMatrix) -> a
    boolean isValidMaskPattern(int) -> a
com.quantimegroup.solutions.archimedean.common.SolidDefinition -> b.b.a.a.a.a:
    int[] signature -> a
    java.lang.String name -> a
    boolean dual -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList knownSolids -> a
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TETRAHEDRON -> a
    com.quantimegroup.solutions.archimedean.common.SolidDefinition CUBE -> b
    com.quantimegroup.solutions.archimedean.common.SolidDefinition OCTAHEDRON -> c
    com.quantimegroup.solutions.archimedean.common.SolidDefinition DODECAHEDRON -> d
    com.quantimegroup.solutions.archimedean.common.SolidDefinition ICOSAHEDRON -> e
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRUNCATED_TETRAHEDRON -> f
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRUNCATED_CUBE -> g
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRUNCATED_OCTAHEDRON -> h
    com.quantimegroup.solutions.archimedean.common.SolidDefinition CUBOCTAHEDRON -> i
    com.quantimegroup.solutions.archimedean.common.SolidDefinition SMALL_RHOMBICUBOCTAHEDRON -> j
    com.quantimegroup.solutions.archimedean.common.SolidDefinition GREAT_RHOMBICUBOCTAHEDRON -> k
    com.quantimegroup.solutions.archimedean.common.SolidDefinition SNUB_CUBE -> l
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRUNCATED_DODECAHEDRON -> m
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRUNCATED_ICOSAHEDRON -> n
    com.quantimegroup.solutions.archimedean.common.SolidDefinition ICOSIDODECAHEDRON -> o
    com.quantimegroup.solutions.archimedean.common.SolidDefinition SMALL_RHOMBICOSIDODECAHEDRON -> p
    com.quantimegroup.solutions.archimedean.common.SolidDefinition GREAT_RHOMBICOSIDODECAHEDRON -> q
    com.quantimegroup.solutions.archimedean.common.SolidDefinition SNUB_DODECAHEDRON -> r
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRIAKIS_TETRAHEDRON -> s
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRIAKIS_OCTAHEDRON -> t
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TETRAKIS_HEXAHEDRON -> u
    com.quantimegroup.solutions.archimedean.common.SolidDefinition RHOMBIC_DODECAHEDRON -> v
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRAPEZOIDAL_ICOSITETRAHEDRON -> w
    com.quantimegroup.solutions.archimedean.common.SolidDefinition HEXAKIS_OCTAHEDRON -> x
    com.quantimegroup.solutions.archimedean.common.SolidDefinition PENTAGONAL_ICOSITETRAHEDRON -> y
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRIAKIS_ICOSAHEDRON -> z
    com.quantimegroup.solutions.archimedean.common.SolidDefinition PENTAKIS_DODECAHEDRON -> A
    com.quantimegroup.solutions.archimedean.common.SolidDefinition RHOMBIC_TRIACONTAHEDRON -> B
    com.quantimegroup.solutions.archimedean.common.SolidDefinition TRAPEZOIDAL_HEXECONTAHEDRON -> C
    com.quantimegroup.solutions.archimedean.common.SolidDefinition HEXAKIS_ICOSAHEDRON -> D
    com.quantimegroup.solutions.archimedean.common.SolidDefinition PENTAGONAL_HEXECONTAHEDRON -> E
    void init() -> a
    int getSolidType(int[],int) -> a
    boolean equals(java.lang.String) -> a
    com.quantimegroup.solutions.archimedean.common.SolidDefinition findSolidDefinition(java.lang.String) -> a
    int[] getSignature() -> a
    boolean isDual() -> a
    java.lang.String toString() -> toString
com.quantimegroup.solutions.archimedean.geom.ArchiBuilder -> b.b.a.a.b.a:
    com.quantimegroup.solutions.archimedean.utils.ObjectList points -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList vectors -> b
    com.quantimegroup.solutions.archimedean.utils.ObjectList corners -> c
    com.quantimegroup.solutions.archimedean.utils.ObjectList sides -> e
    com.quantimegroup.solutions.archimedean.utils.ObjectList firstSides -> d
    boolean ambiguous -> a
    int ambiguousPoly -> a
    int type -> b
    int[] signature -> a
    double maxError -> a
    boolean untwist -> b
    com.quantimegroup.solutions.archimedean.geom.ArchiBuilder dualPartner -> a
    double COMMIT_EPSILON -> b
    double FIND_APPROX_POINT_EPSILON -> c
    com.quantimegroup.solutions.archimedean.geom.ArchiCorner createArchiCorner() -> a
    void identify() -> a
    com.quantimegroup.solutions.archimedean.geom.Surface createSurface() -> a
    void recurse(int,double) -> a
    boolean isComplete() -> a
    void getAmbiguous() -> b
    void createFirstSides(int[],int) -> a
    int registerPoint(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    int registerCorner(com.quantimegroup.solutions.archimedean.geom.ArchiCorner) -> a
    int registerSide(com.quantimegroup.solutions.archimedean.geom.ArchiFacet) -> a
    int cornerIsBuilt(int,int,int) -> a
    int sideIsBuilt(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    void center() -> c
    com.quantimegroup.solutions.archimedean.geom.ArchiFacet getSide(int) -> a
    com.quantimegroup.solutions.archimedean.geom.ArchiCorner getCorner(int) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getPoint(int) -> a
    com.quantimegroup.solutions.archimedean.geom.State getState() -> a
    void setState(com.quantimegroup.solutions.archimedean.geom.State) -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList getPoints() -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList getSides() -> b
com.quantimegroup.solutions.archimedean.geom.ArchiCorner -> b.b.a.a.b.b:
    com.quantimegroup.solutions.archimedean.geom.ArchiBuilder boss -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList firstSides -> a
    int hub -> a
    com.quantimegroup.solutions.archimedean.utils.IntList spokes -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple pole -> a
    com.quantimegroup.solutions.archimedean.utils.IntList sides -> b
    int getHub() -> a
    com.quantimegroup.solutions.archimedean.utils.IntList getSpokes() -> a
    com.quantimegroup.solutions.archimedean.utils.IntList getSides() -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getPole() -> a
    double computePoleTheta(com.quantimegroup.solutions.archimedean.utils.ObjectList,double) -> a
    void init(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,int,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder) -> a
    void init(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,int,double,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder,int) -> a
    com.quantimegroup.solutions.archimedean.geom.ArchiCorner simpleCorner(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,int,double,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder) -> a
    void createFirstCorner(com.quantimegroup.solutions.archimedean.utils.ObjectList,double,int,double,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder) -> a
    void createFirstCorner(com.quantimegroup.solutions.archimedean.utils.ObjectList,double,int,double,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder,boolean) -> a
    void start(com.quantimegroup.solutions.archimedean.geom.ArchiFacet,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,int,double) -> a
    int getFirstSides(com.quantimegroup.solutions.archimedean.geom.ArchiFacet,com.quantimegroup.solutions.archimedean.geom.ArchiFacet,int,int) -> a
    void complete(int,double,int) -> a
    void completeSpokes(double) -> a
    void completeSides() -> a
    void propagateCorners(int,double,com.quantimegroup.solutions.archimedean.geom.ArchiBuilder,int) -> a
    void errorCheck() -> b
    double polyAngle(int) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getSpoke(int) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple wrapgetSpoke(int) -> b
    com.quantimegroup.solutions.archimedean.geom.ArchiFacet getSide(int) -> a
    com.quantimegroup.solutions.archimedean.geom.ArchiFacet wrapgetSide(int) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getHubPoint() -> b
    int[] getSignature() -> a
com.quantimegroup.solutions.archimedean.geom.ArchiFacet -> b.b.a.a.b.c:
    com.quantimegroup.solutions.archimedean.utils.IntList vertexIndices -> a
    int normalIndex -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList points -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList vectors -> b
    boolean isREGULAR -> a
    com.quantimegroup.solutions.archimedean.geom.FacetStateCalculator stateCalculator -> a
    com.quantimegroup.solutions.archimedean.geom.FacetShapeCalculator shapeCalculator -> a
    void setPoints(com.quantimegroup.solutions.archimedean.utils.ObjectList) -> a
    void setVectors(com.quantimegroup.solutions.archimedean.utils.ObjectList) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getNormal() -> a
    void setNormal(int) -> a
    com.quantimegroup.solutions.archimedean.utils.IntList getVertexIndices() -> a
    int findPoint(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    int findIndex(int) -> a
    int toRange(int) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getPoint(int) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple wrapgetPoint(int) -> b
    int wrapgetIndex(int) -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple calcNormal() -> b
    boolean isAdjacent(com.quantimegroup.solutions.archimedean.geom.ArchiFacet) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple[] threeDistinctPoints() -> a
    int getVertexCount() -> a
    com.quantimegroup.solutions.archimedean.geom.FacetStateCalculator getStateCalculator() -> a
    com.quantimegroup.solutions.archimedean.geom.FacetShapeCalculator getShapeCalculator() -> a
com.quantimegroup.solutions.archimedean.geom.Facet -> b.b.a.a.b.d:
    com.quantimegroup.solutions.archimedean.geom.Surface surface -> a
    com.quantimegroup.solutions.archimedean.utils.IntList pointIndices -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple normal -> a
    com.quantimegroup.solutions.archimedean.geom.FacetState defaultState -> a
    com.quantimegroup.solutions.archimedean.geom.FacetStateCalculator stateCalculator -> a
    com.quantimegroup.solutions.archimedean.geom.FacetShapeCalculator shapeCalculator -> a
    java.util.List children -> a
    com.quantimegroup.solutions.archimedean.geom.Facet parent -> a
    void setStateCalculator(com.quantimegroup.solutions.archimedean.geom.FacetStateCalculator) -> a
    void setShapeCalculator(com.quantimegroup.solutions.archimedean.geom.FacetShapeCalculator) -> a
    void init(int[],com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getPoint(int) -> a
    void calcNormal() -> a
    com.quantimegroup.solutions.archimedean.utils.IntList getPointIndices() -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getNormal() -> a
    java.lang.String toString() -> toString
com.quantimegroup.solutions.archimedean.geom.FacetShapeCalculator -> b.b.a.a.b.e:
com.quantimegroup.solutions.archimedean.geom.FacetState -> b.b.a.a.b.f:
    com.quantimegroup.solutions.archimedean.geom.FacetState REAL -> a
    com.quantimegroup.solutions.archimedean.geom.FacetState NOT_REAL -> b
    boolean real -> a
    boolean primary -> b
    java.lang.String toString() -> toString
com.quantimegroup.solutions.archimedean.geom.FacetStateCalculator -> b.b.a.a.b.g:
com.quantimegroup.solutions.archimedean.geom.Geometry -> b.b.a.a.b.h:
    com.quantimegroup.solutions.archimedean.utils.ObjectList points -> a
    java.util.List listeners -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList getPoints() -> a
com.quantimegroup.solutions.archimedean.geom.GeometryUtils -> b.b.a.a.b.i:
    com.quantimegroup.solutions.archimedean.utils.ObjectList createPoly(int,double) -> a
com.quantimegroup.solutions.archimedean.geom.MySolver -> b.b.a.a.b.j:
    double[] v -> a
    boolean insidePole -> a
    int maxi -> a
    double compute(double) -> a
com.quantimegroup.solutions.archimedean.geom.State -> b.b.a.a.b.k:
    int numCorners -> a
    int numPoints -> b
    int numSides -> c
    int numVectors -> d
com.quantimegroup.solutions.archimedean.geom.Surface -> b.b.a.a.b.l:
    java.util.List rootFacets -> a
    java.util.Set excludedRootFacetIndices -> a
    java.util.List facets -> b
    java.util.List boundaries -> c
    int nonTransientPointCount -> a
    java.util.TreeMap savedBspTrees -> a
    void addRootFacet(com.quantimegroup.solutions.archimedean.geom.Facet) -> a
    com.quantimegroup.solutions.archimedean.geom.Facet getRootFacet(int) -> a
    java.util.Iterator rootFacetsIterator() -> a
com.quantimegroup.solutions.archimedean.geom.TransformablePoint -> b.b.a.a.b.m:
com.quantimegroup.solutions.archimedean.utils.Axes -> b.b.a.a.c.a:
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple X -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple Y -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple Z -> d
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple origin -> a
    double sizeFactor -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getX() -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple getY() -> b
    void setX(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    void setY(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    void setZ(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> c
    void correct() -> a
    void transformVector(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> d
    void transformPoint(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> e
    java.lang.String toString() -> toString
com.quantimegroup.solutions.archimedean.utils.IntList -> b.b.a.a.c.b:
    int[] ints -> a
    int num -> a
    int growBy -> b
    void add(int) -> a
    int orderedRemoveIndex(int) -> a
    int get(int) -> b
    int wrapget(int) -> c
    int find(int) -> d
    com.quantimegroup.solutions.archimedean.utils.IntList wrapCopy(int,int) -> a
    int indexToRange(int) -> e
    java.lang.String toString() -> toString
    int[] toArray() -> a
    java.util.Iterator iterator() -> iterator
com.quantimegroup.solutions.archimedean.utils.IntList$1 -> b.b.a.a.c.c:
    int index -> a
    com.quantimegroup.solutions.archimedean.utils.IntList this$0 -> a
    boolean hasNext() -> hasNext
    java.lang.Integer next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
com.quantimegroup.solutions.archimedean.utils.Matrix -> b.b.a.a.c.d:
    double[][] mat -> a
    int numRows() -> a
    int numColumns() -> b
    void timesEquals(double) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple times(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.Matrix times(com.quantimegroup.solutions.archimedean.utils.Matrix) -> a
    void timesEquals(com.quantimegroup.solutions.archimedean.utils.Matrix) -> a
com.quantimegroup.solutions.archimedean.utils.Misc -> b.b.a.a.c.e:
    int arrayCompare(int[],int[]) -> a
    double round(double,int) -> a
com.quantimegroup.solutions.archimedean.utils.ObjectList -> b.b.a.a.c.f:
    java.lang.Object[] objects -> a
    int num -> a
    int growBy -> b
    int addReturnIndex(java.lang.Object) -> a
    boolean add(java.lang.Object) -> add
    boolean remove(java.lang.Object) -> remove
    void removeIndex(int) -> a
    java.lang.Object get(int) -> get
    java.lang.Object wrapget(int) -> a
    java.lang.Object getLast() -> a
    java.lang.Object set(int,java.lang.Object) -> set
    int find(java.lang.Object) -> b
    com.quantimegroup.solutions.archimedean.utils.ObjectList copy() -> a
    com.quantimegroup.solutions.archimedean.utils.ObjectList shrinkCopy() -> b
    com.quantimegroup.solutions.archimedean.utils.ObjectList wrapCopy(int,int) -> a
    int indexToRange(int) -> a
    java.lang.String toString() -> toString
    java.util.Iterator iterator() -> iterator
    int size() -> size
    void clear() -> clear
com.quantimegroup.solutions.archimedean.utils.OrderedDouble -> b.b.a.a.c.g:
    double x -> a
    double y -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedDouble solveEquations(double,double,double,double,double,double) -> a
    boolean isApprox(double,double,double) -> a
com.quantimegroup.solutions.archimedean.utils.OrderedTriple -> b.b.a.a.c.h:
    double x -> a
    double y -> b
    double z -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple origin() -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple xAxis() -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple yAxis() -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple zAxis() -> d
    void become(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    void become(double,double,double) -> a
    double lengthSquared() -> a
    double length() -> b
    double distanceSquared(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    double distance(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple plus(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    void plusEquals(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple minus(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    void minusEquals(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> c
    double dot(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple cross(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> c
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple times(double) -> a
    void timesEquals(double) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple dividedBy(double) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple negative() -> e
    boolean isApprox(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,double) -> a
    double radBetween(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> d
    double degBetween(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> e
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple findThirdVector(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,double,double,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    double[] solveQuadratic(double,double,double) -> a
    boolean isApprox(double,double,double) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple LineLineIntersect(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple sectLines(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple mid(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> d
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple unit() -> f
    java.lang.String toString() -> toString
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple round(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,int) -> a
com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix -> b.b.a.a.c.i:
    com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix identity -> a
    double determinant(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix adjoint(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix inverse(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> b
    void timesEquals(double) -> a
    com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix times(com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix) -> a
    com.quantimegroup.solutions.archimedean.utils.Quick3X3Matrix findRotationMatrix(com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple,com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple times(com.quantimegroup.solutions.archimedean.utils.OrderedTriple) -> a
    java.lang.String toString() -> toString
    java.lang.String toString(double[]) -> a
com.quantimegroup.solutions.archimedean.utils.Rotater -> b.b.a.a.c.j:
    double rad2Deg(double) -> a
com.quantimegroup.solutions.archimedean.utils.Solver -> b.b.a.a.c.k:
    double minx -> a
    double maxx -> b
    double solve() -> a
    double solve(double) -> b
    double compute(double) -> a
geogebra.AppletImplementationInterface -> geogebra.a:
    void dispose() -> a
    void initInBackground() -> b
geogebra.AppletSplashScreen -> geogebra.b:
    java.awt.Image splashImage -> a
    java.awt.Image progressImage -> b
    java.awt.Image splashScreenImage -> c
    java.awt.Graphics splashScreenImageGraphics -> a
    int width -> a
    int height -> b
    geogebra.GeoGebraApplet parentApplet -> a
    boolean dispose -> a
    void dispose() -> a
    void update() -> b
    java.awt.Image getImage() -> a
    boolean isReady() -> a
    boolean imageUpdate(java.awt.Image,int,int,int,int,int) -> imageUpdate
geogebra.CommandLineArguments -> geogebra.c:
    java.util.HashMap args -> a
    int noOfFiles -> a
    int getNoOfFiles() -> a
    java.lang.String getStringValue(java.lang.String) -> a
    boolean getBooleanValue(java.lang.String,boolean) -> a
    boolean isBoolean(java.lang.String) -> a
    boolean containsArg(java.lang.String) -> b
geogebra.GeoGebra -> geogebra.GeoGebra:
    java.awt.Frame splashFrame -> a
    void main(java.lang.String[]) -> main
    void startGeoGebra(geogebra.CommandLineArguments) -> a
geogebra.GeoGebra3D -> geogebra.GeoGebra3D:
    void main(java.lang.String[]) -> main
    void startGeoGebra(geogebra.CommandLineArguments) -> a
geogebra.GeoGebraApplet -> geogebra.GeoGebraApplet:
    geogebra.AppletImplementationInterface appletImplementation -> a
    boolean animationRunningAtLastStop -> a
    geogebra.AppletSplashScreen splashScreen -> a
    boolean appletIsIniting -> b
    void init() -> init
    void initAppletInBackground() -> a
    void start() -> start
    void stop() -> stop
    void destroy() -> destroy
    geogebra.AppletImplementationInterface getAppletImplementation() -> getAppletImplementation
    void setAppletImplementation(geogebra.AppletImplementationInterface) -> setAppletImplementation
    void initAppletImplementation() -> b
    void paint(java.awt.Graphics) -> paint
    boolean isAppletFullyLoaded() -> a
    void deleteObject(java.lang.String) -> deleteObject
    boolean evalCommand(java.lang.String) -> evalCommand
    void evalXML(java.lang.String) -> evalXML
    void debug(java.lang.String) -> debug
    boolean exists(java.lang.String) -> exists
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    java.lang.String getColor(java.lang.String) -> getColor
    double getFilling(java.lang.String) -> getFilling
    int getPointStyle(java.lang.String) -> getPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    int getLineStyle(java.lang.String) -> getLineStyle
    int getLineThickness(java.lang.String) -> getLineThickness
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getHostname() -> getHostname
    java.lang.String getIPAddress() -> getIPAddress
    int getLayer(java.lang.String) -> getLayer
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    double getValue(java.lang.String) -> getValue
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getXML() -> getXML
    java.lang.String getBase64() -> getBase64
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    void openFile(java.lang.String) -> openFile
    void refreshViews() -> refreshViews
    void registerAddListener(java.lang.String) -> registerAddListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    void reset() -> reset
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setColor(java.lang.String,int,int,int) -> setColor
    void setLineThickness(java.lang.String,int) -> setLineThickness
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void setPointSize(java.lang.String,int) -> setPointSize
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setCoords(java.lang.String,double,double) -> setCoords
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void setFixed(java.lang.String,boolean) -> setFixed
    void setGridVisible(boolean) -> setGridVisible
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLayer(java.lang.String,int) -> setLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setMode(int) -> setMode
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setTrace(java.lang.String,boolean) -> setTrace
    void setValue(java.lang.String,double) -> setValue
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    boolean isMoveable(java.lang.String) -> isMoveable
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    void registerPenListener(java.lang.String) -> registerPenListener
    void unregisterPenListener(java.lang.String) -> unregisterPenListener
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
geogebra.GeoGebraApplet$1 -> geogebra.d:
    geogebra.GeoGebraApplet this$0 -> a
    void run() -> run
geogebra.GeoGebraApplet$2 -> geogebra.e:
    geogebra.GeoGebraApplet this$0 -> a
    void run() -> run
    geogebra.GeoGebraApplet access$0(geogebra.GeoGebraApplet$2) -> a
geogebra.GeoGebraApplet$2$1 -> geogebra.f:
    geogebra.GeoGebraApplet$2 this$1 -> a
    void run() -> run
geogebra.GeoGebraAppletPreloader -> geogebra.GeoGebraAppletPreloader:
    void init() -> init
    void loadAllJarFiles(boolean) -> loadAllJarFiles
geogebra.GeoGebraAppletPreloader$1 -> geogebra.g:
    boolean val$loadJavaScriptJAR -> a
    void run() -> run
geogebra.GeoGebraPanel -> geogebra.GeoGebraPanel:
    geogebra.main.Application app -> a
    void main(java.lang.String[]) -> main
    void openFile(java.net.URL) -> openFile
    void setShowToolbar(boolean) -> setShowToolbar
    void setFontSize(int) -> setFontSize
    void setMaxIconSize(int) -> setMaxIconSize
    void setShowMenubar(boolean) -> setShowMenubar
    void setShowAlgebraInput(boolean) -> setShowAlgebraInput
    void setShowAlgebraView(boolean) -> setShowAlgebraView
    void setShowSpreadsheetView(boolean) -> setShowSpreadsheetView
    javax.swing.JPanel getGraphicsPanel() -> getGraphicsPanel
    void setLanguage(java.util.Locale) -> setLanguage
    void attachView(geogebra.common.kernel.View) -> attachView
    void detachView(geogebra.common.kernel.View) -> detachView
    void buildGUI() -> buildGUI
    geogebra.plugin.GgbAPI getGeoGebraAPI() -> getGeoGebraAPI
geogebra.SplashWindow -> geogebra.h:
    java.awt.Image splashImage -> a
    boolean paintCalled -> a
    void update(java.awt.Graphics) -> update
    void paint(java.awt.Graphics) -> paint
    java.awt.Frame splash(java.awt.Image) -> a
    void access$0(geogebra.SplashWindow,boolean) -> a
geogebra.SplashWindow$1 -> geogebra.i:
    geogebra.SplashWindow this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.awt.AffineTransform -> geogebra.awt.a:
    java.awt.geom.AffineTransform at -> a
    java.awt.geom.AffineTransform getImpl() -> a
    void setTransform(geogebra.common.awt.AffineTransform) -> a
    void setTransform(double,double,double,double,double,double) -> a
    void concatenate(geogebra.common.awt.AffineTransform) -> b
    double getScaleX() -> a
    double getScaleY() -> b
    double getShearX() -> c
    double getShearY() -> d
    double getTranslateX() -> e
    double getTranslateY() -> f
    java.awt.geom.AffineTransform getAwtAffineTransform(geogebra.common.awt.AffineTransform) -> a
    geogebra.common.awt.Shape createTransformedShape(geogebra.common.awt.Shape) -> a
    void transform(geogebra.common.awt.Point2D,geogebra.common.awt.Point2D) -> a
    void transform(double[],int,double[],int,int) -> a
    geogebra.common.awt.AffineTransform createInverse() -> a
    void scale(double,double) -> a
    void translate(double,double) -> b
geogebra.awt.AlphaComposite -> geogebra.awt.b:
geogebra.awt.Arc2D -> geogebra.awt.c:
    java.awt.geom.Arc2D$Double impl -> a
    boolean contains(double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    java.awt.Shape getAwtShape() -> a
    void setArc(double,double,double,double,double,double,int) -> a
    geogebra.common.awt.Point2D getStartPoint() -> a
    geogebra.common.awt.Point2D getEndPoint() -> b
    void setArcByCenter(double,double,double,double,double,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.awt.Area -> geogebra.awt.d:
    java.awt.geom.Area impl -> a
    void subtract(geogebra.common.awt.Area) -> a
    void add(geogebra.common.awt.Area) -> b
    void intersect(geogebra.common.awt.Area) -> c
    void exclusiveOr(geogebra.common.awt.Area) -> d
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    boolean isEmpty() -> a
geogebra.awt.BasicStroke -> geogebra.awt.e:
    java.awt.BasicStroke impl -> a
    java.awt.BasicStroke getAwtStroke(geogebra.common.awt.BasicStroke) -> a
    int getEndCap() -> a
    float getMiterLimit() -> a
    int getLineJoin() -> b
    geogebra.common.awt.Shape createStrokedShape(geogebra.common.awt.Shape) -> a
    float getLineWidth() -> b
    float[] getDashArray() -> a
geogebra.awt.BufferedImage -> geogebra.awt.f:
    int TYPE_INT_ARGB -> a
    java.awt.image.BufferedImage impl -> a
    int getWidth() -> a
    int getHeight() -> b
    java.awt.image.BufferedImage getAwtBufferedImage(geogebra.common.awt.BufferedImage) -> a
    geogebra.common.awt.Graphics2D createGraphics() -> a
geogebra.awt.BufferedImageOp -> geogebra.awt.g:
    java.awt.image.BufferedImage createCompatibleDestImage(java.awt.image.BufferedImage,java.awt.image.ColorModel) -> createCompatibleDestImage
    java.awt.image.BufferedImage filter(java.awt.image.BufferedImage,java.awt.image.BufferedImage) -> filter
    java.awt.geom.Rectangle2D getBounds2D(java.awt.image.BufferedImage) -> getBounds2D
    java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D,java.awt.geom.Point2D) -> getPoint2D
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
geogebra.awt.Color -> geogebra.awt.Color:
    double FACTOR -> FACTOR
    java.awt.Color adaptedColor -> adaptedColor
    void getRGBColorComponents(float[]) -> a
    int getBlue() -> a
    int getAlpha() -> b
    int getGreen() -> c
    int getRed() -> d
    java.awt.Color getAwtColor(geogebra.common.awt.Color) -> a
    geogebra.awt.Color darker() -> a
    geogebra.common.awt.Color brighter() -> a
    geogebra.common.awt.Color darker() -> b
geogebra.awt.Composite -> geogebra.awt.h:
    java.awt.Composite impl -> a
    java.awt.Composite getAwtComposite(geogebra.common.awt.Composite) -> a
geogebra.awt.CubicCurve2D -> geogebra.awt.i:
    java.awt.geom.CubicCurve2D impl -> a
    int solveCubic(double[],double[]) -> a
geogebra.awt.Dimension -> geogebra.awt.j:
    java.awt.Dimension impl -> a
    int getWidth() -> a
    int getHeight() -> b
    java.awt.Dimension getAWTDimension(geogebra.common.awt.Dimension) -> a
geogebra.awt.Ellipse2DDouble -> geogebra.awt.k:
    java.awt.geom.Ellipse2D$Double impl -> a
    void setFrame(double,double,double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    java.awt.Shape getAwtShape() -> a
    void setFrameFromCenter(double,double,double,double) -> b
geogebra.awt.Ellipse2DFloat -> geogebra.awt.l:
    java.awt.geom.Ellipse2D$Float impl -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    java.awt.Shape getAwtShape() -> a
geogebra.awt.Font -> geogebra.awt.m:
    java.awt.Font impl -> a
    java.awt.Font getAwtFont(geogebra.common.awt.Font) -> a
    int getStyle() -> a
    int getSize() -> b
    boolean isItalic() -> a
    boolean isBold() -> b
    int canDisplayUpTo(java.lang.String) -> a
    geogebra.awt.Font deriveFont(int,int) -> a
    geogebra.common.awt.Font deriveFont(int) -> a
    java.lang.String getFontName() -> a
    geogebra.common.awt.Font deriveFont(int,int) -> a
geogebra.awt.FontRenderContext -> geogebra.awt.n:
    java.awt.font.FontRenderContext impl -> a
    java.awt.font.FontRenderContext getAwtFrc(geogebra.common.awt.FontRenderContext) -> a
geogebra.awt.GeneralPath -> geogebra.awt.o:
    java.awt.geom.GeneralPath impl -> a
    java.awt.geom.GeneralPath getAwtGeneralPath(geogebra.common.awt.GeneralPath) -> a
    void moveTo(float,float) -> a
    void reset() -> a
    void lineTo(float,float) -> b
    void closePath() -> b
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    boolean intersects(geogebra.common.awt.Rectangle2D) -> a
    geogebra.common.awt.Point2D getCurrentPoint() -> a
    void curveTo(float,float,float,float,float,float) -> a
geogebra.awt.GenericImage -> geogebra.awt.p:
    java.awt.Image impl -> a
    java.awt.Image getAwtImage(geogebra.common.awt.Image) -> a
geogebra.awt.GenericRectangle2D -> geogebra.awt.q:
    java.awt.geom.Rectangle2D impl -> a
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.Rectangle) -> b
    java.awt.geom.Rectangle2D getAWTRectangle2D(geogebra.common.awt.Rectangle2D) -> a
    boolean contains(double,double) -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.awt.GenericShape -> geogebra.awt.r:
    java.awt.Shape impl -> a
    boolean intersects(int,int,int,int) -> a
    java.awt.Shape getAwtShape(geogebra.common.awt.Shape) -> a
    boolean contains(int,int) -> a
    geogebra.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.awt.GradientPaint -> geogebra.awt.s:
    java.awt.GradientPaint impl -> a
    java.awt.GradientPaint getPaint() -> a
geogebra.awt.Graphics2D -> geogebra.awt.t:
    java.awt.Graphics2D impl -> a
    void drawString(java.lang.String,int,int) -> a
    void drawString(java.lang.String,float,float) -> a
    void setComposite(geogebra.common.awt.Composite) -> a
    void setPaint(geogebra.common.awt.Paint) -> a
    void setRenderingHints(java.util.Map) -> a
    void translate(int,int) -> a
    void translate(double,double) -> a
    void rotate(double) -> a
    void scale(double,double) -> b
    void transform(geogebra.common.awt.AffineTransform) -> a
    void setTransform(geogebra.common.awt.AffineTransform) -> b
    geogebra.common.awt.AffineTransform getTransform() -> a
    geogebra.common.awt.Paint getPaint() -> a
    geogebra.common.awt.Composite getComposite() -> a
    geogebra.common.awt.Color getBackground() -> a
    geogebra.common.awt.FontRenderContext getFontRenderContext() -> a
    geogebra.common.awt.Color getColor() -> b
    geogebra.common.awt.Font getFont() -> a
    java.awt.Graphics2D getAwtGraphics(geogebra.common.awt.Graphics2D) -> a
    void setFont(geogebra.common.awt.Font) -> a
    void setStroke(geogebra.common.awt.BasicStroke) -> a
    void setColor(geogebra.common.awt.Color) -> a
    void clip(geogebra.common.awt.Shape) -> a
    void drawImage(geogebra.common.awt.BufferedImage,int,int,geogebra.common.awt.BufferedImageOp) -> a
    void drawImage(geogebra.common.awt.Image,int,int) -> a
    void fillRect(int,int,int,int) -> a
    void drawLine(int,int,int,int) -> b
    void setClip(geogebra.common.awt.Shape) -> b
    void draw(geogebra.common.awt.Shape) -> c
    void fill(geogebra.common.awt.Shape) -> d
    geogebra.common.awt.Shape getClip() -> a
    void drawRect(int,int,int,int) -> c
    void setClip(int,int,int,int) -> d
    void setImpl(java.awt.Graphics2D) -> a
    void drawRoundRect(int,int,int,int,int,int) -> a
    void fillRoundRect(int,int,int,int,int,int) -> b
geogebra.awt.Line2D -> geogebra.awt.u:
    java.awt.geom.Line2D impl -> a
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Shape getAwtShape() -> a
    void setLine(double,double,double,double) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    geogebra.common.awt.Point2D getP1() -> a
    geogebra.common.awt.Point2D getP2() -> b
geogebra.awt.PathIterator -> geogebra.awt.v:
    java.awt.geom.PathIterator impl -> a
    int getWindingRule() -> a
    boolean isDone() -> a
    void next() -> a
    int currentSegment(double[]) -> a
geogebra.awt.Point2D -> geogebra.awt.w:
    java.awt.geom.Point2D$Double impl -> a
    java.awt.geom.Point2D getAwtPoint2D(geogebra.common.awt.Point2D) -> a
    double getX() -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.Point2D) -> a
    double distance(double,double) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
geogebra.awt.Rectangle -> geogebra.awt.x:
    java.awt.Rectangle impl -> a
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setBounds(int,int,int,int) -> a
    void setLocation(int,int) -> a
    void setBounds(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    java.awt.Rectangle getAWTRectangle(geogebra.common.awt.Rectangle) -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    void add(geogebra.common.awt.Rectangle) -> b
    double getMinX() -> e
    double getMinY() -> f
    double getMaxX() -> g
    double getMaxY() -> h
    void add(double,double) -> a
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.Rectangle) -> b
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    java.awt.Shape getAwtShape() -> a
    boolean contains(geogebra.common.awt.Point2D) -> a
    geogebra.common.awt.Rectangle union(geogebra.common.awt.Rectangle) -> a
    void setSize(int,int) -> b
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.awt.Rectangle2D -> geogebra.awt.y:
    geogebra.awt.Rectangle2D impl -> a
geogebra.awt.RectangularShape -> geogebra.awt.z:
geogebra.awt.Shape -> geogebra.awt.A:
    java.awt.Shape getAwtShape() -> a
geogebra.awt.TextLayout -> geogebra.awt.B:
    java.awt.font.TextLayout impl -> a
    float getAdvance() -> a
    geogebra.awt.Rectangle2D getBounds() -> a
    float getAscent() -> b
    float getDescent() -> c
    void draw(geogebra.common.awt.Graphics2D,int,int) -> a
    geogebra.common.awt.Rectangle2D getBounds() -> a
geogebra.cas.error.TimeoutException -> geogebra.a.a.a:
    java.lang.String getKey() -> a
geogebra.cas.mpreduce.CASmpreduce -> geogebra.a.b.a:
    org.mathpiper.mpreduce.Interpreter2 mpreduce_static -> a
    org.mathpiper.mpreduce.Interpreter2 mpreduce -> b
    java.util.List queue -> a
    java.lang.Thread casThread -> a
    org.mathpiper.mpreduce.Interpreter2 getStaticInterpreter() -> a
    geogebra.common.cas.Evaluate getMPReduce() -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> a
    java.lang.String getVersionString(org.mathpiper.mpreduce.Interpreter2) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.cas.AsynchronousCommand) -> a
    void initCAS() -> a
geogebra.cas.mpreduce.CASmpreduce$1 -> geogebra.a.b.b:
    geogebra.cas.mpreduce.CASmpreduce this$0 -> a
    void run() -> run
geogebra.cas.view.CASInputHandler -> geogebra.a.c.a:
    geogebra.cas.view.CASView casView -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.cas.view.CASTable consoleTable -> a
    boolean assignToFreeGeoOnly -> a
    void processCurrentRow(java.lang.String,java.lang.String[]) -> a
    void processMultipleRows(java.lang.String,java.lang.String[]) -> b
    java.lang.String resolveButtonParameter(java.lang.String,geogebra.common.kernel.geos.GeoCasCell) -> a
    boolean processRowThenEdit(int,boolean) -> a
    java.lang.String resolveCASrowReferences(java.lang.String,int,char,boolean) -> a
    void handleReference(java.lang.StringBuilder,int,int,boolean,boolean,boolean) -> a
    void appendReference(java.lang.StringBuilder,java.lang.String,boolean,boolean) -> a
    boolean isPositiveNumber(java.lang.String) -> a
    java.lang.String fixInputErrors(java.lang.String) -> a
geogebra.cas.view.CASInputPanel -> geogebra.a.c.b:
    geogebra.gui.inputfield.AutoCompleteTextField inputArea -> a
    geogebra.main.Application app -> a
    void setInput(java.lang.String) -> a
    java.lang.String getInput() -> a
    javax.swing.text.JTextComponent getInputArea() -> a
    boolean setInputAreaFocused() -> a
    void setFont(java.awt.Font) -> setFont
    void setCommentColor(java.awt.Color) -> a
    void setLabels() -> a
geogebra.cas.view.CASOutputPanel -> geogebra.a.c.c:
    java.awt.Color TEXT_COLOR -> a
    java.awt.Color ERROR_COLOR -> b
    java.awt.Color OUTPUT_PREFIX_COLOR -> c
    java.lang.String OUTPUT_PREFIX -> a
    javax.swing.JLabel outputSign -> a
    javax.swing.JLabel outputArea -> b
    geogebra.cas.view.LaTeXPanel latexPanel -> a
    void setOutput(java.lang.String,java.lang.String,java.lang.String,boolean) -> a
    void setFont(java.awt.Font) -> setFont
geogebra.cas.view.CASStyleBar -> geogebra.a.c.d:
    geogebra.main.Application app -> a
    geogebra.cas.view.CASView casView -> a
    geogebra.gui.util.MyToggleButton[] toggleBtnList -> a
    geogebra.gui.util.PopupMenuButton[] popupBtnList -> a
    geogebra.gui.color.ColorPopupMenuButton btnTextColor -> a
    geogebra.gui.util.PopupMenuButton btnTextSize -> a
    geogebra.gui.util.MyToggleButton btnBold -> a
    geogebra.gui.util.MyToggleButton btnItalic -> b
    geogebra.gui.util.MyToggleButton btnUseAsText -> c
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    boolean needUndo -> a
    boolean isIniting -> b
    java.util.ArrayList selectedRows -> a
    void setSelectedRows(java.util.ArrayList) -> a
    void setSelectedRow(geogebra.common.kernel.geos.GeoElement) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void processSource(java.lang.Object,java.util.ArrayList) -> a
    void updateStyleBar() -> a
    void applyTextColor(java.util.ArrayList) -> b
    void applyUseAsText(java.util.ArrayList) -> c
    void applyFontStyle(java.util.ArrayList) -> d
    void applyTextSize(java.util.ArrayList) -> e
    geogebra.gui.util.PopupMenuButton[] newPopupBtnList() -> a
    geogebra.gui.util.MyToggleButton[] newToggleBtnList() -> a
    void initGUI() -> b
    boolean checkGeoText(java.lang.Object[]) -> a
    void createTextButtons() -> c
    geogebra.gui.util.MyToggleButton access$0(geogebra.cas.view.CASStyleBar) -> a
    geogebra.gui.util.MyToggleButton access$1(geogebra.cas.view.CASStyleBar) -> b
    geogebra.gui.util.MyToggleButton access$2(geogebra.cas.view.CASStyleBar) -> c
geogebra.cas.view.CASStyleBar$1 -> geogebra.a.c.e:
    java.awt.Color geoColor -> a
    geogebra.cas.view.CASStyleBar this$0 -> a
    java.awt.Dimension val$textColorIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.cas.view.CASStyleBar$2 -> geogebra.a.c.f:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$3 -> geogebra.a.c.g:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$4 -> geogebra.a.c.h:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASStyleBar$5 -> geogebra.a.c.i:
    geogebra.cas.view.CASStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.cas.view.CASSubDialog -> geogebra.a.c.j:
    javax.swing.JButton btSub -> a
    javax.swing.JButton btEval -> b
    javax.swing.JButton btNumeric -> c
    javax.swing.JScrollPane scrollPane -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel btPanel -> b
    javax.swing.JPanel captionPanel -> c
    javax.swing.JTable replaceTable -> a
    java.util.Vector data -> a
    geogebra.cas.view.CASView casView -> a
    geogebra.main.Application app -> a
    int editRow -> a
    java.lang.String prefix -> a
    java.lang.String evalText -> b
    java.lang.String postfix -> c
    void createGUI() -> a
    void addRow(boolean) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> setVisible
    boolean apply(java.lang.String) -> a
    geogebra.main.Application getApp() -> a
geogebra.cas.view.CASSubDialog$1 -> geogebra.a.c.k:
    geogebra.cas.view.CASSubDialog this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.CASSubDialog$2 -> geogebra.a.c.l:
    geogebra.cas.view.CASSubDialog this$0 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASSubDialog$MathTextCellEditor -> geogebra.a.c.j$a:
    boolean editing -> a
    geogebra.gui.inputfield.MathTextField delegate -> a
    geogebra.cas.view.CASSubDialog this$0 -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    boolean stopCellEditing() -> stopCellEditing
    void cancelCellEditing() -> cancelCellEditing
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    geogebra.cas.view.CASSubDialog access$0(geogebra.cas.view.CASSubDialog$MathTextCellEditor) -> a
geogebra.cas.view.CASSubDialog$MathTextCellEditor$1 -> geogebra.a.c.m:
    geogebra.cas.view.CASSubDialog$MathTextCellEditor this$1 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASTable -> geogebra.a.c.n:
    geogebra.cas.view.CASTableModel tableModel -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.Application app -> a
    geogebra.cas.view.CASView view -> a
    geogebra.cas.view.CASTableCellEditor editor -> a
    geogebra.cas.view.CASTableCellRenderer renderer -> a
    int currentWidth -> a
    boolean rightClick -> a
    int clickedRow -> b
    geogebra.cas.view.CASView getCASView() -> a
    boolean isOutputPanelClicked(java.awt.Point) -> a
    boolean isEditing() -> isEditing
    void stopEditing() -> a
    geogebra.cas.view.CASTableCellEditor getEditor() -> a
    void insertRow(geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    void insertRow(int,geogebra.common.kernel.geos.GeoCasCell,boolean) -> a
    void setRow(int,geogebra.common.kernel.geos.GeoCasCell) -> a
    int getPreferredRowHeight(int) -> a
    void updateRow(int) -> a
    geogebra.common.kernel.geos.GeoCasCell getGeoCasCell(int) -> a
    boolean isRowEmpty(int) -> a
    void deleteAllRows() -> b
    void deleteRow(int) -> b
    void startEditingRow(int) -> c
    void doEditCellAt(int,int) -> a
    void setFont(java.awt.Font) -> setFont
    boolean getScrollableTracksViewportWidth() -> getScrollableTracksViewportWidth
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    void setLabels() -> c
    int getClickedRow() -> a
    boolean isRightClick() -> a
    void setRightClick(boolean) -> a
    void setClickedRow(int) -> d
    geogebra.cas.view.CASTable getTable() -> a
    int getCurrentWidth() -> b
    void setCurrentWidth(int) -> e
geogebra.cas.view.CASTable$1 -> geogebra.a.c.o:
    geogebra.cas.view.CASTable this$0 -> a
    geogebra.cas.view.CASView val$view -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.cas.view.CASTable$2 -> geogebra.a.c.p:
    geogebra.cas.view.CASTable this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.cas.view.CASTable$3 -> geogebra.a.c.q:
    geogebra.cas.view.CASTable this$0 -> a
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.cas.view.CASTableCell -> geogebra.a.c.r:
    geogebra.cas.view.CASInputPanel inputPanel -> a
    geogebra.cas.view.CASOutputPanel outputPanel -> a
    geogebra.gui.inputfield.MyTextField dummyField -> a
    geogebra.main.Application app -> a
    geogebra.cas.view.CASView view -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    int getInputPanelHeight() -> a
    void setInputPanelWidth(int) -> a
    void setValue(geogebra.common.kernel.geos.GeoCasCell) -> a
    void updateTableRowHeight(javax.swing.JTable,int) -> a
    java.lang.String getInput() -> a
    boolean setInputAreaFocused() -> a
    javax.swing.text.JTextComponent getInputArea() -> a
    void setFont(java.awt.Font) -> setFont
    void setLabels() -> a
geogebra.cas.view.CASTableCellController -> geogebra.a.c.s:
    geogebra.cas.view.CASView view -> a
    geogebra.cas.view.CASTable table -> a
    geogebra.cas.view.CASTableCellEditor tableCellEditor -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void handleKeyPressedInputTextField(java.awt.event.KeyEvent) -> a
    void handleEnterKey(java.awt.event.KeyEvent) -> b
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASTableCellEditor -> geogebra.a.c.t:
    javax.swing.JTable table -> a
    geogebra.common.kernel.geos.GeoCasCell cellValue -> a
    boolean editing -> a
    int editingRow -> a
    java.lang.String inputOnEditingStart -> a
    java.util.ArrayList listeners -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.String getInputSelectedText() -> b
    int getInputSelectionStart() -> b
    int getInputSelectionEnd() -> c
    void setInputSelectionStart(int) -> b
    void setInputSelectionEnd(int) -> c
    void insertText(java.lang.String) -> a
    boolean stopCellEditing() -> stopCellEditing
    void cancelCellEditing() -> cancelCellEditing
    boolean isEditing() -> b
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    void fireEditingCanceled() -> b
    void fireEditingStopped() -> c
    boolean isCellEditable(java.util.EventObject) -> isCellEditable
    void removeCellEditorListener(javax.swing.event.CellEditorListener) -> removeCellEditorListener
    void addCellEditorListener(javax.swing.event.CellEditorListener) -> addCellEditorListener
    boolean shouldSelectCell(java.util.EventObject) -> shouldSelectCell
    int getEditingRow() -> d
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.cas.view.CASTableCellRenderer -> geogebra.a.c.u:
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.cas.view.CASTableModel -> geogebra.a.c.v:
    boolean isCellEditable(int,int) -> isCellEditable
geogebra.cas.view.CASView -> geogebra.a.c.w:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.cas.view.CASTable consoleTable -> a
    geogebra.cas.view.CASInputHandler casInputHandler -> a
    geogebra.cas.view.CASSubDialog subDialog -> a
    javax.swing.ListSelectionModel listSelModel -> a
    geogebra.common.cas.GeoGebraCAS cas -> a
    geogebra.main.Application app -> a
    geogebra.cas.view.RowHeader rowHeader -> a
    boolean toolbarIsUpdatedByDockPanel -> a
    geogebra.cas.view.CASStyleBar styleBar -> a
    javax.swing.event.ListSelectionListener selectionListener() -> a
    java.awt.event.MouseListener scrollPaneListener() -> a
    void showSubstituteDialog(java.lang.String,java.lang.String,java.lang.String,int) -> a
    void setSubstituteDialog(geogebra.cas.view.CASSubDialog) -> a
    void processInput(java.lang.String,java.lang.String[]) -> a
    void processRowThenEdit(int,boolean) -> a
    java.lang.String resolveCASrowReferences(java.lang.String,int) -> a
    void updateFonts() -> a
    void createCASTable() -> h
    geogebra.common.cas.GeoGebraCAS getCAS() -> a
    geogebra.cas.view.CASTable getConsoleTable() -> a
    java.lang.String getRowOutputValue(int) -> a
    java.lang.String getRowInputValue(int) -> b
    int getRowCount() -> a
    javax.swing.JComponent getCASViewComponent() -> a
    geogebra.cas.view.RowHeader getRowHeader() -> a
    geogebra.main.Application getApp() -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void setMode(int) -> a
    boolean deleteCasCells(int[]) -> a
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void clearView() -> b
    void repaintView() -> c
    void reset() -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void attachView() -> e
    void detachView() -> f
    void ensureOneEmptyRow() -> i
    void setLabels() -> g
    int getViewID() -> b
    void setToolbarIsUpdatedByDockPanel(boolean) -> a
    geogebra.main.Application getApplication() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    geogebra.cas.view.CASStyleBar getCASStyleBar() -> a
    geogebra.cas.view.CASStyleBar newCASStyleBar() -> b
geogebra.cas.view.CASView$1 -> geogebra.a.c.x:
    geogebra.cas.view.CASView this$0 -> a
    void run() -> run
geogebra.cas.view.CASView$2 -> geogebra.a.c.y:
    geogebra.cas.view.CASView this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.CASView$3 -> geogebra.a.c.z:
    geogebra.cas.view.CASView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.cas.view.LaTeXPanel -> geogebra.a.c.A:
    geogebra.main.Application app -> a
    java.lang.String latex -> a
    java.awt.image.BufferedImage image -> a
    java.awt.Graphics2D g2image -> a
    java.awt.Dimension equSize -> a
    void setLaTeX(java.lang.String) -> a
    java.awt.Dimension drawEquationToImage() -> a
    boolean ensureImageSize(int,int) -> a
    void paint(java.awt.Graphics) -> paint
geogebra.cas.view.RowContentPopupMenu -> geogebra.a.c.B:
    geogebra.common.kernel.geos.GeoCasCell value -> a
    geogebra.cas.view.CASTable table -> a
    void initMenu() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.cas.view.RowHeader -> geogebra.a.c.C:
geogebra.cas.view.RowHeaderListModel -> geogebra.a.c.D:
    javax.swing.JTable table -> a
    int size -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.cas.view.RowHeaderListener -> geogebra.a.c.E:
    geogebra.cas.view.CASTable table -> a
    javax.swing.JList rowHeader -> a
    int mousePressedRow -> a
    boolean rightClick -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.cas.view.RowHeaderPopupMenu -> geogebra.a.c.F:
    javax.swing.JList rowHeader -> a
    geogebra.cas.view.CASTable table -> a
    geogebra.main.Application app -> a
    javax.swing.JMenuItem cbUseAsText -> a
    void initMenu() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.cas.view.RowHeaderRenderer -> geogebra.a.c.G:
    geogebra.cas.view.CASTable casTable -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.common.GeoGebraConstants -> geogebra.common.a:
    java.lang.String PREFERENCES_ROOT -> a
    java.lang.String XML_FILE_FORMAT -> b
geogebra.common.awt.AffineTransform -> geogebra.common.a.a:
    void setTransform(geogebra.common.awt.AffineTransform) -> a
    void setTransform(double,double,double,double,double,double) -> a
    void concatenate(geogebra.common.awt.AffineTransform) -> b
    double getScaleX() -> a
    double getScaleY() -> b
    double getShearX() -> c
    double getShearY() -> d
    geogebra.common.awt.Shape createTransformedShape(geogebra.common.awt.Shape) -> a
    void transform(geogebra.common.awt.Point2D,geogebra.common.awt.Point2D) -> a
    void transform(double[],int,double[],int,int) -> a
    geogebra.common.awt.AffineTransform createInverse() -> a
    void scale(double,double) -> a
    void translate(double,double) -> b
    double getTranslateX() -> e
    double getTranslateY() -> f
geogebra.common.awt.AlphaComposite -> geogebra.common.a.b:
geogebra.common.awt.Arc2D -> geogebra.common.a.c:
    void setArc(double,double,double,double,double,double,int) -> a
    geogebra.common.awt.Point2D getStartPoint() -> a
    geogebra.common.awt.Point2D getEndPoint() -> b
    void setArcByCenter(double,double,double,double,double,int) -> a
geogebra.common.awt.Area -> geogebra.common.a.d:
    void subtract(geogebra.common.awt.Area) -> a
    void intersect(geogebra.common.awt.Area) -> c
    void exclusiveOr(geogebra.common.awt.Area) -> d
    void add(geogebra.common.awt.Area) -> b
    boolean isEmpty() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
geogebra.common.awt.BasicStroke -> geogebra.common.a.e:
    geogebra.common.awt.Shape createStrokedShape(geogebra.common.awt.Shape) -> a
    int getEndCap() -> a
    float getMiterLimit() -> a
    int getLineJoin() -> b
    float getLineWidth() -> b
    float[] getDashArray() -> a
geogebra.common.awt.BufferedImage -> geogebra.common.a.f:
    int getWidth() -> a
    int getHeight() -> b
    geogebra.common.awt.Graphics2D createGraphics() -> a
geogebra.common.awt.BufferedImageOp -> geogebra.common.a.g:
geogebra.common.awt.Color -> geogebra.common.a.h:
    geogebra.common.awt.Color white -> white
    geogebra.common.awt.Color black -> black
    geogebra.common.awt.Color RED -> RED
    geogebra.common.awt.Color WHITE -> WHITE
    geogebra.common.awt.Color BLACK -> BLACK
    geogebra.common.awt.Color BLUE -> BLUE
    geogebra.common.awt.Color GRAY -> GRAY
    geogebra.common.awt.Color GREEN -> GREEN
    geogebra.common.awt.Color YELLOW -> YELLOW
    geogebra.common.awt.Color DARK_GRAY -> DARK_GRAY
    geogebra.common.awt.Color LIGHT_GRAY -> LIGHT_GRAY
    geogebra.common.awt.Color CYAN -> CYAN
    geogebra.common.awt.Color MAGENTA -> MAGENTA
    geogebra.common.awt.Color red -> red
    geogebra.common.awt.Color yellow -> yellow
    geogebra.common.awt.Color green -> green
    geogebra.common.awt.Color blue -> blue
    geogebra.common.awt.Color cyan -> cyan
    geogebra.common.awt.Color magenta -> magenta
    geogebra.common.awt.Color lightGray -> lightGray
    geogebra.common.awt.Color gray -> gray
    geogebra.common.awt.Color darkGray -> darkGray
    void initColors(geogebra.common.factories.AwtFactory) -> a
    int getRed() -> d
    int getBlue() -> a
    int getGreen() -> c
    int getAlpha() -> b
    void getRGBColorComponents(float[]) -> a
    int HSBtoRGB(float,float,float) -> a
    geogebra.common.awt.Color darker() -> b
    geogebra.common.awt.Color brighter() -> a
geogebra.common.awt.Composite -> geogebra.common.a.i:
geogebra.common.awt.CubicCurve2D -> geogebra.common.a.j:
    int solveCubic(double[],double[]) -> a
geogebra.common.awt.Dimension -> geogebra.common.a.k:
    int getWidth() -> a
    int getHeight() -> b
geogebra.common.awt.Ellipse2DDouble -> geogebra.common.a.l:
    void setFrame(double,double,double,double) -> a
    void setFrameFromCenter(double,double,double,double) -> b
geogebra.common.awt.Ellipse2DFloat -> geogebra.common.a.m:
geogebra.common.awt.Font -> geogebra.common.a.n:
    int getStyle() -> a
    int getSize() -> b
    boolean isItalic() -> a
    boolean isBold() -> b
    int canDisplayUpTo(java.lang.String) -> a
    geogebra.common.awt.Font deriveFont(int,int) -> a
    geogebra.common.awt.Font deriveFont(int) -> a
    java.lang.String getFontName() -> a
geogebra.common.awt.FontRenderContext -> geogebra.common.a.o:
geogebra.common.awt.GeneralPath -> geogebra.common.a.p:
    void moveTo(float,float) -> a
    void reset() -> a
    void lineTo(float,float) -> b
    void closePath() -> b
    geogebra.common.awt.Point2D getCurrentPoint() -> a
    boolean intersects(geogebra.common.awt.Rectangle2D) -> a
    void curveTo(float,float,float,float,float,float) -> a
geogebra.common.awt.GradientPaint -> geogebra.common.a.q:
geogebra.common.awt.Graphics2D -> geogebra.common.a.r:
    void draw(geogebra.common.awt.Shape) -> c
    void drawImage(geogebra.common.awt.BufferedImage,int,int,geogebra.common.awt.BufferedImageOp) -> a
    void drawString(java.lang.String,int,int) -> a
    void drawString(java.lang.String,float,float) -> a
    void fill(geogebra.common.awt.Shape) -> d
    void setComposite(geogebra.common.awt.Composite) -> a
    void setPaint(geogebra.common.awt.Paint) -> a
    void setStroke(geogebra.common.awt.BasicStroke) -> a
    void setRenderingHints(java.util.Map) -> a
    void translate(int,int) -> a
    void translate(double,double) -> a
    void rotate(double) -> a
    void scale(double,double) -> b
    void transform(geogebra.common.awt.AffineTransform) -> a
    void setTransform(geogebra.common.awt.AffineTransform) -> b
    geogebra.common.awt.AffineTransform getTransform() -> a
    geogebra.common.awt.Paint getPaint() -> a
    geogebra.common.awt.Composite getComposite() -> a
    geogebra.common.awt.Color getBackground() -> a
    void clip(geogebra.common.awt.Shape) -> a
    geogebra.common.awt.FontRenderContext getFontRenderContext() -> a
    geogebra.common.awt.Color getColor() -> b
    geogebra.common.awt.Font getFont() -> a
    void setFont(geogebra.common.awt.Font) -> a
    void setColor(geogebra.common.awt.Color) -> a
    void fillRect(int,int,int,int) -> a
    void drawLine(int,int,int,int) -> b
    void setClip(geogebra.common.awt.Shape) -> b
    geogebra.common.awt.Shape getClip() -> a
    void drawRect(int,int,int,int) -> c
    void setClip(int,int,int,int) -> d
    void drawRoundRect(int,int,int,int,int,int) -> a
    void fillRoundRect(int,int,int,int,int,int) -> b
    void drawImage(geogebra.common.awt.Image,int,int) -> a
geogebra.common.awt.Image -> geogebra.common.a.s:
geogebra.common.awt.Line2D -> geogebra.common.a.t:
    void setLine(double,double,double,double) -> a
    geogebra.common.awt.Point2D getP1() -> a
    geogebra.common.awt.Point2D getP2() -> b
geogebra.common.awt.Paint -> geogebra.common.a.u:
geogebra.common.awt.PathIterator -> geogebra.common.a.v:
    int getWindingRule() -> a
    boolean isDone() -> a
    void next() -> a
    int currentSegment(double[]) -> a
geogebra.common.awt.Point -> geogebra.common.a.w:
    int y -> a
    int x -> b
    void setLocation(int,int) -> a
    void setLocation(geogebra.common.awt.Point) -> a
    int getY() -> a
    int getX() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    double distance(geogebra.common.awt.Point) -> a
geogebra.common.awt.Point2D -> geogebra.common.a.x:
    double getX() -> a
    double distance(double,double) -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.Point2D) -> a
    double distanceSq(double,double,double,double) -> a
geogebra.common.awt.Point2D$Double -> geogebra.common.a.x$a:
    double x -> a
    double y -> b
    void setLocation(double,double) -> a
    double getX() -> a
    double getY() -> b
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.Point2D) -> a
    double distance(double,double) -> a
geogebra.common.awt.Rectangle -> geogebra.common.a.y:
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setBounds(int,int,int,int) -> a
    void setLocation(int,int) -> a
    void setBounds(geogebra.common.awt.Rectangle) -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    void add(geogebra.common.awt.Rectangle) -> b
    double getMinX() -> e
    double getMinY() -> f
    double getMaxX() -> g
    double getMaxY() -> h
    boolean contains(double,double) -> a
    void add(double,double) -> a
    boolean contains(geogebra.common.awt.Point2D) -> a
    geogebra.common.awt.Rectangle union(geogebra.common.awt.Rectangle) -> a
    void setSize(int,int) -> b
geogebra.common.awt.Rectangle2D -> geogebra.common.a.z:
    double getY() -> a
    double getX() -> b
    double getWidth() -> c
    double getHeight() -> d
    void setRect(double,double,double,double) -> a
    void setFrame(double,double,double,double) -> b
    boolean intersects(double,double,double,double) -> a
    boolean intersects(geogebra.common.awt.Rectangle) -> b
geogebra.common.awt.RectangularShape -> geogebra.common.a.A:
geogebra.common.awt.Shape -> geogebra.common.a.B:
    boolean intersects(int,int,int,int) -> a
    boolean contains(int,int) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    boolean contains(double,double) -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
geogebra.common.awt.font.TextLayout -> geogebra.common.a.a.a:
    float getAdvance() -> a
    geogebra.common.awt.Rectangle2D getBounds() -> a
    float getAscent() -> b
    void draw(geogebra.common.awt.Graphics2D,int,int) -> a
    float getDescent() -> c
geogebra.common.cas.CASException -> geogebra.common.b.a:
    java.lang.String key -> a
    java.lang.String getKey() -> a
    void setKey(java.lang.String) -> a
geogebra.common.cas.CASgeneric -> geogebra.common.b.b:
    long timeoutMillis -> a
    geogebra.common.cas.CASparser casParser -> a
    java.util.Map rbCasTranslations -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateRaw(java.lang.String) -> b
    void unbindVariable(java.lang.String) -> a
    java.lang.String getTranslatedCASCommand(java.lang.String) -> c
    boolean isCommandAvailable(java.lang.String) -> a
    java.util.Map getTranslationRessourceBundle() -> b
    java.util.Map initTranslationMap() -> a
    java.lang.String toAssignment(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String translateToCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String translateAssignment(java.lang.String,java.lang.String) -> a
    long getTimeoutMilliseconds() -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    java.lang.String translateFunctionDeclaration(java.lang.String,java.lang.String,java.lang.String) -> a
    void setSignificantFiguresForNumeric(int) -> a
    java.util.Set getAvailableCommandNames() -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.cas.AsynchronousCommand) -> a
    void CASAsyncFinished(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String,java.lang.Throwable,geogebra.common.kernel.cas.AsynchronousCommand,java.lang.String) -> a
geogebra.common.cas.CASparser -> geogebra.common.b.c:
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInput(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> b
    void resolveVariablesForCAS(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    java.lang.String toGeoGebraString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseMPReduce(java.lang.String) -> c
    java.lang.String replaceIndices(java.lang.String) -> a
    java.lang.String insertSpecialChars(java.lang.String) -> b
geogebra.common.cas.CasParserTools -> geogebra.common.b.d:
    java.lang.String convertScientificFloatNotation(java.lang.String) -> a
geogebra.common.cas.CasParserToolsImpl -> geogebra.common.b.e:
    com.google.gwt.regexp.shared.RegExp pattern -> a
    java.lang.String convertScientificFloatNotation(java.lang.String) -> a
geogebra.common.cas.Evaluate -> geogebra.common.b.f:
    java.lang.String evaluate(java.lang.String) -> a
    java.lang.String evaluate(java.lang.String,long) -> a
geogebra.common.cas.GeoGebraCAS -> geogebra.common.b.g:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.cas.CASparser casParser -> a
    geogebra.common.cas.CASgeneric cas -> a
    geogebra.common.cas.mpreduce.AbstractCASmpreduce casMPReduce -> a
    geogebra.common.main.AbstractApplication$CasType currentCAS -> a
    java.util.Map getPolynomialCoeffsCache -> a
    java.lang.StringBuilder getPolynomialCoeffsSB -> a
    java.lang.StringBuilder sbPolyCoeffs -> b
    int[] $SWITCH_TABLE$geogebra$common$main$AbstractApplication$CasType -> a
    geogebra.common.cas.CASparser getCASparser() -> a
    geogebra.common.cas.CASgeneric getCurrentCAS() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getCurrentCASstringType() -> a
    void setCurrentCAS(geogebra.common.main.AbstractApplication$CasType) -> a
    void setSignificantFiguresForNumeric(int) -> a
    geogebra.common.cas.mpreduce.AbstractCASmpreduce getMPReduce() -> a
    void unbindVariable(java.lang.String) -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateRaw(java.lang.String) -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> b
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getCASCommand(java.lang.String,java.util.ArrayList,boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isCommandAvailable(geogebra.common.kernel.arithmetic.Command) -> a
    boolean isStructurallyEqual(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.cas.AsynchronousCommand) -> a
    geogebra.common.kernel.cas.CASGenericInterface getCurrentCAS() -> a
    geogebra.common.kernel.cas.CASParserInterface getCASparser() -> a
    int[] $SWITCH_TABLE$geogebra$common$main$AbstractApplication$CasType() -> a
geogebra.common.cas.mpreduce.AbstractCASmpreduce -> geogebra.common.b.a.a:
    geogebra.common.cas.CasParserTools parserTools -> a
    java.lang.String casPrefix -> a
    java.lang.StringBuilder varOrder -> a
    int significantNumbers -> a
    java.util.Set predefinedFunctions -> a
    geogebra.common.cas.Evaluate mpreduce -> a
    java.lang.String evaluateMPReduce(java.lang.String) -> a
    java.lang.String evaluateRaw(java.lang.String) -> b
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String translateFunctionDeclaration(java.lang.String,java.lang.String,java.lang.String) -> a
    java.util.Map initTranslationMap() -> a
    java.lang.String toGeoGebraString(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    void unbindVariable(java.lang.String) -> a
    geogebra.common.cas.Evaluate getMPReduce() -> a
    void setSignificantFiguresForNumeric(int) -> a
    void initStaticMyMPReduceFunctions(geogebra.common.cas.Evaluate) -> a
    void initDependentMyMPReduceFunctions(geogebra.common.cas.Evaluate) -> b
geogebra.common.cas.mpreduce.Ggb2MPReduce -> geogebra.common.b.a.b:
    java.util.Map commandMap -> a
    void p(java.lang.String,java.lang.String) -> a
    java.util.Map getMap() -> a
geogebra.common.cas.singularws.SingularWebService -> geogebra.common.b.b.a:
    int timeout -> a
    java.lang.String testConnectionCommand -> a
    java.lang.String singularDirectCommand -> b
    java.lang.String wsHost -> c
    java.lang.Boolean available -> a
    java.lang.String swsCommandResult(java.lang.String) -> b
    java.lang.String swsCommandResult(java.lang.String,java.lang.String) -> a
    boolean isAvailable() -> a
    boolean testConnection() -> b
    java.lang.String directCommand(java.lang.String) -> a
    java.lang.String getConnectionSite() -> a
    void enable() -> a
geogebra.common.euclidian.AbstractEuclidianController -> geogebra.common.c.a:
    int POLYGON_NORMAL -> a
    int POLYGON_RIGID -> b
    int POLYGON_VECTOR -> c
    double MOUSE_DRAG_MAX_DIST_SQUARE -> a
    int MAX_CONTINUITY_STEPS -> d
    int mx -> e
    int my -> f
    double xTemp -> b
    double yTemp -> c
    double xRW -> d
    double yRW -> e
    double xRWold -> f
    double yRWold -> g
    boolean useLineEndPoint -> a
    geogebra.common.kernel.geos.GeoConic tempConic -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly tempImplicitPoly -> a
    java.util.ArrayList moveDependentPoints -> a
    geogebra.common.kernel.geos.GeoFunction tempFunction -> a
    geogebra.common.kernel.kernelND.GeoPointND movedGeoPoint -> a
    boolean movedGeoPointDragged -> b
    geogebra.common.kernel.geos.GeoLine movedGeoLine -> a
    geogebra.common.kernel.geos.GeoConic movedGeoConic -> b
    geogebra.common.kernel.implicit.GeoImplicitPoly movedGeoImplicitPoly -> b
    geogebra.common.kernel.geos.GeoVector movedGeoVector -> a
    geogebra.common.kernel.geos.GeoText movedGeoText -> a
    geogebra.common.kernel.geos.GeoImage oldImage -> a
    geogebra.common.kernel.geos.GeoImage movedGeoImage -> b
    geogebra.common.kernel.geos.GeoFunction movedGeoFunction -> b
    geogebra.common.kernel.geos.GeoNumeric movedGeoNumeric -> a
    boolean movedGeoNumericDragged -> c
    geogebra.common.kernel.geos.GeoBoolean movedGeoBoolean -> a
    geogebra.common.kernel.geos.GeoButton movedGeoButton -> a
    geogebra.common.kernel.geos.GeoElement movedLabelGeoElement -> a
    geogebra.common.kernel.geos.GeoElement movedGeoElement -> b
    geogebra.common.kernel.geos.GeoElement recordObject -> c
    geogebra.common.kernel.arithmetic.MyDouble tempNum -> a
    double rotStartAngle -> h
    java.util.ArrayList translateableGeos -> b
    geogebra.common.kernel.Matrix.Coords translationVec -> a
    geogebra.common.euclidian.Hits tempArrayList -> a
    geogebra.common.euclidian.Hits tempArrayList2 -> b
    geogebra.common.euclidian.Hits tempArrayList3 -> c
    java.util.ArrayList selectedPoints -> c
    java.util.ArrayList selectedNumbers -> d
    java.util.ArrayList selectedNumberValues -> e
    java.util.ArrayList selectedLines -> f
    java.util.ArrayList selectedDirections -> g
    java.util.ArrayList selectedSegments -> h
    java.util.ArrayList selectedRegions -> i
    java.util.ArrayList selectedPaths -> j
    java.util.ArrayList selectedConicsND -> k
    java.util.ArrayList selectedImplicitpoly -> l
    java.util.ArrayList selectedFunctions -> m
    java.util.ArrayList selectedCurves -> n
    java.util.ArrayList selectedVectors -> o
    java.util.ArrayList selectedPolygons -> p
    java.util.ArrayList selectedPolyLines -> q
    java.util.ArrayList selectedGeos -> r
    java.util.ArrayList selectedLists -> s
    geogebra.common.euclidian.Hits highlightedGeos -> d
    java.util.ArrayList justCreatedGeos -> t
    boolean selectionPreview -> d
    boolean hideIntersection -> e
    boolean previewFromResultedGeo -> f
    geogebra.common.kernel.geos.GeoElement resultedGeo -> d
    boolean TEMPORARY_MODE -> g
    boolean DONT_CLEAR_SELECTION -> h
    boolean DRAGGING_OCCURED -> i
    boolean POINT_CREATED -> j
    boolean moveModeSelectionHandled -> k
    boolean highlightJustCreatedGeos -> l
    java.util.ArrayList pastePreviewSelected -> u
    java.util.ArrayList pastePreviewSelectedAndDependent -> v
    int mode -> g
    int oldMode -> h
    int moveMode -> i
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.kernel.geos.Test[] macroInput -> a
    int DEFAULT_INITIAL_DELAY -> j
    boolean toggleModeChangedKernel -> m
    boolean altDown -> n
    geogebra.common.kernel.geos.GeoElement rotGeoElement -> e
    geogebra.common.kernel.geos.GeoElement rotStartGeo -> f
    geogebra.common.kernel.geos.GeoPoint2 rotationCenter -> a
    int polygonMode -> k
    double[] transformCoordsOffset -> a
    boolean allowSelectionRectangleForTranslateByVector -> o
    int previousPointCapturing -> l
    java.util.ArrayList persistentStickyPointList -> w
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.awt.Point startLoc -> a
    geogebra.common.awt.Point mouseLoc -> b
    geogebra.common.awt.Point lastMouseLoc -> c
    geogebra.common.awt.Point oldLoc -> d
    geogebra.common.awt.Point2D$Double startPoint -> a
    geogebra.common.awt.Point2D$Double lineEndPoint -> b
    geogebra.common.awt.Point selectionStartPoint -> e
    java.util.ArrayList tempDependentPointX -> x
    java.util.ArrayList tempDependentPointY -> y
    boolean mouseIsOverLabel -> p
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    geogebra.common.euclidian.EuclidianPen pen -> a
    geogebra.common.euclidian.Hits handleAddSelectedArrayList -> e
    boolean textfieldHasFocus -> q
    java.lang.String sliderValue -> a
    geogebra.common.euclidian.MyButton pressedButton -> a
    double vertexX -> i
    double vertexY -> j
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void removeAxes(java.util.ArrayList) -> a
    boolean pen() -> a
    void updatePastePreviewPosition() -> a
    void setPastePreviewSelected() -> b
    boolean mayPaste() -> b
    void deletePastePreviewSelected() -> c
    void mergeStickyPointsAfterPaste() -> d
    int getMode() -> a
    void endOfMode(int) -> a
    void clearSelection(java.util.ArrayList,boolean) -> a
    void clearSelection(java.util.ArrayList) -> b
    geogebra.common.euclidian.Hits getRegionHits(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] getSelectedGeos() -> a
    void getSelectedPointsND(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getSelectedPointsND() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getSelectedPoints() -> a
    geogebra.common.kernel.geos.GeoNumeric[] getSelectedNumbers() -> a
    geogebra.common.kernel.geos.GeoList[] getSelectedLists() -> a
    geogebra.common.kernel.geos.GeoPolygon[] getSelectedPolygons() -> a
    geogebra.common.kernel.geos.GeoPolyLine[] getSelectedPolyLines() -> a
    void getSelectedLinesND(geogebra.common.kernel.kernelND.GeoLineND[]) -> a
    geogebra.common.kernel.kernelND.GeoLineND[] getSelectedLinesND() -> a
    geogebra.common.kernel.geos.GeoLine[] getSelectedLines() -> a
    void getSelectedSegmentsND(geogebra.common.kernel.kernelND.GeoSegmentND[]) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND[] getSelectedSegmentsND() -> a
    geogebra.common.kernel.geos.GeoSegment[] getSelectedSegments() -> a
    void getSelectedVectorsND(geogebra.common.kernel.kernelND.GeoVectorND[]) -> a
    geogebra.common.kernel.kernelND.GeoVectorND[] getSelectedVectorsND() -> a
    geogebra.common.kernel.geos.GeoVector[] getSelectedVectors() -> a
    geogebra.common.kernel.geos.GeoConic[] getSelectedConics() -> a
    geogebra.common.kernel.geos.GeoConic[] getSelectedCircles() -> b
    geogebra.common.kernel.kernelND.GeoConicND[] getSelectedConicsND() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND[] getSelectedDirections() -> a
    geogebra.common.kernel.Region[] getSelectedRegions() -> a
    geogebra.common.kernel.Path[] getSelectedPaths() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly[] getSelectedImplicitpoly() -> a
    geogebra.common.kernel.geos.GeoFunction[] getSelectedFunctions() -> a
    geogebra.common.kernel.geos.GeoCurveCartesian[] getSelectedCurves() -> a
    boolean allowPointCreation() -> c
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint2D(boolean,geogebra.common.kernel.Path,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint2D(boolean,geogebra.common.kernel.Region,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,double,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    void setKernel(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void clearJustCreatedGeos() -> e
    java.util.ArrayList getJustCreatedGeos() -> a
    void memorizeJustCreatedGeos(java.util.ArrayList) -> c
    void memorizeJustCreatedGeos(geogebra.common.kernel.geos.GeoElement[]) -> a
    void setHighlightedGeos(boolean) -> a
    void doSingleHighlighting(geogebra.common.kernel.geos.GeoElement) -> a
    boolean mouseIsOverLabel() -> d
    void removeParentPoints(java.util.ArrayList) -> d
    int addToSelectionList(java.util.ArrayList,geogebra.common.kernel.geos.GeoElement,int) -> a
    int addToHighlightedList(java.util.ArrayList,java.util.ArrayList,int) -> a
    geogebra.common.kernel.geos.GeoElement chooseGeo(java.util.ArrayList,boolean) -> a
    geogebra.common.kernel.geos.GeoElement chooseGeo(geogebra.common.euclidian.Hits,geogebra.common.kernel.geos.Test) -> a
    int addToSelectionList(java.util.ArrayList,java.util.ArrayList,int,boolean,boolean) -> a
    int selGeos() -> b
    int selPoints() -> c
    int selNumbers() -> d
    int selLists() -> e
    int selPolyLines() -> f
    int selPolygons() -> g
    int selLines() -> h
    int selDirections() -> i
    int selSegments() -> j
    int selVectors() -> k
    int selConics() -> l
    int selPaths() -> m
    int selRegions() -> n
    int selImplicitpoly() -> o
    int selFunctions() -> p
    int selCurves() -> q
    int handleAddSelected(geogebra.common.euclidian.Hits,int,boolean,java.util.ArrayList,geogebra.common.kernel.geos.Test) -> a
    int handleAddSelectedRegions(geogebra.common.euclidian.Hits,int,boolean,java.util.ArrayList) -> a
    int addSelectedGeo(geogebra.common.euclidian.Hits,int,boolean) -> a
    int addSelectedPoint(geogebra.common.euclidian.Hits,int,boolean) -> b
    int addSelectedNumeric(geogebra.common.euclidian.Hits,int,boolean) -> c
    int addSelectedLine(geogebra.common.euclidian.Hits,int,boolean) -> d
    int addSelectedSegment(geogebra.common.euclidian.Hits,int,boolean) -> e
    int addSelectedVector(geogebra.common.euclidian.Hits,int,boolean) -> f
    int addSelectedVector(geogebra.common.euclidian.Hits,int,boolean,geogebra.common.kernel.geos.Test) -> a
    int addSelectedPath(geogebra.common.euclidian.Hits,int,boolean) -> g
    int addSelectedRegion(geogebra.common.euclidian.Hits,int,boolean) -> h
    int addSelectedImplicitpoly(geogebra.common.euclidian.Hits,int,boolean) -> i
    int addSelectedPolygon(geogebra.common.euclidian.Hits,int,boolean) -> j
    int addSelectedPolyLine(geogebra.common.euclidian.Hits,int,boolean) -> k
    int addSelectedList(geogebra.common.euclidian.Hits,int,boolean) -> l
    int addSelectedDirection(geogebra.common.euclidian.Hits,int,boolean) -> m
    int addSelectedConic(geogebra.common.euclidian.Hits,int,boolean) -> n
    int addSelectedFunction(geogebra.common.euclidian.Hits,int,boolean) -> o
    int addSelectedCurve(geogebra.common.euclidian.Hits,int,boolean) -> p
    void createNewPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createNewPointIntersection(geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] join(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement[] join() -> b
    void updateMovedGeoPoint(geogebra.common.kernel.kernelND.GeoPointND) -> c
    geogebra.common.kernel.geos.GeoElement[] ray() -> c
    geogebra.common.kernel.geos.GeoElement[] segment(geogebra.common.euclidian.Hits) -> b
    geogebra.common.kernel.geos.GeoElement[] segment() -> d
    geogebra.common.kernel.geos.GeoElement[] vector(geogebra.common.euclidian.Hits) -> c
    geogebra.common.kernel.geos.GeoElement vector(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] ray(geogebra.common.euclidian.Hits) -> d
    geogebra.common.kernel.geos.GeoElement[] polygon(geogebra.common.euclidian.Hits) -> e
    geogebra.common.kernel.geos.GeoElement[] polyline(geogebra.common.euclidian.Hits) -> f
    geogebra.common.kernel.geos.GeoElement[] polygon() -> e
    geogebra.common.kernel.geos.GeoElement[] intersect(geogebra.common.euclidian.Hits) -> g
    geogebra.common.kernel.geos.GeoElement[] parallel(geogebra.common.euclidian.Hits) -> h
    geogebra.common.kernel.geos.GeoElement[] parabola(geogebra.common.euclidian.Hits) -> i
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.euclidian.Hits) -> j
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.euclidian.Hits,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.geos.GeoElement[] orthogonal2D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.geos.GeoElement[] midpoint(geogebra.common.euclidian.Hits) -> k
    boolean functionInspector(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement[] lineBisector(geogebra.common.euclidian.Hits) -> l
    geogebra.common.kernel.geos.GeoElement[] angularBisector(geogebra.common.euclidian.Hits) -> m
    geogebra.common.kernel.geos.GeoElement[] threePoints(geogebra.common.euclidian.Hits,int) -> a
    geogebra.common.kernel.geos.GeoElement[] switchModeForThreePoints(int) -> a
    boolean relation(geogebra.common.euclidian.Hits) -> b
    geogebra.common.kernel.geos.GeoElement[] locus(geogebra.common.euclidian.Hits) -> n
    geogebra.common.kernel.geos.GeoElement[] conic5(geogebra.common.euclidian.Hits) -> o
    geogebra.common.kernel.geos.GeoElement[] slope(geogebra.common.euclidian.Hits) -> p
    geogebra.common.kernel.geos.GeoElement[] tangents(geogebra.common.euclidian.Hits) -> q
    boolean delete(geogebra.common.euclidian.Hits) -> c
    geogebra.common.kernel.geos.GeoElement[] polarLine(geogebra.common.euclidian.Hits) -> r
    boolean showHideLabel(geogebra.common.euclidian.Hits) -> d
    boolean copyVisualStyle(geogebra.common.euclidian.Hits) -> e
    void textfieldHasFocus(boolean) -> b
    void initToolTipManager() -> f
    void initShowMouseCoords() -> g
    void wrapMouseEntered() -> h
    boolean move(geogebra.common.euclidian.Hits) -> f
    boolean moveRotate(geogebra.common.euclidian.Hits) -> g
    boolean point(geogebra.common.euclidian.Hits) -> h
    boolean geoElementSelected(geogebra.common.euclidian.Hits,boolean) -> a
    boolean segmentFixed(geogebra.common.euclidian.Hits) -> i
    geogebra.common.kernel.geos.GeoElement[] angleFixed(geogebra.common.euclidian.Hits) -> s
    geogebra.common.kernel.geos.GeoElement[] createCircle2ForPoints3D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] createCircle2(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] switchModeForCircleOrSphere2(int) -> b
    geogebra.common.kernel.geos.GeoElement[] circleOrSphere2(geogebra.common.euclidian.Hits,int) -> b
    boolean showHideObject(geogebra.common.euclidian.Hits) -> j
    boolean text(geogebra.common.euclidian.Hits) -> k
    boolean isAltDown() -> e
    void setAltDown(boolean) -> c
    boolean slider() -> f
    boolean image(geogebra.common.euclidian.Hits) -> l
    geogebra.common.kernel.geos.GeoElement[] mirrorAtPoint(geogebra.common.euclidian.Hits) -> t
    java.lang.String getSliderValue() -> a
    geogebra.common.kernel.geos.GeoElement[] mirrorAtLine(geogebra.common.euclidian.Hits) -> u
    geogebra.common.kernel.geos.GeoElement[] mirrorAtCircle(geogebra.common.euclidian.Hits) -> v
    boolean refreshHighlighting(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> a
    void clearSelections() -> i
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Path) -> a
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Region) -> a
    boolean detach(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean attachDetach(geogebra.common.euclidian.Hits) -> m
    geogebra.common.kernel.geos.GeoElement[] translate(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.geos.GeoElement[] translateByVector(geogebra.common.euclidian.Hits) -> w
    geogebra.common.kernel.geos.GeoElement[] rotateByAngle(geogebra.common.euclidian.Hits) -> x
    geogebra.common.kernel.geos.GeoElement[] dilateFromPoint(geogebra.common.euclidian.Hits) -> y
    geogebra.common.kernel.geos.GeoElement[] fitLine(geogebra.common.euclidian.Hits) -> z
    geogebra.common.kernel.geos.GeoElement[] createList(geogebra.common.euclidian.Hits) -> A
    void calcRWcoords() -> j
    void setMouseLocation(geogebra.common.euclidian.event.AbstractEvent) -> a
    void transformCoords() -> k
    double getTransformCoordsOffset(int) -> a
    geogebra.common.kernel.geos.GeoAngle createAngle(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoAngle createLineAngle(geogebra.common.kernel.geos.GeoLine[]) -> a
    java.lang.String removeUnderscores(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoText createDynamicText(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Point) -> a
    geogebra.common.kernel.geos.GeoText createDistanceText(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement[] area(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> a
    java.lang.String descriptionPoints(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> a
    boolean regularPolygon(geogebra.common.euclidian.Hits) -> n
    geogebra.common.kernel.geos.GeoElement[] angle(geogebra.common.euclidian.Hits) -> B
    geogebra.common.kernel.geos.GeoElement[] distance(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean showCheckBox() -> g
    geogebra.common.kernel.geos.GeoElement[] compasses(geogebra.common.euclidian.Hits) -> C
    geogebra.common.kernel.geos.GeoElement[] vectorFromPoint(geogebra.common.euclidian.Hits) -> D
    boolean circlePointRadius(geogebra.common.euclidian.Hits) -> o
    geogebra.common.kernel.geos.GeoElement getMovedGeoPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND updateNewPoint(boolean,geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND getNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean) -> a
    boolean createNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean,boolean) -> a
    boolean createNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean) -> a
    boolean macro(geogebra.common.euclidian.Hits) -> p
    boolean button(boolean) -> a
    boolean switchModeForProcessMode(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> b
    void processModeLock(geogebra.common.kernel.Path) -> a
    void processModeLock(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void processModeLock() -> l
    boolean processMode(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> c
    void processReleaseForMovedGeoPoint(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean processRightReleaseFor3D() -> h
    void rotateObject(boolean) -> d
    void moveLabel() -> m
    void movePoint(boolean) -> e
    void movePointWithOffset(boolean) -> f
    void moveLine(boolean) -> g
    void moveVector(boolean) -> h
    void moveVectorStartPoint(boolean) -> i
    void moveText(boolean) -> j
    void moveTextAbsoluteLocation() -> n
    void moveImage(boolean) -> k
    void moveConic(boolean) -> l
    void moveImplicitPoly(boolean) -> m
    void moveFunction(boolean) -> n
    void moveBoolean(boolean) -> o
    void moveButton(boolean) -> p
    double getSliderValue(geogebra.common.kernel.geos.GeoNumeric) -> a
    void moveNumeric(boolean) -> q
    void moveSlider(boolean) -> r
    void moveDependent(boolean) -> s
    java.util.ArrayList removeParentsOfView(java.util.ArrayList) -> a
    void moveMultipleObjects(boolean) -> t
    void setMovedGeoPoint(geogebra.common.kernel.geos.GeoElement) -> b
    void switchModeForRemovePolygons(geogebra.common.euclidian.Hits) -> a
    boolean switchModeForMouseReleased(int,geogebra.common.euclidian.Hits,boolean) -> a
    geogebra.common.euclidian.Hits addPointCreatedForMouseReleased(geogebra.common.euclidian.Hits) -> b
    boolean moveMode(int) -> a
    boolean hitResetIcon() -> i
    void processMouseMoved(geogebra.common.euclidian.event.AbstractEvent) -> c
    void wrapMouseMoved(geogebra.common.euclidian.event.AbstractEvent) -> d
    void resetToolTipManager() -> o
    void wrapMouseExited(geogebra.common.euclidian.event.AbstractEvent) -> e
    void handleSelectClick(java.util.ArrayList,boolean) -> b
    void mouseClickedMode(geogebra.common.euclidian.event.AbstractEvent,int) -> a
    void wrapMouseclicked(geogebra.common.euclidian.event.AbstractEvent) -> f
    void resetMovedGeoPoint() -> p
    void setStartPointLocation() -> q
    void setStartPointLocationWithOrigin(double,double) -> a
    void handleMovedElement(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    boolean isCheckboxFixed(geogebra.common.kernel.geos.GeoBoolean) -> a
    void updateSelectionRectangle(boolean) -> u
    void handleMouseDragged(boolean) -> v
    boolean viewHasHitsForMouseDragged() -> j
    boolean processRotate3DView() -> k
    boolean allowSelectionRectangle() -> l
    void handleMousePressedForMoveMode(geogebra.common.euclidian.event.AbstractEvent,boolean) -> a
    void wrapMouseDragged(geogebra.common.euclidian.event.AbstractEvent) -> g
    boolean handleMousePressedForViewButtons() -> m
    void processRightPressFor3D() -> r
    void createNewPointForModePoint(geogebra.common.euclidian.Hits,boolean) -> a
    void createNewPointForModeOther(geogebra.common.euclidian.Hits) -> b
    void handleMousePressedForRotateMode() -> s
    void mousePressedTranslatedView() -> t
    void switchModeForMousePressed(geogebra.common.euclidian.event.AbstractEvent) -> h
    void wrapMousePressed(geogebra.common.euclidian.event.AbstractEvent) -> i
    boolean processZoomRectangle() -> n
    void processSelectionRectangleForTransformations(geogebra.common.euclidian.Hits,geogebra.common.kernel.geos.Test) -> a
    void processSelectionRectangle(geogebra.common.euclidian.event.AbstractEvent) -> j
    void processSelection() -> u
    void showDrawingPadPopup(geogebra.common.awt.Point) -> a
    void wrapMouseReleased(geogebra.common.euclidian.event.AbstractEvent) -> k
    void wrapMouseWheelMoved(geogebra.common.euclidian.event.AbstractEvent) -> l
    geogebra.common.kernel.geos.GeoElement getRecordObject() -> b
    void setLineEndPoint(geogebra.common.awt.Point2D) -> a
    void setLineEndPoint(geogebra.common.awt.Point2D$Double) -> a
    geogebra.common.euclidian.Previewable switchPreviewableForInitNewMode(int) -> a
    boolean noZoomNeeded(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoImage) -> a
    void initNewMode(int) -> b
    void setMode(int) -> c
    geogebra.common.euclidian.EuclidianPen getPen() -> a
    void zoomInOut(boolean,boolean) -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    void showPopupMenuChooseGeo(java.util.ArrayList,geogebra.common.euclidian.Hits) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.euclidian.AbstractEuclidianView -> geogebra.common.c.b:
    boolean hasMouse -> a
    int EVNO_GENERAL -> a
    int evNo -> b
    double xZeroOld -> b
    double yZeroOld -> c
    int mode -> e
    int SCREEN_BORDER -> c
    geogebra.common.awt.BufferedImage bgImage -> a
    geogebra.common.awt.Graphics2D bgGraphics -> a
    geogebra.common.awt.Color colZoomRectangle -> a
    geogebra.common.awt.Color colZoomRectangleFill -> b
    geogebra.common.awt.Color axesColor -> c
    geogebra.common.awt.Color gridColor -> d
    geogebra.common.awt.Rectangle selectionRectangle -> a
    geogebra.common.awt.BasicStroke defAxesStroke -> a
    geogebra.common.awt.BasicStroke boldAxesStroke -> b
    geogebra.common.awt.BasicStroke axesStroke -> c
    geogebra.common.awt.BasicStroke tickStroke -> d
    geogebra.common.awt.BasicStroke gridStroke -> e
    geogebra.common.kernel.Kernel kernel -> a
    int fontSize -> f
    geogebra.common.awt.AffineTransform coordTransform -> a
    double[] AxesTickInterval -> a
    geogebra.common.util.NumberFormatAdapter[] axesNumberFormat -> a
    boolean[] showAxes -> a
    boolean automaticGridDistance -> f
    double[] gridDistances -> b
    int gridLineStyle -> g
    int axesLineType -> h
    boolean gridIsBold -> g
    int tooltipsInThisView -> d
    int gridType -> i
    geogebra.common.awt.Font fontPoint -> a
    geogebra.common.awt.Font fontLine -> b
    geogebra.common.awt.Font fontVector -> c
    geogebra.common.awt.Font fontConic -> d
    geogebra.common.awt.Font fontCoords -> e
    geogebra.common.awt.Font fontAxes -> f
    geogebra.common.awt.Font fontAngle -> g
    geogebra.common.util.NumberFormatAdapter printScaleNF -> a
    boolean showGrid -> b
    boolean antiAliasing -> c
    boolean showMouseCoords -> h
    boolean allowShowMouseCoords -> i
    boolean showAxesRatio -> j
    boolean highlightAnimationButtons -> d
    int pointCapturingMode -> j
    boolean showAxesCornerCoords -> k
    boolean[] showAxesNumbers -> b
    java.lang.String[] axesLabels -> a
    java.lang.String[] axesUnitLabels -> b
    geogebra.common.euclidian.Previewable previewDrawable -> a
    boolean firstPaint -> e
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.main.settings.EuclidianSettings settings -> a
    geogebra.common.euclidian.AbstractEuclidianController euclidianController -> a
    geogebra.common.euclidian.Hits hits -> a
    geogebra.common.kernel.arithmetic.NumberValue xminObject -> a
    geogebra.common.kernel.arithmetic.NumberValue xmaxObject -> b
    geogebra.common.kernel.arithmetic.NumberValue yminObject -> c
    geogebra.common.kernel.arithmetic.NumberValue ymaxObject -> d
    boolean updatingBounds -> l
    java.lang.Double lockedAxesRatio -> a
    double xmin -> d
    double xmax -> e
    double ymin -> f
    double ymax -> g
    double invXscale -> h
    double invYscale -> i
    double xZero -> j
    double yZero -> k
    double xscale -> l
    double yscale -> m
    double printingScale -> a
    java.util.HashMap DrawableMap -> a
    java.util.ArrayList stickyPointList -> a
    geogebra.common.euclidian.DrawableList allDrawableList -> a
    geogebra.common.euclidian.DrawableList[] drawLayers -> a
    geogebra.common.euclidian.DrawableList bgImageList -> b
    boolean[] piAxisUnit -> c
    int[] axesTickStyles -> a
    boolean[] automaticAxesNumberingDistances -> d
    double[] axesNumberingDistances -> c
    double[] axisCross -> d
    boolean[] positiveAxes -> e
    boolean[] drawBorderAxes -> f
    boolean reIniting -> m
    geogebra.common.awt.Ellipse2DDouble circle -> a
    geogebra.common.awt.Line2D tempLine -> a
    geogebra.common.euclidian.EuclidianStyleBar styleBar -> a
    boolean moveAxesLabels -> n
    int widthTemp -> k
    int heightTemp -> l
    double xminTemp -> n
    double xmaxTemp -> o
    double yminTemp -> p
    double ymaxTemp -> q
    geogebra.common.euclidian.Hits tempArrayList -> b
    geogebra.common.euclidian.AbstractZoomer zoomer -> a
    geogebra.common.euclidian.AbstractZoomer axesRatioZoomer -> b
    geogebra.common.euclidian.AbstractZoomer mover -> c
    geogebra.common.euclidian.AbstractZoomer zoomerRW -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> b
    java.lang.Integer[] getLineTypes() -> a
    java.lang.Integer[] getPointStyles() -> b
    void setAxesColor(geogebra.common.awt.Color) -> a
    void setStandardCoordSystem(boolean) -> n
    void attachView() -> a
    int getPointCapturingMode() -> a
    void setPointCapturing(int) -> b
    void setCapturingThreshold(int) -> c
    int getCapturingThreshold() -> c
    int getMode() -> d
    void setMode(int) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean clearRectangle(int) -> d
    geogebra.common.kernel.geos.GeoNumeric getXminObject() -> a
    void updateBoundObjects() -> e
    boolean isLockedAxesRatio() -> a
    void setLockedAxesRatio(java.lang.Double) -> a
    void updateBounds() -> f
    boolean isZoomable() -> b
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric getXmaxObject() -> b
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric getYminObject() -> c
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setSizeListeners() -> F
    int toScreenCoordX(double) -> a
    int toScreenCoordY(double) -> b
    double toScreenCoordXd(double) -> a
    double toScreenCoordYd(double) -> b
    int toClippedScreenCoordX(double) -> c
    void rememberOrigins() -> g
    int toClippedScreenCoordY(double) -> d
    boolean toScreenCoords(double[]) -> a
    boolean isOnScreen(double[]) -> b
    double toRealWorldCoordX(double) -> c
    double toRealWorldCoordY(double) -> d
    void setCoordSystem(double,double,double,double) -> a
    void setCoordSystemFromMouseMove(int,int,int) -> a
    void setRealWorldCoordSystem(double,double,double,double) -> b
    void setCoordSystem(double,double,double,double,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric getYmaxObject() -> d
    void setAntialiasing(boolean) -> a
    int getEuclidianViewNo() -> e
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void setXscale(double) -> c
    void setYscale(double) -> d
    void setFontSize(int) -> d
    double getxZero() -> a
    double getyZero() -> b
    double getXZero() -> c
    double getYZero() -> d
    java.lang.String getXYscaleRatioString() -> a
    double getXscale() -> e
    double getYscale() -> f
    double getInvXscale() -> g
    double getInvYscale() -> h
    int getViewWidth() -> f
    int getViewHeight() -> g
    double getScaleRatio() -> i
    double getXmax() -> j
    double getXmin() -> k
    double getYmax() -> l
    double getYmin() -> m
    int getGridType() -> h
    void setGridType(int) -> e
    void setXYMinMax(double[][]) -> a
    void setRealWorldBounds() -> h
    void zoomAroundCenter(double) -> a
    void updateAllDrawables(boolean) -> b
    void calcPrintingScale() -> i
    void setAxesIntervals(double,int) -> a
    int getFontSize() -> i
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.euclidian.Hits getHits() -> a
    void setHits(geogebra.common.awt.Point) -> a
    geogebra.common.euclidian.MyButton getHitButton(geogebra.common.awt.Point) -> a
    geogebra.common.kernel.geos.GeoElement getLabelHit(geogebra.common.awt.Point) -> a
    geogebra.common.euclidian.DrawableND getDrawable(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.euclidian.DrawableND getDrawableND(geogebra.common.kernel.geos.GeoElement) -> b
    void addToDrawableLists(geogebra.common.euclidian.Drawable) -> a
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.euclidian.DrawableND createDrawable(geogebra.common.kernel.geos.GeoElement) -> d
    void reset() -> d
    void resetMode() -> j
    void repaintView() -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.euclidian.DrawableND getDrawableFor(geogebra.common.kernel.geos.GeoElement) -> e
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void updateDrawableFontSize() -> k
    geogebra.common.awt.Font getFontPoint() -> a
    void setFontPoint(geogebra.common.awt.Font) -> a
    geogebra.common.awt.Font getFontLine() -> b
    void setFontLine(geogebra.common.awt.Font) -> b
    geogebra.common.awt.Font getFontVector() -> c
    void setFontVector(geogebra.common.awt.Font) -> c
    geogebra.common.awt.Font getFontConic() -> d
    void setFontConic(geogebra.common.awt.Font) -> d
    geogebra.common.awt.Font getFontCoords() -> e
    void setFontCoords(geogebra.common.awt.Font) -> e
    geogebra.common.awt.Font getFontAxes() -> f
    void setFontAxes(geogebra.common.awt.Font) -> f
    geogebra.common.awt.Font getFontAngle() -> g
    void setFontAngle(geogebra.common.awt.Font) -> g
    java.util.ArrayList getStickyPointList() -> a
    void setBooleanSize(int) -> f
    int getBooleanSize() -> j
    void setAllowToolTips(int) -> g
    int getAllowToolTips() -> k
    geogebra.common.kernel.Matrix.Coords getCoordsForView(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix getMatrix() -> a
    geogebra.common.kernel.Matrix.CoordMatrix getInverseMatrix() -> b
    geogebra.common.awt.AffineTransform getTransform(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords[]) -> a
    java.lang.String getFromPlaneString() -> b
    java.lang.String getTranslatedFromPlaneString() -> c
    boolean isDefault2D() -> c
    int getViewID() -> b
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND getPlaneContaining() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND getDirection() -> a
    void updateForPlane() -> l
    boolean hasForParent(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> c
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    void replaceBoundObject(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    void setRightAngleStyle(int) -> h
    int getRightAngleStyle() -> l
    boolean isAutomaticGridDistance() -> d
    double[] getGridDistances() -> a
    void setGridDistances(double[]) -> a
    int getGridLineStyle() -> m
    void setAutomaticGridDistance(boolean) -> c
    int getAxesLineStyle() -> n
    void setAxesLineStyle(int) -> i
    geogebra.common.awt.AffineTransform getCoordTransform() -> a
    void updateBackground() -> m
    geogebra.common.awt.Graphics2D getTempGraphics2D(geogebra.common.awt.Font) -> a
    geogebra.common.awt.Font getFont() -> h
    void setHeight(int) -> j
    void setWidth(int) -> k
    void initCursor() -> n
    void setStyleBarMode(int) -> l
    geogebra.common.euclidian.DrawableND newDrawable(geogebra.common.kernel.geos.GeoElement) -> f
    boolean usesSelectionAsInput(int) -> a
    boolean usesSelectionRectangleAsInput(int) -> b
    void setSelectionRectangle(geogebra.common.awt.Rectangle) -> a
    double[] getAxesCross() -> b
    void setAxesCross(double[]) -> b
    void setAxisCross(int,double) -> a
    boolean[] getPositiveAxes() -> a
    void setPositiveAxes(boolean[]) -> a
    void setPositiveAxis(int,boolean) -> a
    boolean[] getDrawBorderAxes() -> b
    void setDrawBorderAxes(boolean[]) -> b
    void setAxesCornerCoordsVisible(boolean) -> d
    double getPrintingScale() -> n
    void setPrintingScale(double) -> b
    java.lang.String[] getAxesLabels() -> a
    void setAxesLabels(java.lang.String[]) -> a
    void setAxisLabel(int,java.lang.String) -> a
    void setAutomaticAxesNumberingDistance(boolean,int) -> a
    boolean[] isAutomaticAxesNumberingDistance() -> c
    double[] getAxesNumberingDistances() -> c
    void setAxesNumberingDistance(double,int) -> b
    boolean getGridIsBold() -> e
    boolean[] getShowAxesNumbers() -> d
    void setShowAxesNumbers(boolean[]) -> c
    void setShowAxisNumbers(int,boolean) -> b
    java.lang.String[] getAxesUnitLabels() -> b
    void setAxesUnitLabels(java.lang.String[]) -> b
    int[] getAxesTickStyles() -> a
    void setAxisTickStyle(int,int) -> a
    void setAxesTickStyles(int[]) -> a
    void setShowMouseCoords(boolean) -> e
    boolean getAllowShowMouseCoords() -> f
    void setAllowShowMouseCoords(boolean) -> f
    boolean getShowMouseCoords() -> g
    void setShowAxesRatio(boolean) -> g
    geogebra.common.euclidian.Previewable getPreviewDrawable() -> a
    double getGridDistances(int) -> a
    boolean getShowGrid() -> h
    boolean isGridOrAxesShown() -> i
    boolean getShowAxis(int) -> c
    boolean getShowXaxis() -> j
    boolean getShowYaxis() -> k
    geogebra.common.euclidian.Previewable createPreviewLine(java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPerpendicularBisector(java.util.ArrayList) -> b
    geogebra.common.euclidian.Previewable createPreviewAngleBisector(java.util.ArrayList) -> c
    geogebra.common.euclidian.Previewable createPreviewSegment(java.util.ArrayList) -> d
    geogebra.common.euclidian.Previewable createPreviewRay(java.util.ArrayList) -> e
    geogebra.common.euclidian.Previewable createPreviewVector(java.util.ArrayList) -> f
    geogebra.common.euclidian.Previewable createPreviewConic(int,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPolygon(java.util.ArrayList) -> g
    geogebra.common.euclidian.Previewable createPreviewAngle(java.util.ArrayList) -> h
    geogebra.common.euclidian.Previewable createPreviewPolyLine(java.util.ArrayList) -> i
    void updatePreviewable() -> o
    void mouseEntered() -> p
    void mouseExited() -> q
    boolean hasMouse() -> l
    geogebra.common.euclidian.Previewable createPreviewParallelLine(java.util.ArrayList,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPerpendicularLine(java.util.ArrayList,java.util.ArrayList) -> b
    void setApplication(geogebra.common.main.AbstractApplication) -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    void updateFonts() -> r
    void updateSize() -> s
    boolean requestFocusInWindow() -> m
    void drawGeometricObjects(geogebra.common.awt.Graphics2D) -> a
    void drawObjects(geogebra.common.awt.Graphics2D) -> b
    void clearBackground(geogebra.common.awt.Graphics2D) -> c
    void drawBackgroundWithImages(geogebra.common.awt.Graphics2D,boolean) -> a
    void drawAxesRatio(geogebra.common.awt.Graphics2D) -> d
    boolean drawSliderValue(geogebra.common.awt.Graphics2D) -> a
    void paintBackground(geogebra.common.awt.Graphics2D) -> e
    void paint(geogebra.common.awt.Graphics2D) -> f
    void updateBackgroundImage() -> t
    void drawZoomRectangle(geogebra.common.awt.Graphics2D) -> g
    void drawMouseCoords(geogebra.common.awt.Graphics2D) -> h
    void drawBackgroundWithImages(geogebra.common.awt.Graphics2D) -> p
    void drawBackground(geogebra.common.awt.Graphics2D,boolean) -> b
    void drawGrid(geogebra.common.awt.Graphics2D) -> i
    double getLabelLength(double,geogebra.common.awt.FontRenderContext) -> a
    void drawAxes(geogebra.common.awt.Graphics2D) -> j
    boolean xAxisOnscreen() -> r
    boolean yAxisOnscreen() -> s
    void drawStringWithBackground(geogebra.common.awt.Graphics2D,java.lang.String,double,double,geogebra.common.awt.Color,geogebra.common.awt.font.TextLayout,int,int) -> a
    void drawResetIcon(geogebra.common.awt.Graphics2D) -> k
    void drawActionObjects(geogebra.common.awt.Graphics2D) -> l
    void setDefRenderingHints(geogebra.common.awt.Graphics2D) -> m
    void setAntialiasing(geogebra.common.awt.Graphics2D) -> n
    void drawAnimationButtons(geogebra.common.awt.Graphics2D) -> o
    void setBackground(geogebra.common.awt.Color) -> b
    void synchronizeMenuBarAndEuclidianStyleBar(geogebra.common.main.settings.EuclidianSettings) -> a
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    void showGrid(boolean) -> h
    void setGridIsBold(boolean) -> i
    void setGridColor(geogebra.common.awt.Color) -> c
    void setGridLineStyle(int) -> m
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    void setHits(geogebra.common.awt.Rectangle) -> b
    geogebra.common.awt.Rectangle getSelectionRectangle() -> a
    geogebra.common.euclidian.GeneralPathClipped getBoundingPath() -> a
    void addBackgroundImage(geogebra.common.euclidian.DrawImage) -> a
    void removeBackgroundImage(geogebra.common.euclidian.DrawImage) -> b
    void resetLists() -> u
    geogebra.common.awt.Rectangle getBounds() -> b
    void setPreview(geogebra.common.euclidian.Previewable) -> a
    void setTemporaryCoordSystemForExport() -> v
    geogebra.common.awt.Point getMaximumLabelSize(geogebra.common.awt.Graphics2D) -> a
    void restoreOldCoordSystem() -> w
    void setTemporarySize(int,int) -> b
    void setShowAxis(int,boolean,boolean) -> a
    void setShowAxes(boolean,boolean) -> a
    boolean isTracing() -> n
    boolean hasBackgroundImages() -> o
    geogebra.common.awt.Graphics2D getBackgroundGraphics() -> a
    void getXML(java.lang.StringBuilder,boolean) -> a
    void drawPoints(geogebra.common.kernel.geos.GeoImage,double[],double[]) -> a
    void resetXYMinMaxObjects() -> x
    void setViewShowAllObjects(boolean) -> j
    int getSelectedWidth() -> o
    int getSelectedHeight() -> p
    int getExportWidth() -> q
    int getExportHeight() -> r
    void clickedGeo(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.event.AbstractEvent) -> a
    geogebra.common.euclidian.AbstractZoomer newZoomer() -> a
    void zoom(double,double,double,int,boolean) -> a
    void zoomAxesRatio(double,boolean) -> a
    void setStandardView(boolean) -> k
    void setAnimatedCoordSystem(double,double,double,double,int,boolean) -> a
    void setAnimatedRealWorldCoordSystem(double,double,double,double,int,boolean) -> b
    void mouseMovedOver(geogebra.common.kernel.geos.GeoElement) -> g
    boolean setAnimationButtonsHighlighted(boolean) -> a
    boolean drawPlayButtonInThisView() -> p
    geogebra.common.awt.Color getAxesColor() -> a
    geogebra.common.awt.Color getGridColor() -> b
    void add(geogebra.common.javax.swing.Box) -> a
    void remove(geogebra.common.javax.swing.Box) -> b
    void initView(boolean) -> l
    void setShowAxis(boolean) -> m
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra.common.euclidian.AbstractZoomer -> geogebra.common.c.c:
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode mode -> a
    double px -> a
    double py -> b
    double factor -> c
    int counter -> a
    int steps -> b
    double oldScale -> d
    double newScale -> e
    double add -> f
    double dx -> g
    double dy -> h
    double x0 -> i
    double x1 -> j
    double y0 -> k
    double y1 -> l
    double xminOld -> m
    double yminOld -> n
    double ymaxOld -> o
    double xmaxOld -> p
    long startTime -> a
    boolean storeUndo -> a
    boolean setStandard -> b
    double standardX -> q
    double standardY -> r
    int[] $SWITCH_TABLE$geogebra$common$euclidian$AbstractZoomer$ZoomerMode -> a
    void init(double,boolean) -> a
    void init(double,double,double,int,boolean) -> a
    void initRW(double,double,double,double,int,boolean) -> a
    void init(double,double,boolean) -> a
    void step() -> a
    void stopAnimation() -> e
    void setStandardViewAfter(double,double) -> a
    void startAnimation() -> b
    void stopTimer() -> c
    void startTimer() -> d
    boolean hasTimer() -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$AbstractZoomer$ZoomerMode() -> a
geogebra.common.euclidian.AbstractZoomer$ZoomerMode -> geogebra.common.c.c$a:
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode ZOOM -> a
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode ZOOM_RW -> b
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode AXES -> c
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode MOVE -> d
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode[] ENUM$VALUES -> a
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode[] values() -> values
    geogebra.common.euclidian.AbstractZoomer$ZoomerMode valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.DrawAngle -> geogebra.common.c.d:
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.kernelND.GeoPointND vertex -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> b
    geogebra.common.kernel.kernelND.GeoPointND point2 -> c
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoLine line2 -> b
    geogebra.common.kernel.geos.GeoVector vector -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    boolean show90degrees -> d
    int angleDrawMode -> d
    geogebra.common.awt.Arc2D drawArc -> a
    geogebra.common.awt.GeneralPath polygon -> a
    geogebra.common.awt.Ellipse2DDouble dot90degree -> a
    geogebra.common.awt.Shape shape -> c
    double[] m -> a
    double[] coords -> b
    double[] firstVec -> c
    geogebra.common.kernel.geos.GeoPoint2 tempPoint -> a
    boolean drawDot -> e
    geogebra.common.kernel.geos.GeoPoint2[] previewTempPoints -> a
    geogebra.common.awt.Shape shapeArc1 -> d
    geogebra.common.awt.Shape shapeArc2 -> e
    geogebra.common.awt.Arc2D decoArc -> b
    geogebra.common.awt.Line2D[] tick -> a
    double[] angleTick -> d
    double MAX_TICK_DISTANCE -> a
    geogebra.common.awt.GeneralPath square -> b
    java.util.ArrayList prevPoints -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos -> a
    void init() -> g
    boolean inView(geogebra.common.kernel.Matrix.Coords) -> a
    double getRawAngle() -> a
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void updateTick(double,int,int) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void initPreview() -> h
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$Algos() -> a
geogebra.common.euclidian.DrawBoolean -> geogebra.common.c.e:
    geogebra.common.kernel.geos.GeoBoolean geoBool -> a
    boolean isVisible -> a
    java.lang.String oldCaption -> b
    geogebra.common.awt.Point textSize -> a
    geogebra.common.euclidian.DrawBoolean$CheckBoxIcon checkBoxIcon -> a
    void update() -> a
    void updateLabel() -> b
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawBoolean$CheckBoxIcon -> geogebra.common.c.e$a:
    geogebra.common.euclidian.AbstractEuclidianView ev -> a
    geogebra.common.awt.Color highlightBackground -> a
    void paintIcon(boolean,boolean,geogebra.common.awt.Graphics2D,int,int) -> a
geogebra.common.euclidian.DrawBoxPlot -> geogebra.common.c.f:
    boolean isVisible -> a
    boolean labelVisible -> c
    double[] coords -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.algos.AlgoBoxPlot algo -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    void init() -> b
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
geogebra.common.euclidian.DrawButton -> geogebra.common.c.g:
    geogebra.common.kernel.geos.GeoButton geoButton -> a
    boolean isVisible -> a
    java.lang.String oldCaption -> b
    geogebra.common.euclidian.MyButton myButton -> a
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void remove() -> b
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawConic -> geogebra.common.c.h:
    geogebra.common.kernel.kernelND.GeoConicND conic -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    int type -> d
    double[] labelCoords -> a
    boolean firstPoint -> d
    geogebra.common.kernel.geos.GeoPoint2 point -> a
    geogebra.common.euclidian.DrawPoint drawPoint -> a
    boolean firstLines -> e
    geogebra.common.kernel.geos.GeoLine[] lines -> a
    geogebra.common.euclidian.DrawLine[] drawLines -> a
    boolean firstCircle -> f
    geogebra.common.kernel.geos.GeoVec2D midpoint -> a
    geogebra.common.awt.Arc2D arc -> a
    geogebra.common.euclidian.GeneralPathClipped arcFiller -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> b
    geogebra.common.awt.RectangularShape circle -> a
    double mx -> a
    double my -> b
    double radius -> c
    double yradius -> d
    double angSt -> e
    double angEnd -> f
    geogebra.common.awt.AffineTransform transform -> a
    geogebra.common.awt.Shape shape -> c
    boolean firstEllipse -> g
    double[] halfAxes -> b
    geogebra.common.awt.Ellipse2DDouble ellipse -> a
    boolean firstParabola -> h
    double x0 -> g
    double y0 -> h
    double k2 -> i
    geogebra.common.kernel.geos.GeoVec2D vertex -> b
    geogebra.common.awt.GeneralPath parabola -> a
    double[] parpoints -> c
    boolean firstHyperbola -> i
    double a -> j
    double b -> k
    double tsq -> l
    double step -> m
    double t -> n
    double denom -> o
    double x -> p
    double y -> q
    int index0 -> e
    int index1 -> f
    int n -> g
    int points -> h
    geogebra.common.euclidian.GeneralPathClipped hypLeft -> c
    geogebra.common.euclidian.GeneralPathClipped hypRight -> d
    boolean hypLeftOnScreen -> j
    boolean hypRightOnScreen -> k
    java.util.ArrayList prevPoints -> a
    java.util.ArrayList prevSegments -> b
    java.util.ArrayList prevConics -> c
    geogebra.common.kernel.geos.GeoPoint2[] previewTempPoints -> a
    geogebra.common.kernel.geos.GeoNumeric previewTempRadius -> a
    int previewMode -> i
    int neededPrevPoints -> j
    boolean isPreview -> l
    geogebra.common.awt.Area getShape() -> a
    void initConic(geogebra.common.kernel.kernelND.GeoConicND) -> a
    void update() -> a
    void updateSinglePoint() -> g
    void updateLines() -> h
    boolean negativeColored() -> a
    geogebra.common.awt.Area lineToGpc(geogebra.common.euclidian.DrawLine) -> a
    void updateCircle() -> i
    void updateEllipse() -> j
    void updateHyperbola() -> k
    void updateParabola() -> l
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void initPreview() -> m
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    geogebra.common.kernel.kernelND.GeoConicND getConic() -> a
geogebra.common.euclidian.DrawConicPart -> geogebra.common.c.i:
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.awt.Arc2D arc -> a
    geogebra.common.awt.Shape shape -> c
    double[] halfAxes -> a
    int closure -> d
    int draw_type -> e
    geogebra.common.awt.AffineTransform transform -> a
    geogebra.common.euclidian.DrawRay drawRay1 -> a
    geogebra.common.euclidian.DrawRay drawRay2 -> b
    geogebra.common.euclidian.DrawSegment drawSegment -> a
    double[] coords -> b
    java.util.ArrayList prevPoints -> a
    geogebra.common.kernel.geos.GeoPoint2[] previewTempPoints -> a
    int previewMode -> f
    int neededPrevPoints -> g
    void initConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void update() -> a
    void updateEllipse() -> g
    void updateParallelLines() -> h
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void initPreview() -> i
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawEquationInterface -> geogebra.common.c.j:
    void setUseJavaFontsForLaTeX(geogebra.common.main.AbstractApplication,boolean) -> a
    geogebra.common.awt.Dimension drawEquation(geogebra.common.main.AbstractApplication,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.Font,boolean,geogebra.common.awt.Color,geogebra.common.awt.Color,boolean) -> a
geogebra.common.euclidian.DrawImage -> geogebra.common.c.k:
    geogebra.common.kernel.geos.GeoImage geoImage -> a
    boolean isVisible -> a
    geogebra.common.awt.BufferedImage image -> a
    boolean absoluteLocation -> c
    geogebra.common.awt.AlphaComposite alphaComp -> a
    float alpha -> a
    boolean isInBackground -> d
    geogebra.common.awt.AffineTransform at -> a
    geogebra.common.awt.AffineTransform atInverse -> b
    geogebra.common.awt.AffineTransform tempAT -> c
    boolean needsInterpolationRenderingHint -> e
    int screenX -> d
    int screenY -> e
    geogebra.common.awt.Rectangle boundingBox -> b
    geogebra.common.awt.GeneralPath highlighting -> a
    double[] hitCoords -> a
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawHighlighting(geogebra.common.awt.AffineTransform,geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawImplicitPoly -> geogebra.common.c.l:
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    geogebra.common.awt.Area getShape() -> a
geogebra.common.euclidian.DrawInequality -> geogebra.common.c.m:
    boolean isVisible -> c
    boolean labelVisible -> a
    geogebra.common.euclidian.Drawable drawable -> a
    geogebra.common.plugin.Operation operation -> a
    geogebra.common.euclidian.DrawInequality left -> a
    geogebra.common.euclidian.DrawInequality right -> b
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar function -> a
    geogebra.common.euclidian.GeneralPathClipped[] gpAxis -> a
    void update() -> a
    void updateRecursive(geogebra.common.kernel.arithmetic.IneqTree) -> a
    void createDrawable() -> b
    void updateShape() -> c
    void updateTrees(geogebra.common.kernel.arithmetic.IneqTree) -> b
    boolean matchBorder(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.Drawable) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit2(int,int) -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawInequality$DrawParametricInequality -> geogebra.common.c.m$a:
    geogebra.common.kernel.arithmetic.Inequality paramIneq -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.euclidian.DrawInequality this$0 -> a
    geogebra.common.awt.Area getShape() -> a
    geogebra.common.kernel.geos.GeoElement getBorder() -> b
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
    boolean isXparametric() -> a
geogebra.common.euclidian.DrawInequality1Var -> geogebra.common.c.n:
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.euclidian.GeneralPathClipped[] gp -> a
    geogebra.common.awt.Ellipse2DDouble[] circle -> a
    boolean varIsY -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> a
geogebra.common.euclidian.DrawIntegral -> geogebra.common.c.o:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    void init() -> b
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawIntegralFunctions -> geogebra.common.c.p:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    void init() -> b
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawLine -> geogebra.common.c.q:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.awt.Line2D line -> a
    double y1 -> a
    double y2 -> b
    double x1 -> c
    double x2 -> d
    double k -> e
    double d -> f
    double gx -> g
    double gy -> h
    double gz -> i
    int labelPos -> d
    int p1Pos -> e
    int p2Pos -> f
    int x -> g
    int y -> h
    boolean isVisible -> a
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    java.util.ArrayList lines -> b
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    geogebra.common.kernel.kernelND.GeoPointND previewPoint2 -> b
    boolean[] attr1 -> a
    boolean[] attr2 -> b
    geogebra.common.euclidian.DrawLine$PreviewType previewMode -> a
    geogebra.common.awt.Point2D endPoint -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$DrawLine$PreviewType -> a
    void update() -> a
    void setClippedLine() -> g
    void clipTopBottom() -> h
    void clipLeftRight() -> i
    void setLabelPosition() -> j
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    int[] $SWITCH_TABLE$geogebra$common$euclidian$DrawLine$PreviewType() -> a
geogebra.common.euclidian.DrawLine$PreviewType -> geogebra.common.c.q$a:
    geogebra.common.euclidian.DrawLine$PreviewType NONE -> a
    geogebra.common.euclidian.DrawLine$PreviewType LINE -> b
    geogebra.common.euclidian.DrawLine$PreviewType PARALLEL -> c
    geogebra.common.euclidian.DrawLine$PreviewType PERPENDICULAR -> d
    geogebra.common.euclidian.DrawLine$PreviewType PERPENDICULAR_BISECTOR -> e
    geogebra.common.euclidian.DrawLine$PreviewType ANGLE_BISECTOR -> f
    geogebra.common.euclidian.DrawLine$PreviewType[] ENUM$VALUES -> a
    geogebra.common.euclidian.DrawLine$PreviewType[] values() -> values
    geogebra.common.euclidian.DrawLine$PreviewType valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.DrawList -> geogebra.common.c.r:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.euclidian.DrawListArray drawables -> a
    boolean isVisible -> a
    void update() -> a
    void remove() -> b
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawListArray -> geogebra.common.c.s:
    geogebra.common.euclidian.EuclidianViewInterfaceSlim view -> a
    boolean addToDrawableList(geogebra.common.kernel.geos.GeoElement,int,int,geogebra.common.euclidian.DrawableND) -> a
    void update(geogebra.common.euclidian.DrawableND) -> a
    geogebra.common.euclidian.DrawableND getDrawable(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawLocus -> geogebra.common.c.t:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] lastPointCoords -> a
    void update() -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void buildGeneralPath(java.util.ArrayList) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawParametricCurve -> geogebra.common.c.u:
    double MAX_BEND -> a
    double MAX_BEND_OFF_SCREEN -> b
    geogebra.common.kernel.geos.ParametricCurve curve -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    boolean fillCurve -> d
    int countPoints -> d
    long countEvaluations -> a
    java.lang.StringBuilder labelSB -> a
    void update() -> a
    geogebra.common.awt.Point plotCurve(geogebra.common.kernel.geos.ParametricCurve,double,double,geogebra.common.euclidian.AbstractEuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.DrawParametricCurve$Gap) -> a
    boolean isUndefined(double) -> a
    boolean isUndefined(double[]) -> a
    geogebra.common.awt.Point plotInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,int,double,geogebra.common.euclidian.AbstractEuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.DrawParametricCurve$Gap) -> a
    boolean isContinuous(geogebra.common.kernel.geos.ParametricCurve,double,double,int) -> a
    boolean isDefinedAround(geogebra.common.kernel.geos.ParametricCurve,double,double) -> a
    boolean isDistanceOK(double,double) -> a
    boolean isSegmentOffScreen(geogebra.common.euclidian.AbstractEuclidianView,double,double,double,double) -> a
    boolean isAngleOK(double,double,double,double,double) -> a
    geogebra.common.awt.Point plotProblemInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,int,double,geogebra.common.euclidian.AbstractEuclidianView,geogebra.common.euclidian.GeneralPathClipped,boolean,geogebra.common.euclidian.DrawParametricCurve$Gap,geogebra.common.awt.Point) -> a
    boolean getDefinedInterval(geogebra.common.kernel.geos.ParametricCurve,double,double,double[]) -> a
    void moveTo(geogebra.common.euclidian.GeneralPathClipped,double,double) -> a
    void lineTo(geogebra.common.euclidian.GeneralPathClipped,double,double) -> b
    void drawTo(geogebra.common.euclidian.GeneralPathClipped,double,double,boolean) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    boolean filling(geogebra.common.kernel.geos.ParametricCurve) -> a
geogebra.common.euclidian.DrawParametricCurve$Gap -> geogebra.common.c.u$a:
    geogebra.common.euclidian.DrawParametricCurve$Gap LINE_TO -> a
    geogebra.common.euclidian.DrawParametricCurve$Gap MOVE_TO -> b
    geogebra.common.euclidian.DrawParametricCurve$Gap RESET_XMIN -> c
    geogebra.common.euclidian.DrawParametricCurve$Gap RESET_YMIN -> d
    geogebra.common.euclidian.DrawParametricCurve$Gap RESET_XMAX -> e
    geogebra.common.euclidian.DrawParametricCurve$Gap RESET_YMAX -> f
    geogebra.common.euclidian.DrawParametricCurve$Gap[] ENUM$VALUES -> a
    geogebra.common.euclidian.DrawParametricCurve$Gap[] values() -> values
    geogebra.common.euclidian.DrawParametricCurve$Gap valueOf(java.lang.String) -> valueOf
geogebra.common.euclidian.DrawPoint -> geogebra.common.c.v:
    int HIGHLIGHT_OFFSET -> d
    int SELECTION_OFFSET -> e
    int SELECTION_DIAMETER_MIN -> f
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    int diameter -> g
    int hightlightDiameter -> h
    int selDiameter -> i
    int pointSize -> j
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.awt.Ellipse2DDouble circle -> a
    geogebra.common.awt.Ellipse2DDouble circleHighlight -> b
    geogebra.common.awt.Ellipse2DDouble circleSel -> c
    geogebra.common.awt.Line2D line1 -> a
    geogebra.common.awt.Line2D line2 -> b
    geogebra.common.awt.Line2D line3 -> c
    geogebra.common.awt.Line2D line4 -> d
    geogebra.common.awt.GeneralPath gp -> a
    geogebra.common.awt.BasicStroke borderStroke -> d
    geogebra.common.awt.BasicStroke[] fillStrokes -> a
    geogebra.common.awt.BasicStroke[] emptyStrokes -> b
    boolean isPreview -> d
    geogebra.common.euclidian.Drawable drawable -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void update() -> a
    void drawClippedSection(geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.BasicStroke getEmptyStroke(int) -> a
    geogebra.common.awt.BasicStroke getFillStroke(int) -> b
    int getSelectionDiamaterMin() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.euclidian.DrawPolyLine -> geogebra.common.c.w:
    geogebra.common.kernel.geos.GeoPolyLine poly -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    java.util.ArrayList points -> a
    geogebra.common.awt.Point2D endPoint -> a
    void update() -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void addPointsToPath(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawPolygon -> geogebra.common.c.x:
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    java.util.ArrayList points -> a
    geogebra.common.awt.Point2D endPoint -> a
    void update() -> a
    boolean addPointsToPath(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawRay -> geogebra.common.c.y:
    geogebra.common.kernel.kernelND.GeoLineND ray -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    geogebra.common.awt.Line2D line -> a
    double[] a -> a
    double[] v -> b
    geogebra.common.awt.Point2D endPoint -> a
    void update() -> a
    void update(boolean) -> a
    void setClippedLine() -> g
    void draw(geogebra.common.awt.Graphics2D) -> a
    void setStroke(geogebra.common.awt.BasicStroke) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.euclidian.DrawSegment -> geogebra.common.c.z:
    geogebra.common.kernel.kernelND.GeoLineND s -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    java.util.ArrayList points -> a
    geogebra.common.awt.Line2D line -> a
    double[] coordsA -> a
    double[] coordsB -> b
    geogebra.common.awt.Line2D[] decoTicks -> a
    geogebra.common.awt.Point2D endPoint -> a
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawSlider -> geogebra.common.c.A:
    geogebra.common.kernel.geos.GeoNumeric number -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    double[] coordsRW -> a
    double[] coordsScreen -> b
    geogebra.common.awt.Line2D line -> a
    geogebra.common.kernel.geos.GeoPoint2 geoPoint -> a
    geogebra.common.euclidian.DrawPoint drawPoint -> a
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitPoint(int,int) -> c
    boolean hitLabel(int,int) -> b
    boolean hitSlider(int,int) -> d
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawSlope -> geogebra.common.c.B:
    geogebra.common.kernel.geos.GeoNumeric slope -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    int xLabelHor -> d
    int yLabelHor -> e
    java.lang.String horLabel -> b
    double[] coords -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    geogebra.common.kernel.Kernel kernel -> a
    void init() -> b
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawText -> geogebra.common.c.C:
    geogebra.common.kernel.geos.GeoText text -> a
    boolean isVisible -> a
    boolean isLaTeX -> c
    int fontSize -> d
    int fontStyle -> e
    boolean serifFont -> d
    geogebra.common.awt.Font textFont -> a
    geogebra.common.kernel.kernelND.GeoPointND loc -> a
    int oldXpos -> f
    int oldYpos -> g
    boolean needsBoundingBoxOld -> e
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean doUpdateFontSize() -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawTextField -> geogebra.common.c.D:
    geogebra.common.kernel.geos.GeoTextField geoTextField -> a
    boolean isVisible -> a
    java.lang.String oldCaption -> b
    geogebra.common.gui.inputfield.AutoCompleteTextField textField -> a
    geogebra.common.javax.swing.JLabel label -> a
    geogebra.common.euclidian.DrawTextField$InputFieldListener ifListener -> a
    geogebra.common.euclidian.DrawTextField$InputFieldKeyListener ifKeyListener -> a
    geogebra.common.javax.swing.Box box -> a
    int oldLength -> d
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void remove() -> b
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    boolean hitLabel(int,int) -> b
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void setFocus(java.lang.String) -> a
geogebra.common.euclidian.DrawTextField$InputFieldKeyListener -> geogebra.common.c.D$a:
    geogebra.common.euclidian.DrawTextField this$0 -> a
    void keyReleased(geogebra.common.euclidian.event.KeyEvent) -> a
geogebra.common.euclidian.DrawTextField$InputFieldListener -> geogebra.common.c.D$b:
    geogebra.common.euclidian.DrawTextField this$0 -> a
    void focusGained(geogebra.common.euclidian.event.FocusEvent) -> a
    void focusLost(geogebra.common.euclidian.event.FocusEvent) -> b
geogebra.common.euclidian.DrawTurtle -> geogebra.common.c.E:
    geogebra.common.kernel.geos.GeoTurtle turtle -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    java.util.ArrayList cmdList -> a
    java.util.ArrayList gpList -> b
    double[] coords -> a
    geogebra.common.awt.Rectangle boundRect -> b
    double turnAngle -> a
    geogebra.common.awt.Rectangle turtleImageBounds -> c
    double imageSize -> b
    double[] currentCoords -> b
    geogebra.common.awt.Ellipse2DDouble ellipse -> a
    geogebra.common.awt.BasicStroke stroke1 -> d
    geogebra.common.awt.BasicStroke stroke2 -> e
    geogebra.common.awt.GeneralPath path -> a
    void update() -> a
    void updateCurrentCoords() -> b
    void addPointToPath(geogebra.common.euclidian.GeneralPathClipped,boolean) -> a
    void addPointToPath(geogebra.common.euclidian.GeneralPathClipped,geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void drawTurtleShape(geogebra.common.awt.Graphics2D,int,geogebra.common.awt.Color) -> a
geogebra.common.euclidian.DrawUpperLowerSum -> geogebra.common.c.F:
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    boolean isVisible -> a
    boolean labelVisible -> c
    geogebra.common.kernel.algos.AlgoFunctionAreaSums algo -> a
    geogebra.common.euclidian.GeneralPathClipped gp -> a
    double[] coords -> a
    boolean trapeziums -> d
    boolean histogram -> e
    boolean barchartFreqs -> f
    boolean barchartFreqsWidth -> g
    void init() -> b
    void update() -> a
    void updateBarChart() -> c
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.DrawVector -> geogebra.common.c.G:
    geogebra.common.kernel.kernelND.GeoVectorND v -> a
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    boolean isVisible -> a
    boolean labelVisible -> c
    boolean traceDrawingNeeded -> d
    geogebra.common.awt.Line2D line -> a
    double[] coordsA -> a
    double[] coordsB -> b
    double[] coordsV -> c
    geogebra.common.awt.GeneralPath gp -> a
    boolean arrowheadVisible -> e
    boolean lineVisible -> f
    java.util.ArrayList points -> a
    geogebra.common.awt.Point2D endPoint -> a
    void update() -> a
    void setArrow(float) -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.common.euclidian.Drawable -> geogebra.common.c.H:
    boolean forceNoFill -> a
    geogebra.common.awt.BasicStroke objStroke -> a
    geogebra.common.awt.BasicStroke selStroke -> b
    geogebra.common.awt.BasicStroke decoStroke -> c
    int lineThickness -> d
    int lineType -> e
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    int hitThreshold -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    int xLabel -> b
    int yLabel -> c
    java.lang.String labelDesc -> a
    java.lang.String oldLabelDesc -> b
    boolean labelHasIndex -> c
    geogebra.common.awt.Rectangle labelRectangle -> a
    geogebra.common.awt.Shape strokedShape -> a
    geogebra.common.awt.Shape strokedShape2 -> b
    geogebra.common.awt.Area shape -> a
    int lastFontSize -> f
    boolean isTracing -> b
    boolean forcedLineType -> d
    void update() -> a
    void draw(geogebra.common.awt.Graphics2D) -> a
    boolean hit(int,int) -> a
    boolean isInside(geogebra.common.awt.Rectangle) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    double getxLabel() -> b
    double getyLabel() -> c
    void updateFontSize() -> d
    geogebra.common.awt.Rectangle getBounds() -> a
    void drawLabel(geogebra.common.awt.Graphics2D) -> d
    void ensureLabelDrawsOnScreen() -> e
    void drawMultilineLaTeX(geogebra.common.awt.Graphics2D,geogebra.common.awt.Font,geogebra.common.awt.Color,geogebra.common.awt.Color) -> a
    boolean isSerif() -> b
    void drawMultilineText(geogebra.common.awt.Graphics2D) -> e
    boolean addLabelOffset() -> c
    boolean addLabelOffset(boolean) -> a
    boolean hitLabel(int,int) -> b
    void forceLineType(int) -> a
    void updateStrokes(geogebra.common.kernel.geos.GeoElement) -> b
    void updateStrokesJustLineThickness(geogebra.common.kernel.geos.GeoElement) -> c
    void recordToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> d
    void fill(geogebra.common.awt.Graphics2D,geogebra.common.awt.Shape,boolean) -> a
    void setForceNoFill(boolean) -> b
    boolean isForceNoFill() -> d
    void setShape(geogebra.common.awt.Area) -> a
    geogebra.common.awt.Area getShape() -> a
    boolean isTracing() -> e
    void drawTrace(geogebra.common.awt.Graphics2D) -> c
geogebra.common.euclidian.DrawableList -> geogebra.common.c.I:
    geogebra.common.euclidian.DrawableList$Link head -> a
    geogebra.common.euclidian.DrawableList$Link tail -> b
    int size -> a
    int size() -> a
    void add(geogebra.common.euclidian.Drawable) -> a
    void addUnique(geogebra.common.euclidian.Drawable) -> b
    boolean contains(geogebra.common.euclidian.Drawable) -> a
    void remove(geogebra.common.euclidian.Drawable) -> c
    void drawAll(geogebra.common.awt.Graphics2D) -> a
    void updateAll() -> a
    void updateFontSizeAll() -> b
    void clear() -> c
    geogebra.common.euclidian.DrawableList$DrawableIterator getIterator() -> a
geogebra.common.euclidian.DrawableList$DrawableIterator -> geogebra.common.c.I$a:
    geogebra.common.euclidian.DrawableList$Link it -> a
    geogebra.common.euclidian.DrawableList this$0 -> a
    geogebra.common.euclidian.Drawable next() -> a
    boolean hasNext() -> hasNext
    void reset() -> a
    void remove() -> remove
    java.lang.Object next() -> next
geogebra.common.euclidian.DrawableList$Link -> geogebra.common.c.I$b:
    geogebra.common.euclidian.Drawable d -> a
    geogebra.common.euclidian.DrawableList$Link next -> a
    geogebra.common.euclidian.DrawableList this$0 -> a
geogebra.common.euclidian.DrawableND -> geogebra.common.c.J:
    boolean createdByDrawList -> a
    boolean createdByDrawListVisible -> b
    geogebra.common.euclidian.DrawableND drawList -> a
    void setCreatedByDrawList(geogebra.common.euclidian.DrawableND) -> a
    void setCreatedByDrawListVisible(boolean) -> c
    boolean createdByDrawList() -> f
    boolean isCreatedByDrawListVisible() -> g
    geogebra.common.euclidian.DrawableND getDrawListCreator() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setWaitForUpdate() -> f
    void update() -> a
    double getxLabel() -> b
    double getyLabel() -> c
geogebra.common.euclidian.EuclidianPen -> geogebra.common.c.K:
    void setPenGeo(geogebra.common.kernel.geos.GeoImage) -> a
    void setFreehand(boolean) -> a
    void resetPenOffsets() -> a
    void handleMousePressedForPenMode(geogebra.common.euclidian.event.AbstractEvent,geogebra.common.euclidian.Hits) -> a
    void handleMouseReleasedForPenMode(geogebra.common.euclidian.event.AbstractEvent) -> a
    void doDrawPoints(geogebra.common.kernel.geos.GeoImage,java.util.List) -> a
    void setPenColor(geogebra.common.awt.Color) -> a
    void setPenSize(int) -> a
    int getPenSize() -> a
    geogebra.common.awt.Color getPenColorCommon() -> a
geogebra.common.euclidian.EuclidianStatic -> geogebra.common.c.L:
    geogebra.common.euclidian.EuclidianStatic prototype -> a
    geogebra.common.awt.BasicStroke standardStroke -> a
    geogebra.common.awt.BasicStroke selStroke -> b
    geogebra.common.awt.BasicStroke getDefaultStroke() -> a
    geogebra.common.awt.BasicStroke getDefaultSelectionStroke() -> b
    float textWidth(java.lang.String,geogebra.common.awt.Font,geogebra.common.awt.FontRenderContext) -> a
    geogebra.common.awt.BasicStroke getStroke(float,int) -> a
    geogebra.common.awt.Rectangle drawMultilineLaTeX(geogebra.common.main.AbstractApplication,geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D,geogebra.common.awt.Font,geogebra.common.awt.Color,geogebra.common.awt.Color,java.lang.String,int,int,boolean) -> a
    geogebra.common.awt.Rectangle doDrawMultilineLaTeX(geogebra.common.main.AbstractApplication,geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D,geogebra.common.awt.Font,geogebra.common.awt.Color,geogebra.common.awt.Color,java.lang.String,int,int,boolean) -> b
    geogebra.common.awt.Font getIndexFont(geogebra.common.awt.Font) -> a
    geogebra.common.awt.Point drawIndexedString(geogebra.common.main.AbstractApplication,geogebra.common.awt.Graphics2D,java.lang.String,float,float,boolean) -> a
    void doFillWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> a
    void fillWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> b
    geogebra.common.awt.Rectangle drawMultiLineText(geogebra.common.main.AbstractApplication,java.lang.String,int,int,geogebra.common.awt.Graphics2D,boolean) -> a
    void drawWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> c
    void doDrawWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> d
    java.lang.Object setInterpolationHint(geogebra.common.awt.Graphics2D,boolean) -> a
    void resetInterpolationHint(geogebra.common.awt.Graphics2D,java.lang.Object) -> a
    java.lang.Object doSetInterpolationHint(geogebra.common.awt.Graphics2D,boolean) -> b
    void doResetInterpolationHint(geogebra.common.awt.Graphics2D,java.lang.Object) -> b
geogebra.common.euclidian.EuclidianStyleBar -> geogebra.common.c.M:
    void applyVisualStyle(java.util.ArrayList) -> a
    void updateButtonPointCapture(int) -> a
    void setMode(int) -> b
    void setLabels() -> a
    void restoreDefaultGeo() -> b
    void updateStyleBar() -> c
geogebra.common.euclidian.EuclidianViewInterfaceCommon -> geogebra.common.c.N:
    void zoom(double,double,double,int,boolean) -> a
    void resetMode() -> j
    void repaint() -> y
    void rememberOrigins() -> g
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.euclidian.DrawableND getDrawableFor(geogebra.common.kernel.geos.GeoElement) -> e
    java.lang.String getFromPlaneString() -> b
    java.lang.String getTranslatedFromPlaneString() -> c
    boolean isLockedAxesRatio() -> a
    boolean isZoomable() -> b
    java.lang.String[] getAxesUnitLabels() -> b
    geogebra.common.awt.Color getBackgroundCommon() -> c
    int getMode() -> d
    boolean getShowGrid() -> h
    boolean getShowXaxis() -> j
    boolean getShowYaxis() -> k
    void setAxesUnitLabels(java.lang.String[]) -> b
    void setAxesNumberingDistance(double,int) -> b
    void setAxisCross(int,double) -> a
    void setAxisLabel(int,java.lang.String) -> a
    void setAxisTickStyle(int,int) -> a
    void setCoordSystemFromMouseMove(int,int,int) -> a
    void setPositiveAxis(int,boolean) -> a
    void setShowAxisNumbers(int,boolean) -> b
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> b
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue) -> d
    int toScreenCoordX(double) -> a
    int toScreenCoordY(double) -> b
    boolean hitAnimationButton(geogebra.common.euclidian.event.AbstractEvent) -> a
    void setDefaultCursor() -> z
    void setHitCursor() -> A
    geogebra.common.euclidian.EuclidianStyleBar getStyleBar() -> a
    void setShowAxis(int,boolean,boolean) -> a
    void setDragCursor() -> B
    void setToolTipText(java.lang.String) -> a
    void setResizeXAxisCursor() -> C
    void setResizeYAxisCursor() -> D
    void setMoveCursor() -> E
    int getEuclidianViewNo() -> e
    double toScreenCoordXd(double) -> a
    double toScreenCoordYd(double) -> b
    void setShowAxes(boolean,boolean) -> a
    void showGrid(boolean) -> h
    void clickedGeo(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.event.AbstractEvent) -> a
    void mouseMovedOver(geogebra.common.kernel.geos.GeoElement) -> g
    void setBackground(geogebra.common.awt.Color) -> b
    boolean hasFocus() -> q
    void setShowAxis(boolean) -> m
geogebra.common.euclidian.EuclidianViewInterfaceSlim -> geogebra.common.c.O:
    boolean isDefault2D() -> c
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> c
    int getWidth() -> s
    int getHeight() -> t
    double toRealWorldCoordX(double) -> c
    double toRealWorldCoordY(double) -> d
    void updateBounds() -> f
    void replaceBoundObject(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.euclidian.AbstractEuclidianController getEuclidianController() -> a
    double[] getGridDistances() -> a
    double getXmax() -> j
    double getYmax() -> l
    double getXmin() -> k
    double getYmin() -> m
    double getXscale() -> e
    double getYscale() -> f
    geogebra.common.euclidian.DrawableND getDrawableND(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> c
    void zoom(double,double,double,int,boolean) -> a
    void setPointCapturing(int) -> b
    void setSelectionRectangle(geogebra.common.awt.Rectangle) -> a
geogebra.common.euclidian.GeneralPathClipped -> geogebra.common.c.P:
    java.util.ArrayList pathPoints -> a
    geogebra.common.awt.GeneralPath gp -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim view -> a
    double largestCoord -> a
    boolean needClosePath -> a
    geogebra.common.awt.Rectangle bounds -> a
    void reset() -> a
    void closePath() -> b
    geogebra.common.awt.GeneralPath getGeneralPath() -> a
    void addSimpleSegments() -> c
    void addClippedSegments() -> d
    void addClippedLine(geogebra.common.kernel.MyPoint,geogebra.common.kernel.MyPoint,geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Point2D getPointCloseToScreen(double,double) -> a
    void addToGeneralPath(geogebra.common.awt.Point2D,boolean) -> a
    void moveTo(double,double) -> a
    void lineTo(double,double) -> b
    void addPoint(int,double,double) -> a
    void addPoint(double,double,boolean) -> a
    void updateBounds(geogebra.common.kernel.MyPoint) -> a
    geogebra.common.awt.Point2D getCurrentPoint() -> a
    void transform(geogebra.common.awt.AffineTransform) -> a
    boolean contains(double,double) -> a
    boolean contains(int,int) -> a
    boolean contains(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    geogebra.common.awt.Rectangle2D getBounds2D() -> a
    geogebra.common.awt.PathIterator getPathIterator(geogebra.common.awt.AffineTransform) -> a
    boolean intersects(geogebra.common.awt.Rectangle2D) -> a
    boolean intersects(int,int,int,int) -> a
geogebra.common.euclidian.GetViewId -> geogebra.common.c.Q:
    int getViewId() -> a
geogebra.common.euclidian.HatchingHandler -> geogebra.common.c.R:
    geogebra.common.euclidian.HatchingHandler prototype -> a
    void dosetHatching(geogebra.common.awt.Graphics2D,geogebra.common.awt.BasicStroke,geogebra.common.awt.Color,geogebra.common.awt.Color,float,double,double) -> a
    void setHatching(geogebra.common.awt.Graphics2D,geogebra.common.awt.BasicStroke,geogebra.common.awt.Color,geogebra.common.awt.Color,float,double,double) -> b
    void doSetTexture(geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,float) -> a
    void setTexture(geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,float) -> b
geogebra.common.euclidian.Hits -> geogebra.common.c.S:
    int listCount -> a
    int polyCount -> b
    int imageCount -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$Test -> a
    void init() -> a
    geogebra.common.euclidian.Hits clone() -> a
    geogebra.common.euclidian.Hits newHits() -> b
    boolean add(geogebra.common.kernel.geos.GeoElement) -> a
    int getImageCount() -> a
    int getListCount() -> b
    void removePolygonsIfSidePresent() -> b
    void removePolygonsIfSideNotPresent() -> c
    void keepOnlyHitsForNewPointMode() -> d
    void removeConicsHittedOnFilling() -> e
    void removePolygonsDependingSidePresent(boolean) -> a
    void removeSegmentsFromPolygons() -> f
    void removePolygons() -> g
    void removeAllPolygons() -> h
    void removeAllPolygonsButOne() -> i
    void removeAllButImages() -> j
    void removeImages() -> k
    geogebra.common.euclidian.Hits getMoveableHits(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    geogebra.common.euclidian.Hits getPointRotateableHits(geogebra.common.euclidian.EuclidianViewInterfaceSlim,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.euclidian.Hits getMoveables(geogebra.common.euclidian.EuclidianViewInterfaceSlim,geogebra.common.kernel.geos.Test,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.euclidian.Hits getOtherHits(geogebra.common.kernel.geos.Test,geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.Hits getHits(geogebra.common.kernel.geos.Test,geogebra.common.euclidian.Hits) -> b
    geogebra.common.euclidian.Hits getHits(geogebra.common.kernel.geos.Test,boolean,geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.Hits getRegionHits(geogebra.common.euclidian.Hits) -> a
    geogebra.common.euclidian.Hits getHits(geogebra.common.kernel.geos.Test[],boolean,geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement getFirstHit(geogebra.common.kernel.geos.Test) -> a
    geogebra.common.euclidian.Hits getTopHits() -> c
    geogebra.common.euclidian.Hits getTopHits(int) -> a
    geogebra.common.euclidian.Hits getHits(int) -> b
    geogebra.common.euclidian.Hits createNewHits() -> d
    boolean containsGeoPoint() -> a
    boolean containsGeoPoint(geogebra.common.euclidian.Hits) -> a
    java.lang.String toString() -> toString
    java.lang.Object clone() -> clone
    boolean add(java.lang.Object) -> add
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$Test() -> a
geogebra.common.euclidian.MyButton -> geogebra.common.c.T:
    geogebra.common.kernel.geos.GeoButton geoButton -> a
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    int x -> a
    int y -> b
    int width -> c
    int height -> d
    boolean selected -> a
    java.lang.String text -> a
    geogebra.common.awt.Font font -> a
    boolean pressed -> b
    boolean draggedOrContext -> c
    java.lang.String getCaption() -> b
    void paintComponent(geogebra.common.awt.Graphics2D) -> a
    void setForeground(geogebra.common.awt.Color) -> a
    boolean isSelected() -> b
    int getWidth() -> a
    int getHeight() -> b
    void setBounds(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void setSelected(boolean) -> a
    void setText(java.lang.String) -> a
    java.lang.String getText() -> a
    void setFont(geogebra.common.awt.Font) -> a
    void setPressed(boolean) -> b
    void setDraggedOrContext(boolean) -> c
    boolean getDraggedOrContext() -> a
geogebra.common.euclidian.Previewable -> geogebra.common.c.U:
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void disposePreview() -> c
geogebra.common.euclidian.RemoveNeeded -> geogebra.common.c.V:
    void remove() -> b
geogebra.common.euclidian.clipping.ClipLine -> geogebra.common.c.a.a:
    geogebra.common.awt.Point2D[] getClipped(double,double,double,double,int,int,int,int) -> a
    geogebra.common.awt.Point2D[] getClipped(double,double,int,double,double,int,double,double,double,double) -> a
    geogebra.common.awt.Point2D intersect(double,double,double,double,double,double,double,double) -> a
geogebra.common.euclidian.clipping.ClipShape -> geogebra.common.c.a.b:
    geogebra.common.euclidian.clipping.DoubleArrayFactory doubleFactory -> a
    geogebra.common.awt.GeneralPath clipToRect(geogebra.common.awt.Shape,geogebra.common.awt.AffineTransform,geogebra.common.awt.Rectangle2D) -> a
    geogebra.common.euclidian.clipping.DoubleArrayFactory access$0() -> a
geogebra.common.euclidian.clipping.ClipShape$CFunction -> geogebra.common.c.a.b$a:
    double a -> a
    double b -> b
    double c -> c
    double d -> d
    double[] t2 -> a
    double[] eqn -> b
    java.lang.String toString() -> toString
    void define(double,double,double,double) -> a
    double evaluate(double) -> a
    double getDerivative(double) -> b
    int evaluateInverse(double,double[],int) -> a
geogebra.common.euclidian.clipping.ClipShape$ClippedPath -> geogebra.common.c.a.b$b:
    geogebra.common.awt.GeneralPath g -> a
    java.util.Stack uncommittedPoints -> a
    double initialX -> a
    double initialY -> b
    void moveTo(double,double) -> a
    void curveTo(geogebra.common.euclidian.clipping.ClipShape$Function,geogebra.common.euclidian.clipping.ClipShape$Function,double,double) -> a
    void lineTo(double,double) -> b
    void closePath() -> a
    void flush() -> b
geogebra.common.euclidian.clipping.ClipShape$Function -> geogebra.common.c.a.b$c:
    double evaluate(double) -> a
    int evaluateInverse(double,double[],int) -> a
    double getDerivative(double) -> b
geogebra.common.euclidian.clipping.ClipShape$LFunction -> geogebra.common.c.a.b$d:
    double slope -> a
    double intercept -> b
    void define(double,double) -> a
    java.lang.String toString() -> toString
    double evaluate(double) -> a
    int evaluateInverse(double,double[],int) -> a
    double getDerivative(double) -> b
geogebra.common.euclidian.clipping.ClipShape$QFunction -> geogebra.common.c.a.b$e:
    double a -> a
    double b -> b
    double c -> c
    java.lang.String toString() -> toString
    void define(double,double,double) -> a
    double evaluate(double) -> a
    double getDerivative(double) -> b
    int evaluateInverse(double,double[],int) -> a
geogebra.common.euclidian.clipping.DoubleArrayFactory -> geogebra.common.c.a.c:
    geogebra.common.euclidian.clipping.DoubleArrayFactory prototype -> a
    geogebra.common.euclidian.clipping.MutableInteger key -> a
    double[] getArray(int) -> a
    void putArray(double[]) -> a
geogebra.common.euclidian.clipping.MutableInteger -> geogebra.common.c.a.d:
    int value -> a
    double doubleValue() -> doubleValue
    float floatValue() -> floatValue
    int intValue() -> intValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
geogebra.common.euclidian.event.AbstractEvent -> geogebra.common.c.b.a:
    geogebra.common.awt.Point getPoint() -> a
    boolean isAltDown() -> a
    boolean isShiftDown() -> b
    void release() -> a
    int getX() -> a
    int getY() -> b
    boolean isRightClick() -> c
    boolean isControlDown() -> d
    int getClickCount() -> c
    boolean isMetaDown() -> e
    double getWheelRotation() -> a
    boolean isMiddleClick() -> f
    boolean isPopupTrigger() -> g
geogebra.common.euclidian.event.FocusEvent -> geogebra.common.c.b.b:
geogebra.common.euclidian.event.FocusListener -> geogebra.common.c.b.c:
    java.lang.Object listenerClass -> a
    void wrapFocusGained(geogebra.common.euclidian.event.FocusEvent) -> c
    void wrapFocusLost(geogebra.common.euclidian.event.FocusEvent) -> d
    void setListenerClass(java.lang.Object) -> a
geogebra.common.euclidian.event.KeyEvent -> geogebra.common.c.b.d:
    char getKeyChar() -> a
geogebra.common.euclidian.event.KeyListener -> geogebra.common.c.b.e:
    java.lang.Object listenerClass -> a
    void setListenerClass(java.lang.Object) -> a
    void wrapKeyReleased(geogebra.common.euclidian.event.KeyEvent) -> b
geogebra.common.export.GeoGebraTubeExport -> geogebra.common.d.a:
    geogebra.common.main.AbstractApplication app -> a
    java.util.ArrayList macros -> a
    java.lang.String getBase64String() -> a
    java.lang.String getBase64Tools(java.util.ArrayList) -> a
    java.lang.StringBuffer getPostData() -> a
    java.lang.String encode(java.lang.String) -> a
geogebra.common.export.GeoGebraTubeExport$UploadResults -> geogebra.common.d.a$a:
    java.lang.String status -> a
    java.lang.String uid -> b
    java.lang.String errorMessage -> c
    geogebra.common.export.GeoGebraTubeExport this$0 -> a
    boolean HasError() -> a
    java.lang.String getUID() -> a
geogebra.common.factories.AwtFactory -> geogebra.common.e.a:
    geogebra.common.factories.AwtFactory prototype -> a
    geogebra.common.awt.Color newColor(int) -> a
    geogebra.common.awt.Color newColor(int,int,int) -> a
    geogebra.common.awt.Color newColor(int,int,int,int) -> a
    geogebra.common.awt.Color newColor(float,float,float,float) -> a
    geogebra.common.awt.Color newColor(float,float,float) -> a
    geogebra.common.awt.AffineTransform newAffineTransform() -> a
    geogebra.common.awt.Rectangle2D newRectangle2D() -> a
    geogebra.common.awt.Rectangle newRectangle(int,int,int,int) -> a
    geogebra.common.awt.BufferedImage newBufferedImage(int,int,int) -> a
    geogebra.common.awt.Dimension newDimension(int,int) -> a
    geogebra.common.awt.Point2D newPoint2D() -> a
    geogebra.common.awt.Rectangle newRectangle(int,int) -> a
    geogebra.common.awt.Rectangle newRectangle() -> a
    geogebra.common.awt.Point2D newPoint2D(double,double) -> a
    geogebra.common.awt.GeneralPath newGeneralPath() -> a
    geogebra.common.awt.BasicStroke newMyBasicStroke(float) -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float,int,int) -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float,int,int,float,float[],float) -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float) -> b
    geogebra.common.awt.Line2D newLine2D() -> a
    geogebra.common.awt.Rectangle newRectangle(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Ellipse2DDouble newEllipse2DDouble() -> a
    geogebra.common.awt.Ellipse2DFloat newEllipse2DFloat(int,int,int,int) -> a
    geogebra.common.awt.Arc2D newArc2D() -> a
    geogebra.common.awt.Area newArea() -> a
    geogebra.common.awt.Area newArea(geogebra.common.awt.Shape) -> a
    geogebra.common.awt.GeneralPath newGeneralPath(int) -> a
    geogebra.common.awt.CubicCurve2D newCubicCurve2D() -> a
    geogebra.common.awt.font.TextLayout newTextLayout(java.lang.String,geogebra.common.awt.Font,geogebra.common.awt.FontRenderContext) -> a
    geogebra.common.awt.AlphaComposite newAlphaComposite(int,float) -> a
    geogebra.common.awt.BasicStroke newBasicStrokeJoinMitre(float) -> c
    geogebra.common.awt.GradientPaint newGradientPaint(int,int,geogebra.common.awt.Color,int,int,geogebra.common.awt.Color) -> a
    geogebra.common.euclidian.event.FocusListener newFocusListener(java.lang.Object) -> a
    geogebra.common.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
geogebra.common.factories.CASFactory -> geogebra.common.e.b:
    geogebra.common.factories.CASFactory prototype -> a
    geogebra.common.cas.mpreduce.AbstractCASmpreduce newMPReduce(geogebra.common.cas.CASparser,geogebra.common.cas.CasParserTools,geogebra.common.kernel.Kernel) -> a
geogebra.common.factories.FormatFactory -> geogebra.common.e.c:
    geogebra.common.factories.FormatFactory prototype -> a
    geogebra.common.util.ScientificFormatAdapter getScientificFormat(int,int,boolean) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(int) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(java.lang.String,int) -> a
geogebra.common.factories.LaTeXFactory -> geogebra.common.e.d:
    geogebra.common.factories.LaTeXFactory prototype -> a
    geogebra.common.util.LaTeXCache newLaTeXCache() -> a
geogebra.common.factories.SwingFactory -> geogebra.common.e.e:
    geogebra.common.factories.SwingFactory prototype -> a
    geogebra.common.gui.inputfield.AutoCompleteTextField newAutoCompleteTextField(int,geogebra.common.main.AbstractApplication,geogebra.common.euclidian.Drawable) -> a
    geogebra.common.javax.swing.JLabel newJLabel(java.lang.String) -> a
    geogebra.common.javax.swing.Box createHorizontalBox() -> a
geogebra.common.factories.UtilFactory -> geogebra.common.e.f:
    geogebra.common.factories.UtilFactory prototype -> a
    geogebra.common.util.HttpRequest newHttpRequest() -> a
    geogebra.common.util.URLEncoder newURLEncoder() -> a
geogebra.common.gui.GuiManager -> geogebra.common.f.a:
    void removeSpreadsheetTrace(geogebra.common.kernel.geos.GeoElement) -> a
    void updateMenubar() -> a
    void updateMenubarSelection() -> b
    void showPopupMenu(java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.Point) -> a
    void setMode(int) -> a
    void setFocusedPanel(geogebra.common.euclidian.event.AbstractEvent) -> a
    void loadImage(geogebra.common.kernel.geos.GeoPoint2,java.lang.Object,boolean) -> a
    boolean hasAlgebraView() -> a
    void updateFonts() -> c
    boolean isUsingConstructionProtocol() -> b
    void getConsProtocolXML(java.lang.StringBuilder) -> a
    boolean isInputFieldSelectionListener() -> c
    void addSpreadsheetTrace(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isPropertiesDialogSelectionListener() -> d
    geogebra.common.javax.swing.JTextComponent getAlgebraInputTextField() -> a
    void showDrawingPadPopup(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.Point) -> a
    boolean hasSpreadsheetView() -> e
    void attachSpreadsheetView() -> d
    void setShowView(boolean,int) -> a
    boolean showView(int) -> a
    geogebra.common.kernel.View getConstructionProtocolData() -> a
    geogebra.common.kernel.View getCasView() -> b
    geogebra.common.kernel.View getSpreadsheetView() -> c
    geogebra.common.kernel.View getProbabilityCalculator() -> d
    geogebra.common.kernel.View getPlotPanelView(int) -> a
    boolean hasProbabilityCalculator() -> f
    void getProbabilityCalculatorXML(java.lang.StringBuilder) -> b
    void getSpreadsheetViewXML(java.lang.StringBuilder,boolean) -> a
    void updateActions() -> e
    void doAfterRedefine(geogebra.common.kernel.geos.GeoElement) -> c
    void updateSpreadsheetColumnWidths() -> f
    void updateConstructionProtocol() -> g
    void updateAlgebraInput() -> h
    void setShowAuxiliaryObjects(boolean) -> a
geogebra.common.gui.Layout -> geogebra.common.f.b:
    java.util.ArrayList perspectives -> a
    geogebra.common.main.settings.LayoutSettings settings -> a
    geogebra.common.io.layout.Perspective[] defaultPerspectives -> a
    void initializeDefaultPerspectives(boolean) -> a
    void setPerspectives(java.util.ArrayList) -> a
    void applyPerspective(geogebra.common.io.layout.Perspective) -> a
geogebra.common.gui.SetLabels -> geogebra.common.f.c:
    void setLabels() -> a
geogebra.common.gui.VirtualKeyboardListener -> geogebra.common.f.d:
    void insertString(java.lang.String) -> a
geogebra.common.gui.dialog.DialogManager -> geogebra.common.f.a.a:
    java.lang.String defaultAngle -> a
    geogebra.common.main.AbstractApplication app -> a
    java.lang.Object oldString -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showRedefineDialog(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void doAngleFixed(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    boolean showSliderCreationDialog(int,int) -> a
    boolean confirm(java.lang.String) -> a
    void showNumberInputDialogRotate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showNumberInputDialogRegularPolygon(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.Point,geogebra.common.kernel.geos.GeoBoolean) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.AbstractEuclidianView) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    java.lang.String rotateObject(geogebra.common.main.AbstractApplication,java.lang.String,boolean,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    boolean makeRegularPolygon(geogebra.common.main.AbstractApplication,java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.arithmetic.NumberValue getNumber(geogebra.common.kernel.Kernel,java.lang.String,java.lang.String) -> a
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoNumeric setSliderFromDefault(geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    void closeAll() -> a
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showOptionsDialog(int) -> a
    void showPropertiesDialog() -> b
    void showToolbarConfigDialog() -> c
    boolean doDilate(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void doSegmentFixed(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    void showTextDialog(geogebra.common.kernel.geos.GeoText) -> a
    void showTextCreationDialog(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void showTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
geogebra.common.gui.inputfield.AltKeys -> geogebra.common.f.b.a:
    java.util.HashMap LookupLower -> a
    java.util.HashMap LookupUpper -> b
geogebra.common.gui.inputfield.AutoCompleteTextField -> geogebra.common.f.b.b:
    void showPopupSymbolButton(boolean) -> a
    void setAutoComplete(boolean) -> b
    void enableColoring(boolean) -> c
    void setOpaque(boolean) -> setOpaque
    void setFont(geogebra.common.awt.Font) -> a
    void setForeground(geogebra.common.awt.Color) -> a
    void setBackground(geogebra.common.awt.Color) -> b
    void setFocusable(boolean) -> setFocusable
    void setEditable(boolean) -> setEditable
    void requestFocus() -> requestFocus
    void setLabel(geogebra.common.javax.swing.JLabel) -> a
    void setVisible(boolean) -> setVisible
    void setColumns(int) -> setColumns
    void addFocusListener(geogebra.common.euclidian.event.FocusListener) -> a
    void addKeyListener(geogebra.common.euclidian.event.KeyListener) -> a
    int getCaretPosition() -> getCaretPosition
    void setCaretPosition(int) -> setCaretPosition
geogebra.common.gui.inputfield.MyTextField -> geogebra.common.f.b.c:
    int[] getBracketPositions(java.lang.String,int) -> a
    boolean isCloseBracketOrWhitespace(char) -> a
    boolean isWhiteSpace(char) -> b
    geogebra.common.gui.inputfield.ValidateAutocompletionResult commonValidateAutocompletion(int,java.util.List,java.lang.String,int) -> a
geogebra.common.gui.inputfield.ValidateAutocompletionResult -> geogebra.common.f.b.d:
    int carPos -> a
    java.lang.String sb -> a
    boolean returnval -> a
geogebra.common.gui.layout.DockPanel -> geogebra.common.f.c.a:
    java.lang.String getToolbarString() -> a
    java.lang.String getDefaultToolbarString() -> b
    int getViewId() -> a
geogebra.common.gui.toolbar.ToolBar -> geogebra.common.f.d.a:
    java.lang.Integer SEPARATOR -> a
    java.lang.String getAllToolsNoMacros(boolean) -> a
    java.lang.String getAllToolsNoMacrosForPlane() -> a
    java.lang.String getAllToolsNoMacros3D() -> b
    java.util.Vector parseToolbarString(java.lang.String) -> a
geogebra.common.gui.toolbar.ToolbarItem -> geogebra.common.f.d.b:
    java.util.Vector menu -> a
    java.lang.Integer mode -> a
    java.util.Vector getMenu() -> a
    java.lang.Integer getMode() -> a
geogebra.common.gui.util.TableSymbols -> geogebra.common.f.e.a:
    java.lang.String[] functions -> a
    java.lang.String[] greekLowerCase -> b
    java.lang.String[] greekUpperCaseFull -> c
    java.lang.String[] analysis -> d
    java.lang.String[] logical -> e
    java.lang.String[] sets -> f
    java.lang.String[] operators -> g
    java.lang.String[] sub_superscripts -> h
    java.lang.String[] basic_arrows -> i
    java.lang.String[] otherArrows -> j
    java.lang.String[] geometricShapes -> k
    java.lang.String[] games_music -> l
    java.lang.String[] handPointers -> m
    java.lang.String[] UNICODEotherarrows -> n
    java.lang.String[] UNICODEmisc -> o
    java.lang.String[] UNICODEweather_astrology -> p
    java.lang.String[] UNICODEgames_music -> q
    java.lang.String[] UNICODEwriting -> r
    java.lang.String[] UNICODEbullets -> s
    java.lang.String[] otherdingbats -> t
    java.lang.String[] UNICODEgeometricShapes -> u
    java.lang.String[] letterLikeSymbols -> v
    java.lang.String[] currency -> w
    java.lang.String[] JLatex -> x
    java.lang.String[] displayChars -> y
    java.lang.String[] specialChars -> z
    java.lang.String[] symbols -> A
    java.lang.String[][] basicSymbolsMap(geogebra.common.main.AbstractApplication) -> a
    java.lang.String[] basicSymbols(geogebra.common.main.AbstractApplication) -> a
    java.lang.String[] basicSymbolsToolTips(geogebra.common.main.AbstractApplication) -> b
    java.lang.String[] greekLettersPlusVariants() -> a
geogebra.common.gui.view.algebra.AbstractAlgebraController -> geogebra.common.f.f.a.a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.gui.view.algebra.AlgebraView view -> a
    geogebra.common.kernel.geos.GeoElement lastSelectedGeo -> a
    boolean skipSelection -> a
    void setView(geogebra.common.gui.view.algebra.AlgebraView) -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.gui.view.algebra.AlgebraView -> geogebra.common.f.f.a.b:
    boolean isVisible() -> isVisible
    geogebra.common.kernel.geos.GeoElement getGeoElementForLocation(java.lang.Object,int,int) -> a
    void startEditing(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void cancelEditing() -> cancelEditing
    boolean isEditing() -> isEditing
    java.lang.Object getPathForLocation(int,int) -> a
    java.lang.Object getPathBounds(java.lang.Object) -> a
geogebra.common.gui.view.properties.PropertiesView -> geogebra.common.f.f.b.a:
    void updateSelection() -> a
geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel -> geogebra.common.f.f.c.a:
    geogebra.common.main.AbstractApplication app -> a
    int highestUsedColumn -> a
    int highestUsedRow -> b
    int getRowCount() -> a
    int getColumnCount() -> c
    void setRowCount(int) -> b
    void setColumnCount(int) -> c
    java.lang.Object getValueAt(int,int) -> a
    void setValueAt(java.lang.Object,int,int) -> a
    void attachView() -> a
    int getHighestUsedColumn() -> d
    int getHighestUsedRow() -> e
    void updateHighestUsedColAndRow(int,int) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void doRemove(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void clearView() -> b
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void setMode(int) -> a
    int getViewID() -> b
geogebra.common.gui.view.spreadsheet.CellRange -> geogebra.common.f.f.c.b:
    int minColumn -> a
    int minRow -> b
    int maxColumn -> c
    int maxRow -> d
    int anchorColumn -> e
    int anchorRow -> f
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel tableModel -> a
    void setCellRange(int,int,int,int) -> a
    int getMinColumn() -> a
    int getMinRow() -> b
    int getMaxColumn() -> c
    int getMaxRow() -> d
    boolean isSingleCell() -> a
    boolean isColumn() -> b
    boolean isRow() -> c
    boolean is2D() -> d
    boolean isPartialRow() -> e
    boolean isPartialColumn() -> f
    boolean isEmpty() -> g
    boolean isEmptyRange() -> h
    boolean isPointList() -> i
    void setActualRange() -> a
    int getWidth() -> e
    java.util.ArrayList toGeoList() -> a
    java.util.ArrayList toCellList(boolean) -> a
    boolean hasSameAnchor(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean hasEmptyCells() -> j
    boolean isValid() -> k
    geogebra.common.gui.view.spreadsheet.CellRange clone() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean contains(java.lang.Object) -> a
    java.lang.Object clone() -> clone
geogebra.common.gui.view.spreadsheet.RelativeCopy -> geogebra.common.f.f.c.c:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    com.google.gwt.regexp.shared.RegExp pattern2 -> a
    boolean doDragCopy(int,int,int,int,int,int,int,int) -> a
    boolean isPatternSource(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void doCopyVerticalNoStoringUndoInfo1(int,int,int,int,int) -> a
    void doCopyHorizontalNoStoringUndoInfo1(int,int,int,int,int) -> b
    geogebra.common.kernel.geos.GeoElement doCopyNoStoringUndoInfo0(geogebra.common.kernel.Kernel,geogebra.common.main.AbstractApplication,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    java.lang.String updateCellReferences(geogebra.common.kernel.geos.GeoElement,java.lang.String,int,int) -> a
    void doCopyNoStoringUndoInfo1(geogebra.common.kernel.Kernel,geogebra.common.main.AbstractApplication,java.lang.String,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    java.lang.String replaceAll(com.google.gwt.regexp.shared.RegExp,java.lang.String,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] getDependentObjects(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[][] getValues(geogebra.common.main.AbstractApplication,int,int,int,int) -> a
    geogebra.common.kernel.geos.GeoElement getValue(geogebra.common.main.AbstractApplication,int,int) -> a
    geogebra.common.kernel.geos.GeoElement prepareNewValue(geogebra.common.kernel.Kernel,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement updateOldValue(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoElement,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement prepareAddingValueToTableNoStoringUndoInfo(geogebra.common.kernel.Kernel,geogebra.common.main.AbstractApplication,java.lang.String,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    boolean isNumber(java.lang.String) -> a
    boolean isStandardNumber(java.lang.String) -> b
geogebra.common.gui.view.spreadsheet.SpreadsheetTraceManager -> geogebra.common.f.f.c.d:
    boolean isTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void handleColumnDelete(int,int) -> a
    void addSpreadsheetTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.io.DocHandler -> geogebra.common.g.a:
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    void startDocument() -> a
    void endDocument() -> b
    void text(java.lang.String) -> b
    int getConsStep() -> a
geogebra.common.io.MyXMLHandler -> geogebra.common.g.b:
    double FORMAT -> a
    int[] menuFontSizes -> a
    java.lang.String[] tooltipTimeouts -> a
    java.lang.Integer[] cbTimeoutOptions -> a
    int mode -> a
    int constMode -> b
    int casMode -> c
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoCasCell geoCasCell -> a
    geogebra.common.kernel.arithmetic.Command cmd -> a
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.main.AbstractApplication app -> a
    java.lang.String[] macroInputLabels -> b
    java.lang.String[] macroOutputLabels -> c
    geogebra.common.kernel.geos.GeoElement[] cmdOutput -> a
    boolean startAnimation -> a
    int docPointStyle -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Kernel origKernel -> b
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Construction origCons -> b
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.parser.Parser origParser -> b
    java.util.LinkedList startPointList -> a
    java.util.LinkedList linkedGeoList -> b
    java.util.LinkedList showObjectConditionList -> c
    java.util.LinkedList dynamicColorList -> d
    java.util.LinkedList animationSpeedList -> e
    java.util.LinkedList animationStepList -> f
    java.util.LinkedList animatingList -> g
    java.util.LinkedList minMaxList -> h
    int consStep -> e
    double ggbFileFormat -> b
    boolean hasGuiElement -> b
    geogebra.common.io.layout.Perspective tmp_perspective -> a
    java.util.ArrayList tmp_perspectives -> a
    java.util.ArrayList tmp_panes -> b
    java.util.ArrayList tmp_views -> c
    int tmp_sp1 -> f
    int tmp_sp2 -> g
    boolean tmp_spHorizontal -> c
    boolean tmp_showAlgebra -> d
    boolean tmp_showSpreadsheet -> e
    int viewNo -> h
    boolean resetEVsettingsNeeded -> f
    java.util.HashMap xmin -> a
    java.util.HashMap xmax -> b
    java.util.HashMap ymin -> c
    java.util.HashMap ymax -> d
    void reset(boolean) -> a
    void initKernelVars() -> c
    int getConsStep() -> a
    java.lang.Integer getTimeoutOption(long) -> a
    void text(java.lang.String) -> b
    void startDocument() -> a
    void endDocument() -> b
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void startScriptingElement(java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    void startGeoGebraElement(java.lang.String,java.util.LinkedHashMap) -> d
    void handleKeyboard(java.util.LinkedHashMap) -> b
    void startMacroElement(java.lang.String,java.util.LinkedHashMap) -> e
    void startEuclidianView3DElement(java.lang.String,java.util.LinkedHashMap) -> b
    void startEuclidianViewElement(java.lang.String,java.util.LinkedHashMap) -> f
    void startSpreadsheetViewElement(java.lang.String,java.util.LinkedHashMap) -> g
    void startProbabilityCalculatorElement(java.lang.String,java.util.LinkedHashMap) -> h
    boolean handleProbabilityDistribution(java.util.LinkedHashMap) -> a
    void startAlgebraViewElement(java.lang.String,java.util.LinkedHashMap) -> i
    boolean handleCoordSystem(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> b
    boolean handleEvSettings(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> c
    boolean handleEvSize(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> d
    boolean handleSpreadsheetSize(java.util.LinkedHashMap) -> b
    boolean handleSpreadsheetColumn(java.util.LinkedHashMap) -> c
    boolean handleSpreadsheetCellSize(java.util.LinkedHashMap) -> d
    boolean handleSpreadsheetFormat(java.util.LinkedHashMap) -> e
    boolean handleSpreadsheetRow(java.util.LinkedHashMap) -> f
    boolean handleSpreadsheetLayout(java.util.LinkedHashMap) -> g
    boolean handleSpreadsheetInitalSelection(java.util.LinkedHashMap) -> h
    boolean handleSpreadsheetBrowser(java.util.LinkedHashMap) -> i
    boolean handleBgColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> e
    boolean handleAxesColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> f
    boolean handleGridColor(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> g
    boolean handleLineStyle(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> h
    boolean handleGrid(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> i
    boolean handleAxis(geogebra.common.main.settings.EuclidianSettings,java.util.LinkedHashMap) -> a
    void startKernelElement(java.lang.String,java.util.LinkedHashMap) -> j
    boolean handleAngleUnit(java.util.LinkedHashMap) -> j
    boolean handleAlgebraStyle(java.util.LinkedHashMap) -> k
    boolean handleKernelCoordStyle(java.util.LinkedHashMap) -> l
    boolean handleKernelInvTrig(java.util.LinkedHashMap) -> m
    boolean handleKernelDecimals(java.util.LinkedHashMap) -> n
    boolean handleKernelStartAnimation(java.util.LinkedHashMap) -> o
    boolean handleKernelLocalization(java.util.LinkedHashMap) -> p
    boolean handleCasSettings(java.util.LinkedHashMap) -> q
    boolean handleKernelFigures(java.util.LinkedHashMap) -> r
    boolean handleKernelContinuous(java.util.LinkedHashMap) -> s
    boolean handleKernelUsePathAndRegionParameters(java.util.LinkedHashMap) -> t
    void startGuiElement(java.lang.String,java.util.LinkedHashMap) -> k
    void createCompabilityLayout() -> d
    boolean handleConsProtColumns(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> a
    boolean handleConsProtocol(java.util.LinkedHashMap) -> u
    boolean handleConsProtNavigationBar(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> b
    boolean handleGuiShow(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> c
    boolean handleGuiSettings(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> d
    boolean handleGraphicsSettings(java.util.LinkedHashMap) -> v
    boolean handleSplitDivider(java.util.LinkedHashMap) -> w
    boolean handleToolbar(java.util.LinkedHashMap) -> x
    boolean handleWindowSize(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> e
    boolean handleFont(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> f
    boolean handleMenuFont(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> g
    boolean handleTooltipSettings(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> h
    boolean handleMouse(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> i
    boolean handleLabelingStyle(geogebra.common.main.AbstractApplication,java.util.LinkedHashMap) -> j
    void startGuiPerspectivesElement(java.lang.String,java.util.LinkedHashMap) -> l
    boolean handlePerspective(java.util.LinkedHashMap) -> y
    void endGuiPerspectivesElement() -> e
    void startGuiPerspectiveElement(java.lang.String,java.util.LinkedHashMap) -> m
    boolean handleAlgebraInput(java.util.LinkedHashMap) -> z
    void endGuiPerspectiveElement() -> f
    void startGuiViewsElement(java.lang.String,java.util.LinkedHashMap) -> n
    boolean handleView(java.util.LinkedHashMap) -> A
    void startGuiPanesElement(java.lang.String,java.util.LinkedHashMap) -> o
    boolean handlePane(java.util.LinkedHashMap) -> B
    void handleConstruction(java.util.LinkedHashMap) -> c
    void initMacro(java.util.LinkedHashMap) -> d
    void endMacro() -> g
    void handleWorksheetText(java.util.LinkedHashMap) -> e
    void startCasCell(java.lang.String,java.util.LinkedHashMap) -> p
    void endCasCell(java.lang.String) -> c
    void startCellPair() -> h
    void endCellPair(java.lang.String) -> d
    void startCellOutputElement(java.lang.String,java.util.LinkedHashMap) -> q
    void startCellInputElement(java.lang.String,java.util.LinkedHashMap) -> r
    void startCellTextElement(java.lang.String,java.util.LinkedHashMap) -> s
    void startConstructionElement(java.lang.String,java.util.LinkedHashMap) -> t
    void endConstructionElement(java.lang.String) -> e
    void processEvSizes() -> i
    geogebra.common.kernel.geos.GeoElement getGeoElement(java.util.LinkedHashMap) -> a
    void startGeoElement(java.lang.String,java.util.LinkedHashMap) -> c
    char firstChar(java.lang.String) -> a
    boolean handleShow(java.util.LinkedHashMap) -> C
    boolean handleShowOnAxis(java.util.LinkedHashMap) -> D
    boolean handleObjColor(java.util.LinkedHashMap) -> E
    boolean handleBgColor(java.util.LinkedHashMap) -> F
    geogebra.common.awt.Color handleColorAttrs(java.util.LinkedHashMap) -> a
    geogebra.common.awt.Color handleColorAlphaAttrs(java.util.LinkedHashMap) -> b
    boolean handleLineStyle(java.util.LinkedHashMap) -> G
    boolean handleDecoration(java.util.LinkedHashMap) -> H
    boolean handleEqnStyle(java.util.LinkedHashMap) -> I
    boolean handleCoords(java.util.LinkedHashMap) -> J
    boolean handleCoordStyle(java.util.LinkedHashMap) -> K
    boolean handleCaption(java.util.LinkedHashMap) -> L
    boolean handleScript(java.util.LinkedHashMap,geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    boolean handleCondition(java.util.LinkedHashMap) -> M
    boolean handleCheckbox(java.util.LinkedHashMap) -> N
    boolean handleValue(java.util.LinkedHashMap) -> O
    boolean handlePointSize(java.util.LinkedHashMap) -> P
    boolean handlePointStyle(java.util.LinkedHashMap) -> Q
    boolean handleLayer(java.util.LinkedHashMap) -> R
    boolean handleCasCellInput(java.util.LinkedHashMap) -> S
    boolean handleCasCellOutput(java.util.LinkedHashMap) -> T
    boolean handleSlider(java.util.LinkedHashMap) -> U
    boolean handleTrace(java.util.LinkedHashMap) -> V
    boolean handleSpreadsheetTrace(java.util.LinkedHashMap) -> W
    boolean handleShowTrimmed(java.util.LinkedHashMap) -> X
    boolean handleSelectionAllowed(java.util.LinkedHashMap) -> Y
    boolean handleSelectedIndex(java.util.LinkedHashMap) -> Z
    boolean handleAnimation(java.util.LinkedHashMap) -> aa
    boolean handleFixed(java.util.LinkedHashMap) -> ab
    boolean handleBreakpoint(java.util.LinkedHashMap) -> ac
    boolean handleFile(java.util.LinkedHashMap) -> ad
    boolean handleTextFont(java.util.LinkedHashMap) -> ae
    boolean handleTextDecimals(java.util.LinkedHashMap) -> af
    boolean handleTextFigures(java.util.LinkedHashMap) -> ag
    boolean handleInBackground(java.util.LinkedHashMap) -> ah
    boolean handleInterpolate(java.util.LinkedHashMap) -> ai
    boolean handleAuxiliary(java.util.LinkedHashMap) -> aj
    boolean handleIsLaTeX(java.util.LinkedHashMap) -> ak
    boolean handleArcSize(java.util.LinkedHashMap) -> al
    boolean handleAbsoluteScreenLocation(java.util.LinkedHashMap) -> am
    boolean handleAllowReflexAngle(java.util.LinkedHashMap) -> an
    boolean handleEmphasizeRightAngle(java.util.LinkedHashMap) -> ao
    boolean handleForceReflexAngle(java.util.LinkedHashMap) -> ap
    boolean handleOutlyingIntersections(java.util.LinkedHashMap) -> aq
    boolean handleKeepTypeOnTransform(java.util.LinkedHashMap) -> ar
    boolean handleSlopeTriangleSize(java.util.LinkedHashMap) -> as
    boolean handleStartPoint(java.util.LinkedHashMap) -> at
    geogebra.common.kernel.kernelND.GeoPointND handleAbsoluteStartPoint(java.util.LinkedHashMap) -> a
    void processStartPointList() -> j
    boolean handleLength(java.util.LinkedHashMap) -> au
    boolean handleLinkedGeo(java.util.LinkedHashMap) -> av
    void processLinkedGeoList() -> k
    void processShowObjectConditionList() -> l
    void processAnimationSpeedList() -> m
    void processAnimationStepList() -> n
    void processAnimatingList() -> o
    void processMinMaxList() -> p
    void processDynamicColorList() -> q
    boolean handleEigenvectors(java.util.LinkedHashMap) -> aw
    boolean handleMatrix(java.util.LinkedHashMap) -> ax
    boolean handleLabelOffset(java.util.LinkedHashMap) -> ay
    boolean handleLabelMode(java.util.LinkedHashMap) -> az
    boolean handleTooltipMode(java.util.LinkedHashMap) -> aA
    boolean handleCoefficients(java.util.LinkedHashMap) -> aB
    boolean handleUserInput(java.util.LinkedHashMap) -> aC
    geogebra.common.kernel.arithmetic.Command getCommand(java.util.LinkedHashMap) -> a
    void startCommandElement(java.lang.String,java.util.LinkedHashMap) -> u
    boolean handleCmdInput(java.util.LinkedHashMap) -> aD
    boolean handleCmdOutput(java.util.LinkedHashMap) -> aE
    java.lang.String[] getAttributeStrings(java.util.LinkedHashMap) -> a
    void startExpressionElement(java.util.LinkedHashMap) -> f
    boolean parseBoolean(java.lang.String) -> a
geogebra.common.io.MyXMLHandler$GeoExpPair -> geogebra.common.g.b$a:
    geogebra.common.kernel.geos.GeoElement geoElement -> a
    java.lang.String exp -> a
    geogebra.common.io.MyXMLHandler this$0 -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void setGeo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.io.MyXMLHandler$LocateableExpPair -> geogebra.common.g.b$b:
    geogebra.common.kernel.Locateable locateable -> a
    java.lang.String exp -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    int number -> a
    geogebra.common.io.MyXMLHandler this$0 -> a
geogebra.common.io.MyXMLio -> geogebra.common.g.c:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.StringBuilder getUndoXML(geogebra.common.kernel.Construction) -> a
    void processXMLString(java.lang.String,boolean,boolean) -> a
    void processXMLString(java.lang.String,boolean,boolean,boolean) -> a
    void addGeoGebraHeader(java.lang.StringBuilder,boolean,java.lang.String) -> a
    void addXMLHeader(java.lang.StringBuilder) -> a
    java.lang.String getFullXML() -> a
    java.lang.String getFullMacroXML(java.util.ArrayList) -> a
    java.lang.String getPreferencesXML() -> b
    java.lang.String getConstructionRegressionOut() -> c
geogebra.common.io.QDParser -> geogebra.common.g.d:
    java.util.LinkedHashMap attrs -> a
    java.util.Stack stack -> a
    java.lang.StringBuilder sb -> a
    java.lang.StringBuilder etag -> b
    int CHAR_SPACE -> a
    int CHAR_TAB -> b
    int CHAR_CR -> c
    int CHAR_NL -> d
    boolean isWhitespace(char) -> a
    void reset() -> a
    int popMode(java.util.Stack) -> a
    void parse(geogebra.common.io.DocHandler,java.io.Reader) -> a
    void exc(java.lang.String,int,int) -> a
geogebra.common.io.layout.DockPanelData -> geogebra.common.g.a.a:
    int viewId -> a
    boolean isVisible -> a
    boolean openInFrame -> b
    boolean showStyleBar -> c
    geogebra.common.awt.Rectangle frameBounds -> a
    java.lang.String embeddedDef -> a
    java.lang.String toolbarString -> b
    int embeddedSize -> b
    int getViewId() -> a
    java.lang.String getToolbarString() -> a
    boolean isVisible() -> a
    boolean isOpenInFrame() -> b
    boolean showStyleBar() -> c
    geogebra.common.awt.Rectangle getFrameBounds() -> a
    java.lang.String getEmbeddedDef() -> b
    int getEmbeddedSize() -> b
    java.lang.String getXml() -> c
    java.lang.Object clone() -> clone
geogebra.common.io.layout.DockSplitPaneData -> geogebra.common.g.a.b:
    java.lang.String location -> a
    double dividerLocation -> a
    int orientation -> a
    java.lang.String getLocation() -> a
    double getDividerLocation() -> a
    int getOrientation() -> a
    java.lang.String getXml() -> b
geogebra.common.io.layout.Perspective -> geogebra.common.g.a.c:
    java.lang.String id -> a
    geogebra.common.io.layout.DockSplitPaneData[] splitPaneData -> a
    geogebra.common.io.layout.DockPanelData[] dockPanelData -> a
    java.lang.String toolbarDefinition -> b
    boolean showToolBar -> a
    boolean showGrid -> b
    boolean showAxes -> c
    boolean unitAxesRatio -> d
    boolean showInputPanel -> e
    boolean showInputPanelCommands -> f
    boolean showInputPanelOnTop -> g
    java.lang.String getId() -> a
    void setSplitPaneData(geogebra.common.io.layout.DockSplitPaneData[]) -> a
    geogebra.common.io.layout.DockSplitPaneData[] getSplitPaneData() -> a
    geogebra.common.io.layout.DockPanelData[] getDockPanelData() -> a
    void setDockPanelData(geogebra.common.io.layout.DockPanelData[]) -> a
    void setShowToolBar(boolean) -> a
    boolean getShowToolBar() -> a
    void setToolbarDefinition(java.lang.String) -> a
    java.lang.String getToolbarDefinition() -> b
    void setShowGrid(boolean) -> b
    boolean getShowGrid() -> b
    void setShowAxes(boolean) -> c
    boolean getShowAxes() -> c
    void setShowInputPanel(boolean) -> d
    boolean getShowInputPanel() -> d
    void setShowInputPanelCommands(boolean) -> e
    boolean getShowInputPanelCommands() -> e
    void setShowInputPanelOnTop(boolean) -> f
    boolean getShowInputPanelOnTop() -> f
    java.lang.String getXml() -> c
    void setUnitAxesRatio(boolean) -> g
    boolean isUnitAxesRatio() -> g
geogebra.common.javax.swing.Box -> geogebra.common.h.a.a:
    void add(geogebra.common.javax.swing.JLabel) -> a
    void add(geogebra.common.gui.inputfield.AutoCompleteTextField) -> a
    void setVisible(boolean) -> a
    void setBounds(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Dimension getPreferredSize() -> a
    geogebra.common.awt.Rectangle getBounds() -> a
    void validate() -> a
geogebra.common.javax.swing.JLabel -> geogebra.common.h.a.b:
    void setVisible(boolean) -> a
    void setText(java.lang.String) -> a
    void setOpaque(boolean) -> b
    void setFont(geogebra.common.awt.Font) -> a
    void setForeground(geogebra.common.awt.Color) -> a
    void setBackground(geogebra.common.awt.Color) -> b
geogebra.common.javax.swing.JPopupMenu -> geogebra.common.h.a.c:
geogebra.common.javax.swing.JSplitPane -> geogebra.common.h.a.d:
    int HORIZONTAL_SPLIT -> a
geogebra.common.javax.swing.JTextComponent -> geogebra.common.h.a.e:
    void replaceSelection(java.lang.String) -> a
geogebra.common.kernel.AbstractAnimationManager -> geogebra.common.i.a:
    geogebra.common.kernel.Kernel kernel -> a
    java.util.ArrayList animatedGeos -> a
    java.util.ArrayList changedGeos -> b
    double frameRate -> a
    boolean needToShowAnimationButton -> a
    java.util.TreeSet tempSet -> a
    boolean needToShowAnimationButton() -> a
    void updateNeedToShowAnimationButton() -> a
    void addAnimatedGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void removeAnimatedGeo(geogebra.common.kernel.geos.GeoElement) -> b
    void startAnimation() -> b
    void stopAnimation() -> c
    boolean isPaused() -> b
    void clearAnimatedGeos() -> d
    void adaptFrameRate(long) -> a
    java.util.TreeSet getTempSet() -> a
    void sliderStep() -> e
    boolean isRunning() -> c
    void setTimerDelay(int) -> a
    void stopTimer() -> f
    void startTimer() -> g
geogebra.common.kernel.AbstractUndoManager -> geogebra.common.i.b:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Construction construction -> a
    java.util.LinkedList undoInfoList -> a
    java.util.ListIterator iterator -> a
    void processXML(java.lang.String) -> a
    void undo() -> a
    void redo() -> b
    void updateUndoActions() -> c
    geogebra.common.kernel.AbstractUndoManager$AppState getCurrentUndoInfo() -> a
    void storeUndoInfo() -> d
    void restoreCurrentUndoInfo() -> e
    void initUndoInfo() -> f
    boolean undoPossible() -> a
    boolean redoPossible() -> b
    void storeUndoInfoAfterPasteOrAdd() -> g
    void storeUndoInfo(boolean) -> a
    void loadUndoInfo(geogebra.common.kernel.AbstractUndoManager$AppState) -> a
    void clearUndoInfo() -> h
    void pruneStateList() -> i
geogebra.common.kernel.AbstractUndoManager$AppState -> geogebra.common.i.b$a:
    void delete() -> a
geogebra.common.kernel.CircularDefinitionException -> geogebra.common.i.c:
geogebra.common.kernel.Construction -> geogebra.common.i.d:
    java.util.ArrayList usedMacros -> a
    geogebra.common.kernel.AbstractUndoManager undoManager -> a
    geogebra.common.kernel.ConstructionDefaults consDefaults -> a
    java.lang.String title -> a
    java.lang.String author -> b
    java.lang.String date -> c
    java.lang.String[] worksheetText -> a
    boolean showOnlyBreakpoints -> a
    geogebra.common.kernel.Kernel kernel -> a
    int step -> a
    boolean supressLabelCreation -> b
    java.util.HashMap geoSetsTypeMap -> d
    java.util.ArrayList ceList -> b
    java.util.ArrayList algoList -> c
    java.util.HashMap geoTable -> a
    java.util.ArrayList euclidianViewCE -> d
    java.util.HashMap localVariableTable -> b
    java.util.TreeSet geoSetConsOrder -> a
    java.util.TreeSet geoSetLabelOrder -> b
    java.util.TreeSet geoSetWithCasCells -> c
    java.util.TreeSet randomElements -> d
    java.util.HashMap geoCasCellTable -> c
    boolean collectRedefineCalls -> c
    java.util.HashMap redefineMap -> e
    geogebra.common.kernel.geos.GeoElement keepGeo -> a
    geogebra.common.kernel.geos.GeoAxis xAxis -> a
    geogebra.common.kernel.geos.GeoAxis yAxis -> b
    java.lang.String xAxisLocalName -> d
    java.lang.String yAxisLocalName -> e
    geogebra.common.kernel.geos.GeoPoint2 origin -> a
    boolean undoEnabled -> d
    geogebra.common.io.MyXMLio xmlio -> a
    geogebra.common.kernel.geos.GeoElement outputGeo -> b
    geogebra.common.kernel.arithmetic.FunctionVariable registredFV -> a
    void newConstructionDefaults() -> a
    geogebra.common.kernel.geos.GeoElement getKeepGeo() -> a
    geogebra.common.kernel.geos.GeoPoint2 getOrigin() -> a
    geogebra.common.kernel.geos.GeoAxis getXAxis() -> a
    geogebra.common.kernel.geos.GeoAxis getYAxis() -> b
    void initAxis() -> b
    void updateLocalAxesNames() -> c
    geogebra.common.kernel.ConstructionDefaults getConstructionDefaults() -> a
    java.lang.String getAuthor() -> a
    java.lang.String getDate() -> b
    java.lang.String getTitle() -> c
    void setAuthor(java.lang.String) -> a
    void setDate(java.lang.String) -> b
    void setTitle(java.lang.String) -> c
    java.lang.String getWorksheetText(int) -> a
    void setWorksheetText(java.lang.String,int) -> a
    boolean worksheetTextDefined() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void setSuppressLabelCreation(boolean) -> a
    boolean isSuppressLabelsActive() -> b
    geogebra.common.main.AbstractApplication getApplication() -> a
    boolean isEmpty() -> c
    int steps() -> a
    geogebra.common.kernel.geos.GeoElement getLastGeoElement() -> b
    geogebra.common.kernel.geos.GeoCasCell getCasCell(int) -> a
    geogebra.common.kernel.geos.GeoCasCell getLastCasCell() -> a
    void setCasCellRow(geogebra.common.kernel.geos.GeoCasCell,int) -> a
    void addLocalVariable(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    void removeLocalVariable(java.lang.String) -> d
    geogebra.common.kernel.geos.GeoElement geoTableVarLookup(java.lang.String) -> a
    void setShowOnlyBreakpoints(boolean) -> b
    boolean showOnlyBreakpoints() -> d
    void updateConstructionIndex(int) -> a
    boolean updateAllConstructionProtocolAlgorithms() -> e
    void addToConstructionList(geogebra.common.kernel.algos.ConstructionElement,int) -> a
    void updateCasCellRows() -> d
    boolean moveInConstructionList(int,int) -> a
    void addToConstructionList(geogebra.common.kernel.algos.ConstructionElement,boolean) -> a
    void removeFromConstructionList(geogebra.common.kernel.algos.ConstructionElement) -> a
    void addToAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> b
    boolean moveInConstructionList(geogebra.common.kernel.geos.GeoElement,int) -> a
    void updateAllAlgorithms() -> e
    void registerEuclidianViewCE(geogebra.common.kernel.EuclidianViewCE) -> a
    void unregisterEuclidianViewCE(geogebra.common.kernel.EuclidianViewCE) -> b
    boolean notifyEuclidianViewCE() -> f
    boolean hasEuclidianViewCE() -> g
    void updateAllRandomGeos() -> f
    void addRandomGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void removeRandomGeo(geogebra.common.kernel.geos.GeoElement) -> b
    void updateConstruction() -> g
    void getConstructionXML(java.lang.StringBuilder) -> a
    void getConstructionElementsXML(java.lang.StringBuilder) -> b
    void getConstructionRegressionOut(java.lang.StringBuilder) -> c
    boolean isUndoEnabled() -> h
    void setUndoEnabled(boolean) -> c
    geogebra.common.kernel.algos.ConstructionElement getConstructionElement(int) -> a
    java.util.TreeSet getGeoSetConstructionOrder() -> a
    java.util.TreeSet getGeoSetWithCasCellsConstructionOrder() -> b
    java.util.TreeSet getGeoSetLabelOrder() -> c
    void startCollectingRedefineCalls() -> h
    void stopCollectingRedefineCalls() -> i
    void replace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void processCollectedRedefineCalls() -> j
    void changeCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    void doReplaceInXML(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void setStep(int) -> b
    int getStep() -> b
    void putLabel(geogebra.common.kernel.geos.GeoElement) -> c
    void removeLabel(geogebra.common.kernel.geos.GeoElement) -> d
    void addToGeoSets(geogebra.common.kernel.geos.GeoElement) -> e
    java.util.TreeSet getGeoSetLabelOrder(geogebra.common.plugin.GeoClass) -> a
    java.util.TreeSet createTypeSet(geogebra.common.plugin.GeoClass) -> b
    void removeFromGeoSets(geogebra.common.kernel.geos.GeoElement) -> f
    void putCasCellLabel(geogebra.common.kernel.geos.GeoCasCell,java.lang.String) -> a
    void removeCasCellLabel(java.lang.String) -> e
    void removeCasCellLabel(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoCasCell lookupCasCellLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasRowReference(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement checkConstructionStep(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFreeLabel(java.lang.String) -> a
    boolean isFreeLabel(java.lang.String,boolean) -> a
    void updateConstructionOrder(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> c
    boolean updateConstructionOrder(geogebra.common.kernel.geos.GeoCasCell) -> a
    void prepareReplace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    void addToGeoSetWithCasCells(geogebra.common.kernel.geos.GeoCasCell) -> b
    void removeFromGeoSetWithCasCells(geogebra.common.kernel.geos.GeoCasCell) -> c
    geogebra.common.kernel.geos.GeoElement createSpreadsheetGeoElement(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    java.lang.String getIndexLabel(java.lang.String,int) -> a
    java.lang.String getIndexLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement autoCreateGeoElement(java.lang.String) -> c
    geogebra.common.kernel.geos.GeoFunction createFunction(geogebra.common.plugin.Operation) -> a
    void initGeoTables() -> k
    java.util.TreeSet getGeoSetNameDescriptionOrder() -> d
    geogebra.common.kernel.optimization.ExtremumFinder getExtremumFinder() -> a
    void storeUndoInfo() -> l
    void restoreCurrentUndoInfo() -> m
    void redo() -> n
    void undo() -> o
    boolean undoPossible() -> i
    boolean redoPossible() -> j
    void addUsedMacro(geogebra.common.kernel.Macro) -> a
    java.util.ArrayList getUsedMacros() -> a
    void clearConstruction() -> p
    java.lang.StringBuilder getCurrentUndoXML() -> a
    void setXMLio(geogebra.common.io.MyXMLio) -> a
    void initUndoInfo() -> q
    void buildConstruction(java.lang.StringBuilder) -> d
    geogebra.common.kernel.AbstractUndoManager getUndoManager() -> a
    void setOutputGeo(java.lang.String) -> f
    geogebra.common.kernel.geos.GeoElement getOutputGeo() -> c
    void registerFunctionVariable(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.FunctionVariable getRegistredFunctionVariable() -> a
geogebra.common.kernel.Construction$LabelComparator -> geogebra.common.i.d$a:
    geogebra.common.kernel.Construction this$0 -> a
    int compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.ConstructionDefaults -> geogebra.common.i.e:
    geogebra.common.awt.Color colPoint -> a
    geogebra.common.awt.Color colDepPoint -> b
    geogebra.common.awt.Color colPathPoint -> c
    geogebra.common.awt.Color colRegionPoint -> d
    geogebra.common.awt.Color colComplexPoint -> e
    geogebra.common.awt.Color colLine -> i
    geogebra.common.awt.Color colInequality -> j
    geogebra.common.awt.Color colConic -> k
    geogebra.common.awt.Color colPolygon -> f
    geogebra.common.awt.Color colAngle -> l
    geogebra.common.awt.Color colLocus -> m
    geogebra.common.awt.Color colFunction -> n
    geogebra.common.awt.Color colList -> o
    geogebra.common.awt.Color colPreview -> g
    geogebra.common.awt.Color colPreviewFill -> h
    geogebra.common.kernel.Construction cons -> a
    java.util.HashMap defaultGeoElements -> a
    int lineThickness -> a
    int pointSize -> b
    int angleSize -> c
    float filling -> a
    boolean blackWhiteMode -> a
    java.lang.String strFree -> a
    java.lang.String strDependent -> b
    java.lang.String strIntersection -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void createDefaultGeoElementsFromScratch() -> a
    void createDefaultGeoElements() -> b
    java.lang.String getCDXML() -> a
    geogebra.common.kernel.geos.GeoElement getDefaultGeo(int) -> a
    void addDefaultGeo(java.lang.Integer,geogebra.common.kernel.geos.GeoElement) -> a
    int getDefaultType(geogebra.common.kernel.geos.GeoElement) -> a
    void setMaxLayerUsed(geogebra.common.kernel.geos.GeoElement,geogebra.common.main.AbstractApplication) -> a
    void setDefaultVisualStyles(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setBlackWhiteMode(boolean) -> a
    void resetDefaults() -> c
    void setDefaultAngleSize(int) -> a
    void setDefaultPointSize(int) -> b
    void setDefaultLineThickness(int) -> c
    void setDefaultFilling(float) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.ConstructionElementCycle -> geogebra.common.i.f:
    long minID -> a
    int minIndex -> a
    int direction -> b
    int cycleIndex -> c
    geogebra.common.kernel.ConstructionElementCycle SegmentDescription(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    boolean add(geogebra.common.kernel.algos.ConstructionElement) -> a
    void setDirection() -> a
    int compareTo(geogebra.common.kernel.ConstructionElementCycle) -> a
    boolean equals(java.lang.Object) -> equals
    void setCycleFirst() -> b
    geogebra.common.kernel.algos.ConstructionElement getCycleNext() -> a
    java.lang.String toString() -> toString
    boolean add(java.lang.Object) -> add
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.EquationSolver -> geogebra.common.i.g:
    org.apache.commons.math.analysis.solvers.LaguerreSolver laguerreSolver -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinderBrent -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinderNewton -> b
    java.util.Comparator comparatorReal -> a
    int polynomialRoots(double[],boolean) -> a
    int polynomialComplexRoots(double[],double[]) -> a
    int solveQuadratic(double[],double[]) -> b
    int solveQuadraticComplex(double[],double[]) -> c
    int solveCubic(double[],double[]) -> d
    void fixRoots(double[],double[]) -> a
    double solveEqn(double[],int,double) -> a
    double findZero(double,double,double[]) -> a
    int getTag(double,double,double) -> a
    int laguerreAll(double[]) -> a
    int laguerreAllComplex(double[],double[]) -> f
    int solveQuartic(double[],double[]) -> e
    java.util.Comparator getComparatorReal() -> a
geogebra.common.kernel.EquationSolver$1 -> geogebra.common.i.h:
    int compare(org.apache.commons.math.complex.Complex,org.apache.commons.math.complex.Complex) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.EquationSolverInterface -> geogebra.common.i.i:
    int solveCubic(double[],double[]) -> d
    int solveQuadratic(double[],double[]) -> b
    int solveQuartic(double[],double[]) -> e
    int polynomialRoots(double[],boolean) -> a
    int polynomialComplexRoots(double[],double[]) -> a
geogebra.common.kernel.EuclidianViewCE -> geogebra.common.i.j:
    boolean euclidianViewUpdate() -> a
geogebra.common.kernel.Kernel -> geogebra.common.i.k:
    int MAX_SPREADSHEET_COLUMNS -> a
    int MAX_SPREADSHEET_ROWS -> b
    int algebraStyle -> e
    geogebra.common.kernel.MacroManager macroManager -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    boolean insertLineBreaks -> a
    boolean viewReiniting -> c
    boolean undoActive -> d
    geogebra.common.kernel.View[] views -> a
    int viewCnt -> c
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator expressionNodeEvaluator -> a
    int kernelInstances -> f
    boolean continuous -> e
    geogebra.common.kernel.PathRegionHandling usePathAndRegionParameters -> a
    int kernelID -> g
    java.lang.String casVariablePrefix -> a
    geogebra.common.kernel.cas.GeoGebraCasInterface ggbCAS -> a
    double SQRT_2_HALF -> a
    int GEOGEBRA_CAS_CACHE_SIZE -> d
    double PRINT_PRECISION -> d
    geogebra.common.util.NumberFormatAdapter nf -> a
    geogebra.common.util.ScientificFormatAdapter sf -> a
    boolean useSignificantFigures -> b
    int coordStyle -> h
    double EPSILON -> b
    double EPSILON_SQRT -> c
    double ROUND_HALF_UP_FACTOR -> e
    boolean useInternalCommandNames -> f
    boolean notifyConstructionProtocolViewAboutAddRemoveActive -> g
    boolean allowVisibilitySideEffects -> h
    boolean saveScriptsToXML -> i
    boolean elementDefaultAllowed -> j
    boolean silentMode -> k
    boolean wantAnimationStarted -> l
    boolean resolveUnkownVarsAsDummyGeos -> m
    java.lang.StringBuilder sbBuildExplicitLineEquation -> a
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.EquationSolver eqnSolver -> a
    geogebra.common.kernel.SystemOfEquationsSolver sysEqSolv -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.Manager3DInterface manager3D -> a
    geogebra.common.kernel.AbstractAnimationManager animationManager -> a
    boolean loadingMode -> n
    geogebra.common.main.AbstractApplication$CasType DEFAULT_CAS -> a
    double[] temp -> a
    java.lang.StringBuilder sbFormat -> b
    java.lang.StringBuilder formatSB -> c
    java.lang.StringBuilder sbBuildImplicitEquation -> d
    java.lang.StringBuilder sbBuildLHS -> e
    java.lang.StringBuilder sbBuildExplicitConicEquation -> f
    java.lang.StringBuilder sbBuildImplicitVarPart -> g
    java.lang.StringBuilder sbFormatSF -> h
    java.lang.String libraryJavaScript -> b
    java.lang.String libraryPythonScript -> c
    java.lang.String libraryLogoScript -> d
    boolean isSaving -> o
    java.lang.StringBuilder sbFormatAngle -> i
    boolean arcusFunctionCreatesAngle -> p
    int angleUnit -> i
    boolean keepCasNumbers -> q
    geogebra.common.util.MaxSizeHashMap ggbCasCache -> a
    double xmin -> f
    double xmax -> g
    double ymin -> h
    double ymax -> i
    double xscale -> j
    double yscale -> k
    double xmin2 -> l
    double xmax2 -> m
    double ymin2 -> n
    double ymax2 -> o
    double xscale2 -> p
    double yscale2 -> q
    boolean graphicsView2showing -> r
    java.util.ArrayList intersectionAlgos -> a
    boolean notifyRepaint -> s
    int oldViewCnt -> j
    boolean notifyViewsActive -> t
    java.util.ArrayList renameListenerAlgos -> b
    geogebra.common.kernel.geos.GeoVec2D imaginaryUnit -> a
    geogebra.common.kernel.geos.GeoElementSpreadsheet ges -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> b
    geogebra.common.kernel.commands.AlgebraProcessor getAlgebraProcessor() -> a
    geogebra.common.kernel.commands.AlgebraProcessor newAlgebraProcessor(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.Manager3DInterface newManager3D(geogebra.common.kernel.Kernel) -> a
    void setManager3D(geogebra.common.kernel.Manager3DInterface) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND getDefaultPlane() -> a
    geogebra.common.kernel.Manager3DInterface getManager3D() -> a
    void newConstruction() -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Construction) -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Kernel,geogebra.common.kernel.Construction) -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.kernel.EquationSolver getEquationSolver() -> a
    geogebra.common.kernel.SystemOfEquationsSolver getSystemOfEquationsSolver(geogebra.common.kernel.EquationSolverInterface) -> a
    geogebra.common.kernel.optimization.ExtremumFinder getExtremumFinder() -> a
    geogebra.common.kernel.parser.Parser getParser() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator newExpressionNodeEvaluator() -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator getExpressionNodeEvaluator() -> b
    java.util.Comparator DoubleComparator(double) -> a
    boolean isAnimationRunning() -> a
    boolean isAnimationPaused() -> b
    boolean needToShowAnimationButton() -> c
    void udpateNeedToShowAnimationButton() -> b
    boolean handleCoords(geogebra.common.kernel.geos.GeoElement,java.util.LinkedHashMap) -> a
    geogebra.common.kernel.Construction getConstruction() -> a
    geogebra.common.kernel.algos.ConstructionElement getConstructionElement(int) -> a
    void setConstructionStep(int) -> a
    int getConstructionStep() -> a
    int getLastConstructionStep() -> b
    void firstStep() -> c
    void lastStep() -> d
    void nextStep() -> e
    int getNextBreakpoint(int) -> a
    void previousStep() -> f
    int getPreviousBreakpoint(int) -> b
    boolean moveInConstructionList(int,int) -> a
    void setSaveScriptsToXML(boolean) -> a
    boolean getSaveScriptsToXML() -> d
    void setElementDefaultAllowed(boolean) -> b
    boolean getElementDefaultAllowed() -> e
    boolean isContinuous() -> f
    void setContinuous(boolean) -> c
    boolean usePathAndRegionParameters(geogebra.common.kernel.geos.GeoElement) -> a
    void setUsePathAndRegionParameters(geogebra.common.kernel.PathRegionHandling) -> a
    void setLoadingMode(boolean) -> d
    boolean getLoadingMode() -> g
    char sign(double) -> a
    void setNotifyConstructionProtocolViewAboutAddRemoveActive(boolean) -> e
    boolean isNotifyConstructionProtocolViewAboutAddRemoveActive() -> h
    java.lang.StringBuilder buildImplicitEquation(double[],java.lang.String[],boolean,boolean,char,geogebra.common.kernel.StringTemplate) -> a
    void formatSignedCoefficient(double,java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    void formatSigned(double,java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String formatPiERaw(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String formatRaw(double,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatNF(double,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String format(double,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String internationalizeDigits(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatPiE(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.kernel.StringTemplate) -> a
    void copy(double[],double[]) -> a
    void negative(double[],double[]) -> b
    void divide(double[],double,double[]) -> a
    long gcd(long,long) -> a
    double gcd(double[]) -> a
    double roundToScale(double,double) -> a
    void unbindVariableInGeoGebraCAS(java.lang.String) -> a
    java.lang.StringBuilder buildLHS(double[],java.lang.String[],boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    char oppositeSign(char) -> a
    java.lang.StringBuilder buildImplicitVarPart(double[],java.lang.String[],boolean,boolean,geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildExplicitConicEquation(double[],java.lang.String[],int,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String formatSF(double,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String formatCoeff(double,geogebra.common.kernel.StringTemplate) -> e
    java.lang.StringBuilder buildExplicitLineEquation(double[],java.lang.String[],char,geogebra.common.kernel.StringTemplate) -> a
    boolean isZero(double) -> a
    boolean isInteger(double) -> b
    boolean isEqual(double,double) -> a
    boolean isEqual(double,double,double) -> a
    boolean isGreater(double,double) -> b
    boolean isGreater(double,double,double) -> b
    boolean isGreaterEqual(double,double) -> c
    double convertToAngleValue(double) -> a
    double checkDecimalFraction(double,double) -> b
    double checkDecimalFraction(double) -> b
    double checkInteger(double) -> c
    java.lang.StringBuilder formatAngle(double,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String convertScientificNotation(java.lang.String,geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder formatAngle(double,double,geogebra.common.kernel.StringTemplate) -> a
    void resetLibraryJavaScript() -> g
    void resetLibraryPythonScript() -> h
    void setLibraryPythonScript(java.lang.String) -> b
    void setLibraryLogoScript(java.lang.String) -> c
    void setLibraryJavaScript(java.lang.String) -> d
    java.lang.String getLibraryJavaScript() -> a
    java.lang.String getLibraryPythonScript() -> b
    java.util.TreeSet getPointSet() -> a
    boolean isSaving() -> i
    void setSaving(boolean) -> f
    void setInverseTrigReturnsAngle(boolean) -> g
    boolean getInverseTrigReturnsAngle() -> j
    void setAngleUnit(int) -> b
    int getAngleUnit() -> c
    boolean isZvarAllowed() -> k
    void setEpsilon(double) -> a
    void setEpsilonForPrintPrecision(double) -> b
    double getEpsilon() -> a
    void setMinPrecision() -> i
    void resetPrecision() -> j
    boolean isKeepCasNumbers() -> l
    void setKeepCasNumbers(boolean) -> h
    java.lang.String printVariableName(java.lang.String,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String printVariableName(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,java.lang.String) -> a
    java.lang.String getCasVariablePrefix() -> c
    java.lang.String addTempVariablePrefix(java.lang.String) -> b
    java.lang.String addCASVariablePrefix(java.lang.String) -> c
    java.lang.String removeCASVariablePrefix(java.lang.String) -> a
    java.lang.String removeCASVariablePrefix(java.lang.String,java.lang.String) -> a
    void setPrintFigures(int) -> c
    void setPrintDecimals(int) -> d
    int getPrintDecimals() -> d
    int getPrintFigures() -> e
    boolean isUsingInternalCommandNames() -> m
    void setUseInternalCommandNames(boolean) -> i
    boolean isAllowVisibilitySideEffects() -> n
    void setAllowVisibilitySideEffects(boolean) -> j
    boolean isMacroKernel() -> o
    boolean isSilentMode() -> p
    boolean isGeoGebraCASready() -> q
    void setSilentMode(boolean) -> k
    void setResolveUnkownVarsAsDummyGeos(boolean) -> l
    boolean isResolveUnkownVarsAsDummyGeos() -> r
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String evaluateCachedGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> b
    java.lang.String evaluateGeoGebraCAS(java.lang.String,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.cas.AsynchronousCommand) -> a
    void putToCasCache(java.lang.String,java.lang.String) -> a
    void resetGeoGebraCAS() -> k
    void setAlgebraStyle(int) -> e
    int getAlgebraStyle() -> f
    geogebra.common.util.MaxSizeHashMap getCasCache() -> a
    boolean hasCasCache() -> s
    void setEuclidianViewBounds(int,double,double,double,double,double,double) -> a
    double getViewsXMin(geogebra.common.kernel.geos.GeoElement) -> a
    double getViewsXMax(geogebra.common.kernel.geos.GeoElement) -> b
    double getViewsYMin(geogebra.common.kernel.geos.GeoElement) -> c
    double getViewsYMax(geogebra.common.kernel.geos.GeoElement) -> d
    void notifyEuclidianViewCE() -> l
    void clearConstruction() -> m
    double getXmax() -> b
    double getXmin() -> c
    double getXscale() -> d
    double getYmax() -> e
    double getYmin() -> f
    double getYscale() -> g
    geogebra.common.kernel.cas.GeoGebraCasInterface getGeoGebraCAS() -> a
    int getCoordStyle() -> g
    void setCoordStyle(int) -> f
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasCellLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoCasCell lookupCasRowReference(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    java.lang.String getModeText(int) -> a
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement getGeoAt(int,int) -> a
    geogebra.common.kernel.AbstractAnimationManager getAnimatonManager() -> a
    void removeIntersectionAlgorithm(geogebra.common.kernel.algos.AlgoIntersectAbstract) -> a
    void addIntersectionAlgorithm(geogebra.common.kernel.algos.AlgoIntersectAbstract) -> b
    double[] getViewBoundsForGeo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoAxis getXAxis() -> a
    geogebra.common.kernel.geos.GeoAxis getYAxis() -> b
    boolean isAxis(geogebra.common.kernel.geos.GeoElement) -> b
    void updateLocalAxesNames() -> n
    void setNotifyRepaintActive(boolean) -> m
    void notifyRepaint() -> o
    void notifyReset() -> p
    void notifyClearView() -> q
    void clearJustCreatedGeosInViews() -> r
    void setNotifyViewsActive(boolean) -> n
    void attach(geogebra.common.kernel.View) -> a
    void detach(geogebra.common.kernel.View) -> b
    void notifyModeChanged(int) -> g
    void notifyAddAll(geogebra.common.kernel.View) -> c
    void registerRenameListenerAlgo(geogebra.common.kernel.algos.AlgoElement) -> a
    void notifyRenameListenerAlgos() -> B
    void notifyAddAll(geogebra.common.kernel.View,int) -> a
    void notifyAdd(geogebra.common.kernel.geos.GeoElement) -> a
    void notifyRemove(geogebra.common.kernel.geos.GeoElement) -> b
    void notifyUpdate(geogebra.common.kernel.geos.GeoElement) -> c
    void notifyUpdateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void notifyUpdateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> e
    void notifyRename(geogebra.common.kernel.geos.GeoElement) -> f
    boolean isNotifyViewsActive() -> t
    boolean isViewReiniting() -> u
    void updateConstruction() -> s
    boolean isEmpty() -> v
    void setUndoActive(boolean) -> o
    boolean isUndoActive() -> w
    void storeUndoInfo() -> t
    void initUndoInfo() -> u
    void redo() -> v
    void undo() -> w
    boolean undoPossible() -> x
    boolean redoPossible() -> y
    boolean isInsertLineBreaks() -> z
    geogebra.common.kernel.arithmetic.ExpressionNode handleTrigPower(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.plugin.Operation) -> a
    geogebra.common.kernel.geos.GeoNumeric convertIndexToNumber(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoPoint2 Point(java.lang.String,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 Point(java.lang.String,double,double,boolean) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,double,double) -> a
    geogebra.common.kernel.geos.GeoVector Vector(double,double) -> a
    geogebra.common.kernel.geos.GeoConic Conic(java.lang.String,double,double,double,double,double,double) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly ImplicitPoly(java.lang.String,geogebra.common.kernel.arithmetic.Polynomial) -> a
    geogebra.common.kernel.geos.GeoElement DependentImplicitPoly(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoBoolean DependentBoolean(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoBoolean Prove(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoPoint2 Point(java.lang.String,geogebra.common.kernel.Path,double,double,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint2 Point(java.lang.String,geogebra.common.kernel.Path,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 ClosestPoint(java.lang.String,geogebra.common.kernel.Path,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement Point(java.lang.String,geogebra.common.kernel.Path) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,double,double,double) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoNumeric AffineRatio(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoFunction Function(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar FunctionNVar(java.lang.String,geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.geos.GeoInterval Interval(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoRay Ray(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.kernelND.GeoRayND RayND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoRay Ray(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoLine OrthogonalLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoLine OrthogonalLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> b
    geogebra.common.kernel.geos.GeoLine LineBisector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> b
    geogebra.common.kernel.geos.GeoLine LineBisector(java.lang.String,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoLine AngularBisector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoLine[] AngularBisector(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoVector Vector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoVector Direction(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoNumeric Slope(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoBoolean Boolean(java.lang.String,boolean) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND SegmentND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoSegment Segment(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoList List(java.lang.String,java.util.ArrayList,boolean) -> a
    geogebra.common.kernel.geos.GeoList ListExpression(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoCasCell DependentCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    geogebra.common.kernel.geos.GeoNumeric DependentNumber(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint2 DependentPoint(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode,boolean) -> a
    geogebra.common.kernel.geos.GeoVector DependentVector(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoLine DependentLine(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoConic DependentConic(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoFunction DependentFunction(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> b
    geogebra.common.kernel.geos.GeoFunctionNVar DependentFunctionNVar(java.lang.String,geogebra.common.kernel.arithmetic.FunctionNVar) -> b
    geogebra.common.kernel.geos.GeoFunction DependentInterval(java.lang.String,geogebra.common.kernel.arithmetic.Function) -> c
    geogebra.common.kernel.geos.GeoText DependentText(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement DependentGeoCopy(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement DependentGeoCopy(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoTextField textfield(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoLine Line(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVector) -> b
    geogebra.common.kernel.geos.GeoElement[] Segment(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Angle(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Angle(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.geos.GeoAngle Angle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement[] Angles(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoNumeric getDefaultNumber(boolean) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoConic Incircle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> b
    geogebra.common.kernel.geos.GeoConicPart ConicArc(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConicPart ConicArc(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoConicPart ConicSector(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoConicPart ConicSector(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> b
    geogebra.common.kernel.geos.GeoConicPart CircumcircleArc(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoConicPart CircumcircleSector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> b
    geogebra.common.kernel.geos.GeoConicPart CircleArc(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> c
    geogebra.common.kernel.geos.GeoConicPart CircleSector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> d
    geogebra.common.kernel.geos.GeoPoint2[] Focus(java.lang.String[],geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoPoint2[] Vertex(java.lang.String[],geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoElement[] Vertex(java.lang.String[],geogebra.common.kernel.geos.GeoPolyLineInterface) -> a
    geogebra.common.kernel.geos.GeoPoint2 Vertex(java.lang.String,geogebra.common.kernel.geos.GeoPolyLineInterface,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 Center(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoPoint2 Centroid(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoPoint2 Corner(java.lang.String,geogebra.common.kernel.geos.GeoImage,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 Corner(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConic CircleCompasses(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> c
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoConic Circle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoConicPart Semicircle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoConic Parabola(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoConic Ellipse(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoConic Ellipse(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> d
    geogebra.common.kernel.geos.GeoConic Hyperbola(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoConic Hyperbola(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> e
    geogebra.common.kernel.geos.GeoConic Conic(java.lang.String,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    geogebra.common.kernel.geos.GeoElement[] Conic(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoLine PolarLine(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine DiameterLine(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine DiameterLine(java.lang.String,geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoBoolean isInRegion(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Region) -> a
    geogebra.common.kernel.geos.GeoElement[] Sequence(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement[] Zip(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoList[]) -> a
    geogebra.common.kernel.geos.GeoElement[] OrthogonalLineToConic(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoVec2D getImaginaryUnit() -> a
    geogebra.common.kernel.geos.GeoElement[] useMacro(java.lang.String[],geogebra.common.kernel.Macro,geogebra.common.kernel.geos.GeoElement[]) -> a
    void getKernelXML(java.lang.StringBuilder,boolean) -> a
    void addMacro(geogebra.common.kernel.Macro) -> a
    void removeMacro(geogebra.common.kernel.Macro) -> b
    void removeAllMacros() -> x
    boolean setMacroCommandName(geogebra.common.kernel.Macro,java.lang.String) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    java.lang.String getMacroXML(java.util.ArrayList) -> a
    boolean hasMacros() -> A
    int getMacroNumber() -> h
    java.util.ArrayList getAllMacros() -> a
    geogebra.common.kernel.Macro getMacro(int) -> a
    int getMacroID(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.geos.GeoElement createGeoElement(geogebra.common.kernel.Construction,java.lang.String) -> a
    void setWantAnimationStarted() -> y
    boolean wantAnimationStarted() -> B
    geogebra.common.kernel.arithmetic.ExpressionNode convertNumberValueToExpressionNode(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.statistics.RegressionMath getRegressionMath() -> a
    geogebra.common.kernel.geos.GeoNumeric AxisStepX(java.lang.String) -> b
    geogebra.common.kernel.geos.GeoNumeric AxisStepY(java.lang.String) -> c
    geogebra.common.kernel.geos.GeoLine[] Asymptote(java.lang.String[],geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine[] Axes(java.lang.String[],geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoList AsymptoteFunction(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoList AsymptoteImplicitpoly(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoNumeric Area(java.lang.String,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    geogebra.common.kernel.geos.GeoNumeric Area(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoNumeric Area(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoList Append(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoList Append(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] ApplyMatrix(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric Cauchy(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement Cell(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric ChiSquared(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement CompleteSquare(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint2[] ComplexRoot(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoNumeric Column(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoList CellRange(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoList Classes(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Classes(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Coefficients(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoList Coefficients(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoText ColumnName(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoNumeric ConstructionStep(java.lang.String) -> d
    geogebra.common.kernel.geos.GeoNumeric ConstructionStep(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoNumeric CountIf(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric Curvature(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoNumeric CurvatureCurve(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoNumeric CrossRatio(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoNumeric Covariance(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric Covariance(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoVector CurvatureVector(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoVector CurvatureVectorCurve(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoCurveCartesian CurveCartesian(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Perimeter(java.lang.String,geogebra.common.kernel.geos.GeoPolygon) -> b
    geogebra.common.kernel.geos.GeoNumeric Perimeter(java.lang.String,geogebra.common.kernel.geos.GeoLocus) -> a
    geogebra.common.kernel.geos.GeoNumeric Circumference(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoNumeric PMCC(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoNumeric PMCC(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoNumeric MeanX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoNumeric MeanY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoNumeric SDY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoNumeric SDX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> f
    geogebra.common.kernel.geos.GeoNumeric SampleSDX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> g
    geogebra.common.kernel.geos.GeoNumeric SampleSDY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> h
    geogebra.common.kernel.geos.GeoNumeric SXX(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoNumeric SXY(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoNumeric SXY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> i
    geogebra.common.kernel.geos.GeoNumeric SYY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> j
    geogebra.common.kernel.geos.GeoNumeric SXX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> k
    geogebra.common.kernel.geos.GeoNumeric Degree(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoBoolean Defined(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoFunction Denominator(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoElement Derivative(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Dilate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement[] Dilate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoLine Directrix(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoNumeric Distance(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoNumeric Div(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoFunction Div(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoElement DynamicCoordinates(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Eccentricity(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> c
    geogebra.common.kernel.geos.GeoElement Element(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement Element(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue[]) -> a
    geogebra.common.kernel.geos.GeoNumeric Excentricity(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> d
    geogebra.common.kernel.geos.GeoElement Expand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction) -> a
    geogebra.common.kernel.geos.GeoNumeric Exponential(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.geos.GeoPoint2[] Extremum(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoPoint2[] Extremum(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement Factor(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction) -> b
    geogebra.common.kernel.geos.GeoList Factors(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> c
    geogebra.common.kernel.geos.GeoList PrimeFactorisation(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric FDistribution(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoList First(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoText First(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList FirstLocus(java.lang.String,geogebra.common.kernel.geos.GeoLocus,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoLine FirstAxis(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoNumeric FirstAxisLength(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> e
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoNumeric BarChart(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Binomial(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> d
    geogebra.common.kernel.geos.GeoNumeric RandomNormal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> e
    geogebra.common.kernel.geos.GeoNumeric Random(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> f
    geogebra.common.kernel.geos.GeoNumeric RandomUniform(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> g
    geogebra.common.kernel.geos.GeoNumeric RandomBinomial(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> h
    geogebra.common.kernel.geos.GeoNumeric BoxPlot(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric BoxPlot(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoPoint2 Point(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoPoint2[] PointsFromList(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Flatten(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FractionText(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoPolyLine FrequencyPolygon(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoPolyLine FrequencyPolygon(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoPolyLine FrequencyPolygon(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoPolyLine FrequencyPolygon(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoFunction Function(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoFunction Function(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric Gamma(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.geos.GeoNumeric GCD(java.lang.String,geogebra.common.kernel.geos.GeoList) -> l
    geogebra.common.kernel.geos.GeoNumeric GCD(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> i
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Histogram(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric,boolean) -> a
    geogebra.common.kernel.geos.GeoElement If(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoFunction If(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly ImplicitPoly(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly ImplicitPoly(java.lang.String,geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    geogebra.common.kernel.geos.GeoNumeric IndexOf(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoNumeric IndexOf(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric IndexOf(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoNumeric IndexOf(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Sequence(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoText Name(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoElement Object(java.lang.String,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoText LaTeX(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText LaTeX(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText Text(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoNumeric Row(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoNumeric LetterToUnicode(java.lang.String,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoList TextToUnicode(java.lang.String,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoText UnicodeToLetter(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoText UnicodeToText(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText Ordinal(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoPoint2 PointIn(java.lang.String,geogebra.common.kernel.Region,double,double,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint2 PointIn(java.lang.String,geogebra.common.kernel.Region) -> a
    geogebra.common.kernel.geos.GeoPoint2 ClosestPoint(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoPoint2 Midpoint(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2 Midpoint(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2 Midpoint(java.lang.String,geogebra.common.kernel.geos.GeoSegment) -> a
    geogebra.common.kernel.geos.GeoNumeric Midpoint(java.lang.String,geogebra.common.kernel.geos.GeoInterval) -> a
    geogebra.common.kernel.geos.GeoNumeric Min(java.lang.String,geogebra.common.kernel.geos.GeoInterval) -> b
    geogebra.common.kernel.geos.GeoNumeric Max(java.lang.String,geogebra.common.kernel.geos.GeoInterval) -> c
    geogebra.common.kernel.geos.GeoList DotPlot(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoList NormalQuantilePlot(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoNumeric UpperSum(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric TrapezoidalSum(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric LowerSum(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.geos.GeoNumeric LeftSum(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> d
    geogebra.common.kernel.geos.GeoNumeric RectangleSum(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric SumSquaredErrors(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoFunctionable) -> a
    geogebra.common.kernel.geos.GeoNumeric RSquare(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoFunctionable) -> b
    geogebra.common.kernel.geos.GeoList ResidualPlot(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoFunctionable) -> a
    geogebra.common.kernel.geos.GeoVector UnitVector(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> b
    geogebra.common.kernel.geos.GeoVector UnitVector(java.lang.String,geogebra.common.kernel.geos.GeoVector) -> a
    geogebra.common.kernel.geos.GeoVector OrthogonalVector(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> c
    geogebra.common.kernel.geos.GeoVector OrthogonalVector(java.lang.String,geogebra.common.kernel.geos.GeoVector) -> b
    geogebra.common.kernel.geos.GeoVector UnitOrthogonalVector(java.lang.String,geogebra.common.kernel.geos.GeoLine) -> d
    geogebra.common.kernel.geos.GeoVector UnitOrthogonalVector(java.lang.String,geogebra.common.kernel.geos.GeoVector) -> c
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.geos.GeoNumeric Mod(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> j
    geogebra.common.kernel.geos.GeoFunction Mod(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoNumeric Min(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> k
    geogebra.common.kernel.geos.GeoNumeric Min(java.lang.String,geogebra.common.kernel.geos.GeoList) -> m
    geogebra.common.kernel.geos.GeoPoint2 Min(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Max(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> l
    geogebra.common.kernel.geos.GeoNumeric Max(java.lang.String,geogebra.common.kernel.geos.GeoList) -> n
    geogebra.common.kernel.geos.GeoPoint2 Max(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric LCM(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> m
    geogebra.common.kernel.geos.GeoNumeric LCM(java.lang.String,geogebra.common.kernel.geos.GeoList) -> o
    geogebra.common.kernel.geos.GeoNumeric SigmaXY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> p
    geogebra.common.kernel.geos.GeoNumeric SigmaYY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> q
    geogebra.common.kernel.geos.GeoNumeric Spearman(java.lang.String,geogebra.common.kernel.geos.GeoList) -> r
    geogebra.common.kernel.geos.GeoNumeric Spearman(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> f
    geogebra.common.kernel.geos.GeoNumeric SigmaXY(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> g
    geogebra.common.kernel.geos.GeoLine FitLineY(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoLine FitLineX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoFunction FitPoly(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoFunction FitExp(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoFunction FitLog(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoFunction FitPow(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoFunction FitSin(java.lang.String,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoFunction FitLogistic(java.lang.String,geogebra.common.kernel.geos.GeoList) -> f
    geogebra.common.kernel.geos.GeoFunction Fit(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoFunction Fit(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoFunction FitGrowth(java.lang.String,geogebra.common.kernel.geos.GeoList) -> g
    geogebra.common.kernel.geos.GeoNumeric RandomPoisson(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric InverseNormal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> d
    geogebra.common.kernel.geos.GeoNumeric Normal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> e
    geogebra.common.kernel.geos.GeoNumeric TDistribution(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> n
    geogebra.common.kernel.geos.GeoNumeric InverseTDistribution(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> o
    geogebra.common.kernel.geos.GeoNumeric InverseChiSquared(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> p
    geogebra.common.kernel.geos.GeoNumeric InverseExponential(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> q
    geogebra.common.kernel.geos.GeoNumeric InverseFDistribution(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> f
    geogebra.common.kernel.geos.GeoNumeric InverseGamma(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> g
    geogebra.common.kernel.geos.GeoNumeric InverseCauchy(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> h
    geogebra.common.kernel.geos.GeoNumeric Weibull(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> i
    geogebra.common.kernel.geos.GeoNumeric InverseWeibull(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> j
    geogebra.common.kernel.geos.GeoNumeric Zipf(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Zipf(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> r
    geogebra.common.kernel.geos.GeoNumeric Zipf(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoNumeric InverseZipf(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> k
    geogebra.common.kernel.geos.GeoNumeric Pascal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> b
    geogebra.common.kernel.geos.GeoNumeric Pascal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> s
    geogebra.common.kernel.geos.GeoNumeric Pascal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> b
    geogebra.common.kernel.geos.GeoNumeric InversePascal(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> l
    geogebra.common.kernel.geos.GeoNumeric Poisson(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> c
    geogebra.common.kernel.geos.GeoNumeric Poisson(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric Poisson(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoNumeric InversePoisson(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> t
    geogebra.common.kernel.geos.GeoNumeric HyperGeometric(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoNumeric HyperGeometric(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> m
    geogebra.common.kernel.geos.GeoNumeric HyperGeometric(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> c
    geogebra.common.kernel.geos.GeoNumeric InverseHyperGeometric(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric BinomialDist(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> d
    geogebra.common.kernel.geos.GeoNumeric Bernoulli(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> b
    geogebra.common.kernel.geos.GeoNumeric BinomialDist(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> u
    geogebra.common.kernel.geos.GeoNumeric BinomialDist(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> d
    geogebra.common.kernel.geos.GeoNumeric InverseBinomial(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> n
    geogebra.common.kernel.geos.GeoList ANOVATest(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoList TTest(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoList TTest(java.lang.String,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoList TTestPaired(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoList TTest2(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList TTest2(java.lang.String,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList TMeanEstimate(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> c
    geogebra.common.kernel.geos.GeoList TMeanEstimate(java.lang.String,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList TMean2Estimate(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList TMean2Estimate(java.lang.String,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList Sort(java.lang.String,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoList OrdinalRank(java.lang.String,geogebra.common.kernel.geos.GeoList) -> f
    geogebra.common.kernel.geos.GeoList TiedRank(java.lang.String,geogebra.common.kernel.geos.GeoList) -> g
    geogebra.common.kernel.geos.GeoNumeric Percentile(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoList Shuffle(java.lang.String,geogebra.common.kernel.geos.GeoList) -> h
    geogebra.common.kernel.geos.GeoList PointList(java.lang.String,geogebra.common.kernel.geos.GeoList) -> i
    geogebra.common.kernel.geos.GeoList RootList(java.lang.String,geogebra.common.kernel.geos.GeoList) -> j
    geogebra.common.kernel.geos.GeoText Last(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoText Take(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Last(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> d
    geogebra.common.kernel.geos.GeoList Take(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoList Join(java.lang.String,geogebra.common.kernel.geos.GeoList) -> k
    geogebra.common.kernel.geos.GeoList Union(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Intersection(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoList Insert(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList RemoveUndefined(java.lang.String,geogebra.common.kernel.geos.GeoList) -> l
    geogebra.common.kernel.geos.GeoList KeepIf(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoBoolean IsInteger(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Mode(java.lang.String,geogebra.common.kernel.geos.GeoList) -> m
    geogebra.common.kernel.geos.GeoList PrimeFactors(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoList Invert(java.lang.String,geogebra.common.kernel.geos.GeoList) -> n
    geogebra.common.kernel.geos.GeoList Transpose(java.lang.String,geogebra.common.kernel.geos.GeoList) -> o
    geogebra.common.kernel.geos.GeoList ReducedRowEchelonForm(java.lang.String,geogebra.common.kernel.geos.GeoList) -> p
    geogebra.common.kernel.geos.GeoNumeric Determinant(java.lang.String,geogebra.common.kernel.geos.GeoList) -> s
    geogebra.common.kernel.geos.GeoList Reverse(java.lang.String,geogebra.common.kernel.geos.GeoList) -> q
    geogebra.common.kernel.geos.GeoNumeric Product(java.lang.String,geogebra.common.kernel.geos.GeoList) -> t
    geogebra.common.kernel.geos.GeoNumeric Product(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> c
    geogebra.common.kernel.geos.GeoElement Sum(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement Sum(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement SumFunctions(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoElement SumFunctions(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoElement SumPoints(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoElement SumPoints(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> c
    geogebra.common.kernel.geos.GeoElement SumText(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoElement SumText(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> d
    geogebra.common.kernel.geos.GeoElement Sample(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText TableText(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList) -> r
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoList Frequency(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoText FrequencyTable(java.lang.String,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoBoolean,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoList Unique(java.lang.String,geogebra.common.kernel.geos.GeoList) -> s
    geogebra.common.kernel.geos.GeoText SurdText(java.lang.String,geogebra.common.kernel.geos.GeoNumeric) -> c
    geogebra.common.kernel.geos.GeoText SurdText(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoNumeric Mean(java.lang.String,geogebra.common.kernel.geos.GeoList) -> u
    geogebra.common.kernel.geos.GeoText VerticalText(java.lang.String,geogebra.common.kernel.geos.GeoText) -> a
    geogebra.common.kernel.geos.GeoText RotateText(java.lang.String,geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoNumeric) -> c
    geogebra.common.kernel.geos.GeoNumeric Variance(java.lang.String,geogebra.common.kernel.geos.GeoList) -> v
    geogebra.common.kernel.geos.GeoNumeric SampleVariance(java.lang.String,geogebra.common.kernel.geos.GeoList) -> w
    geogebra.common.kernel.geos.GeoNumeric StandardDeviation(java.lang.String,geogebra.common.kernel.geos.GeoList) -> x
    geogebra.common.kernel.geos.GeoNumeric SampleStandardDeviation(java.lang.String,geogebra.common.kernel.geos.GeoList) -> y
    geogebra.common.kernel.geos.GeoNumeric SigmaXX(java.lang.String,geogebra.common.kernel.geos.GeoList) -> z
    geogebra.common.kernel.geos.GeoNumeric Median(java.lang.String,geogebra.common.kernel.geos.GeoList) -> A
    geogebra.common.kernel.geos.GeoNumeric Q1(java.lang.String,geogebra.common.kernel.geos.GeoList) -> B
    geogebra.common.kernel.geos.GeoNumeric Q3(java.lang.String,geogebra.common.kernel.geos.GeoList) -> C
    geogebra.common.kernel.geos.GeoNumeric GeometricMean(java.lang.String,geogebra.common.kernel.geos.GeoList) -> D
    geogebra.common.kernel.geos.GeoNumeric HarmonicMean(java.lang.String,geogebra.common.kernel.geos.GeoList) -> E
    geogebra.common.kernel.geos.GeoNumeric RootMeanSquare(java.lang.String,geogebra.common.kernel.geos.GeoList) -> F
    geogebra.common.kernel.geos.GeoNumeric Iteration(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoList IterationList(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement RandomElement(java.lang.String,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoElement SelectedElement(java.lang.String,geogebra.common.kernel.geos.GeoList) -> f
    geogebra.common.kernel.geos.GeoElement SelectedIndex(java.lang.String,geogebra.common.kernel.geos.GeoList) -> g
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoList) -> G
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoLocus) -> b
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.geos.GeoText) -> b
    geogebra.common.kernel.geos.GeoNumeric PathParameter(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoElement[] Polygon(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLine(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    geogebra.common.kernel.geos.GeoElement[] PolyLine(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoElement[] RigidPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2[]) -> a
    geogebra.common.kernel.geos.GeoElement[] RegularPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement[] PolygonND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> c
    geogebra.common.kernel.geos.GeoElement[] PolyLineND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> d
    geogebra.common.kernel.geos.GeoElement[] VectorPolygon(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2[]) -> b
    geogebra.common.kernel.kernelND.GeoPointND IntersectLines(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLinePolyLine(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPolyLine) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLinePolygonalRegion(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoLine[] IntersectLineConicRegion(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectLinePolygon(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPolygon) -> b
    geogebra.common.kernel.geos.GeoPoint2 IntersectFunctions(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectFunctionLine(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectFunctions(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoLocus Locus(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoLocus Locus(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectLineConic(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectPolynomials(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialsSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialsSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectPolynomialLine(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialLineSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialLineSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectConicsSingle(java.lang.String,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectPolynomialConic(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectPolynomialConicSingle(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectImplicitpolyLine(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyLineSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyLineSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectImplicitpolyPolynomial(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyPolynomialSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyPolynomialSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectImplicitpolys(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolysSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolysSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2[] IntersectImplicitpolyConic(java.lang.String[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyConicSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 IntersectImplicitpolyConicSingle(java.lang.String,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic,double,double) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomialConic getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectConics getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomials getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.algos.AlgoIntersectPolynomialLine getIntersectionAlgorithm(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys getIntersectionAlgorithm(geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.algos.AlgoElement findExistingIntersectionAlgorithm(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine[] CommonTangents(java.lang.String[],geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> b
    geogebra.common.kernel.geos.GeoLine Tangent(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoLine Tangent(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoLine[] Tangent(java.lang.String[],geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.geos.GeoLine SecondAxis(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> c
    geogebra.common.kernel.geos.GeoNumeric SecondAxisLength(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> f
    geogebra.common.kernel.geos.GeoNumeric Parameter(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> g
    geogebra.common.kernel.geos.GeoNumeric Radius(java.lang.String,geogebra.common.kernel.geos.GeoConic) -> h
    geogebra.common.kernel.geos.GeoText StemPlot(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoText StemPlot(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoPoint2 CornerOfDrawingPad(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Translate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.geos.GeoVector Translate(java.lang.String,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement[] Rotate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement[] Rotate(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement[] Shear(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement[] Stretch(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoElement[] Mirror(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoLine) -> a
    geogebra.common.kernel.geos.GeoFunction PolynomialFunction(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoFunction PolynomialFunction(java.lang.String,geogebra.common.kernel.geos.GeoList) -> h
    geogebra.common.kernel.geos.GeoElement Simplify(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction) -> c
    geogebra.common.kernel.geos.GeoElement Simplify(java.lang.String,geogebra.common.kernel.geos.GeoText) -> b
    geogebra.common.kernel.geos.GeoFunction Numerator(java.lang.String,geogebra.common.kernel.geos.GeoFunction) -> c
    geogebra.common.kernel.geos.GeoNumeric Limit(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric LimitBelow(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric LimitAbove(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.geos.GeoElement PartialFractions(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction) -> d
    geogebra.common.kernel.geos.GeoFunction TaylorSeries(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement Integral(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoNumeric Integral(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoNumeric Integral(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoNumeric Integral(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoNumeric Integral(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoPoint2[] Root(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> c
    geogebra.common.kernel.geos.GeoPoint2[] RootMultiple(geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoPoint2 Root(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 Root(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.geos.GeoPoint2[] Roots(java.lang.String[],geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement Maximize(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElement Minimize(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric) -> b
    geogebra.common.kernel.geos.GeoPoint2[] TurningPoint(java.lang.String[],geogebra.common.kernel.geos.GeoFunction) -> d
    geogebra.common.kernel.geos.GeoConic OsculatingCircle(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.geos.GeoConic OsculatingCircleCurve(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoNumeric FunctionLength(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoNumeric FunctionLength2Points(java.lang.String,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoNumeric CurveLength(java.lang.String,geogebra.common.kernel.geos.GeoCurveCartesian,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoNumeric CurveLength2Points(java.lang.String,geogebra.common.kernel.geos.GeoCurveCartesian,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoLine Tangent(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoPoint2 Kimberling(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoPoint2 Barycenter(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoPoint2 Trilinear(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly TriangleCubic(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement TriangleCubic(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoLocus Voronoi(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoLocus DelauneyTriangulation(java.lang.String,geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoLocus Hull(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoLocus TravelingSalesman(java.lang.String,geogebra.common.kernel.geos.GeoList) -> c
    geogebra.common.kernel.geos.GeoLocus ConvexHull(java.lang.String,geogebra.common.kernel.geos.GeoList) -> d
    geogebra.common.kernel.geos.GeoLocus MinimumSpanningTree(java.lang.String,geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoLocus ShortestDistance(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.geos.GeoLocus SolveODE(java.lang.String,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoLocus SolveODE2(java.lang.String,geogebra.common.kernel.geos.GeoFunctionable,geogebra.common.kernel.geos.GeoFunctionable,geogebra.common.kernel.geos.GeoFunctionable,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra.common.kernel.geos.GeoElementSpreadsheet getGeoElementSpreadsheet() -> a
    geogebra.common.kernel.MacroKernel newMacroKernel() -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectPolygons(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> a
    geogebra.common.kernel.geos.GeoElement[] Union(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> b
    geogebra.common.kernel.geos.GeoBoolean AreCollinear(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement AreConcyclic(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoElement AreParallel(java.lang.String,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    void notifyChangeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    double getXmaxForFunctions() -> h
    double getXminForFunctions() -> i
    void clearCasCache() -> z
    void refreshCASCommands() -> A
    geogebra.common.kernel.geos.GeoElement Sort(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> b
geogebra.common.kernel.Kernel$1 -> geogebra.common.i.l:
    double val$eps -> a
    int compare(java.lang.Double,java.lang.Double) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.LayerView -> geogebra.common.i.m:
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
geogebra.common.kernel.Locateable -> geogebra.common.i.n:
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    boolean isAlwaysFixed() -> a
    void setWaitForStartPoint() -> b_
geogebra.common.kernel.LocateableList -> geogebra.common.i.o:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    void registerLocateable(geogebra.common.kernel.Locateable) -> a
    void unregisterLocateable(geogebra.common.kernel.Locateable) -> b
    void doRemove() -> a
geogebra.common.kernel.Macro -> geogebra.common.i.p:
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.String cmdName -> a
    java.lang.String toolName -> b
    java.lang.String toolHelp -> c
    java.lang.String iconFileName -> d
    boolean showInToolBar -> a
    geogebra.common.kernel.Construction macroCons -> a
    geogebra.common.kernel.geos.GeoElement[] macroInput -> a
    geogebra.common.kernel.geos.GeoElement[] macroOutput -> b
    java.lang.String[] macroInputLabels -> a
    java.lang.String[] macroOutputLabels -> b
    geogebra.common.kernel.geos.Test[] inputTypes -> a
    java.util.LinkedList usingAlgos -> a
    boolean copyCaptions -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.kernel.geos.GeoElement[] getMacroInput() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.geos.GeoElement[] getMacroOutput() -> b
    boolean isInMacroConstruction(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.Construction getMacroConstruction() -> a
    void initMacro(geogebra.common.kernel.Construction,java.lang.String[],java.lang.String[]) -> a
    void initInputOutput() -> b
    void initMacro(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void addDependentElement(geogebra.common.kernel.geos.GeoElement,java.util.Set,java.util.Set) -> a
    void addSpecialInputElement(geogebra.common.kernel.geos.GeoElement,java.util.Set) -> a
    java.lang.String buildMacroXML(geogebra.common.kernel.Kernel,java.util.Set) -> a
    geogebra.common.kernel.Construction createMacroConstruction(java.lang.String) -> a
    void registerAlgorithm(geogebra.common.kernel.algos.AlgoMacroInterface) -> a
    void unregisterAlgorithm(geogebra.common.kernel.algos.AlgoMacroInterface) -> b
    boolean isUsed() -> a
    void setUnused() -> a
    geogebra.common.kernel.geos.Test[] getInputTypes() -> a
    java.lang.String getToolHelp() -> a
    java.lang.String getNeededTypesString() -> b
    void setToolHelp(java.lang.String) -> a
    java.lang.String getCommandName() -> c
    void setCommandName(java.lang.String) -> b
    java.lang.String getToolName() -> d
    java.lang.String getToolOrCommandName() -> e
    void setToolName(java.lang.String) -> c
    void setIconFileName(java.lang.String) -> d
    java.lang.String getIconFileName() -> f
    java.lang.String toString() -> toString
    void getXML(java.lang.StringBuilder) -> a
    boolean isShowInToolBar() -> b
    void setShowInToolBar(boolean) -> a
    java.util.ArrayList getUsedMacros() -> a
    java.util.ArrayList getDependentGeos() -> b
    void setCopyCaptionsAndVisibility(boolean) -> b
    boolean isCopyCaptionsAndVisibility() -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.MacroConstruction -> geogebra.common.i.q:
    geogebra.common.kernel.Construction parentCons -> a
    java.util.HashSet reservedLabels -> a
    boolean globalVariableLookup -> a
    void loadXML(java.lang.String) -> g
    void addReservedLabel(java.lang.String) -> h
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String,boolean) -> a
    boolean isReservedLabel(java.lang.String) -> b
    void setGlobalVariableLookup(boolean) -> d
geogebra.common.kernel.MacroKernel -> geogebra.common.i.r:
    geogebra.common.kernel.Kernel parentKernel -> a
    geogebra.common.kernel.MacroConstruction macroCons -> a
    boolean isMacroKernel() -> o
    geogebra.common.kernel.Kernel getParentKernel() -> a
    void addReservedLabel(java.lang.String) -> e
    void setGlobalVariableLookup(boolean) -> p
    void loadXML(java.lang.String) -> f
    double getXmax() -> b
    double getXmin() -> c
    double getXscale() -> d
    double getYmax() -> e
    double getYmin() -> f
    double getYscale() -> g
    void addMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.commands.AlgebraProcessor newAlgebraProcessor(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator newExpressionNodeEvaluator() -> a
    geogebra.common.kernel.geos.GeoElement createGeoElement(geogebra.common.kernel.Construction,java.lang.String) -> a
    boolean handleCoords(geogebra.common.kernel.geos.GeoElement,java.util.LinkedHashMap) -> a
    geogebra.common.kernel.cas.GeoGebraCasInterface getGeoGebraCAS() -> a
    boolean isGeoGebraCASready() -> q
    void resetGeoGebraCAS() -> k
    void unbindVariableInGeoGebraCAS(java.lang.String) -> a
    geogebra.common.util.MaxSizeHashMap getCasCache() -> a
    boolean hasCasCache() -> s
geogebra.common.kernel.MacroManager -> geogebra.common.i.s:
    java.util.HashMap macroMap -> a
    java.util.ArrayList macroList -> a
    void addMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro(java.lang.String) -> a
    void removeMacro(geogebra.common.kernel.Macro) -> b
    void removeAllMacros() -> a
    void setMacroCommandName(geogebra.common.kernel.Macro,java.lang.String) -> a
    geogebra.common.kernel.Macro getMacro(int) -> a
    int getMacroID(geogebra.common.kernel.Macro) -> a
    void setAllMacrosUnused() -> b
    int getMacroNumber() -> a
    java.util.ArrayList getAllMacros() -> a
    void notifyEuclidianViewCE() -> c
    java.lang.String getMacroXML(java.util.ArrayList) -> a
geogebra.common.kernel.Manager3DInterface -> geogebra.common.i.t:
    geogebra.common.kernel.geos.GeoElement Point3D(java.lang.String,double,double,double) -> a
    geogebra.common.kernel.geos.GeoElement DependentPoint3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement DependentVector3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> b
    geogebra.common.kernel.geos.GeoElement Vector3D(java.lang.String,double,double,double) -> b
    geogebra.common.kernel.geos.GeoElement Vector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3DIn(java.lang.String,geogebra.common.kernel.Region,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3DIn(java.lang.String,geogebra.common.kernel.Region) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3D(java.lang.String,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3D(java.lang.String,geogebra.common.kernel.Path) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND Segment3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.GeoRayND Ray3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoVectorND OrthogonalVector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoVectorND UnitOrthogonalVector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> b
    geogebra.common.kernel.geos.GeoElement[] Polygon3D(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLine3D(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    geogebra.common.kernel.geos.GeoElement[] PolyLine3D(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> c
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> d
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,double,double,double,double) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND DependentPlane3D(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.kernelND.GeoPlaneND OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.geos.GeoElement Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> c
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] ConeLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] ConeLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] CylinderLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement[] CylinderLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoQuadricND QuadricSide(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoConicND QuadricBottom(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoConicND QuadricTop(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> b
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.geos.GeoElement Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoElement Intersect(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionPoint(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionSegment(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> b
    geogebra.common.kernel.geos.GeoElement[] IntersectionPoint(java.lang.String[],geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionSegment(java.lang.String[],geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> b
    geogebra.common.kernel.kernelND.GeoConicND Intersect(java.lang.String,geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Intersect(geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar Function2Var(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar Function2Var(java.lang.String,geogebra.common.kernel.geos.GeoFunctionNVar,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement CurveCartesian3D(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement SurfaceCartesian3D(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectLineConic(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectLineQuadric(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,double,double,geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectPlaneConic(java.lang.String[],geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.geos.GeoElement IntersectPlanes(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoElement IntersectPlanes(geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoAngle Angle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.geos.GeoElement ArchimedeanSolid(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] Translate3D(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.Geo3DVec newGeo3DVec(double,double,double) -> a
geogebra.common.kernel.Matrix.CoordMatrix -> geogebra.common.i.a.a:
    double[] val -> a
    int rows -> a
    int columns -> b
    boolean transpose -> a
    boolean isSingular -> b
    geogebra.common.kernel.Matrix.CoordMatrix GgbMatrixOrVector(int,int) -> a
    void initialise(int,int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix Identity(int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix ScaleMatrix(double[]) -> a
    geogebra.common.kernel.Matrix.CoordMatrix ScaleMatrix(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix DiagonalMatrix(double[]) -> b
    geogebra.common.kernel.Matrix.CoordMatrix TranslationMatrix(double[]) -> c
    geogebra.common.kernel.Matrix.CoordMatrix TranslationMatrix(geogebra.common.kernel.Matrix.Coords) -> b
    geogebra.common.kernel.Matrix.CoordMatrix Rotation3DMatrix(int,double) -> a
    double[] get() -> a
    double get(int,int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix subMatrix(int,int) -> b
    geogebra.common.kernel.Matrix.Coords getColumn(int) -> a
    void set(geogebra.common.kernel.Matrix.Coords,int) -> a
    void set(geogebra.common.kernel.Matrix.Coords[]) -> a
    void set(int,int,double) -> a
    void set(double) -> a
    void set(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    int getRows() -> a
    int getColumns() -> b
    boolean transpose() -> a
    geogebra.common.kernel.Matrix.CoordMatrix copy() -> a
    geogebra.common.kernel.Matrix.CoordMatrix transposeCopy() -> b
    java.lang.String toString() -> toString
    boolean isDefined() -> b
    boolean isFinite() -> c
    geogebra.common.kernel.Matrix.CoordMatrix mul(double) -> a
    geogebra.common.kernel.Matrix.CoordMatrix add(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords mul(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix mul(geogebra.common.kernel.Matrix.CoordMatrix) -> b
    void mul(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    double det() -> a
    geogebra.common.kernel.Matrix.CoordMatrix inverse() -> c
    geogebra.common.kernel.Matrix.Coords solve(geogebra.common.kernel.Matrix.Coords) -> b
    boolean isSingular() -> d
    void setIsSingular(boolean) -> a
    geogebra.common.kernel.Matrix.Coords getOrigin() -> a
    geogebra.common.kernel.Matrix.Coords getVx() -> b
    geogebra.common.kernel.Matrix.Coords getVy() -> c
    geogebra.common.kernel.Matrix.Coords getVz() -> d
    void setOrigin(geogebra.common.kernel.Matrix.Coords) -> a
    void setVx(geogebra.common.kernel.Matrix.Coords) -> b
    void setVy(geogebra.common.kernel.Matrix.Coords) -> c
    void setVz(geogebra.common.kernel.Matrix.Coords) -> d
geogebra.common.kernel.Matrix.CoordMatrix4x4 -> geogebra.common.i.a.b:
    geogebra.common.kernel.Matrix.CoordMatrix4x4 IDENTITY -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 MIRROR_Y -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 ROTATION_OZ_90 -> c
    geogebra.common.kernel.Matrix.CoordMatrix4x4 ROTATION_OZ_M90 -> d
    geogebra.common.kernel.Matrix.CoordMatrix4x4 Identity() -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 RotationOz(double) -> a
    geogebra.common.kernel.Matrix.Coords[] getOrthoVectors(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 mul(geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    void mulAllButOrigin(double) -> b
    void setDiag(double) -> c
    geogebra.common.kernel.Matrix.CoordMatrix4x4 mirrorY() -> b
geogebra.common.kernel.Matrix.CoordMatrixUtil -> geogebra.common.i.a.c:
    geogebra.common.kernel.Matrix.Coords[] nearestPointsFromTwoLines(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords sphericalCoords(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords lineEquationVector(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords lineEquationVector(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] intersectPlanes(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.CoordMatrix) -> a
geogebra.common.kernel.Matrix.CoordNearest -> geogebra.common.i.a.d:
    geogebra.common.kernel.Matrix.Coords point -> a
    double currentDistance -> a
    geogebra.common.kernel.Matrix.Coords currentNearest -> b
    boolean check(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords get() -> a
geogebra.common.kernel.Matrix.CoordSys -> geogebra.common.i.a.e:
    geogebra.common.kernel.Matrix.CoordMatrix matrix -> a
    int dimension -> a
    int madeCoordSys -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 matrixOrthonormal -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 drawingMatrix -> b
    geogebra.common.kernel.Matrix.Coords equationVector -> a
    geogebra.common.kernel.Matrix.Coords origin -> b
    geogebra.common.kernel.Matrix.Coords[] vectors -> a
    int spaceDimension -> c
    void set(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.CoordSys Identity3D() -> a
    int getDimension() -> a
    void setOrigin(geogebra.common.kernel.Matrix.Coords) -> a
    void setVx(geogebra.common.kernel.Matrix.Coords) -> b
    void setVy(geogebra.common.kernel.Matrix.Coords) -> c
    void setVz(geogebra.common.kernel.Matrix.Coords) -> d
    void setV(geogebra.common.kernel.Matrix.Coords,int) -> a
    geogebra.common.kernel.Matrix.Coords getV(int) -> a
    geogebra.common.kernel.Matrix.Coords getOrigin() -> a
    geogebra.common.kernel.Matrix.Coords getVx() -> b
    geogebra.common.kernel.Matrix.Coords getVy() -> c
    geogebra.common.kernel.Matrix.Coords getVz() -> d
    geogebra.common.kernel.Matrix.Coords getPoint(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getPoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords getPointForDrawing(double,double) -> b
    geogebra.common.kernel.Matrix.Coords getPoint(double) -> a
    geogebra.common.kernel.Matrix.Coords getVector(geogebra.common.kernel.Matrix.Coords) -> b
    geogebra.common.kernel.Matrix.Coords getVector(double,double) -> c
    geogebra.common.kernel.Matrix.Coords getNormal() -> e
    geogebra.common.kernel.Matrix.Coords[] getNormalProjection(geogebra.common.kernel.Matrix.Coords) -> a
    void setMadeCoordSys(int) -> a
    void resetCoordSys() -> a
    int getMadeCoordSys() -> b
    boolean isMadeCoordSys() -> a
    void addPoint(geogebra.common.kernel.Matrix.Coords) -> e
    void addVector(geogebra.common.kernel.Matrix.Coords) -> f
    void addVectorWithoutCheckMadeCoordSys(geogebra.common.kernel.Matrix.Coords) -> g
    void makeEquationVector() -> b
    geogebra.common.kernel.Matrix.Coords getEquationVector() -> f
    void makeCoordSys(double[]) -> a
    boolean makeOrthoMatrix(boolean,boolean) -> a
    boolean isDefined() -> b
    void setUndefined() -> c
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getMatrixOrthonormal() -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getDrawingMatrix() -> b
    void translate(geogebra.common.kernel.Matrix.Coords) -> h
    void translateDrawingMatrix(geogebra.common.kernel.Matrix.Coords) -> i
geogebra.common.kernel.Matrix.Coords -> geogebra.common.i.a.f:
    double norm -> a
    double sqNorm -> b
    boolean calcNorm -> b
    boolean calcSqNorm -> c
    void set(int,double) -> a
    void set(double[]) -> a
    void set(double) -> a
    double get(int) -> a
    double getX() -> b
    double getY() -> c
    double getZ() -> d
    double getW() -> e
    double getLast() -> f
    void setX(double) -> b
    void setY(double) -> c
    void setZ(double) -> d
    void setW(double) -> e
    int getLength() -> c
    geogebra.common.kernel.Matrix.Coords copyVector() -> e
    double dotproduct(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords crossProduct(geogebra.common.kernel.Matrix.Coords) -> c
    geogebra.common.kernel.Matrix.Coords crossProduct4(geogebra.common.kernel.Matrix.Coords) -> d
    void setCrossProduct(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    double norm() -> g
    void calcNorm() -> a
    double getNorm() -> h
    double squareNorm() -> i
    geogebra.common.kernel.Matrix.Coords normalized() -> f
    geogebra.common.kernel.Matrix.Coords normalized(boolean) -> a
    geogebra.common.kernel.Matrix.Coords normalize() -> g
    geogebra.common.kernel.Matrix.Coords normalize(boolean) -> b
    double distance(geogebra.common.kernel.Matrix.Coords) -> b
    double distLine(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] projectPlane(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords[] projectPlaneThruV(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] projectPlaneThruVIfPossible(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.Coords) -> b
    geogebra.common.kernel.Matrix.Coords[] projectPlaneThruVIfPossible(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] projectLine(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords projectNearLine(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] projectOnLineWithDirection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords sub(geogebra.common.kernel.Matrix.Coords) -> e
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> h
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInSameDimension() -> i
    geogebra.common.kernel.Matrix.Coords getCoordsLast1() -> j
    geogebra.common.kernel.Matrix.Coords projectInfDim() -> k
    boolean equalsForKernel(geogebra.common.kernel.Matrix.Coords,double) -> a
    boolean isEqual(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isZero() -> e
    boolean equalsForKernel(double,double) -> a
    geogebra.common.kernel.Matrix.Coords[] completeOrthonormal() -> a
    geogebra.common.kernel.Matrix.Coords add(geogebra.common.kernel.Matrix.Coords) -> f
    geogebra.common.kernel.Matrix.Coords mul(double) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsIn2DView() -> l
    double getGrayScale() -> j
    void convertToGrayScale() -> b
    geogebra.common.kernel.Matrix.CoordMatrix mul(double) -> a
geogebra.common.kernel.MatrixTransformable -> geogebra.common.i.u:
    void matrixTransform(double,double,double,double) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
geogebra.common.kernel.MyPoint -> geogebra.common.i.v:
    double x -> a
    double y -> b
    boolean lineTo -> a
    boolean isEqual(double,double) -> a
    java.lang.String toString() -> toString
    double distance(geogebra.common.kernel.MyPoint) -> a
    geogebra.common.kernel.geos.GeoPoint2 getGeoPoint(geogebra.common.kernel.Construction) -> a
    boolean getLineTo() -> a
    double getX() -> a
    double getY() -> b
    double distance(double,double) -> a
    void setX(double) -> a
    void setY(double) -> b
    double distance(geogebra.common.awt.Point2D) -> a
geogebra.common.kernel.NameDescriptionComparator -> geogebra.common.i.w:
    int compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.ParametricCurveDistanceFunction -> geogebra.common.i.x:
    double px -> a
    double py -> b
    geogebra.common.kernel.roots.RealRootFunction funX -> a
    geogebra.common.kernel.roots.RealRootFunction funY -> b
    void setDistantPoint(double,double) -> a
    double evaluate(double) -> a
geogebra.common.kernel.Path -> geogebra.common.i.y:
geogebra.common.kernel.PathAlgo -> geogebra.common.i.z:
    boolean isChangeable() -> a_
geogebra.common.kernel.PathMover -> geogebra.common.i.A:
    void init(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean getNext(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean hasNext() -> a
    void resetStartParameter() -> a
    boolean hasPositiveOrientation() -> b
    boolean smallerStep() -> c
    boolean biggerStep() -> d
    void stepBack() -> b
geogebra.common.kernel.PathMoverGeneric -> geogebra.common.i.B:
    geogebra.common.kernel.Path path -> a
    double start_param -> a
    double start_paramUP -> b
    double start_paramDOWN -> c
    double curr_param -> d
    double last_param -> e
    double param_extent -> f
    double min_param -> g
    double max_param -> h
    double max_step_width -> i
    double step_width -> j
    double offset -> k
    int mode -> a
    boolean posOrientation -> a
    boolean maxBorderSet -> b
    boolean minBorderSet -> c
    boolean lastMaxBorderSet -> d
    boolean lastMinBorderSet -> e
    void init(geogebra.common.kernel.geos.GeoPoint2) -> a
    void init(double) -> a
    void resetStartParameter() -> a
    boolean getNext(geogebra.common.kernel.geos.GeoPoint2) -> a
    void calcPoint(geogebra.common.kernel.geos.GeoPoint2) -> b
    boolean hasNext() -> a
    boolean hasPositiveOrientation() -> b
    boolean smallerStep() -> c
    boolean biggerStep() -> d
    boolean changeStep(double) -> a
    void stepBack() -> b
geogebra.common.kernel.PathMoverLocus -> geogebra.common.i.C:
    java.util.ArrayList myPointList -> a
    boolean noLineToSet -> f
    boolean lastNoLineToSet -> g
    void init(geogebra.common.kernel.geos.GeoPoint2) -> a
    void resetStartParameter() -> a
    void calcPoint(geogebra.common.kernel.geos.GeoPoint2) -> b
    boolean getNext(geogebra.common.kernel.geos.GeoPoint2) -> a
    void stepBack() -> b
    boolean noLineTo(double) -> a
    double borderParam(double) -> a
    boolean hasNext() -> a
geogebra.common.kernel.PathNormalizer -> geogebra.common.i.D:
    geogebra.common.kernel.Path parentPath -> a
    double toParentPathParameter(double,double,double) -> a
    double toNormalizedPathParameter(double,double,double) -> b
    void toParentPathParameter(geogebra.common.kernel.PathParameter) -> a
    void toNormalizedPathParameter(geogebra.common.kernel.PathParameter) -> b
    double infFunction(double) -> a
    double inverseInfFunction(double) -> b
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.PathOrPoint -> geogebra.common.i.E:
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> u_
    geogebra.common.kernel.PathMover createPathMover() -> a
geogebra.common.kernel.PathParameter -> geogebra.common.i.F:
    double t -> a
    int pathType -> a
    void set(geogebra.common.kernel.PathParameter) -> a
    int getPathType() -> a
    void setPathType(int) -> a
    double getT() -> a
    void setT(double) -> a
geogebra.common.kernel.PathRegionHandling -> geogebra.common.i.G:
    geogebra.common.kernel.PathRegionHandling OFF -> a
    geogebra.common.kernel.PathRegionHandling ON -> b
    geogebra.common.kernel.PathRegionHandling AUTO -> c
    java.lang.String xml -> a
    geogebra.common.kernel.PathRegionHandling[] ENUM$VALUES -> a
    java.lang.String getXML() -> a
    geogebra.common.kernel.PathRegionHandling parse(java.lang.String) -> a
    geogebra.common.kernel.PathRegionHandling[] values() -> values
    geogebra.common.kernel.PathRegionHandling valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.PointPair -> geogebra.common.i.H:
    int indexP -> a
    boolean isPalive -> a
    int indexQ -> b
    boolean isQonPath -> b
    double dist -> a
    geogebra.common.kernel.PointPair next -> a
geogebra.common.kernel.PointPairList -> geogebra.common.i.I:
    geogebra.common.kernel.PointPair head -> a
    boolean isEmpty() -> a
    void clear() -> a
    void insertPointPair(int,boolean,int,boolean,double) -> a
    boolean smallerThan(geogebra.common.kernel.PointPair,geogebra.common.kernel.PointPair) -> a
    boolean smallerThan2(geogebra.common.kernel.PointPair,geogebra.common.kernel.PointPair) -> b
    void removeAllPairs(geogebra.common.kernel.PointPair) -> a
    geogebra.common.kernel.PointPair getHead() -> a
geogebra.common.kernel.Region -> geogebra.common.i.J:
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean isInRegion(double,double) -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.RegionParameters -> geogebra.common.i.K:
    double t1 -> a
    double t2 -> b
    geogebra.common.kernel.Matrix.Coords normal -> a
    boolean isOnPath -> a
    double getT1() -> a
    void setT1(double) -> a
    double getT2() -> b
    void setT2(double) -> b
    boolean isNaN(double) -> a
    void setNormal(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
    void setIsOnPath(boolean) -> a
    boolean isOnPath() -> a
geogebra.common.kernel.Relation -> geogebra.common.i.L:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    java.lang.String relation(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoSegment,geogebra.common.kernel.geos.GeoSegment) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoVector) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPolygon) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.Path) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoConicPart,geogebra.common.kernel.geos.GeoConicPart) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    java.lang.String relation(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String equalityString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> a
    java.lang.String linDependencyString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> b
    java.lang.String incidenceString(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoElement,boolean) -> a
    java.lang.String incidencePerimeterString(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoElement,boolean) -> b
    java.lang.String parallelString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> b
    java.lang.String perpendicularString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> c
    java.lang.String intersectString(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,boolean) -> c
    java.lang.String lineConicString(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,int) -> a
    java.lang.String getPlainNumerical(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlainNumerical(java.lang.String,java.lang.String) -> a
geogebra.common.kernel.SliderMover -> geogebra.common.i.M:
    geogebra.common.kernel.geos.GeoNumeric slider -> a
    void init(geogebra.common.kernel.geos.GeoNumeric) -> a
    void init(double) -> a
    boolean getNext(geogebra.common.kernel.geos.GeoNumeric) -> a
    void calcPoint(geogebra.common.kernel.geos.GeoNumeric) -> b
geogebra.common.kernel.StringTemplate -> geogebra.common.i.N:
    geogebra.common.kernel.StringTemplate noLocalDefault -> a
    geogebra.common.kernel.StringTemplate prefixedDefault -> b
    geogebra.common.kernel.StringTemplate defaultTemplate -> c
    geogebra.common.kernel.StringTemplate latexTemplate -> d
    geogebra.common.kernel.StringTemplate casTemplate -> e
    geogebra.common.kernel.StringTemplate xmlTemplate -> f
    geogebra.common.kernel.StringTemplate editTemplate -> g
    geogebra.common.kernel.StringTemplate regression -> h
    geogebra.common.kernel.StringTemplate ogpTemplate -> i
    geogebra.common.kernel.StringTemplate maxPrecision -> j
    geogebra.common.kernel.StringTemplate casCellTemplate -> k
    boolean symbolicArbConst -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType stringType -> a
    boolean internationalizeDigits -> b
    java.lang.String casPrintFormPI -> a
    geogebra.common.util.ScientificFormatAdapter sf -> a
    geogebra.common.util.NumberFormatAdapter nf -> a
    boolean forceSF -> c
    boolean forceNF -> d
    boolean allowMoreDigits -> e
    boolean localizeCmds -> f
    boolean usePrefix -> g
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getStringType() -> a
    boolean internationalizeDigits() -> a
    java.lang.String getPi() -> a
    geogebra.common.kernel.StringTemplate get(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    void setType(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    boolean useScientific(boolean) -> a
    boolean hasType(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    geogebra.common.kernel.StringTemplate printDecimals(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,int,boolean) -> a
    geogebra.common.kernel.StringTemplate printFigures(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType,int,boolean) -> b
    geogebra.common.util.ScientificFormatAdapter getSF(geogebra.common.util.ScientificFormatAdapter) -> a
    geogebra.common.util.NumberFormatAdapter getNF(geogebra.common.util.NumberFormatAdapter) -> a
    boolean isPrintLocalizedCommandNames() -> b
    int getCoordStyle(int) -> a
    boolean isUseTempVariablePrefix() -> c
    boolean allowsRoundHack(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.util.ScientificFormatAdapter) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.StringTemplate$1 -> geogebra.common.i.O:
    boolean allowsRoundHack(double,geogebra.common.util.NumberFormatAdapter,geogebra.common.util.ScientificFormatAdapter) -> a
geogebra.common.kernel.StringTemplate$2 -> geogebra.common.i.P:
    int getCoordStyle(int) -> a
geogebra.common.kernel.SystemOfEquationsSolver -> geogebra.common.i.Q:
    double epsilon -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    int solveSystemOfQuadraticEquations(double[],double[],double[][]) -> a
geogebra.common.kernel.Transform -> geogebra.common.i.R:
    geogebra.common.kernel.Construction cons -> a
    java.lang.String transformedGeoLabel(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement doTransform(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] transform(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] transformPoly(java.lang.String,geogebra.common.kernel.geos.GeoPolyLineInterface,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] transformPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoConic getTransformedConic(geogebra.common.kernel.geos.GeoConic) -> a
    geogebra.common.kernel.geos.GeoElement getTransformedLine(geogebra.common.kernel.kernelND.GeoLineND) -> a
    boolean isAffine() -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformApplyMatrix -> geogebra.common.i.S:
    geogebra.common.kernel.geos.GeoList matrix -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformDilate -> geogebra.common.i.T:
    geogebra.common.kernel.arithmetic.NumberValue ratio -> a
    geogebra.common.kernel.geos.GeoPoint2 center -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.TransformMirror -> geogebra.common.i.U:
    geogebra.common.kernel.geos.GeoElement mirror -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isAffine() -> a
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformRotate -> geogebra.common.i.V:
    geogebra.common.kernel.geos.GeoPoint2 center -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.TransformShearOrStretch -> geogebra.common.i.W:
    boolean shear -> a
    geogebra.common.kernel.geos.GeoVec3D line -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isSimilar() -> b
    boolean changesOrientation() -> c
geogebra.common.kernel.TransformTranslate -> geogebra.common.i.X:
    geogebra.common.kernel.geos.GeoVec3D transVec -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.VarString -> geogebra.common.i.Y:
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.View -> geogebra.common.i.Z:
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void clearView() -> b
    void setMode(int) -> a
    int getViewID() -> b
geogebra.common.kernel.algos.AlgoAffineRatio -> geogebra.common.i.b.a:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoNumeric M -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAngleConic -> geogebra.common.i.b.b:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngleLines -> geogebra.common.i.b.c:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.AlgoAngleLines copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> a
    geogebra.common.kernel.geos.GeoLine geth() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoAngleNumeric -> geogebra.common.i.b.d:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAnglePoints -> geogebra.common.i.b.e:
    geogebra.common.kernel.kernelND.GeoPointND An -> a
    geogebra.common.kernel.kernelND.GeoPointND Bn -> b
    geogebra.common.kernel.kernelND.GeoPointND Cn -> c
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.Matrix.Coords STANDARD_VN -> a
    geogebra.common.kernel.algos.AlgoAnglePolygon algoAnglePoly -> a
    double bx -> a
    double by -> b
    double vx -> c
    double vy -> d
    double wx -> e
    double wy -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoAngle newGeoAngle(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.AlgoAnglePoints copy() -> a
    void setInputOutput() -> a
    void remove() -> c
    int getConstructionIndex() -> a_
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.kernelND.GeoPointND getA() -> a
    geogebra.common.kernel.kernelND.GeoPointND getB() -> b
    geogebra.common.kernel.kernelND.GeoPointND getC() -> c
    geogebra.common.kernel.Matrix.Coords getVn() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoAnglePolygon -> geogebra.common.i.b.f:
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputAngles -> a
    geogebra.common.kernel.algos.AlgoAnglePoints algoAngle -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getAngles() -> a
    geogebra.common.kernel.geos.GeoPolygon getPolygon() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
geogebra.common.kernel.algos.AlgoAnglePolygon$1 -> geogebra.common.i.b.g:
    geogebra.common.kernel.algos.AlgoAnglePolygon this$0 -> a
    geogebra.common.kernel.geos.GeoAngle newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoAngleVector -> geogebra.common.i.b.h:
    geogebra.common.kernel.geos.GeoVec3D vec -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    double[] coords -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoVec3D getVec3D() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngleVectors -> geogebra.common.i.b.i:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector w -> b
    geogebra.common.kernel.geos.GeoAngle angle -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoAngle getAngle() -> a
    geogebra.common.kernel.geos.GeoVector getv() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngularBisectorLines -> geogebra.common.i.b.j:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoLine[] bisector -> a
    double gx -> a
    double gy -> b
    double hx -> c
    double hy -> d
    double wx -> e
    double wy -> f
    double bx -> g
    double by -> h
    double lenH -> i
    double lenG -> j
    double length -> k
    double ip -> l
    geogebra.common.kernel.geos.GeoVector[] wv -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> a
    boolean infiniteB -> a
    int index -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getLines() -> a
    boolean isNearToAlgorithm() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAngularBisectorPoints -> geogebra.common.i.b.k:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoLine bisector -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    geogebra.common.kernel.geos.GeoLine h -> c
    geogebra.common.kernel.geos.GeoVector wv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAppend -> geogebra.common.i.b.l:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int order -> b
    int ADD_OBJECT_AT_START -> c
    int ADD_OBJECT_AT_END -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoApplyMatrix -> geogebra.common.i.b.m:
    geogebra.common.kernel.MatrixTransformable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoList matrix -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    boolean swapOrientation(boolean) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
geogebra.common.kernel.algos.AlgoAreCollinear -> geogebra.common.i.b.n:
    geogebra.common.kernel.geos.GeoPoint2 inputPoint1 -> a
    geogebra.common.kernel.geos.GeoPoint2 inputPoint2 -> b
    geogebra.common.kernel.geos.GeoPoint2 inputPoint3 -> c
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Polynomial[] botanaPolynomials -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoAreConcyclic -> geogebra.common.i.b.o:
    geogebra.common.kernel.geos.GeoPoint2 inputPoint1 -> a
    geogebra.common.kernel.geos.GeoPoint2 inputPoint2 -> b
    geogebra.common.kernel.geos.GeoPoint2 inputPoint3 -> c
    geogebra.common.kernel.geos.GeoPoint2 inputPoint4 -> d
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoAreParallel -> geogebra.common.i.b.p:
    geogebra.common.kernel.geos.GeoLine inputLine1 -> a
    geogebra.common.kernel.geos.GeoLine inputLine2 -> b
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Polynomial[] botanaPolynomials -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoAreaConic -> geogebra.common.i.b.q:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAreaPoints -> geogebra.common.i.b.r:
    geogebra.common.kernel.geos.GeoPoint2[] P -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAreaPolygon -> geogebra.common.i.b.s:
    geogebra.common.kernel.geos.GeoPolygon polygon -> a
    geogebra.common.kernel.geos.GeoNumeric area -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getArea() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAsymptote -> geogebra.common.i.b.t:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] asymptotes -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    double[] halfAxes -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getAsymptotes() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAsymptoteFunction -> geogebra.common.i.b.u:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAsymptoteInterface -> geogebra.common.i.b.v:
geogebra.common.kernel.algos.AlgoAxes -> geogebra.common.i.b.w:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] axes -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getAxes() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAxisFirst -> geogebra.common.i.b.x:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine axis -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getAxis() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAxisFirstLength -> geogebra.common.i.b.y:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAxisSecond -> geogebra.common.i.b.z:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine axis -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getAxis() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAxisSecondLength -> geogebra.common.i.b.A:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoAxisStepX -> geogebra.common.i.b.B:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean euclidianViewUpdate() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoAxisStepY -> geogebra.common.i.b.C:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean euclidianViewUpdate() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoBarChart -> geogebra.common.i.b.D:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoBarChart copy() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoBinomial -> geogebra.common.i.b.E:
    double Binom(double,double) -> a
    double BinomBig(double,double) -> b
    double BinomLog(double,double) -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoBoxPlot -> geogebra.common.i.b.F:
    int type -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoElement minGeo -> c
    geogebra.common.kernel.geos.GeoElement Q1geo -> d
    geogebra.common.kernel.geos.GeoElement medianGeo -> e
    geogebra.common.kernel.geos.GeoElement Q3geo -> f
    geogebra.common.kernel.geos.GeoElement maxGeo -> g
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList tempList -> b
    int N -> b
    double[] yval -> a
    double[] leftBorder -> b
    geogebra.common.kernel.arithmetic.NumberValue getB() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoBoxPlot copy() -> a
    void compute() -> b
    void calcBoxPlot() -> e
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getSum() -> a
    double[] getLeftBorders() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoCell -> geogebra.common.i.b.G:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    java.lang.String currentLabel -> a
    geogebra.common.kernel.geos.GeoElement refObject -> b
    geogebra.common.kernel.geos.GeoElement[] inputForUpdateSetPropagation -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void updateReferencedObject() -> e
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a_
geogebra.common.kernel.algos.AlgoCellRange -> geogebra.common.i.b.H:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement startCell -> a
    geogebra.common.kernel.geos.GeoElement endCell -> b
    java.lang.String toStringOutput -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void remove() -> c
    void clearGeoList() -> e
    void setInputOutput() -> a
    java.util.ArrayList initCellRangeList(geogebra.common.awt.Point,geogebra.common.awt.Point) -> a
    geogebra.common.kernel.geos.GeoList getList() -> a
    void compute() -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.awt.Point[] getRectangle() -> a
geogebra.common.kernel.algos.AlgoCenterConic -> geogebra.common.i.b.I:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint2 midpoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCentroidPolygon -> geogebra.common.i.b.J:
    geogebra.common.kernel.geos.GeoPolygon p -> a
    geogebra.common.kernel.geos.GeoPoint2 centroid -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCirclePointRadius -> geogebra.common.i.b.K:
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCirclePointRadiusInterface -> geogebra.common.i.b.L:
geogebra.common.kernel.algos.AlgoCircleThreePoints -> geogebra.common.i.b.M:
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoPointND C -> c
    geogebra.common.kernel.kernelND.GeoConicND circle -> a
    geogebra.common.kernel.geos.GeoLine s0 -> a
    geogebra.common.kernel.geos.GeoLine s1 -> b
    geogebra.common.kernel.geos.GeoPoint2 center -> a
    double[] det -> a
    double ax -> a
    double ay -> b
    double bx -> c
    double by -> d
    double cx -> e
    double cy -> f
    double ABx -> g
    double ABy -> h
    double ACx -> i
    double ACy -> j
    double BCx -> k
    double BCy -> l
    double maxDet -> m
    int casenr -> a
    void setIncidence() -> p
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createCircle() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a_
    void setInput() -> e
    void setOutput() -> f
    geogebra.common.kernel.kernelND.GeoConicND getCircle() -> a
    geogebra.common.kernel.geos.GeoPoint2 getA() -> a
    geogebra.common.kernel.geos.GeoPoint2 getB() -> b
    geogebra.common.kernel.geos.GeoPoint2 getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCircleTwoPoints -> geogebra.common.i.b.N:
    void setIncidence() -> e
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCircumferenceConic -> geogebra.common.i.b.O:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.integration.EllipticArcLength ellipticArcLength -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getCircumference() -> a
geogebra.common.kernel.algos.AlgoClasses -> geogebra.common.i.b.P:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoNumeric start -> a
    geogebra.common.kernel.geos.GeoNumeric width -> b
    geogebra.common.kernel.geos.GeoNumeric numClasses -> c
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoClosestPoint -> geogebra.common.i.b.Q:
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.geos.GeoPoint2 point -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isChangeable() -> a_
geogebra.common.kernel.algos.AlgoColumn -> geogebra.common.i.b.R:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoColumnName -> geogebra.common.i.b.S:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoCommonTangents -> geogebra.common.i.b.T:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoPoint2 P2 -> b
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoConic c2 -> b
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.geos.GeoLine polar2 -> b
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect2 -> b
    geogebra.common.kernel.geos.GeoPoint2[] tangentPoints -> a
    geogebra.common.kernel.geos.GeoPoint2[] tangentPoints2 -> b
    boolean equalLines -> a
    boolean equalLines2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    void initForNearToRelationship() -> d
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCompleteSquare -> geogebra.common.i.b.U:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction square -> b
    geogebra.common.kernel.arithmetic.FunctionVariable fv -> a
    geogebra.common.kernel.arithmetic.MyDouble a -> a
    geogebra.common.kernel.arithmetic.MyDouble h -> b
    geogebra.common.kernel.arithmetic.MyDouble k -> c
    int lastDeg -> a
    geogebra.common.kernel.cas.AlgoCoefficients algoCoef -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoComplexRootsPolynomial -> geogebra.common.i.b.V:
    double[] curComplexRoots -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void computeComplexRoots() -> f
    void calcComplexRoots(geogebra.common.kernel.arithmetic.Function) -> a
    void addToCurrentRoots(double[],double[],int) -> a
    void setRootPoints(double[],double[],int) -> b
geogebra.common.kernel.algos.AlgoConicCoefficients -> geogebra.common.i.b.W:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoList g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicFivePoints -> geogebra.common.i.b.X:
    geogebra.common.kernel.geos.GeoPoint2[] P -> a
    geogebra.common.kernel.geos.GeoPoint2[] Ppert -> b
    geogebra.common.kernel.geos.GeoConic conic -> a
    double delta -> a
    double[][] A -> a
    double[][] B -> b
    double[][] C -> c
    double[][] Cpert -> d
    double[][] Cmin -> e
    double l -> b
    double m -> c
    geogebra.common.kernel.geos.GeoVec3D[] line -> a
    int i -> a
    int j -> b
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    void degCone(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D,double[][]) -> a
    double evalMatrix(double[][],geogebra.common.kernel.geos.GeoPoint2) -> a
    void linComb(double[][],double[][],double,double,double[][]) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicFociLength -> geogebra.common.i.b.Y:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoConicFromCoeffList -> geogebra.common.i.b.Z:
    geogebra.common.kernel.geos.GeoList L -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicPart -> geogebra.common.i.b.aa:
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.arithmetic.NumberValue startParam -> a
    geogebra.common.kernel.arithmetic.NumberValue endParam -> b
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    int type -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoConicPart getConicPart() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoConicPartCircle -> geogebra.common.i.b.ab:
    geogebra.common.kernel.geos.GeoPoint2 center -> a
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> b
    geogebra.common.kernel.geos.GeoPoint2 endPoint -> c
    geogebra.common.kernel.geos.GeoPoint2 P -> d
    geogebra.common.kernel.geos.GeoPoint2 Q -> e
    void setIncidence() -> e
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2 getEndPoint() -> b
    geogebra.common.kernel.geos.GeoPoint2 getCenter() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoConicPartCircumcircle -> geogebra.common.i.b.ac:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoLine line -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    void computeDegenerate() -> f
    void computeCircle() -> p
geogebra.common.kernel.algos.AlgoConicPartConicParameters -> geogebra.common.i.b.ad:
    void setInputOutput() -> a
geogebra.common.kernel.algos.AlgoConicPartConicPoints -> geogebra.common.i.b.ae:
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 endPoint -> b
    geogebra.common.kernel.geos.GeoPoint2 P -> c
    geogebra.common.kernel.geos.GeoPoint2 Q -> d
    void setIncidence() -> e
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2 getEndPoint() -> b
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void setInputOutput() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoConstructionStep -> geogebra.common.i.b.af:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean wantsConstructionProtocolUpdate() -> c
    void compute() -> b
geogebra.common.kernel.algos.AlgoCountIf -> geogebra.common.i.b.ag:
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoCrossRatio -> geogebra.common.i.b.ah:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoPoint2 D -> d
    geogebra.common.kernel.geos.GeoNumeric M -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoCurvature -> geogebra.common.i.b.ai:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoNumeric K -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.algos.AlgoCurvatureCurve -> geogebra.common.i.b.aj:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoNumeric K -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoCurvatureVector -> geogebra.common.i.b.ak:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction f1 -> b
    geogebra.common.kernel.geos.GeoFunction f2 -> c
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.algos.AlgoCurvatureVectorCurve -> geogebra.common.i.b.al:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f1 -> b
    geogebra.common.kernel.geos.GeoCurveCartesian f2 -> c
    geogebra.common.kernel.geos.GeoVector v -> a
    double[] f1eval -> a
    double[] f2eval -> b
    geogebra.common.kernel.cas.AlgoDerivative algoCAS -> a
    geogebra.common.kernel.cas.AlgoDerivative algoCAS2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.algos.AlgoCurveCartesian -> geogebra.common.i.b.am:
    geogebra.common.kernel.arithmetic.NumberValue[] coords -> a
    geogebra.common.kernel.arithmetic.NumberValue from -> a
    geogebra.common.kernel.arithmetic.NumberValue to -> b
    geogebra.common.kernel.geos.GeoNumeric localVar -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND curve -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND createCurve(geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.Function[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoCurveCartesianND getCurve() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDefined -> geogebra.common.i.b.an:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDenominator -> geogebra.common.i.b.ao:
    geogebra.common.kernel.arithmetic.ExpressionValue getPart(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoDependentBoolean -> geogebra.common.i.b.ap:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoBoolean bool -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getGeoBoolean() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentConic -> geogebra.common.i.b.aq:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[] ev -> a
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentFunction -> geogebra.common.i.b.ar:
    geogebra.common.kernel.arithmetic.Function fun -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.Function expandedFun -> b
    geogebra.common.kernel.arithmetic.ExpressionNode expression -> a
    boolean expContainsFunctions -> a
    java.lang.StringBuilder sb -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue expandFunctionDerivativeNodes(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean containsFunctions(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String getDerivativeLabel(geogebra.common.kernel.arithmetic.Function) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.algos.AlgoDependentFunctionNVar -> geogebra.common.i.b.as:
    geogebra.common.kernel.arithmetic.FunctionNVar fun -> a
    geogebra.common.kernel.geos.GeoFunctionNVar f -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunctionNVar getFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentGeoCopy -> geogebra.common.i.b.at:
    geogebra.common.kernel.arithmetic.ExpressionNode origGeoNode -> a
    geogebra.common.kernel.geos.GeoElement origGeo -> a
    geogebra.common.kernel.geos.GeoElement copyGeo -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDependentInterval -> geogebra.common.i.b.au:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDependentLine -> geogebra.common.i.b.av:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[] ev -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentList -> geogebra.common.i.b.aw:
    java.util.ArrayList listItems -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void remove() -> c
    geogebra.common.kernel.geos.GeoList getGeoList() -> a
    int getRelatedModeID() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentListExpression -> geogebra.common.i.b.ax:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getList() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentNumber -> geogebra.common.i.b.ay:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoNumeric number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getNumber() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpression() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentPoint -> geogebra.common.i.b.az:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVec2D temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpressionNode() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentText -> geogebra.common.i.b.aA:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.StringTemplate oldTpl -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getRoot() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDependentVector -> geogebra.common.i.b.aB:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVec2D temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
geogebra.common.kernel.algos.AlgoDeterminant -> geogebra.common.i.b.aC:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDiameterLine -> geogebra.common.i.b.aD:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine diameter -> b
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getDiameter() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDiameterVector -> geogebra.common.i.b.aE:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine diameter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getDiameter() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDilate -> geogebra.common.i.b.aF:
    geogebra.common.kernel.geos.GeoPoint2 S -> a
    geogebra.common.kernel.geos.Dilateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue r -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement rgeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
geogebra.common.kernel.algos.AlgoDirection -> geogebra.common.i.b.aG:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDirectrix -> geogebra.common.i.b.aH:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine directrix -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getDirectrix() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDistanceLineLine -> geogebra.common.i.b.aI:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDistancePointObject -> geogebra.common.i.b.aJ:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoElement g -> a
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.AlgoClosestPoint closePt -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDistancePoints -> geogebra.common.i.b.aK:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.geos.GeoNumeric dist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getDistance() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDiv -> geogebra.common.i.b.aL:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDotPlot -> geogebra.common.i.b.aM:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double[] sortedData -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoDrawInformation -> geogebra.common.i.b.aN:
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoDrawingPadCorner -> geogebra.common.i.b.aO:
    geogebra.common.kernel.geos.GeoPoint2 corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.arithmetic.NumberValue evNum -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getCorner() -> a
    void compute() -> b
    boolean euclidianViewUpdate() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDynamicCoordinates -> geogebra.common.i.b.aP:
    geogebra.common.kernel.arithmetic.NumberValue x -> a
    geogebra.common.kernel.arithmetic.NumberValue y -> b
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoPoint2 M -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2 getParentPoint() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoDynamicCoordinatesInterface -> geogebra.common.i.b.aQ:
    geogebra.common.kernel.geos.GeoPoint2 getParentPoint() -> a
geogebra.common.kernel.algos.AlgoEccentricity -> geogebra.common.i.b.aR:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getEccentricity() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoElement -> geogebra.common.i.b.aS:
    geogebra.common.kernel.geos.GeoElement[] input -> a
    geogebra.common.kernel.geos.GeoElement[] output -> b
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> c
    geogebra.common.kernel.geos.GeoNumeric[] randomUnlabeledInput -> a
    boolean isPrintedInXML -> a
    boolean stopUpdateCascade -> b
    java.util.List outputHandler -> a
    java.util.TreeSet tempSet -> a
    boolean removed -> c
    java.util.ArrayList freeInputPoints -> a
    java.util.ArrayList inputPoints -> b
    java.lang.StringBuilder sbAE -> b
    geogebra.common.kernel.algos.AlgoElement updateAfterAlgo -> a
    void addToConstructionList() -> g
    void setOutputLength(int) -> a
    void setOnlyOutput(geogebra.common.kernel.geos.ToGeoElement) -> a
    void setOutput(int,geogebra.common.kernel.geos.GeoElement) -> a
    void setOutput(geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoElement getOutput(int) -> a
    int getOutputLength() -> c
    void refreshOutput() -> h
    java.lang.String getCommandString(geogebra.common.kernel.algos.Algos) -> a
    void compute() -> b
    void initForNearToRelationship() -> d
    boolean isNearToAlgorithm() -> b
    void update() -> i
    void updateCascadeAlgos(java.util.ArrayList) -> a
    java.util.TreeSet getTempSet() -> b
    geogebra.common.kernel.geos.GeoElement[] getOutput() -> b
    geogebra.common.kernel.geos.GeoElement[] getInput() -> c
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a_
    void setDependencies() -> j
    void doSetDependencies() -> k
    void setRandomUnlabeledInput() -> a
    void setEfficientDependencies(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void setOutputDependencies() -> e
    void setOutputDependencies(geogebra.common.kernel.geos.GeoElement) -> a
    boolean euclidianViewUpdate() -> a
    void remove() -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void removeOutputExcept(geogebra.common.kernel.geos.GeoElement) -> c
    void notifyAdd() -> l
    void notifyRemove() -> m
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> d
    boolean hasSingleOutputType() -> d
    boolean isAlgoElement() -> e
    boolean isGeoElement() -> h_
    boolean isConsProtocolBreakpoint() -> g
    int compareTo(geogebra.common.kernel.algos.ConstructionElement) -> a
    int getConstructionIndex() -> a_
    int getMinConstructionIndex() -> d
    int getMaxConstructionIndex() -> e
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void addPredecessorsToSet(java.util.TreeSet,boolean) -> a
    void addRandomizablePredecessorsToSet(java.util.TreeSet) -> a
    java.util.ArrayList getFreeInputPoints() -> a
    java.util.ArrayList getInputPoints() -> b
    boolean isIndependent() -> h
    java.lang.String getNameDescription() -> a
    java.lang.String getAlgebraDescriptionRegrOut(geogebra.common.kernel.StringTemplate) -> d
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate,boolean) -> a
    void appendCheckVector(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoElement,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toString() -> toString
    java.lang.String getCommandName(geogebra.common.kernel.StringTemplate) -> e
    void getXML(java.lang.StringBuilder) -> a
    java.lang.String getXML() -> b
    void getXML(java.lang.StringBuilder,boolean) -> a
    void getOutputXML(java.lang.StringBuilder) -> b
    java.lang.String getExpXML(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getCmdXML(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setPrintedInXML(boolean) -> a_
    boolean isPrintedInXML() -> i
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toExpString(geogebra.common.kernel.StringTemplate) -> g
    boolean doStopUpdateCascade() -> j
    void setStopUpdateCascade(boolean) -> b_
    boolean wantsConstructionProtocolUpdate() -> c
    void setUpdateAfterAlgo(geogebra.common.kernel.algos.AlgoElement) -> a
    geogebra.common.kernel.algos.AlgoElement getUpdateAfterAlgo() -> a
    void removeOutputFromAlgebraView() -> n
    void removeOutputFromPicking() -> o
    java.util.List getOutputHandler() -> a
    void setOutputHandler(java.util.List) -> a
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoElement$OutputHandler -> geogebra.common.i.b.aS$a:
    geogebra.common.kernel.algos.AlgoElement$elementFactory fac -> a
    java.util.ArrayList outputList -> a
    java.lang.String[] labels -> a
    java.lang.String indexLabel -> a
    boolean setLabels -> a
    int labelsSetLength -> a
    geogebra.common.kernel.algos.AlgoElement this$0 -> a
    void removeFromHandler() -> a
    void adjustOutputSize(int) -> a
    void augmentOutputSize(int) -> b
    void augmentOutputSize(int,boolean) -> a
    void addOutput(geogebra.common.kernel.geos.GeoElement[],boolean,boolean) -> a
    void addOutput(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setLabels(java.lang.String[]) -> a
    void setIndexLabels(java.lang.String) -> a
    void updateLabels() -> b
    geogebra.common.kernel.geos.GeoElement getElement(int) -> a
    geogebra.common.kernel.geos.GeoElement[] getOutput(geogebra.common.kernel.geos.GeoElement[]) -> a
    int size() -> a
geogebra.common.kernel.algos.AlgoElement$elementFactory -> geogebra.common.i.b.aS$b:
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoEllipseFociLength -> geogebra.common.i.b.aT:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoEllipseFociPoint -> geogebra.common.i.b.aU:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoConic ellipse -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getEllipse() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoExcentricity -> geogebra.common.i.b.aV:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLinearEccentricity() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoExtremumMulti -> geogebra.common.i.b.aW:
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getExtremumPoints() -> a
    void setInputOutput() -> a
    void compute() -> b
    double[] findExtremums(geogebra.common.kernel.roots.RealRootFunction,double,double,int) -> a
    int findNumberOfSamples(double,double) -> a
    double gradient(geogebra.common.kernel.roots.RealRootFunction,double,double,double) -> a
geogebra.common.kernel.algos.AlgoExtremumPolynomial -> geogebra.common.i.b.aX:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFirst -> geogebra.common.i.b.aY:
    geogebra.common.kernel.geos.GeoElement inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFirstLocus -> geogebra.common.i.b.aZ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFirstString -> geogebra.common.i.b.ba:
    geogebra.common.kernel.geos.GeoText inputText -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoText outputText -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFitPoly -> geogebra.common.i.b.bb:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.arithmetic.NumberValue degree -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.geos.GeoElement geodegree -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitPoly() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFitPow -> geogebra.common.i.b.bc:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitPow() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFitSin -> geogebra.common.i.b.bd:
    geogebra.common.main.AbstractApplication app -> b
    geogebra.common.kernel.Kernel k -> b
    double a -> a
    double b -> b
    double c -> c
    double d -> d
    double[] xd -> a
    double[] yd -> b
    int size -> a
    int iterations -> b
    boolean error -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitSin() -> a
    void compute() -> b
    void doReg() -> e
    void findParameters() -> f
    void sinus_Reg() -> p
    double sin(double,double,double) -> a
    double cos(double,double,double) -> b
    double f(double,double,double,double,double) -> a
    double df_a() -> a
    double df_b(double,double,double) -> c
    double df_c(double,double,double,double) -> a
    double df_d(double,double,double,double) -> b
    double beta(double,double,double,double,double,double) -> a
    double beta2(double[],double[],double,double,double,double) -> a
    double beta(double[],double[],double,double,double,double) -> b
    int direction(double,double,double) -> a
    void getPoints() -> q
    boolean nearmaxmin(double,double,double,int,int,double,double) -> a
    void errorMsg(java.lang.String) -> a
    int findNumberOfHalfPeriods(int,int,int) -> a
geogebra.common.kernel.algos.AlgoFlatten -> geogebra.common.i.b.be:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void flatten(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFocus -> geogebra.common.i.b.bf:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint2[] focus -> a
    double temp1 -> a
    double temp2 -> b
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getFocus() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFractionText -> geogebra.common.i.b.bg:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.geos.GeoText text -> a
    double[] frac -> a
    java.lang.StringBuilder sb -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    double[] DecimalToFraction(double,double) -> a
    boolean isLaTeXTextCommand() -> k
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.algos.AlgoFrequency -> geogebra.common.i.b.bh:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoList frequency -> c
    geogebra.common.kernel.geos.GeoList value -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    geogebra.common.kernel.geos.GeoList getValue() -> b
    void compute() -> b
geogebra.common.kernel.algos.AlgoFrequencyPolygon -> geogebra.common.i.b.bi:
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoPolyLine outputPolyLine -> a
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.algos.AlgoHistogram algoHistogram -> a
    boolean right -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void setOutput() -> e
    geogebra.common.kernel.geos.GeoPolyLine getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFrequencyTable -> geogebra.common.i.b.bj:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList classList -> b
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoBoolean useDensity -> b
    geogebra.common.kernel.geos.GeoNumeric density -> a
    geogebra.common.kernel.geos.GeoText table -> a
    geogebra.common.kernel.algos.AlgoFrequency freq -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFunctionAreaSums -> geogebra.common.i.b.bk:
    double CHECKPOINTS -> a
    int type -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue n -> c
    geogebra.common.kernel.arithmetic.NumberValue width -> d
    geogebra.common.kernel.arithmetic.NumberValue density -> e
    geogebra.common.kernel.arithmetic.NumberValue p1 -> f
    geogebra.common.kernel.arithmetic.NumberValue p2 -> g
    geogebra.common.kernel.arithmetic.NumberValue p3 -> h
    geogebra.common.kernel.arithmetic.NumberValue d -> i
    geogebra.common.kernel.geos.GeoList list1 -> a
    geogebra.common.kernel.geos.GeoList list2 -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoElement ngeo -> c
    geogebra.common.kernel.geos.GeoElement dgeo -> d
    geogebra.common.kernel.geos.GeoElement widthGeo -> e
    geogebra.common.kernel.geos.GeoElement densityGeo -> f
    geogebra.common.kernel.geos.GeoElement useDensityGeo -> g
    geogebra.common.kernel.geos.GeoElement isCumulative -> h
    geogebra.common.kernel.geos.GeoElement p1geo -> i
    geogebra.common.kernel.geos.GeoElement p2geo -> j
    geogebra.common.kernel.geos.GeoElement p3geo -> k
    geogebra.common.kernel.geos.GeoNumeric sum -> a
    int N -> b
    double STEP -> b
    double[] yval -> a
    double[] leftBorder -> b
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    double freqMax -> c
    boolean histogramRight -> a
    geogebra.common.kernel.arithmetic.NumberValue getP1() -> a
    geogebra.common.kernel.arithmetic.NumberValue getP2() -> b
    geogebra.common.kernel.arithmetic.NumberValue getP3() -> c
    geogebra.common.kernel.geos.GeoElement getDensityGeo() -> a
    geogebra.common.kernel.geos.GeoElement getUseDensityGeo() -> b
    geogebra.common.kernel.geos.GeoElement getIsCumulative() -> c
    double getFreqMax() -> a
    double[] getYValue() -> a
    double[] getLeftBorder() -> b
    boolean isRight() -> l
    boolean euclidianViewUpdate() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getF() -> a
    int getIntervals() -> f
    double getStep() -> b
    double[] getValues() -> c
    geogebra.common.kernel.geos.GeoNumeric getSum() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> d
    geogebra.common.kernel.arithmetic.NumberValue getB() -> e
    geogebra.common.kernel.geos.GeoNumeric getN() -> b
    geogebra.common.kernel.geos.GeoNumeric getD() -> c
    void compute() -> b
    void compute(boolean) -> c
    boolean functionDefined(double,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean useTrapeziums() -> m
    boolean isHistogram() -> n
    int getType() -> g
    boolean prepareDistributionLists() -> p
    void loadDistributionLists(int,int,org.apache.commons.math.distribution.IntegerDistribution) -> a
    void update() -> i
geogebra.common.kernel.algos.AlgoFunctionFreehand -> geogebra.common.i.b.bl:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunction g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFunctionInterval -> geogebra.common.i.b.bm:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.ExpressionNode exp -> a
    geogebra.common.kernel.arithmetic.ExpressionNode exp2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    void compute() -> b
    boolean hasEqualExpressions(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoFunctionMax -> geogebra.common.i.b.bn:
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.geos.GeoPoint2 E -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoFunctionMin -> geogebra.common.i.b.bo:
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    geogebra.common.kernel.geos.GeoPoint2 E -> a
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoGCD -> geogebra.common.i.b.bp:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoGeoPointsFunction -> geogebra.common.i.b.bq:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    java.lang.String[] labels -> a
    boolean initLabels -> b
    boolean setLabels -> a
    geogebra.common.kernel.geos.GeoPoint2[] getPoints() -> b
    void showOneRootInAlgebraView() -> e
    void removeDuplicates(double[]) -> a
    void setPoints(double[],int) -> a
    void updateLabels(int) -> b
    void noUndefinedPointsInAlgebraView(geogebra.common.kernel.geos.GeoPoint2[]) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initPoints(int) -> c
    void removePoint(int) -> e
geogebra.common.kernel.algos.AlgoHistogram -> geogebra.common.i.b.br:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoHistogram copy() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoHyperbolaFociLength -> geogebra.common.i.b.bs:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoHyperbolaFociPoint -> geogebra.common.i.b.bt:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoConic hyperbola -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getHyperbola() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIf -> geogebra.common.i.b.bu:
    geogebra.common.kernel.geos.GeoBoolean condition -> a
    geogebra.common.kernel.geos.GeoElement ifGeo -> a
    geogebra.common.kernel.geos.GeoElement elseGeo -> b
    geogebra.common.kernel.geos.GeoElement result -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIfFunction -> geogebra.common.i.b.bv:
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> b
    geogebra.common.kernel.geos.GeoFunction elseFun -> c
    geogebra.common.kernel.geos.GeoFunctionConditional result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoImageCorner -> geogebra.common.i.b.bw:
    geogebra.common.kernel.geos.GeoImage img -> a
    geogebra.common.kernel.geos.GeoPoint2 corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getCorner() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIncircle -> geogebra.common.i.b.bx:
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoPointND C -> c
    geogebra.common.kernel.kernelND.GeoConicND circle -> a
    geogebra.common.kernel.geos.GeoLine bisectorC -> a
    geogebra.common.kernel.geos.GeoLine bisectorB -> b
    geogebra.common.kernel.geos.GeoLine sideBC -> c
    geogebra.common.kernel.geos.GeoLine heightBC -> d
    geogebra.common.kernel.geos.GeoPoint2 heightFoot -> a
    geogebra.common.kernel.geos.GeoPoint2 incenter -> b
    geogebra.common.kernel.geos.GeoPoint2 A1 -> c
    geogebra.common.kernel.geos.GeoPoint2 B1 -> d
    geogebra.common.kernel.geos.GeoPoint2 C1 -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoConicND getCircle() -> a
    geogebra.common.kernel.geos.GeoPoint2 getA() -> a
    geogebra.common.kernel.geos.GeoPoint2 getB() -> b
    geogebra.common.kernel.geos.GeoPoint2 getC() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIndexOf -> geogebra.common.i.b.by:
    geogebra.common.kernel.geos.GeoElement hayStack -> a
    geogebra.common.kernel.geos.GeoElement needle -> b
    geogebra.common.kernel.geos.GeoNumeric index -> a
    geogebra.common.kernel.arithmetic.NumberValue start -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoInsert -> geogebra.common.i.b.bz:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int insertPoint -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntegralFunctions -> geogebra.common.i.b.bA:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoBoolean evaluate -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric intF -> b
    geogebra.common.kernel.geos.GeoNumeric intG -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoIntegralFunctions copy() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getIntegral() -> a
    geogebra.common.kernel.geos.GeoFunction getF() -> a
    geogebra.common.kernel.geos.GeoFunction getG() -> b
    geogebra.common.kernel.arithmetic.NumberValue getA() -> a
    geogebra.common.kernel.arithmetic.NumberValue getB() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoIntersect -> geogebra.common.i.b.bB:
    void avoidDoubleTangentPoint() -> a
    int getClosestPointIndex(double,double) -> a
    int getClosestPointIndex(geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getLastDefinedIntersectionPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getIntersectionPoints() -> b
geogebra.common.kernel.algos.AlgoIntersectAbstract -> geogebra.common.i.b.bC:
geogebra.common.kernel.algos.AlgoIntersectConics -> geogebra.common.i.b.bD:
    geogebra.common.kernel.geos.GeoConic A -> a
    geogebra.common.kernel.geos.GeoConic B -> b
    geogebra.common.kernel.geos.GeoPoint2[] P -> a
    geogebra.common.kernel.geos.GeoPoint2[] D -> b
    geogebra.common.kernel.geos.GeoPoint2[] Q -> c
    geogebra.common.kernel.geos.GeoConic degConic -> c
    geogebra.common.kernel.geos.GeoLine tempLine -> a
    int[] age -> a
    int[] permutation -> b
    double[][] distTable -> a
    boolean[] isQonPath -> a
    boolean[] isPalive -> b
    boolean firstIntersection -> a
    boolean isLimitedPathSituation -> b
    boolean isPermutationNeeded -> c
    boolean possibleSpecialCase -> d
    int specialCasePointOnCircleIndex -> a
    geogebra.common.kernel.PointPairList pointList -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    geogebra.common.kernel.SystemOfEquationsSolver sysSolver -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setIncidence() -> f
    void setInputOutput() -> e
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoConic getA() -> a
    geogebra.common.kernel.geos.GeoConic getB() -> b
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    boolean isNearToAlgorithm() -> b
    void initForNearToRelationship() -> d
    void compute() -> b
    boolean handleSpecialCase() -> l
    geogebra.common.kernel.geos.GeoPoint2 getPointFrom1on2(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    void computeNonContinous() -> p
    void computeContinous() -> t
    void handleLimitedPaths() -> u
    void updateQonPath() -> v
    boolean pointLiesOnBothPaths(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isSingularitySituation() -> m
    void intersectConics(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    void moveDefinedPointsToFront(geogebra.common.kernel.geos.GeoPoint2[]) -> a
    void intersectWithDegenerate(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[]) -> b
    boolean testPoints(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[],double) -> a
    boolean calcIntersectionPoints(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[],double) -> b
    boolean intersectConicsWithEqualSubmatrixS(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    void normalizeArray(double[]) -> a
    void distanceTable(geogebra.common.kernel.geos.GeoPoint2[],int[],geogebra.common.kernel.geos.GeoPoint2[],double[][]) -> a
    void setNearTo(geogebra.common.kernel.geos.GeoPoint2[],boolean[],geogebra.common.kernel.geos.GeoPoint2[],boolean[],double[][],geogebra.common.kernel.PointPairList,int[]) -> a
geogebra.common.kernel.algos.AlgoIntersectFunctionLineNewton -> geogebra.common.i.b.bE:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 rootPoint -> b
    geogebra.common.kernel.arithmetic.Function diffFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoPoint2 getIntersectionPoint() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectFunctions -> geogebra.common.i.b.bF:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
geogebra.common.kernel.algos.AlgoIntersectFunctionsNewton -> geogebra.common.i.b.bG:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 rootPoint -> b
    geogebra.common.kernel.arithmetic.Function diffFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoPoint2 getIntersectionPoint() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectLineConic -> geogebra.common.i.b.bH:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint2[] D -> c
    geogebra.common.kernel.geos.GeoPoint2[] P -> a
    geogebra.common.kernel.geos.GeoPoint2[] Q -> b
    int intersectionType -> a
    int[] age -> a
    int[] permutation -> b
    double[][] distTable -> a
    boolean[] isQonPath -> a
    boolean[] isPalive -> b
    int i -> c
    boolean isDefinedAsTangent -> c
    boolean firstIntersection -> d
    boolean isPermutationNeeded -> e
    geogebra.common.kernel.geos.GeoPoint2 tangentPoint -> a
    geogebra.common.kernel.PointPairList pointList -> a
    boolean isLimitedPathSituation -> f
    boolean possibleSpecialCase -> a
    boolean handlingSpecialCase -> b
    int specialCasePointOnCircleIndex -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setIncidence() -> p
    void initElements() -> e
    void setInputOutput() -> f
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    boolean isNearToAlgorithm() -> b
    void initForNearToRelationship() -> d
    void compute() -> b
    boolean handleSpecialCase() -> l
    void computeNonContinous() -> t
    void computeContinous() -> u
    void handleLimitedPaths() -> v
    void updateQonPath() -> w
    boolean pointLiesOnBothPaths(geogebra.common.kernel.geos.GeoPoint2) -> a
    int intersect(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    int intersectLineConic(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.geos.GeoPoint2[]) -> a
    boolean testPoints(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoPoint2[],double) -> a
geogebra.common.kernel.algos.AlgoIntersectLineConicRegion -> geogebra.common.i.b.bI:
    geogebra.common.kernel.geos.GeoLine[] lines -> a
    int numberOfPoints -> c
    int numberOfLineParts -> d
    int numberOfOutputLines -> e
    java.lang.String labelPrefixForLines -> a
    java.lang.Double tMin -> a
    java.lang.Double tMax -> b
    boolean currentPartIsInRegion -> c
    geogebra.common.kernel.geos.GeoPoint2[] outputPoints -> c
    geogebra.common.kernel.geos.GeoLine[] outputLines -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void initElements() -> e
    geogebra.common.kernel.geos.GeoLine[] getIntersectionLines() -> a
    void compute() -> b
    void setLabelsForPointsAndLines() -> t
    void refreshOutput() -> h
    void setInputOutput() -> f
    boolean inOpenInterval(double,double,double) -> a
    void initCurrentPartIsInRegion() -> p
geogebra.common.kernel.algos.AlgoIntersectLinePolyLine -> geogebra.common.i.b.bJ:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.geos.GeoPolyLine p -> a
    geogebra.common.kernel.geos.GeoPolyLineInterface pi -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    java.util.TreeMap newCoords -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void intersectionsCoords(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolyLine,java.util.TreeMap) -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolyLine$1 -> geogebra.common.i.b.bK:
    geogebra.common.kernel.algos.AlgoIntersectLinePolyLine this$0 -> a
    geogebra.common.kernel.geos.GeoPoint2 newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolygonalRegion -> geogebra.common.i.b.bL:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.geos.GeoPolygon p -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegments -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> b
    int spaceDim -> a
    java.util.TreeMap newCoords -> a
    java.util.TreeMap newSegmentCoords -> b
    geogebra.common.awt.Color BLUE_VIOLET -> a
    int THICK_LINE_WITHIN_LINE -> b
    java.lang.String labelPrefix -> a
    void init() -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputSegments() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    void intersectionsCoords(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolygon,java.util.TreeMap) -> a
    void intersectionsSegments(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolygon,java.util.TreeMap,java.util.TreeMap) -> a
    void compute() -> b
    void setStyle(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setLabels(java.lang.String[]) -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolygonalRegion$1 -> geogebra.common.i.b.bM:
    geogebra.common.kernel.algos.AlgoIntersectLinePolygonalRegion this$0 -> a
    geogebra.common.kernel.geos.GeoPoint2 newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoIntersectLinePolygonalRegion$2 -> geogebra.common.i.b.bN:
    geogebra.common.kernel.algos.AlgoIntersectLinePolygonalRegion this$0 -> a
    geogebra.common.kernel.geos.GeoSegment newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoIntersectLines -> geogebra.common.i.b.bO:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoLine h -> b
    geogebra.common.kernel.geos.GeoPoint2 S -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Polynomial[] botanaPolynomials -> b
    geogebra.common.kernel.prover.Variable[] botanaVars -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoIntersectPolynomialConic -> geogebra.common.i.b.bP:
    geogebra.common.kernel.geos.GeoFunction h -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    double getYValue(double) -> a
geogebra.common.kernel.algos.AlgoIntersectPolynomialLine -> geogebra.common.i.b.bQ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectPolynomials -> geogebra.common.i.b.bR:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersectSingle -> geogebra.common.i.b.bS:
    geogebra.common.kernel.algos.AlgoIntersect algo -> a
    int index -> a
    geogebra.common.kernel.geos.GeoPoint2 refPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 point -> b
    geogebra.common.kernel.geos.GeoPoint2[] parentOutput -> a
    void setIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    boolean isNearToAlgorithm() -> b
    void initForNearToRelationship() -> d
    void compute() -> b
    void remove() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoIntersection -> geogebra.common.i.b.bT:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList inputList2 -> b
    geogebra.common.kernel.geos.GeoList outputList -> c
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalAbstract -> geogebra.common.i.b.bU:
    geogebra.common.kernel.geos.GeoInterval interval -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.algos.AlgoIntervalMax -> geogebra.common.i.b.bV:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalMidpoint -> geogebra.common.i.b.bW:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIntervalMin -> geogebra.common.i.b.bX:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoInvert -> geogebra.common.i.b.bY:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIsInRegion -> geogebra.common.i.b.bZ:
    geogebra.common.kernel.kernelND.GeoPointND pi -> a
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.geos.GeoBoolean result -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoIsInteger -> geogebra.common.i.b.ca:
    geogebra.common.kernel.geos.GeoNumeric inputGeo -> a
    geogebra.common.kernel.geos.GeoBoolean outputBoolean -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIteration -> geogebra.common.i.b.cb:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue startValue -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoElement startValueGeo -> a
    geogebra.common.kernel.geos.GeoElement nGeo -> b
    geogebra.common.kernel.geos.GeoNumeric result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoIterationList -> geogebra.common.i.b.cc:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue startValue -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoElement startValueGeo -> a
    geogebra.common.kernel.geos.GeoElement nGeo -> b
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.algos.AlgoJoin -> geogebra.common.i.b.cd:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoJoinPoints -> geogebra.common.i.b.ce:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoPoint2 Q -> b
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Variable[] botanaVars -> a
    void addIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoJoinPointsRay -> geogebra.common.i.b.cf:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoPoint2 Q -> b
    geogebra.common.kernel.geos.GeoRay ray -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoRay getRay() -> a
    geogebra.common.kernel.geos.GeoPoint2 getP() -> a
    geogebra.common.kernel.geos.GeoPoint2 getQ() -> b
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoJoinPointsSegment -> geogebra.common.i.b.cg:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoPoint2 Q -> b
    geogebra.common.kernel.geos.GeoSegment s -> a
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    void setIncidence() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void modifyInputPoints(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoSegment getSegment() -> a
    geogebra.common.kernel.geos.GeoPolygon getPoly() -> a
    void compute() -> b
    void remove() -> c
    void removeSegmentOnly() -> e
    int getConstructionIndex() -> a_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoKeepIf -> geogebra.common.i.b.ch:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.geos.GeoFunction boolFun -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLCM -> geogebra.common.i.b.ci:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLaTeX -> geogebra.common.i.b.cj:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoBoolean substituteVars -> a
    geogebra.common.kernel.geos.GeoBoolean showName -> b
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoLast -> geogebra.common.i.b.ck:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLastString -> geogebra.common.i.b.cl:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLengthLocus -> geogebra.common.i.b.cm:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLengthSegment -> geogebra.common.i.b.cn:
    geogebra.common.kernel.kernelND.GeoSegmentND seg -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLengthVector -> geogebra.common.i.b.co:
    geogebra.common.kernel.geos.GeoVec3D v -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    double[] coords -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLetterToUnicode -> geogebra.common.i.b.cp:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLineBisector -> geogebra.common.i.b.cq:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint2 midPoint -> c
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoLineBisectorSegment -> geogebra.common.i.b.cr:
    geogebra.common.kernel.geos.GeoSegment s -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint2 midPoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLinePointLine -> geogebra.common.i.b.cs:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoLinePointVector -> geogebra.common.i.b.ct:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoListElement -> geogebra.common.i.b.cu:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.arithmetic.NumberValue[] num2 -> a
    geogebra.common.kernel.geos.GeoElement numGeo -> a
    geogebra.common.kernel.geos.GeoElement element -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate,boolean) -> a
geogebra.common.kernel.algos.AlgoListGCD -> geogebra.common.i.b.cv:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getGCD() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListLCM -> geogebra.common.i.b.cw:
    java.math.BigInteger bigZero -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLCM() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListLength -> geogebra.common.i.b.cx:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListMax -> geogebra.common.i.b.cy:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric max -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMax() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoListMin -> geogebra.common.i.b.cz:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric min -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMin() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoLocus -> geogebra.common.i.b.cA:
    int MAX_TIME_FOR_ONE_STEP -> a
    int MAX_X_PIXEL_DIST -> b
    int MAX_Y_PIXEL_DIST -> c
    geogebra.common.kernel.geos.GeoPoint2 movingPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 locusPoint -> b
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.PathMover pathMover -> a
    int pointCount -> d
    geogebra.common.kernel.geos.GeoPoint2 Pcopy -> c
    geogebra.common.kernel.geos.GeoPoint2 Qcopy -> d
    geogebra.common.kernel.geos.GeoPoint2 PstartPos -> e
    geogebra.common.kernel.geos.GeoPoint2 QstartPos -> f
    double lastX -> a
    double lastY -> b
    double maxXdist -> c
    double maxYdist -> d
    double xmin -> e
    double xmax -> f
    double ymin -> g
    double ymax -> h
    double farXmin -> i
    double farXmax -> j
    double farYmin -> k
    double farYmax -> l
    geogebra.common.awt.Rectangle2D nearToScreenRect -> a
    boolean continuous -> a
    boolean lastFarAway -> b
    boolean foundDefined -> c
    boolean maxTimeExceeded -> d
    geogebra.common.kernel.Construction macroCons -> b
    geogebra.common.kernel.MacroKernel macroKernel -> a
    java.util.TreeSet locusConsOrigElements -> a
    java.util.TreeSet Qin -> b
    long countUpdates -> a
    double[] paramCache -> a
    geogebra.common.awt.Point2D[] qcopyCache -> a
    int cacheIndex -> e
    long useCache -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void init() -> e
    void setInputOutput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    void buildLocusMacroConstruction(java.util.TreeSet) -> b
    void resetMacroConstruction() -> f
    void compute() -> b
    boolean isPathIterable(geogebra.common.kernel.geos.GeoElement) -> a
    void pcopyUpdateCascade() -> p
    void clearCache() -> q
    geogebra.common.awt.Point2D getCachedPoint(double) -> a
    void putCachedPoint(double,geogebra.common.kernel.geos.GeoPoint2) -> a
    void insertPoint(double,double,boolean) -> a
    boolean isFarAway(double,double) -> a
    boolean distanceOK(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean distanceSmall(geogebra.common.kernel.geos.GeoPoint2) -> b
    void updateScreenBorders() -> r
    boolean euclidianViewUpdate() -> a
geogebra.common.kernel.algos.AlgoLocusSlider -> geogebra.common.i.b.cB:
    int MAX_TIME_FOR_ONE_STEP -> a
    int MAX_X_PIXEL_DIST -> b
    int MAX_Y_PIXEL_DIST -> c
    geogebra.common.kernel.geos.GeoPoint2 locusPoint -> a
    geogebra.common.kernel.geos.GeoNumeric movingSlider -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoElement[] efficientInput -> b
    geogebra.common.kernel.geos.GeoElement[] standardInput -> c
    geogebra.common.kernel.SliderMover sliderMover -> a
    int pointCount -> d
    geogebra.common.kernel.geos.GeoPoint2 Qcopy -> b
    geogebra.common.kernel.geos.GeoPoint2 QstartPos -> c
    geogebra.common.kernel.geos.GeoNumeric Pcopy -> b
    geogebra.common.kernel.geos.GeoNumeric PstartPos -> c
    double lastX -> a
    double lastY -> b
    double maxXdist -> c
    double maxYdist -> d
    double xmin -> e
    double xmax -> f
    double ymin -> g
    double ymax -> h
    double farXmin -> i
    double farXmax -> j
    double farYmin -> k
    double farYmax -> l
    geogebra.common.awt.Rectangle2D nearToScreenRect -> a
    boolean continuous -> a
    boolean lastFarAway -> b
    boolean foundDefined -> c
    boolean maxTimeExceeded -> d
    geogebra.common.kernel.Construction macroCons -> b
    geogebra.common.kernel.MacroKernel macroKernel -> a
    java.util.TreeSet locusConsOrigElements -> a
    java.util.TreeSet Qin -> b
    long countUpdates -> a
    double[] paramCache -> a
    geogebra.common.awt.Point2D[] qcopyCache -> a
    int cacheIndex -> e
    long useCache -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void init() -> e
    void setInputOutput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
    void buildLocusMacroConstruction(java.util.TreeSet) -> b
    void resetMacroConstruction() -> f
    void compute() -> b
    void pcopyUpdateCascade() -> p
    void clearCache() -> q
    geogebra.common.awt.Point2D getCachedPoint(double) -> a
    void putCachedPoint(double,geogebra.common.kernel.geos.GeoPoint2) -> a
    void insertPoint(double,double,boolean) -> a
    boolean isFarAway(double,double) -> a
    boolean distanceOK(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean distanceSmall(geogebra.common.kernel.geos.GeoPoint2) -> b
    void updateScreenBorders() -> r
    boolean euclidianViewUpdate() -> a
geogebra.common.kernel.algos.AlgoLocusSliderInterface -> geogebra.common.i.b.cC:
geogebra.common.kernel.algos.AlgoMacro -> geogebra.common.i.b.cD:
    geogebra.common.kernel.Macro macro -> a
    geogebra.common.kernel.geos.GeoElement[] macroInput -> b
    geogebra.common.kernel.geos.GeoElement[] macroOutput -> c
    java.util.HashMap macroToAlgoMap -> a
    java.util.ArrayList macroOutputAndReferencedGeos -> a
    java.util.ArrayList algoOutputAndReferencedGeos -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void remove() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String getCommandName(geogebra.common.kernel.StringTemplate) -> e
    void setInputOutput() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isMacroInputObject(geogebra.common.kernel.geos.GeoElement) -> a
    void setMacroConstructionState() -> e
    void getMacroConstructionState() -> f
    void createOutputObjects() -> p
    void initMap() -> q
    void map(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getAlgoGeo(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement createAlgoCopy(geogebra.common.kernel.geos.GeoElement) -> b
    void initSpecialReferences(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    void initLine(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoLine) -> a
    void initConic(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoConic) -> a
    void initLocateable(geogebra.common.kernel.Locateable,geogebra.common.kernel.Locateable) -> a
    void initPolygon(geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoPolygon) -> a
    void initList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    void initFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    void replaceReferencedMacroObjects(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.common.kernel.algos.AlgoMacroInterface -> geogebra.common.i.b.cE:
    void initFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    void initList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.algos.AlgoMax -> geogebra.common.i.b.cF:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoMaximize -> geogebra.common.i.b.cG:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoMidpoint -> geogebra.common.i.b.cH:
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Polynomial[] botanaPolynomials -> b
    geogebra.common.kernel.prover.Variable[] botanaVars -> a
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void copyCoords(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void computeMidCoords() -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
geogebra.common.kernel.algos.AlgoMidpointSegment -> geogebra.common.i.b.cI:
    geogebra.common.kernel.geos.GeoSegment segment -> a
    geogebra.common.kernel.geos.GeoPoint2 M -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> b
    geogebra.common.kernel.geos.GeoPoint2 Q -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoMin -> geogebra.common.i.b.cJ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoMinimize -> geogebra.common.i.b.cK:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoMirror -> geogebra.common.i.b.cL:
    geogebra.common.kernel.geos.Mirrorable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoLine mirrorLine -> a
    geogebra.common.kernel.geos.GeoPoint2 mirrorPoint -> a
    geogebra.common.kernel.geos.GeoConic mirrorConic -> a
    geogebra.common.kernel.geos.GeoElement mirror -> c
    geogebra.common.kernel.geos.GeoPoint2 transformedPoint -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
geogebra.common.kernel.algos.AlgoMod -> geogebra.common.i.b.cM:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoName -> geogebra.common.i.b.cN:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoNormalQuantilePlot -> geogebra.common.i.b.cO:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double[] zValues -> a
    double[] sortedData -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void calculateZValues(int) -> b
    geogebra.common.kernel.geos.GeoSegment getQQLineSegment() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoNumerator -> geogebra.common.i.b.cP:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue getPart(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoObject -> geogebra.common.i.b.cQ:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.String currentLabel -> a
    geogebra.common.kernel.geos.GeoElement refObject -> b
    geogebra.common.kernel.geos.GeoElement[] inputForUpdateSetPropagation -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void updateReferencedObject() -> e
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a_
geogebra.common.kernel.algos.AlgoOptimize -> geogebra.common.i.b.cR:
    geogebra.common.kernel.Construction optCons -> b
    geogebra.common.kernel.optimization.ExtremumFinder extrFinder -> a
    geogebra.common.kernel.optimization.RealRootFunctionVariable i_am_not_a_real_function -> a
    geogebra.common.kernel.geos.GeoElement dep -> a
    geogebra.common.kernel.geos.GeoNumeric indep -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType type -> a
    boolean isrunning -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getResult() -> a
geogebra.common.kernel.algos.AlgoOptimize$OptimizationType -> geogebra.common.i.b.cR$a:
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType MINIMIZE -> a
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType MAXIMIZE -> b
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType[] ENUM$VALUES -> a
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType[] values() -> values
    geogebra.common.kernel.algos.AlgoOptimize$OptimizationType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.algos.AlgoOrdinal -> geogebra.common.i.b.cS:
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoOrthoLinePointConic -> geogebra.common.i.b.cT:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoConic l -> a
    geogebra.common.kernel.geos.GeoLine[] g -> a
    geogebra.common.kernel.geos.GeoNumeric[] n -> a
    geogebra.common.kernel.algos.AlgoPointOnPath[] algoPoint -> a
    geogebra.common.kernel.algos.AlgoClosestPoint closestPoint -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoLinePointLine -> geogebra.common.i.b.cU:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoLine g -> b
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoOrthoLinePointVector -> geogebra.common.i.b.cV:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoVectorLine -> geogebra.common.i.b.cW:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector n -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOrthoVectorVector -> geogebra.common.i.b.cX:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector n -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoOsculatingCircle -> geogebra.common.i.b.cY:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 R -> b
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoNumeric curv -> a
    geogebra.common.kernel.geos.GeoConic circle -> a
    geogebra.common.kernel.algos.AlgoCurvature algo -> a
    geogebra.common.kernel.algos.AlgoCurvatureVector cv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.algos.AlgoOsculatingCircleCurve -> geogebra.common.i.b.cZ:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 R -> b
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoNumeric curv -> a
    geogebra.common.kernel.geos.GeoConic circle -> a
    geogebra.common.kernel.algos.AlgoCurvatureCurve algo -> a
    geogebra.common.kernel.algos.AlgoCurvatureVectorCurve cv -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getCircle() -> a
    void compute() -> b
    void remove() -> c
geogebra.common.kernel.algos.AlgoParabolaParameter -> geogebra.common.i.b.da:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getParameter() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoParabolaPointLine -> geogebra.common.i.b.db:
    geogebra.common.kernel.geos.GeoPoint2 F -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoConic parabola -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConic getParabola() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPathParameter -> geogebra.common.i.b.dc:
    geogebra.common.kernel.geos.GeoPoint2 point -> a
    geogebra.common.kernel.geos.GeoNumeric value -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.algos.AlgoPerimeterLocus -> geogebra.common.i.b.dd:
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
geogebra.common.kernel.algos.AlgoPerimeterPoly -> geogebra.common.i.b.de:
    geogebra.common.kernel.geos.GeoPolygon polygon -> a
    geogebra.common.kernel.geos.GeoNumeric circum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric getCircumference() -> a
geogebra.common.kernel.algos.AlgoPointInRegion -> geogebra.common.i.b.df:
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPointList -> geogebra.common.i.b.dg:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoPointOnPath -> geogebra.common.i.b.dh:
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.arithmetic.NumberValue param -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.prover.Polynomial[] botanaPolynomials -> b
    geogebra.common.kernel.prover.Variable variable -> a
    geogebra.common.kernel.prover.Variable[] botanaVars -> a
    java.util.HashMap oldvalues -> a
    java.math.BigInteger[] exactCoordinates -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getP() -> a
    geogebra.common.kernel.Path getPath() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    boolean isChangeable() -> a_
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
geogebra.common.kernel.algos.AlgoPointVector -> geogebra.common.i.b.di:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoPoint2 Q -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getQ() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPointsFromList -> geogebra.common.i.b.dj:
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    java.lang.String[] labels -> a
    boolean initLabels -> a
    boolean setLabels -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getPoints() -> a
    void compute() -> b
    void setPoints(double[],double[],int) -> a
    void updateLabels(int) -> b
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initPoints(int) -> c
    void removeRootPoint(int) -> e
geogebra.common.kernel.algos.AlgoPolarLine -> geogebra.common.i.b.dk:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getLine() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPolyLine -> geogebra.common.i.b.dl:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoPolyLine poly -> a
    java.lang.StringBuilder sb -> a
    void createPolyLine(boolean) -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void updatePointArray(geogebra.common.kernel.geos.GeoList) -> a
    void setInputOutput() -> a
    void update() -> i
    geogebra.common.kernel.geos.GeoPoint2[] getPoints() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPolygon -> geogebra.common.i.b.dm:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoPolygon poly -> a
    geogebra.common.kernel.Matrix.CoordSys cs2D -> a
    geogebra.common.kernel.geos.GeoElement polyhedron -> a
    geogebra.common.kernel.kernelND.GeoDirectionND direction -> a
    java.lang.StringBuilder sb -> a
    void createPolygon(boolean) -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void updatePointArray(geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] createEfficientInput() -> e
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void setInputOutput() -> a
    void setOutput() -> e
    void update() -> i
    geogebra.common.kernel.geos.GeoPolygon getPoly() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getPoints() -> a
    void remove() -> c
    void compute() -> b
    void createStringBuilder(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPolygonIntersection -> geogebra.common.i.b.dn:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoPolygonOperation -> geogebra.common.i.b.do:
    geogebra.common.kernel.geos.GeoPolygon inPoly0 -> a
    geogebra.common.kernel.geos.GeoPolygon inPoly1 -> b
    geogebra.common.kernel.geos.GeoPolygon poly -> c
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation operationType -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim ev -> a
    boolean labelPointsAndSegments -> a
    boolean labelsNeedIniting -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$AlgoPolygonOperation$PolyOperation -> a
    void setInputOutput() -> a
    void setOutput() -> e
    geogebra.common.awt.Area getArea(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void compute() -> b
    void updateSegmentsAndPointsLabels() -> f
    void updatePointsArray(int) -> b
    void removePoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$algos$AlgoPolygonOperation$PolyOperation() -> a
geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation -> geogebra.common.i.b.do$a:
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation INTERSECTION -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation UNION -> b
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation DIFFERENCE -> c
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation[] ENUM$VALUES -> a
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation[] values() -> values
    geogebra.common.kernel.algos.AlgoPolygonOperation$PolyOperation valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.algos.AlgoPolygonRegular -> geogebra.common.i.b.dp:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    int numOld -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygon -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegments -> c
    geogebra.common.kernel.geos.GeoPoint2 centerPoint -> c
    geogebra.common.kernel.arithmetic.MyDouble rotAngle -> a
    boolean labelPointsAndSegments -> c
    boolean showNewSegmentsLabels -> a
    boolean showNewPointsLabels -> b
    boolean labelsNeedIniting -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPolygon getPoly() -> a
    void compute() -> b
    void compute(int) -> b
    void updateOutput(int) -> c
    void removePoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    void removeOutputExcept(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
geogebra.common.kernel.algos.AlgoPolygonRegular$1 -> geogebra.common.i.b.dq:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoPolygon newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonRegular$2 -> geogebra.common.i.b.dr:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoSegment newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonRegular$3 -> geogebra.common.i.b.ds:
    geogebra.common.kernel.algos.AlgoPolygonRegular this$0 -> a
    geogebra.common.kernel.geos.GeoPoint2 newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoPolygonUnion -> geogebra.common.i.b.dt:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoPolynomialFromCoordinates -> geogebra.common.i.b.du:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunction g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    geogebra.common.kernel.arithmetic.Function buildPolyFunctionExpression(geogebra.common.kernel.Kernel,double[]) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void polcoe(double[],double[],int,double[]) -> a
    void polcoeBig(double[],double[],int,double[]) -> b
geogebra.common.kernel.algos.AlgoPolynomialFromFunction -> geogebra.common.i.b.dv:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.parser.Parser parser -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    double evaluateToDouble(java.lang.String) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoPrimeFactorization -> geogebra.common.i.b.dw:
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    double LARGEST_INTEGER -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double,double) -> a
geogebra.common.kernel.algos.AlgoPrimeFactors -> geogebra.common.i.b.dx:
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> a
    double LARGEST_INTEGER -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.algos.AlgoProve -> geogebra.common.i.b.dy:
    geogebra.common.kernel.geos.GeoElement root -> a
    geogebra.common.kernel.geos.GeoBoolean bool -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoBoolean getGeoBoolean() -> a
    void compute() -> b
    java.lang.String getCommandName(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void update() -> i
geogebra.common.kernel.algos.AlgoRadius -> geogebra.common.i.b.dz:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getRadius() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRandomElement -> geogebra.common.i.b.dA:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement element -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRayPointVector -> geogebra.common.i.b.dB:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoRay ray -> a
    void setIncidence() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoRay getRay() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoReducedRowEchelonForm -> geogebra.common.i.b.dC:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRemoveUndefined -> geogebra.common.i.b.dD:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoResidualPlot -> geogebra.common.i.b.dE:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    double min -> a
    double max -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double[] getResidualBounds() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoReverse -> geogebra.common.i.b.dF:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRootInterval -> geogebra.common.i.b.dG:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoPoint2 rootPoint -> a
    geogebra.common.kernel.geos.GeoElement aGeo -> a
    geogebra.common.kernel.geos.GeoElement bGeo -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver rootFinder -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getRootPoint() -> a
    void compute() -> b
    double calcRoot() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRootList -> geogebra.common.i.b.dH:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoRootNewton -> geogebra.common.i.b.dI:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue start -> a
    geogebra.common.kernel.geos.GeoPoint2 rootPoint -> a
    geogebra.common.kernel.geos.GeoElement startGeo -> a
    org.apache.commons.math.analysis.solvers.NewtonSolver rootFinderNewton -> a
    org.apache.commons.math.analysis.solvers.BrentSolver rootFinderBrent -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getRootPoint() -> b
    void compute() -> b
    double calcRoot(geogebra.common.kernel.arithmetic.Function,double) -> a
    boolean checkRoot(geogebra.common.kernel.arithmetic.Function,double) -> a
    double[] getDomain(geogebra.common.kernel.arithmetic.Function,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRoots -> geogebra.common.i.b.dJ:
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> c
    geogebra.common.kernel.geos.GeoFunction f2 -> d
    geogebra.common.kernel.geos.GeoFunction diff -> e
    geogebra.common.kernel.arithmetic.NumberValue left -> a
    geogebra.common.kernel.geos.GeoElement geoleft -> a
    geogebra.common.kernel.arithmetic.NumberValue right -> b
    geogebra.common.kernel.geos.GeoElement georight -> b
    int type -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getRootPoints() -> c
    void setInputOutput() -> a
    void compute() -> b
    void compute2(geogebra.common.kernel.geos.GeoFunction) -> a
    double[] findRoots(geogebra.common.kernel.geos.GeoFunction,double,double,int) -> a
    double calcSingleRoot(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    int findNumberOfSamples(double,double) -> a
    boolean signChanged(geogebra.common.kernel.geos.GeoFunction,double) -> a
geogebra.common.kernel.algos.AlgoRootsPolynomial -> geogebra.common.i.b.dK:
    int mode -> b
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoLine line -> a
    geogebra.common.kernel.geos.GeoPoint2[] rootPoints -> a
    java.lang.String[] labels -> a
    boolean initLabels -> b
    boolean setLabels -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    double[] curRoots -> b
    int curRealRoots -> a
    geogebra.common.kernel.arithmetic.Function yValFunction -> a
    geogebra.common.kernel.arithmetic.Function diffFunction -> b
    geogebra.common.kernel.geos.GeoPoint2 tempPoint -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e
    geogebra.common.kernel.geos.GeoPoint2[] getRootPoints() -> c
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    void compute() -> b
    void computeRoots() -> f
    void computePolynomialIntersection() -> p
    void computePolyLineIntersection() -> t
    void calcRoots(geogebra.common.kernel.arithmetic.Function,int) -> a
    geogebra.common.kernel.roots.RealRootFunction calcRootsMultiple(geogebra.common.kernel.arithmetic.Function,int) -> a
    void ensureSignChanged(geogebra.common.kernel.roots.RealRootFunction) -> a
    void addToCurrentRoots(double[],int) -> b
    void removeRoot(int) -> e
    void setRootPoints(double[],int) -> a
    void updateLabels(int) -> b
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void initRootPoints(int) -> c
    void removeRootPoint(int) -> f
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoRotate -> geogebra.common.i.b.dL:
    geogebra.common.kernel.geos.Rotateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement angleGeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.algos.AlgoRotatePoint -> geogebra.common.i.b.dM:
    geogebra.common.kernel.geos.GeoPoint2 Q -> a
    geogebra.common.kernel.geos.PointRotateable out -> a
    geogebra.common.kernel.arithmetic.NumberValue angle -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoElement angleGeo -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.algos.AlgoRotateText -> geogebra.common.i.b.dN:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    geogebra.common.kernel.geos.GeoNumeric angle -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    void appendRotatedText(java.lang.StringBuilder,geogebra.common.kernel.geos.GeoText,double) -> a
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoRow -> geogebra.common.i.b.dO:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSelectedElement -> geogebra.common.i.b.dP:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoElement element -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSelectedIndex -> geogebra.common.i.b.dQ:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric index -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getElement() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSemicircle -> geogebra.common.i.b.dR:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoConicPart conicPart -> a
    geogebra.common.kernel.geos.GeoPoint2 M -> c
    geogebra.common.kernel.geos.GeoConic conic -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoConicPart getSemicircle() -> a
    geogebra.common.kernel.geos.GeoPoint2 getA() -> a
    geogebra.common.kernel.geos.GeoPoint2 getB() -> b
    geogebra.common.kernel.geos.GeoConic getConic() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoSequence -> geogebra.common.i.b.dS:
    geogebra.common.kernel.geos.GeoElement expression -> a
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.NumberValue var_from -> a
    geogebra.common.kernel.arithmetic.NumberValue var_to -> b
    geogebra.common.kernel.arithmetic.NumberValue var_step -> c
    geogebra.common.kernel.geos.GeoElement var_from_geo -> b
    geogebra.common.kernel.geos.GeoElement var_to_geo -> c
    geogebra.common.kernel.geos.GeoElement var_step_geo -> d
    geogebra.common.kernel.geos.GeoList list -> a
    boolean isSimple -> a
    double last_from -> a
    double last_to -> b
    double last_step -> c
    boolean expIsFunctionOrCurve -> b
    boolean isEmpty -> c
    geogebra.common.kernel.algos.AlgoElement expressionParentAlgo -> a
    boolean updateRunning -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a_
    void compute() -> b
    void computeSimple() -> e
    void createNewList(double,double,double) -> a
    void addElement(int) -> b
    geogebra.common.kernel.geos.GeoElement createNewListElement() -> a
    void updateListItems(double,double,double) -> b
    void updateLocalVar(double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoShearOrStretch -> geogebra.common.i.b.dT:
    geogebra.common.kernel.MatrixTransformable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> a
    geogebra.common.kernel.geos.GeoElement outGeo -> b
    geogebra.common.kernel.geos.GeoVec3D l -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    boolean shear -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial -> geogebra.common.i.b.dU:
    boolean setLabels -> a
    geogebra.common.kernel.EquationSolverInterface eqnSolver -> a
    geogebra.common.kernel.geos.GeoElement[] geos -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler points -> a
    void setRootsPolynomial(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    void setRootsPolynomialWithinRange(org.apache.commons.math.analysis.polynomials.PolynomialFunction,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2[] getIntersectionPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getLastDefinedIntersectionPoints() -> b
    void setInputOutput() -> e
    int getRoots(double[],geogebra.common.kernel.EquationSolverInterface) -> a
    void doCalc(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> b
    void doCalc(org.apache.commons.math.analysis.polynomials.PolynomialFunction,double,double) -> b
    double distancePairSq(double[],double[]) -> a
    void makePoints(double[],int) -> a
    void setLabels(java.lang.String[]) -> a
    void setPoints(java.util.List) -> b
    int getNrPoints(double) -> a
    double getYValue(double,int) -> a
    double getYValue(double) -> a
    double getXValue(double) -> b
    double getXValue(double,int) -> b
    double[] getXYPair(double,int) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial$1 -> geogebra.common.i.b.dV:
    geogebra.common.kernel.algos.AlgoSimpleRootsPolynomial this$0 -> a
    geogebra.common.kernel.geos.GeoPoint2 newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoSimplifyText -> geogebra.common.i.b.dW:
    geogebra.common.kernel.geos.GeoText textIn -> a
    geogebra.common.kernel.geos.GeoText text -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSlope -> geogebra.common.i.b.dX:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoNumeric slope -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getSlope() -> a
    geogebra.common.kernel.geos.GeoLine getg() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSolveODE -> geogebra.common.i.b.dY:
    geogebra.common.kernel.arithmetic.FunctionalNVar f0 -> b
    geogebra.common.kernel.arithmetic.FunctionalNVar f1 -> a
    geogebra.common.kernel.geos.GeoNumeric x -> a
    geogebra.common.kernel.geos.GeoNumeric y -> b
    geogebra.common.kernel.geos.GeoNumeric end -> c
    geogebra.common.kernel.geos.GeoNumeric step -> d
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    org.apache.commons.math.ode.sampling.StepHandler stepHandler -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoSolveODE$1 -> geogebra.common.i.b.dZ:
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.algos.AlgoSolveODE this$0 -> a
    void reset() -> a
    boolean requiresDenseOutput() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
geogebra.common.kernel.algos.AlgoSolveODE$ODE -> geogebra.common.i.b.dY$a:
    geogebra.common.kernel.arithmetic.FunctionalNVar f -> a
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.algos.AlgoSolveODE$ODE2 -> geogebra.common.i.b.dY$b:
    geogebra.common.kernel.arithmetic.FunctionalNVar y0 -> a
    geogebra.common.kernel.arithmetic.FunctionalNVar y1 -> b
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.algos.AlgoSolveODE2 -> geogebra.common.i.b.ea:
    geogebra.common.kernel.geos.GeoFunction b -> a
    geogebra.common.kernel.geos.GeoFunction c -> b
    geogebra.common.kernel.geos.GeoFunction f -> c
    geogebra.common.kernel.geos.GeoNumeric x -> a
    geogebra.common.kernel.geos.GeoNumeric y -> b
    geogebra.common.kernel.geos.GeoNumeric yDot -> c
    geogebra.common.kernel.geos.GeoNumeric end -> d
    geogebra.common.kernel.geos.GeoNumeric step -> e
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    org.apache.commons.math.ode.sampling.StepHandler stepHandler -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoSolveODE2$1 -> geogebra.common.i.b.eb:
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.algos.AlgoSolveODE2 this$0 -> a
    void reset() -> a
    boolean requiresDenseOutput() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
geogebra.common.kernel.algos.AlgoSolveODE2$ODE2 -> geogebra.common.i.b.ea$a:
    geogebra.common.kernel.geos.GeoFunction b -> a
    geogebra.common.kernel.geos.GeoFunction c -> b
    geogebra.common.kernel.geos.GeoFunction f -> c
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
geogebra.common.kernel.algos.AlgoSort -> geogebra.common.i.b.ec:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.geos.GeoList valueList -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSphereNDPointRadius -> geogebra.common.i.b.ed:
    geogebra.common.kernel.kernelND.GeoPointND M -> a
    geogebra.common.kernel.arithmetic.NumberValue r -> a
    geogebra.common.kernel.geos.GeoElement rgeo -> a
    geogebra.common.kernel.kernelND.GeoQuadricND sphereND -> a
    int type -> a
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoQuadricND getSphereND() -> a
    geogebra.common.kernel.kernelND.GeoPointND getM() -> a
    geogebra.common.kernel.geos.GeoElement getRGeo() -> a
    void compute() -> b
    int getType() -> f
geogebra.common.kernel.algos.AlgoSphereNDTwoPoints -> geogebra.common.i.b.ee:
    geogebra.common.kernel.kernelND.GeoPointND M -> a
    geogebra.common.kernel.kernelND.GeoPointND P -> b
    geogebra.common.kernel.kernelND.GeoQuadricND sphereND -> a
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoQuadricND getSphereND() -> a
    geogebra.common.kernel.kernelND.GeoPointND getM() -> a
    geogebra.common.kernel.kernelND.GeoPointND getP() -> b
    void compute() -> b
geogebra.common.kernel.algos.AlgoStemPlot -> geogebra.common.i.b.ef:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric scaleAdjustment -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder low -> a
    java.lang.StringBuilder high -> c
    java.lang.StringBuffer sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    int[] getOutlierIndex(double[]) -> a
    java.util.ArrayList createStemPlotArray(double[],double,int[]) -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoStepObject -> geogebra.common.i.b.eg:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    boolean wantsConstructionProtocolUpdate() -> c
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumFunctions -> geogebra.common.i.b.eh:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric truncate -> a
    geogebra.common.kernel.geos.GeoFunction resultFun -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumLeft -> geogebra.common.i.b.ei:
    geogebra.common.kernel.algos.AlgoSumLeft copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSumLower -> geogebra.common.i.b.ej:
    geogebra.common.kernel.algos.AlgoSumLower copy() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSumPoints -> geogebra.common.i.b.ek:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoElement result -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumRectangle -> geogebra.common.i.b.el:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumRectangle copy() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSumText -> geogebra.common.i.b.em:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoText result -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoSumTrapezoidal -> geogebra.common.i.b.en:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumTrapezoidal copy() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSumUpper -> geogebra.common.i.b.eo:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoSumUpper copy() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.algos.AlgoSurdText -> geogebra.common.i.b.ep:
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.geos.GeoText text -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    void Fractionappend(java.lang.StringBuilder,int,int,geogebra.common.kernel.StringTemplate) -> a
    void PSLQappend(java.lang.StringBuilder,double,geogebra.common.kernel.StringTemplate) -> a
    int[] PSLQ(double[],double,int) -> a
    double frobNormSq(double[][],int,int) -> a
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoSurdTextPoint -> geogebra.common.i.b.eq:
    geogebra.common.kernel.geos.GeoPoint2 p -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoTableText -> geogebra.common.i.b.er:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    geogebra.common.kernel.geos.GeoList[] geoLists -> a
    java.lang.StringBuffer sb -> a
    int VERTICAL -> a
    int HORIZONTAL -> b
    int alignment -> c
    boolean verticalLines -> a
    boolean horizontalLines -> b
    java.lang.String justification -> a
    java.lang.String openBracket -> b
    java.lang.String closeBracket -> c
    java.lang.String openString -> d
    java.lang.String closeString -> e
    int columns -> d
    int rows -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    boolean isVerticalLines() -> l
    boolean isHorizontalLines() -> m
    java.lang.String getJustification() -> c
    java.lang.String getOpenSymbol() -> d
    java.lang.String getCloseSymbol() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void parseArgs() -> e
    void compute() -> b
    void mathml(geogebra.common.kernel.StringTemplate) -> a
    void latex(geogebra.common.kernel.StringTemplate) -> b
    void addCellLaTeX(int,int,boolean,geogebra.common.kernel.StringTemplate) -> a
    void addCellMathML(int,int,geogebra.common.kernel.StringTemplate) -> a
    boolean isLaTeXTextCommand() -> k
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.algos.AlgoTake -> geogebra.common.i.b.es:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric m -> a
    geogebra.common.kernel.geos.GeoNumeric n -> b
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTakeString -> geogebra.common.i.b.et:
    geogebra.common.kernel.geos.GeoText inputText -> a
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoNumeric m -> b
    geogebra.common.kernel.geos.GeoText outputText -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTangentLine -> geogebra.common.i.b.eu:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine diameter -> b
    geogebra.common.kernel.geos.GeoVector direction -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.geos.GeoPoint2[] tangentPoints -> a
    int i -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    geogebra.common.kernel.geos.GeoPoint2 getTangentPoint(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoLine) -> a
    void initForNearToRelationship() -> d
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTangentPoint -> geogebra.common.i.b.ev:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoLine[] tangents -> a
    geogebra.common.kernel.geos.GeoLine polar -> a
    geogebra.common.kernel.algos.AlgoIntersectLineConic algoIntersect -> a
    geogebra.common.kernel.geos.GeoPoint2[] tangentPoints -> a
    boolean equalLines -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    geogebra.common.kernel.geos.GeoPoint2 getTangentPoint(geogebra.common.kernel.geos.GeoConic,geogebra.common.kernel.geos.GeoLine) -> a
    void initForNearToRelationship() -> d
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTaylorSeries -> geogebra.common.i.b.ew:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue n -> b
    geogebra.common.kernel.geos.GeoFunction g -> b
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement ngeo -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getPolynomial() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoText -> geogebra.common.i.b.ex:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.kernel.geos.GeoBoolean substituteVars -> a
    geogebra.common.kernel.geos.GeoBoolean latex -> b
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 startPointCopy -> b
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextCorner -> geogebra.common.i.b.ey:
    geogebra.common.kernel.geos.GeoText txt -> a
    geogebra.common.kernel.geos.GeoPoint2 corner -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getCorner() -> a
    void compute() -> b
    boolean euclidianViewUpdate() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTextLength -> geogebra.common.i.b.ez:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextToUnicode -> geogebra.common.i.b.eA:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTextfield -> geogebra.common.i.b.eB:
    geogebra.common.kernel.geos.GeoElement inputGeo -> a
    geogebra.common.kernel.geos.GeoTextField textfield -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoTextField getResult() -> a
    void compute() -> b
    int getRelatedModeID() -> a
geogebra.common.kernel.algos.AlgoTransformation -> geogebra.common.i.b.eC:
    geogebra.common.kernel.algos.AlgoClosestPoint pt -> a
    geogebra.common.kernel.geos.GeoPoint2 transformedPoint -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void transformList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement getResultTemplate(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement copy(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement) -> a
    void transformLimitedPath(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    boolean swapOrientation(boolean) -> a
    void transformLimitedConic(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> c
geogebra.common.kernel.algos.AlgoTranslate -> geogebra.common.i.b.eD:
    geogebra.common.kernel.geos.Translateable out -> a
    geogebra.common.kernel.geos.GeoElement inGeo -> b
    geogebra.common.kernel.geos.GeoElement outGeo -> c
    geogebra.common.kernel.geos.GeoElement v -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getVectorCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setTransformedObject(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoTranslateVector -> geogebra.common.i.b.eE:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoVec3D v -> a
    geogebra.common.kernel.geos.GeoVector w -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getTranslatedVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTranspose -> geogebra.common.i.b.eF:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoTurningPointPolynomial -> geogebra.common.i.b.eG:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTurtle -> geogebra.common.i.b.eH:
    geogebra.common.kernel.geos.GeoTurtle turtle -> a
    java.lang.StringBuilder sb -> a
    void createTurtle() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e
    void update() -> i
    geogebra.common.kernel.geos.GeoTurtle getTurtle() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoTwoNumFunction -> geogebra.common.i.b.eI:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoNumeric num -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnicodeToLetter -> geogebra.common.i.b.eJ:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnicodeToText -> geogebra.common.i.b.eK:
    geogebra.common.kernel.geos.GeoList list -> a
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnion -> geogebra.common.i.b.eL:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList inputList2 -> b
    geogebra.common.kernel.geos.GeoList outputList -> c
    int size -> a
    int size2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void addToOutputList(geogebra.common.kernel.geos.GeoElement) -> d
geogebra.common.kernel.algos.AlgoUnique -> geogebra.common.i.b.eM:
    geogebra.common.kernel.geos.GeoList dataList -> a
    geogebra.common.kernel.geos.GeoList uniqueList -> b
    org.apache.commons.math.stat.Frequency f -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoUnitOrthoVectorLine -> geogebra.common.i.b.eN:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector n -> a
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitOrthoVectorVector -> geogebra.common.i.b.eO:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector n -> b
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitVectorLine -> geogebra.common.i.b.eP:
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoVector u -> a
    double length -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoUnitVectorVector -> geogebra.common.i.b.eQ:
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.geos.GeoVector u -> b
    double length -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoVector -> geogebra.common.i.b.eR:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.kernelND.GeoVectorND v -> a
    geogebra.common.kernel.prover.Polynomial[] polynomials -> a
    geogebra.common.kernel.kernelND.GeoVectorND createNewVector() -> a
    geogebra.common.kernel.kernelND.GeoPointND newStartPoint() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoVectorND getVector() -> b
    geogebra.common.kernel.kernelND.GeoPointND getP() -> b
    geogebra.common.kernel.kernelND.GeoPointND getQ() -> c
    void compute() -> b
    void setCoords() -> e
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.AlgoVectorPoint -> geogebra.common.i.b.eS:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoVector v -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoVector getVector() -> a
    geogebra.common.kernel.geos.GeoPoint2 getP() -> a
    void compute() -> b
geogebra.common.kernel.algos.AlgoVertex -> geogebra.common.i.b.eT:
    geogebra.common.kernel.geos.GeoConic c -> a
    geogebra.common.kernel.geos.GeoPoint2[] vertex -> a
    double temp1 -> a
    double temp2 -> b
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getVertex() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgoVertexPolygon -> geogebra.common.i.b.eU:
    geogebra.common.kernel.geos.GeoPolyLineInterface p -> a
    geogebra.common.kernel.arithmetic.NumberValue index -> a
    geogebra.common.kernel.geos.GeoPoint2 oneVertex -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    int getOutputLength() -> c
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement[] getVertex() -> e
    geogebra.common.kernel.geos.GeoElement getOutput(int) -> a
    geogebra.common.kernel.geos.GeoPoint2 getOneVertex() -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
geogebra.common.kernel.algos.AlgoVertexPolygon$1 -> geogebra.common.i.b.eV:
    geogebra.common.kernel.algos.AlgoVertexPolygon this$0 -> a
    geogebra.common.kernel.geos.GeoPoint2 newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.algos.AlgoVerticalText -> geogebra.common.i.b.eW:
    geogebra.common.kernel.geos.GeoText text -> a
    geogebra.common.kernel.geos.GeoText args -> b
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoText getResult() -> a
    void compute() -> b
    boolean isLaTeXTextCommand() -> k
geogebra.common.kernel.algos.AlgoZip -> geogebra.common.i.b.eX:
    geogebra.common.kernel.geos.GeoElement expression -> a
    geogebra.common.kernel.geos.GeoElement[] vars -> b
    int varCount -> a
    geogebra.common.kernel.geos.GeoList[] over -> a
    geogebra.common.kernel.geos.GeoList list -> a
    int last_length -> b
    boolean expIsFunctionOrCurve -> a
    boolean isEmpty -> b
    geogebra.common.kernel.algos.AlgoElement expressionParentAlgo -> a
    boolean updateRunning -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] getInputForUpdateSetPropagation() -> a_
    void compute() -> b
    void createNewList() -> e
    void addElement(int) -> b
    geogebra.common.kernel.geos.GeoElement createNewListElement() -> a
    void updateListItems() -> f
    int minOverSize() -> f
    void updateLocalVar(int) -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.algos.AlgorithmSet -> geogebra.common.i.b.eY:
    java.util.HashMap hashMap -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link head -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link tail -> b
    int size -> a
    boolean add(geogebra.common.kernel.algos.AlgoElement) -> a
    void addAll(geogebra.common.kernel.algos.AlgorithmSet) -> a
    boolean contains(geogebra.common.kernel.algos.AlgoElement) -> b
    boolean remove(geogebra.common.kernel.algos.AlgoElement) -> c
    void updateAll() -> a
    void updateAllUntil(geogebra.common.kernel.algos.AlgoElement) -> a
    void addAllToCollection(java.util.Collection) -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.algos.AlgorithmSet$AlgorithmSetIterator getIterator() -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link getHead() -> a
    void setHead(geogebra.common.kernel.algos.AlgorithmSet$Link) -> a
geogebra.common.kernel.algos.AlgorithmSet$AlgorithmSetIterator -> geogebra.common.i.b.eY$a:
    geogebra.common.kernel.algos.AlgorithmSet$Link cur -> a
    geogebra.common.kernel.algos.AlgorithmSet this$0 -> a
    void remove() -> remove
    boolean hasNext() -> hasNext
    geogebra.common.kernel.algos.AlgoElement next() -> a
    java.lang.Object next() -> next
geogebra.common.kernel.algos.AlgorithmSet$Link -> geogebra.common.i.b.eY$b:
    geogebra.common.kernel.algos.AlgoElement algo -> a
    geogebra.common.kernel.algos.AlgorithmSet$Link next -> a
    geogebra.common.kernel.algos.AlgorithmSet this$0 -> a
geogebra.common.kernel.algos.Algos -> geogebra.common.i.b.eZ:
    geogebra.common.kernel.algos.Algos AlgoAngleConic -> a
    geogebra.common.kernel.algos.Algos AlgoAngleLines -> b
    geogebra.common.kernel.algos.Algos AlgoAngleNumeric -> c
    geogebra.common.kernel.algos.Algos AlgoAnglePoints -> d
    geogebra.common.kernel.algos.Algos AlgoAnglePolygon -> e
    geogebra.common.kernel.algos.Algos AlgoAngleVector -> f
    geogebra.common.kernel.algos.Algos AlgoAngleVectors -> g
    geogebra.common.kernel.algos.Algos AlgoAngularBisector -> h
    geogebra.common.kernel.algos.Algos AlgoAngularBisectorLines -> i
    geogebra.common.kernel.algos.Algos AlgoAngularBisectorPoints -> j
    geogebra.common.kernel.algos.Algos AlgoAreaConic -> k
    geogebra.common.kernel.algos.Algos AlgoAreaPoints -> l
    geogebra.common.kernel.algos.Algos AlgoAreaPolygon -> m
    geogebra.common.kernel.algos.Algos AlgoAsymptote -> n
    geogebra.common.kernel.algos.Algos AlgoAxes -> o
    geogebra.common.kernel.algos.Algos AlgoAxisFirst -> p
    geogebra.common.kernel.algos.Algos AlgoAxisFirstLength -> q
    geogebra.common.kernel.algos.Algos AlgoAxisSecond -> r
    geogebra.common.kernel.algos.Algos AlgoAxisSecondLength -> s
    geogebra.common.kernel.algos.Algos AlgoTriangleCubic -> t
    geogebra.common.kernel.algos.Algos AlgoBarycenter -> u
    geogebra.common.kernel.algos.Algos AlgoTrilinear -> v
    geogebra.common.kernel.algos.Algos AlgoCellRange -> w
    geogebra.common.kernel.algos.Algos AlgoCenterConic -> x
    geogebra.common.kernel.algos.Algos AlgoCentroidPolygon -> y
    geogebra.common.kernel.algos.Algos AlgoCirclePointRadius -> z
    geogebra.common.kernel.algos.Algos AlgoCircleThreePoints -> A
    geogebra.common.kernel.algos.Algos AlgoIncircle -> B
    geogebra.common.kernel.algos.Algos AlgoCircleTwoPoints -> C
    geogebra.common.kernel.algos.Algos AlgoConicFivePoints -> D
    geogebra.common.kernel.algos.Algos AlgoConicArc -> E
    geogebra.common.kernel.algos.Algos AlgoConicSector -> F
    geogebra.common.kernel.algos.Algos AlgoCircleArc -> G
    geogebra.common.kernel.algos.Algos AlgoCircleSector -> H
    geogebra.common.kernel.algos.Algos AlgoCircumcircleArc -> I
    geogebra.common.kernel.algos.Algos AlgoCircumcircleSector -> J
    geogebra.common.kernel.algos.Algos AlgoCurveCartesian -> K
    geogebra.common.kernel.algos.Algos AlgoDerivative -> L
    geogebra.common.kernel.algos.Algos AlgoDiameterLine -> M
    geogebra.common.kernel.algos.Algos AlgoDiameterVector -> N
    geogebra.common.kernel.algos.Algos AlgoDilate -> O
    geogebra.common.kernel.algos.Algos AlgoDirection -> P
    geogebra.common.kernel.algos.Algos AlgoDirectrix -> Q
    geogebra.common.kernel.algos.Algos AlgoDistanceLineLine -> R
    geogebra.common.kernel.algos.Algos AlgoDistancePointObject -> S
    geogebra.common.kernel.algos.Algos AlgoDistancePoints -> T
    geogebra.common.kernel.algos.Algos AlgoEllipseFociLength -> U
    geogebra.common.kernel.algos.Algos AlgoEllipseFociPoint -> V
    geogebra.common.kernel.algos.Algos AlgoExcentricity -> W
    geogebra.common.kernel.algos.Algos AlgoEccentricity -> X
    geogebra.common.kernel.algos.Algos AlgoExtremumPolynomial -> Y
    geogebra.common.kernel.algos.Algos AlgoExtremumMulti -> Z
    geogebra.common.kernel.algos.Algos AlgoFocus -> aa
    geogebra.common.kernel.algos.Algos AlgoFunctionInterval -> ab
    geogebra.common.kernel.algos.Algos AlgoHyperbolaFociLength -> ac
    geogebra.common.kernel.algos.Algos AlgoHyperbolaFociPoint -> ad
    geogebra.common.kernel.algos.Algos AlgoIf -> ae
    geogebra.common.kernel.algos.Algos AlgoIfFunction -> af
    geogebra.common.kernel.algos.Algos AlgoIntegral -> ag
    geogebra.common.kernel.algos.Algos AlgoIntegralDefinite -> ah
    geogebra.common.kernel.algos.Algos AlgoIntegralFunctions -> ai
    geogebra.common.kernel.algos.Algos AlgoIntersectConics -> aj
    geogebra.common.kernel.algos.Algos AlgoIntersectCS1D1D -> ak
    geogebra.common.kernel.algos.Algos AlgoIntersectCS1D2D -> al
    geogebra.common.kernel.algos.Algos AlgoIntersectCS2D2D -> am
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctionLineNewton -> an
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctionsNewton -> ao
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConic -> ap
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConic3D -> aq
    geogebra.common.kernel.algos.Algos AlgoIntersectLineConicRegion -> ar
    geogebra.common.kernel.algos.Algos AlgoIntersectLines -> as
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolyLine -> at
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygon -> au
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygon3D -> av
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygonalRegion -> aw
    geogebra.common.kernel.algos.Algos AlgoIntersectLinePolygonalRegion3D -> ax
    geogebra.common.kernel.algos.Algos AlgoIntersectLineQuadric3D -> ay
    geogebra.common.kernel.algos.Algos AlgoIntersectPlaneConic -> az
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanePolygon -> aA
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanePolygonalRegion -> aB
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomialLine -> aC
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomials -> aD
    geogebra.common.kernel.algos.Algos AlgoIntersectSingle -> aE
    geogebra.common.kernel.algos.Algos AlgoIntersectSingle3D -> aF
    geogebra.common.kernel.algos.Algos AlgoIntersectPolynomialConic -> aG
    geogebra.common.kernel.algos.Algos AlgoIntersectImplicitpolyParametric -> aH
    geogebra.common.kernel.algos.Algos AlgoIntersectFunctions -> aI
    geogebra.common.kernel.algos.Algos AlgoIntersectImplicitpolys -> aJ
    geogebra.common.kernel.algos.Algos AlgoImageCorner -> aK
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyThroughPoints -> aL
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyFunction -> aM
    geogebra.common.kernel.algos.Algos AlgoTextCorner -> aN
    geogebra.common.kernel.algos.Algos AlgoDrawingPadCorner -> aO
    geogebra.common.kernel.algos.Algos AlgoJoinPoints -> aP
    geogebra.common.kernel.algos.Algos AlgoJoinPointsRay -> aQ
    geogebra.common.kernel.algos.Algos AlgoJoinPointsSegment -> aR
    geogebra.common.kernel.algos.Algos AlgoLengthSegment -> aS
    geogebra.common.kernel.algos.Algos AlgoLengthVector -> aT
    geogebra.common.kernel.algos.Algos AlgoLineBisector -> aU
    geogebra.common.kernel.algos.Algos AlgoLineBisectorSegment -> aV
    geogebra.common.kernel.algos.Algos AlgoLinePointLine -> aW
    geogebra.common.kernel.algos.Algos AlgoLinePointVector -> aX
    geogebra.common.kernel.algos.Algos AlgoLocus -> aY
    geogebra.common.kernel.algos.Algos AlgoLocusSlider -> aZ
    geogebra.common.kernel.algos.Algos AlgoMidpoint -> ba
    geogebra.common.kernel.algos.Algos AlgoMidpointSegment -> bb
    geogebra.common.kernel.algos.Algos AlgoMirror -> bc
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointLine -> bd
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointVector -> be
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorLine -> bf
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorVector -> bg
    geogebra.common.kernel.algos.Algos AlgoParabolaParameter -> bh
    geogebra.common.kernel.algos.Algos AlgoParabolaPointLine -> bi
    geogebra.common.kernel.algos.Algos AlgoPointOnPath -> bj
    geogebra.common.kernel.algos.Algos AlgoPointVector -> bk
    geogebra.common.kernel.algos.Algos AlgoPolarLine -> bl
    geogebra.common.kernel.algos.Algos AlgoPolygon -> bm
    geogebra.common.kernel.algos.Algos AlgoPolygonRegular -> bn
    geogebra.common.kernel.algos.Algos AlgoPolygonUnion -> bo
    geogebra.common.kernel.algos.Algos AlgoPolygonIntersection -> bp
    geogebra.common.kernel.algos.Algos AlgoPolynomialFromFunction -> bq
    geogebra.common.kernel.algos.Algos AlgoPolynomialFromCoordinates -> br
    geogebra.common.kernel.algos.Algos AlgoRadius -> bs
    geogebra.common.kernel.algos.Algos AlgoRayPointVector -> bt
    geogebra.common.kernel.algos.Algos AlgoRootInterval -> bu
    geogebra.common.kernel.algos.Algos AlgoRootNewton -> bv
    geogebra.common.kernel.algos.Algos AlgoRootsPolynomial -> bw
    geogebra.common.kernel.algos.Algos AlgoRoots -> bx
    geogebra.common.kernel.algos.Algos AlgoRotate -> by
    geogebra.common.kernel.algos.Algos AlgoRotatePoint -> bz
    geogebra.common.kernel.algos.Algos AlgoSemicircle -> bA
    geogebra.common.kernel.algos.Algos AlgoSequence -> bB
    geogebra.common.kernel.algos.Algos AlgoSlope -> bC
    geogebra.common.kernel.algos.Algos AlgoSumLower -> bD
    geogebra.common.kernel.algos.Algos AlgoSumUpper -> bE
    geogebra.common.kernel.algos.Algos AlgoSumLeft -> bF
    geogebra.common.kernel.algos.Algos AlgoSumRectangle -> bG
    geogebra.common.kernel.algos.Algos AlgoTangentFunctionNumber -> bH
    geogebra.common.kernel.algos.Algos AlgoTangentFunctionPoint -> bI
    geogebra.common.kernel.algos.Algos AlgoTangentImplicitpoly -> bJ
    geogebra.common.kernel.algos.Algos AlgoTangentLine -> bK
    geogebra.common.kernel.algos.Algos AlgoTangentPoint -> bL
    geogebra.common.kernel.algos.Algos AlgoCommonTangents -> bM
    geogebra.common.kernel.algos.Algos AlgoTaylorSeries -> bN
    geogebra.common.kernel.algos.Algos AlgoTranslate -> bO
    geogebra.common.kernel.algos.Algos AlgoTranslateVector -> bP
    geogebra.common.kernel.algos.Algos AlgoTurningPointPolynomial -> bQ
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorLine -> bR
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorVector -> bS
    geogebra.common.kernel.algos.Algos AlgoUnitVectorLine -> bT
    geogebra.common.kernel.algos.Algos AlgoUnitVectorVector -> bU
    geogebra.common.kernel.algos.Algos AlgoVector -> bV
    geogebra.common.kernel.algos.Algos AlgoVectorPoint -> bW
    geogebra.common.kernel.algos.Algos AlgoVertex -> bX
    geogebra.common.kernel.algos.Algos Expression -> bY
    geogebra.common.kernel.algos.Algos AlgoAffineRatio -> bZ
    geogebra.common.kernel.algos.Algos AlgoCrossRatio -> ca
    geogebra.common.kernel.algos.Algos AlgoCurvatureVector -> cb
    geogebra.common.kernel.algos.Algos AlgoCurvatureVectorCurve -> cc
    geogebra.common.kernel.algos.Algos AlgoCurvature -> cd
    geogebra.common.kernel.algos.Algos AlgoCurvatureCurve -> ce
    geogebra.common.kernel.algos.Algos AlgoOsculatingCircle -> cf
    geogebra.common.kernel.algos.Algos AlgoOsculatingCircleCurve -> cg
    geogebra.common.kernel.algos.Algos AlgoTangentCurve -> ch
    geogebra.common.kernel.algos.Algos AlgoLengthFunction -> ci
    geogebra.common.kernel.algos.Algos AlgoLengthFunction2Points -> cj
    geogebra.common.kernel.algos.Algos AlgoLengthCurve -> ck
    geogebra.common.kernel.algos.Algos AlgoLengthCurve2Points -> cl
    geogebra.common.kernel.algos.Algos AlgoCircumferenceConic -> cm
    geogebra.common.kernel.algos.Algos AlgoPerimeterPoly -> cn
    geogebra.common.kernel.algos.Algos AlgoPerimeterLocus -> co
    geogebra.common.kernel.algos.Algos AlgoMod -> cp
    geogebra.common.kernel.algos.Algos AlgoDiv -> cq
    geogebra.common.kernel.algos.Algos AlgoMax -> cr
    geogebra.common.kernel.algos.Algos AlgoFunctionMax -> cs
    geogebra.common.kernel.algos.Algos AlgoMin -> ct
    geogebra.common.kernel.algos.Algos AlgoFunctionMin -> cu
    geogebra.common.kernel.algos.Algos AlgoLCM -> cv
    geogebra.common.kernel.algos.Algos AlgoListLCM -> cw
    geogebra.common.kernel.algos.Algos AlgoGCD -> cx
    geogebra.common.kernel.algos.Algos AlgoListGCD -> cy
    geogebra.common.kernel.algos.Algos AlgoSort -> cz
    geogebra.common.kernel.algos.Algos AlgoFirst -> cA
    geogebra.common.kernel.algos.Algos AlgoLast -> cB
    geogebra.common.kernel.algos.Algos AlgoTake -> cC
    geogebra.common.kernel.algos.Algos AlgoRemoveUndefined -> cD
    geogebra.common.kernel.algos.Algos AlgoDefined -> cE
    geogebra.common.kernel.algos.Algos AlgoReverse -> cF
    geogebra.common.kernel.algos.Algos AlgoSum -> cG
    geogebra.common.kernel.algos.Algos AlgoMean -> cH
    geogebra.common.kernel.algos.Algos AlgoVariance -> cI
    geogebra.common.kernel.algos.Algos AlgoSigmaXX -> cJ
    geogebra.common.kernel.algos.Algos AlgoStandardDeviation -> cK
    geogebra.common.kernel.algos.Algos AlgoMedian -> cL
    geogebra.common.kernel.algos.Algos AlgoQ1 -> cM
    geogebra.common.kernel.algos.Algos AlgoQ3 -> cN
    geogebra.common.kernel.algos.Algos AlgoMode -> cO
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaXY -> cP
    geogebra.common.kernel.algos.Algos AlgoDoubleListPMCC -> cQ
    geogebra.common.kernel.algos.Algos AlgoDoubleListCovariance -> cR
    geogebra.common.kernel.algos.Algos AlgoDoubleListMeanX -> cS
    geogebra.common.kernel.algos.Algos AlgoDoubleListMeanY -> cT
    geogebra.common.kernel.algos.Algos AlgoDoubleListSXY -> cU
    geogebra.common.kernel.algos.Algos AlgoListSigmaXY -> cV
    geogebra.common.kernel.algos.Algos AlgoListSigmaXX -> cW
    geogebra.common.kernel.algos.Algos AlgoListSigmaYY -> cX
    geogebra.common.kernel.algos.Algos AlgoListPMCC -> cY
    geogebra.common.kernel.algos.Algos AlgoListCovariance -> cZ
    geogebra.common.kernel.algos.Algos AlgoListMeanX -> da
    geogebra.common.kernel.algos.Algos AlgoListMeanY -> db
    geogebra.common.kernel.algos.Algos AlgoListSampleSDX -> dc
    geogebra.common.kernel.algos.Algos AlgoListSampleSDY -> dd
    geogebra.common.kernel.algos.Algos AlgoSXX -> de
    geogebra.common.kernel.algos.Algos AlgoListSXX -> df
    geogebra.common.kernel.algos.Algos AlgoListSYY -> dg
    geogebra.common.kernel.algos.Algos AlgoListSXY -> dh
    geogebra.common.kernel.algos.Algos AlgoFitLineY -> di
    geogebra.common.kernel.algos.Algos AlgoFitLineX -> dj
    geogebra.common.kernel.algos.Algos AlgoFitPoly -> dk
    geogebra.common.kernel.algos.Algos AlgoFitExp -> dl
    geogebra.common.kernel.algos.Algos AlgoFitLog -> dm
    geogebra.common.kernel.algos.Algos AlgoFitPow -> dn
    geogebra.common.kernel.algos.Algos AlgoRandomNormal -> do
    geogebra.common.kernel.algos.Algos AlgoInverseNormal -> dp
    geogebra.common.kernel.algos.Algos AlgoNormal -> dq
    geogebra.common.kernel.algos.Algos AlgoBinomial -> dr
    geogebra.common.kernel.algos.Algos AlgoExpand -> ds
    geogebra.common.kernel.algos.Algos AlgoFactor -> dt
    geogebra.common.kernel.algos.Algos AlgoFactors -> du
    geogebra.common.kernel.algos.Algos AlgoConstructionStep -> dv
    geogebra.common.kernel.algos.Algos AlgoStepObject -> dw
    geogebra.common.kernel.algos.Algos AlgoName -> dx
    geogebra.common.kernel.algos.Algos AlgoListMax -> dy
    geogebra.common.kernel.algos.Algos AlgoListMin -> dz
    geogebra.common.kernel.algos.Algos AlgoListElement -> dA
    geogebra.common.kernel.algos.Algos AlgoListLength -> dB
    geogebra.common.kernel.algos.Algos AlgoIteration -> dC
    geogebra.common.kernel.algos.Algos AlgoIterationList -> dD
    geogebra.common.kernel.algos.Algos AlgoProduct -> dE
    geogebra.common.kernel.algos.Algos AlgoRow -> dF
    geogebra.common.kernel.algos.Algos AlgoColumn -> dG
    geogebra.common.kernel.algos.Algos AlgoLaTeX -> dH
    geogebra.common.kernel.algos.Algos AlgoUnicodeToLetter -> dI
    geogebra.common.kernel.algos.Algos AlgoUnicodeToText -> dJ
    geogebra.common.kernel.algos.Algos AlgoTextToUnicode -> dK
    geogebra.common.kernel.algos.Algos AlgoLetterToUnicode -> dL
    geogebra.common.kernel.algos.Algos AlgoBarChart -> dM
    geogebra.common.kernel.algos.Algos AlgoBoxPlot -> dN
    geogebra.common.kernel.algos.Algos AlgoHistogram -> dO
    geogebra.common.kernel.algos.Algos AlgoHistogramRight -> dP
    geogebra.common.kernel.algos.Algos AlgoDotPlot -> dQ
    geogebra.common.kernel.algos.Algos AlgoResidualPlot -> dR
    geogebra.common.kernel.algos.Algos AlgoNormalQuantilePlot -> dS
    geogebra.common.kernel.algos.Algos AlgoSumTrapezoidal -> dT
    geogebra.common.kernel.algos.Algos AlgoCountIf -> dU
    geogebra.common.kernel.algos.Algos AlgoTableText -> dV
    geogebra.common.kernel.algos.Algos AlgoObject -> dW
    geogebra.common.kernel.algos.Algos AlgoColumnName -> dX
    geogebra.common.kernel.algos.Algos AlgoAppend -> dY
    geogebra.common.kernel.algos.Algos AlgoJoin -> dZ
    geogebra.common.kernel.algos.Algos AlgoFlatten -> ea
    geogebra.common.kernel.algos.Algos AlgoUnion -> eb
    geogebra.common.kernel.algos.Algos AlgoInsert -> ec
    geogebra.common.kernel.algos.Algos AlgoIntersection -> ed
    geogebra.common.kernel.algos.Algos AlgoSumFunctions -> ee
    geogebra.common.kernel.algos.Algos AlgoIsInteger -> ef
    geogebra.common.kernel.algos.Algos AlgoRandom -> eg
    geogebra.common.kernel.algos.Algos AlgoRandomUniform -> eh
    geogebra.common.kernel.algos.Algos AlgoRandomBinomial -> ei
    geogebra.common.kernel.algos.Algos AlgoRandomPoisson -> ej
    geogebra.common.kernel.algos.Algos AlgoFractionText -> ek
    geogebra.common.kernel.algos.Algos AlgoKeepIf -> el
    geogebra.common.kernel.algos.Algos AlgoAxisStepX -> em
    geogebra.common.kernel.algos.Algos AlgoAxisStepY -> en
    geogebra.common.kernel.algos.Algos AlgoInvert -> eo
    geogebra.common.kernel.algos.Algos AlgoTranspose -> ep
    geogebra.common.kernel.algos.Algos AlgoDeterminant -> eq
    geogebra.common.kernel.algos.Algos AlgoSumText -> er
    geogebra.common.kernel.algos.Algos AlgoSimplify -> es
    geogebra.common.kernel.algos.Algos AlgoText -> et
    geogebra.common.kernel.algos.Algos AlgoFitSin -> eu
    geogebra.common.kernel.algos.Algos AlgoFitLogistic -> ev
    geogebra.common.kernel.algos.Algos AlgoSumPoints -> ew
    geogebra.common.kernel.algos.Algos AlgoSurdText -> ex
    geogebra.common.kernel.algos.Algos AlgoSurdTextPoint -> ey
    geogebra.common.kernel.algos.Algos AlgoTTest -> ez
    geogebra.common.kernel.algos.Algos AlgoTTestPaired -> eA
    geogebra.common.kernel.algos.Algos AlgoTTest2 -> eB
    geogebra.common.kernel.algos.Algos AlgoTMeanEstimate -> eC
    geogebra.common.kernel.algos.Algos AlgoTMean2Estimate -> eD
    geogebra.common.kernel.algos.Algos AlgoANOVA -> eE
    geogebra.common.kernel.algos.Algos AlgoPercentile -> eF
    geogebra.common.kernel.algos.Algos AlgoGeometricMean -> eG
    geogebra.common.kernel.algos.Algos AlgoHarmonicMean -> eH
    geogebra.common.kernel.algos.Algos AlgoDynamicCoordinates -> eI
    geogebra.common.kernel.algos.Algos AlgoTDistribution -> eJ
    geogebra.common.kernel.algos.Algos AlgoInverseTDistribution -> eK
    geogebra.common.kernel.algos.Algos AlgoFDistribution -> eL
    geogebra.common.kernel.algos.Algos AlgoInverseFDistribution -> eM
    geogebra.common.kernel.algos.Algos AlgoGamma -> eN
    geogebra.common.kernel.algos.Algos AlgoInverseGamma -> eO
    geogebra.common.kernel.algos.Algos AlgoCauchy -> eP
    geogebra.common.kernel.algos.Algos AlgoInverseCauchy -> eQ
    geogebra.common.kernel.algos.Algos AlgoChiSquared -> eR
    geogebra.common.kernel.algos.Algos AlgoInverseChiSquared -> eS
    geogebra.common.kernel.algos.Algos AlgoExponential -> eT
    geogebra.common.kernel.algos.Algos AlgoInverseExponential -> eU
    geogebra.common.kernel.algos.Algos AlgoHyperGeometric -> eV
    geogebra.common.kernel.algos.Algos AlgoHyperGeometricBarChart -> eW
    geogebra.common.kernel.algos.Algos AlgoInverseHyperGeometric -> eX
    geogebra.common.kernel.algos.Algos AlgoPascal -> eY
    geogebra.common.kernel.algos.Algos AlgoPascalBarChart -> eZ
    geogebra.common.kernel.algos.Algos AlgoInversePascal -> fa
    geogebra.common.kernel.algos.Algos AlgoPoisson -> fb
    geogebra.common.kernel.algos.Algos AlgoPoissonBarChart -> fc
    geogebra.common.kernel.algos.Algos AlgoInversePoisson -> fd
    geogebra.common.kernel.algos.Algos AlgoBinomialDist -> fe
    geogebra.common.kernel.algos.Algos AlgoBinomialDistBarChart -> ff
    geogebra.common.kernel.algos.Algos AlgoInverseBinomial -> fg
    geogebra.common.kernel.algos.Algos AlgoWeibull -> fh
    geogebra.common.kernel.algos.Algos AlgoInverseWeibull -> fi
    geogebra.common.kernel.algos.Algos AlgoZipf -> fj
    geogebra.common.kernel.algos.Algos AlgoInverseZipf -> fk
    geogebra.common.kernel.algos.Algos AlgoCell -> fl
    geogebra.common.kernel.algos.Algos AlgoTextLength -> fm
    geogebra.common.kernel.algos.Algos AlgoTextElement -> fn
    geogebra.common.kernel.algos.Algos AlgoPolynomialDiv -> fo
    geogebra.common.kernel.algos.Algos AlgoPolynomialMod -> fp
    geogebra.common.kernel.algos.Algos AlgoDegree -> fq
    geogebra.common.kernel.algos.Algos AlgoCoefficients -> fr
    geogebra.common.kernel.algos.Algos AlgoConicCoefficients -> fs
    geogebra.common.kernel.algos.Algos AlgoConicFromCoeffList -> ft
    geogebra.common.kernel.algos.Algos AlgoLimit -> fu
    geogebra.common.kernel.algos.Algos AlgoLimitBelow -> fv
    geogebra.common.kernel.algos.Algos AlgoLimitAbove -> fw
    geogebra.common.kernel.algos.Algos AlgoAsymptoteFunction -> fx
    geogebra.common.kernel.algos.Algos AlgoAsymptoteImplicitPoly -> fy
    geogebra.common.kernel.algos.Algos AlgoPartialFractions -> fz
    geogebra.common.kernel.algos.Algos AlgoNumerator -> fA
    geogebra.common.kernel.algos.Algos AlgoDenominator -> fB
    geogebra.common.kernel.algos.Algos AlgoSumSquaredErrors -> fC
    geogebra.common.kernel.algos.Algos AlgoRSquare -> fD
    geogebra.common.kernel.algos.Algos AlgoFit -> fE
    geogebra.common.kernel.algos.Algos AlgoFitNL -> fF
    geogebra.common.kernel.algos.Algos AlgoFitGrowth -> fG
    geogebra.common.kernel.algos.Algos AlgoPointsFromList -> fH
    geogebra.common.kernel.algos.Algos AlgoPointList -> fI
    geogebra.common.kernel.algos.Algos AlgoRootList -> fJ
    geogebra.common.kernel.algos.Algos AlgoIntersectLineCubic -> fK
    geogebra.common.kernel.algos.Algos AlgoSampleStandardDeviation -> fL
    geogebra.common.kernel.algos.Algos AlgoSampleVariance -> fM
    geogebra.common.kernel.algos.Algos AlgoSpearman -> fN
    geogebra.common.kernel.algos.Algos AlgoFrequencyPolygon -> fO
    geogebra.common.kernel.algos.Algos AlgoFrequencyTable -> fP
    geogebra.common.kernel.algos.Algos AlgoReducedRowEchelonForm -> fQ
    geogebra.common.kernel.algos.Algos AlgoTiedRank -> fR
    geogebra.common.kernel.algos.Algos AlgoOrdinalRank -> fS
    geogebra.common.kernel.algos.Algos AlgoShuffle -> fT
    geogebra.common.kernel.algos.Algos AlgoRotateVector -> fU
    geogebra.common.kernel.algos.Algos AlgoRandomElement -> fV
    geogebra.common.kernel.algos.Algos AlgoApplyMatrix -> fW
    geogebra.common.kernel.algos.Algos AlgoShear -> fX
    geogebra.common.kernel.algos.Algos AlgoStretch -> fY
    geogebra.common.kernel.algos.Algos AlgoComplexRoot -> fZ
    geogebra.common.kernel.algos.Algos AlgoSimplifyText -> ga
    geogebra.common.kernel.algos.Algos AlgoSolveODE -> gb
    geogebra.common.kernel.algos.Algos AlgoSolveODE2 -> gc
    geogebra.common.kernel.algos.Algos AlgoSolveODECas -> gd
    geogebra.common.kernel.algos.Algos AlgoPolyLine -> ge
    geogebra.common.kernel.algos.Algos AlgoPolyLine3D -> gf
    geogebra.common.kernel.algos.Algos AlgoFirstString -> gg
    geogebra.common.kernel.algos.Algos AlgoLastString -> gh
    geogebra.common.kernel.algos.Algos AlgoTakeString -> gi
    geogebra.common.kernel.algos.Algos AlgoRotateText -> gj
    geogebra.common.kernel.algos.Algos AlgoVerticalText -> gk
    geogebra.common.kernel.algos.Algos AlgoSample -> gl
    geogebra.common.kernel.algos.Algos AlgoVoronoi -> gm
    geogebra.common.kernel.algos.Algos AlgoHull -> gn
    geogebra.common.kernel.algos.Algos AlgoConvexHull -> go
    geogebra.common.kernel.algos.Algos AlgoMinimumSpanningTree -> gp
    geogebra.common.kernel.algos.Algos AlgoDelauneyTriangulation -> gq
    geogebra.common.kernel.algos.Algos AlgoTravelingSalesman -> gr
    geogebra.common.kernel.algos.Algos AlgoShortestDistance -> gs
    geogebra.common.kernel.algos.Algos AlgoSelectedElement -> gt
    geogebra.common.kernel.algos.Algos AlgoSelectedIndex -> gu
    geogebra.common.kernel.algos.Algos AlgoStemPlot -> gv
    geogebra.common.kernel.algos.Algos AlgoFrequency -> gw
    geogebra.common.kernel.algos.Algos AlgoUnique -> gx
    geogebra.common.kernel.algos.Algos AlgoClasses -> gy
    geogebra.common.kernel.algos.Algos AlgoIndexOf -> gz
    geogebra.common.kernel.algos.Algos AlgoZip -> gA
    geogebra.common.kernel.algos.Algos AlgoFirstLocus -> gB
    geogebra.common.kernel.algos.Algos AlgoLengthLocus -> gC
    geogebra.common.kernel.algos.Algos AlgoPrimeFactors -> gD
    geogebra.common.kernel.algos.Algos AlgoIsInRegion -> gE
    geogebra.common.kernel.algos.Algos AlgoPathParameter -> gF
    geogebra.common.kernel.algos.Algos AlgoClosestPoint -> gG
    geogebra.common.kernel.algos.Algos AlgoComplexPolynomial -> gH
    geogebra.common.kernel.algos.Algos AlgoOrdinal -> gI
    geogebra.common.kernel.algos.Algos AlgoIntervalMidpoint -> gJ
    geogebra.common.kernel.algos.Algos AlgoIntervalMin -> gK
    geogebra.common.kernel.algos.Algos AlgoIntervalMax -> gL
    geogebra.common.kernel.algos.Algos AlgoMaximize -> gM
    geogebra.common.kernel.algos.Algos AlgoMinimize -> gN
    geogebra.common.kernel.algos.Algos AlgoTextfield -> gO
    geogebra.common.kernel.algos.Algos AlgoListSDX -> gP
    geogebra.common.kernel.algos.Algos AlgoListSDY -> gQ
    geogebra.common.kernel.algos.Algos AlgoRootMeanSquare -> gR
    geogebra.common.kernel.algos.Algos AlgoCompleteSquare -> gS
    geogebra.common.kernel.algos.Algos AlgoBernoulliBarChart -> gT
    geogebra.common.kernel.algos.Algos AlgoZipfBarChart -> gU
    geogebra.common.kernel.algos.Algos AlgoKimberling -> gV
    geogebra.common.kernel.algos.Algos AlgoFunctionFreehand -> gW
    geogebra.common.kernel.algos.Algos AlgoTriangleCurve -> gX
    geogebra.common.kernel.algos.Algos AlgoPolygon3D -> gY
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DSegment -> gZ
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DLine -> ha
    geogebra.common.kernel.algos.Algos AlgoJoinPoints3DRay -> hb
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePoint -> hc
    geogebra.common.kernel.algos.Algos AlgoOrthoLinePointPlane -> hd
    geogebra.common.kernel.algos.Algos AlgoOrthoLineLineLine -> he
    geogebra.common.kernel.algos.Algos AlgoOrthoLineLinePointPlane -> hf
    geogebra.common.kernel.algos.Algos AlgoOrthoVectorPlane -> hg
    geogebra.common.kernel.algos.Algos AlgoUnitOrthoVectorPlane -> hh
    geogebra.common.kernel.algos.Algos AlgoCircle3DThreePoints -> hi
    geogebra.common.kernel.algos.Algos AlgoCircleAxisPoint -> hj
    geogebra.common.kernel.algos.Algos AlgoCirclePointRadiusDirection -> hk
    geogebra.common.kernel.algos.Algos AlgoCirclePointPointDirection -> hl
    geogebra.common.kernel.algos.Algos AlgoPlane -> hm
    geogebra.common.kernel.algos.Algos AlgoPlaneThroughPoint -> hn
    geogebra.common.kernel.algos.Algos AlgoOrthoPlanePoint -> ho
    geogebra.common.kernel.algos.Algos AlgoPlaneBisector -> hp
    geogebra.common.kernel.algos.Algos AlgoPoint3DOnPath -> hq
    geogebra.common.kernel.algos.Algos AlgoIntersectCoordSys -> hr
    geogebra.common.kernel.algos.Algos AlgoPointInRegion -> hs
    geogebra.common.kernel.algos.Algos AlgoPoint3DInRegion -> ht
    geogebra.common.kernel.algos.Algos AlgoSphere -> hu
    geogebra.common.kernel.algos.Algos AlgoPrism -> hv
    geogebra.common.kernel.algos.Algos AlgoPyramid -> hw
    geogebra.common.kernel.algos.Algos AlgoIntersectPlanes -> hx
    geogebra.common.kernel.algos.Algos AlgoIntersectPlaneQuadric -> hy
    geogebra.common.kernel.algos.Algos AlgoSpherePointRadius -> hz
    geogebra.common.kernel.algos.Algos AlgoSphereTwoPoints -> hA
    geogebra.common.kernel.algos.Algos AlgoCone -> hB
    geogebra.common.kernel.algos.Algos AlgoLimitedCone -> hC
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointVectorNumber -> hD
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointPointNumber -> hE
    geogebra.common.kernel.algos.Algos AlgoConeInfinitePointLineAngle -> hF
    geogebra.common.kernel.algos.Algos AlgoCylinder -> hG
    geogebra.common.kernel.algos.Algos AlgoLimitedCylinder -> hH
    geogebra.common.kernel.algos.Algos AlgoCylinderInfinitePointPointNumber -> hI
    geogebra.common.kernel.algos.Algos AlgoCylinderInfinitePointVectorNumber -> hJ
    geogebra.common.kernel.algos.Algos AlgoCylinderInfiniteAxisRadius -> hK
    geogebra.common.kernel.algos.Algos AlgoTetrahedron -> hL
    geogebra.common.kernel.algos.Algos AlgoCube -> hM
    geogebra.common.kernel.algos.Algos AlgoOctahedron -> hN
    geogebra.common.kernel.algos.Algos AlgoDodecahedron -> hO
    geogebra.common.kernel.algos.Algos AlgoIcosahedron -> hP
    geogebra.common.kernel.algos.Algos AlgoQuadricSide -> hQ
    geogebra.common.kernel.algos.Algos AlgoQuadricEnds -> hR
    geogebra.common.kernel.algos.Algos AlgoQuadricEndBottom -> hS
    geogebra.common.kernel.algos.Algos AlgoQuadricEndTop -> hT
    geogebra.common.kernel.algos.Algos AlgoSurfaceCartesian -> hU
    geogebra.common.kernel.algos.Algos AlgoDependentPlane -> hV
    geogebra.common.kernel.algos.Algos AlgoDependentPoint3D -> hW
    geogebra.common.kernel.algos.Algos AlgoDependentPoint -> hX
    geogebra.common.kernel.algos.Algos AlgoDependentList -> hY
    geogebra.common.kernel.algos.Algos AlgoDependentImplicitPoly -> hZ
    geogebra.common.kernel.algos.Algos AlgoDependentCasCell -> ia
    geogebra.common.kernel.algos.Algos AlgoDependentVector -> ib
    geogebra.common.kernel.algos.Algos AlgoDependentText -> ic
    geogebra.common.kernel.algos.Algos AlgoDependentNumber -> id
    geogebra.common.kernel.algos.Algos AlgoDependentListExpression -> ie
    geogebra.common.kernel.algos.Algos AlgoDependentBoolean -> if
    geogebra.common.kernel.algos.Algos AlgoDependentConic -> ig
    geogebra.common.kernel.algos.Algos AlgoDependentFunction -> ih
    geogebra.common.kernel.algos.Algos AlgoDependentFunctionNVar -> ii
    geogebra.common.kernel.algos.Algos AlgoDependentInterval -> ij
    geogebra.common.kernel.algos.Algos AlgoDependentLine -> ik
    geogebra.common.kernel.algos.Algos AlgoCellRangeExpression -> il
    geogebra.common.kernel.algos.Algos AlgoDependentGeoCopy -> im
    geogebra.common.kernel.algos.Algos AlgoMacro -> in
    geogebra.common.kernel.algos.Algos AlgoTo2D -> io
    geogebra.common.kernel.algos.Algos AlgoDependentVector3D -> ip
    geogebra.common.kernel.algos.Algos AlgoParametricDerivative -> iq
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaXX -> ir
    geogebra.common.kernel.algos.Algos AlgoDoubleListSigmaYY -> is
    geogebra.common.kernel.algos.Algos AlgoDoubleListSXX -> it
    geogebra.common.kernel.algos.Algos AlgoDoubleListSYY -> iu
    geogebra.common.kernel.algos.Algos AlgoExtremumNumerical -> iv
    geogebra.common.kernel.algos.Algos AlgoSimpleRootsPoly -> iw
    geogebra.common.kernel.algos.Algos AlgoImplicitPolyTangentCurve -> ix
    geogebra.common.kernel.algos.Algos AlgoProve -> iy
    geogebra.common.kernel.algos.Algos AlgoAreCollinear -> iz
    geogebra.common.kernel.algos.Algos AlgoAreParallel -> iA
    geogebra.common.kernel.algos.Algos AlgoAreConcyclic -> iB
    java.lang.String command -> a
    geogebra.common.kernel.algos.Algos[] ENUM$VALUES -> a
    java.lang.String getCommand() -> a
    geogebra.common.kernel.algos.Algos[] values() -> values
    geogebra.common.kernel.algos.Algos valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.algos.AngleAlgo -> geogebra.common.i.b.fa:
geogebra.common.kernel.algos.ConstructionElement -> geogebra.common.i.b.fb:
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    int constIndex -> a
    long ceIDcounter -> a
    long ceID -> b
    void setConstruction(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.Construction getConstruction() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int getMinConstructionIndex() -> d
    int getMaxConstructionIndex() -> e
    int getConstructionIndex() -> a_
    void setConstructionIndex(int) -> d
    boolean isInConstructionList() -> o
    boolean isConsProtocolBreakpoint() -> g
    boolean isAvailableAtConstructionStep(int) -> a
    boolean isIndependent() -> h
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void getXML(java.lang.StringBuilder) -> a
    void remove() -> c
    void update() -> i
    void notifyRemove() -> m
    void notifyAdd() -> l
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> d
    boolean isGeoElement() -> h_
    boolean isAlgoElement() -> e
    java.lang.String getNameDescription() -> a
    int getRelatedModeID() -> a
    int compareTo(geogebra.common.kernel.algos.ConstructionElement) -> a
    boolean equals(java.lang.Object) -> equals
    long getID() -> a
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.algos.SymbolicParameters -> geogebra.common.i.b.fc:
    int[] degree -> a
    java.util.HashSet variables -> a
    geogebra.common.kernel.algos.SymbolicParametersAlgo spa -> a
    int[] getDegrees() -> a
    int[] crossDegree(int[],int[]) -> a
    java.math.BigInteger[] crossProduct(java.math.BigInteger[],java.math.BigInteger[]) -> a
    geogebra.common.kernel.prover.Polynomial[] crossProduct(geogebra.common.kernel.prover.Polynomial[],geogebra.common.kernel.prover.Polynomial[]) -> a
    java.util.HashSet getFreeVariables() -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    java.math.BigInteger[] reduce(java.math.BigInteger[]) -> a
    void initDegrees() -> a
    geogebra.common.kernel.prover.Polynomial det4(geogebra.common.kernel.prover.Polynomial[][]) -> a
    java.math.BigInteger det4(java.math.BigInteger[][]) -> a
geogebra.common.kernel.algos.SymbolicParametersAlgo -> geogebra.common.i.b.fd:
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
geogebra.common.kernel.algos.TangentAlgo -> geogebra.common.i.b.fe:
geogebra.common.kernel.arithmetic.BooleanValue -> geogebra.common.i.c.a:
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    boolean getBoolean() -> a
    double getDouble() -> a
geogebra.common.kernel.arithmetic.Command -> geogebra.common.i.c.b:
    java.util.ArrayList args -> a
    java.lang.String name -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.geos.GeoElement[] evalGeos -> a
    geogebra.common.kernel.Macro macro -> a
    boolean allowEvaluationForTypeCheck -> a
    java.lang.StringBuilder sbToString -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    void addArgument(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String getVariableName(int) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode[] getArguments() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getArgument(int) -> a
    void setArgument(int,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    int getArgumentNumber() -> a
    java.lang.String getName() -> a_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.arithmetic.ExpressionValue,boolean,boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement[] evaluateMultiple() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    java.util.HashSet getVariables() -> a
    boolean isExpressionNode() -> i_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isListValue() -> j
    geogebra.common.kernel.Macro getMacro() -> a
    void setMacro(geogebra.common.kernel.Macro) -> a
    boolean isVector3DValue() -> k
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.Equation -> geogebra.common.i.c.c:
    geogebra.common.kernel.arithmetic.ExpressionNode lhs -> a
    geogebra.common.kernel.arithmetic.ExpressionNode rhs -> b
    geogebra.common.kernel.arithmetic.Polynomial leftPoly -> a
    geogebra.common.kernel.arithmetic.Polynomial rightPoly -> b
    geogebra.common.kernel.arithmetic.Polynomial normalForm -> c
    boolean isFunctionDependent -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean forcePlane -> b
    boolean forceLine -> c
    boolean forceConic -> d
    boolean forceImplicitPoly -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getRHS() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getLHS() -> b
    void setForceLine() -> b
    boolean isForcedLine() -> m
    void setForcePlane() -> c
    boolean isForcedPlane() -> n
    boolean isForcedConic() -> o
    void setForceConic() -> d
    boolean isForcedImplicitPoly() -> p
    void setForceImplicitPoly() -> e
    void initEquation() -> f
    void setFunctionDependent(boolean) -> a
    boolean isFunctionDependent() -> q
    geogebra.common.kernel.arithmetic.Polynomial getNormalForm() -> a
    int degree() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    boolean isExplicit(java.lang.String) -> a
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    boolean isBooleanValue() -> j_
    boolean isConstant() -> b_
    boolean isExpressionNode() -> i_
    boolean isLeaf() -> b
    boolean isListValue() -> j
    boolean isNumberValue() -> c
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isVectorValue() -> d
    void resolveVariables() -> a
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String getAssignmentOperator() -> a
    java.lang.String getAssignmentOperatorLaTeX() -> b
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.Evaluatable -> geogebra.common.i.c.d:
    double evaluate(double) -> a
geogebra.common.kernel.arithmetic.ExpressionNode -> geogebra.common.i.c.e:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue left -> a
    geogebra.common.kernel.arithmetic.ExpressionValue right -> b
    geogebra.common.plugin.Operation operation -> a
    boolean forceVector -> c
    boolean forcePoint -> d
    boolean forceFunction -> e
    boolean holdsLaTeXtext -> a
    boolean leaf -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> b
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.plugin.Operation getOperation() -> a
    void setOperation(geogebra.common.plugin.Operation) -> a
    void setHoldsLaTeXtext(boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getLeft() -> a
    void setLeft(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getLeftTree() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getRight() -> b
    void setRight(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode getRightTree() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue copy(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.Kernel) -> a
    void simplifyLeafs() -> b
    void simplifyAndEvalCommands() -> g
    void simplifyConstantIntegers() -> c
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables() -> a
    void doResolveVariables() -> h
    boolean includesPolynomial() -> m
    java.util.TreeSet getPolynomialVars() -> a
    void getPolynomialVars(java.util.Set) -> a
    boolean shouldEvaluateToGeoVector() -> n
    boolean includesDivisionBy(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    int replaceVariables(java.lang.String,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    int replacePolynomials(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    int replaceXYZnodes(geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.FunctionVariable,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode replaceAndWrap(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode traverseAndWrap(geogebra.common.kernel.arithmetic.Traversing) -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean containsFunctionVariable() -> o
    boolean containsCasEvaluableFunction() -> p
    boolean containsGeoFunctionNVar() -> q
    void makePolynomialTree(geogebra.common.kernel.arithmetic.Equation) -> a
    boolean isConstant() -> b_
    boolean isVectorValue() -> d
    void setForceVector() -> d
    boolean isForcedVector() -> r
    void setForcePoint() -> e
    boolean isForcedPoint() -> s
    void setForceFunction() -> f
    boolean isForcedFunction() -> t
    boolean hasOperations() -> u
    java.util.HashSet getVariables() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    boolean isLeaf() -> b
    boolean isSingleVariable() -> v
    boolean isImaginaryUnit() -> w
    java.lang.String getCASstring(geogebra.common.kernel.StringTemplate,boolean) -> a
    boolean containsMyStringBuffer() -> x
    java.lang.String printCASstring(boolean,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String checkMathML(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String operationToString(java.lang.String,java.lang.String,boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isMultiplyOrDivide(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void mathml(java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String) -> a
    void mathml(java.lang.StringBuilder,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    int opID(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> j_
    boolean isListValue() -> j
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isVector3DValue() -> k
    boolean isEqual(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isEqualString(geogebra.common.kernel.arithmetic.ExpressionValue,double,boolean) -> a
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String leftBracket(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    java.lang.String rightBracket(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> b
    java.lang.String multiplicationSign(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> c
    java.lang.String multiplicationSpace(geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> d
    java.lang.Double getCoefficient(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    void append(java.lang.StringBuilder,java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    boolean isConstantDouble(geogebra.common.kernel.arithmetic.ExpressionValue,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode plus(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode power(geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionNode divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    geogebra.common.kernel.arithmetic.ExpressionNode and(geogebra.common.kernel.arithmetic.ExpressionValue) -> e
    geogebra.common.kernel.arithmetic.ExpressionNode negation() -> c
    boolean replacePowersRoots(boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue replace(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> b
geogebra.common.kernel.arithmetic.ExpressionNodeConstants -> geogebra.common.i.c.f:
    java.util.Set RESERVED_FUNCTION_NAMES -> a
geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType -> geogebra.common.i.c.f$a:
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType GEOGEBRA_XML -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType GEOGEBRA -> b
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MAXIMA -> c
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MATH_PIPER -> d
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType LATEX -> e
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType PSTRICKS -> f
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType PGF -> g
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType JASYMCA -> h
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MPREDUCE -> i
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType MATHML -> j
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType OGP -> k
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType[] ENUM$VALUES -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType[] values() -> values
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator -> geogebra.common.i.c.g:
    geogebra.common.kernel.StringTemplate errorTemplate -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyBoolean evalEquals(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.ExpressionValue -> geogebra.common.i.c.h:
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isVector3DValue() -> k
    boolean isListValue() -> j
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isGeoElement() -> h_
    boolean isVariable() -> y
    void setInTree(boolean) -> b
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void resolveVariables() -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    geogebra.common.kernel.Kernel getKernel() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
geogebra.common.kernel.arithmetic.Function -> geogebra.common.i.c.i:
    geogebra.common.kernel.arithmetic.ExpressionNode factorParentExp -> b
    java.util.LinkedList symbolicPolyFactorList -> a
    java.util.LinkedList numericPolyFactorList -> b
    boolean symbolicPolyFactorListDefined -> c
    geogebra.common.kernel.arithmetic.ExpressionNode zeroExpr -> c
    geogebra.common.kernel.geos.GeoFunction geoDeriv -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.arithmetic.FunctionVariable getFunctionVariable() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    void initFunction() -> b
    double evaluate(double) -> a
    boolean evaluateBoolean(double) -> a
    void translate(double,double) -> a
    void translateX(geogebra.common.kernel.arithmetic.ExpressionNode,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode shiftXnode(double) -> a
    void translateY(double) -> a
    void addNumber(double) -> b
    java.util.LinkedList getPolynomialFactors(boolean) -> a
    java.util.LinkedList getSymbolicPolynomialDerivativeFactors(int,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction getNumericPolynomialDerivative(int) -> a
    java.util.LinkedList getSymbolicPolynomialFactors(boolean) -> b
    java.util.LinkedList getNumericPolynomialFactors(boolean) -> c
    boolean addPolynomialFactors(geogebra.common.kernel.arithmetic.ExpressionValue,java.util.List,boolean,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction expandToPolyFunction(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    geogebra.common.kernel.arithmetic.PolyFunction expandToPolyFunctionNoCas(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode evaluateToExpressionNode(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    geogebra.common.kernel.arithmetic.Function getDerivative(int) -> a
    geogebra.common.kernel.arithmetic.Function getDerivativeNoFractions(int) -> b
    geogebra.common.kernel.arithmetic.Function getDerivative(int,boolean) -> a
    void difference(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.arithmetic.Function) -> a
    void difference(geogebra.common.kernel.arithmetic.Function,geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.roots.RealRootDerivFunction getRealRootDerivFunction() -> a
    boolean includesDivisionByVariable() -> m
    boolean isVector3DValue() -> k
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.Function$DerivFunction -> geogebra.common.i.c.i$a:
    geogebra.common.kernel.arithmetic.Function fun -> b
    geogebra.common.kernel.arithmetic.Function derivative -> c
    double[] ret -> a
    geogebra.common.kernel.arithmetic.Function this$0 -> a
    double evaluate(double) -> a
    double evaluateDerivative(double) -> b
geogebra.common.kernel.arithmetic.FunctionNVar -> geogebra.common.i.c.j:
    geogebra.common.kernel.arithmetic.ExpressionNode expression -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] fVars -> a
    geogebra.common.kernel.arithmetic.IneqTree ineqs -> a
    boolean isBooleanFunction -> a
    boolean isConstantFunction -> b
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionNode casEvalExpression -> b
    java.lang.String casEvalStringSymbolic -> a
    geogebra.common.util.MaxSizeHashMap casEvalMap -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    boolean isFunctionVariable(java.lang.String) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getExpression() -> a
    void resolveVariables() -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    void setExpression(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] getFunctionVariables() -> a
    java.lang.String getVarString(int,geogebra.common.kernel.StringTemplate) -> a
    int getVarNumber() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    void initFunction() -> b
    void fixStructure() -> c
    void initType(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isBooleanFunction() -> n
    boolean isConstantFunction() -> o
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    double evaluate(double[]) -> a
    boolean evaluateBoolean(double[]) -> a
    java.util.HashSet getVariables() -> a
    geogebra.common.kernel.geos.GeoElement[] getGeoElementVariables() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar evalCasCommand(java.lang.String,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    geogebra.common.util.MaxSizeHashMap getCasEvalMap() -> a
    geogebra.common.kernel.arithmetic.FunctionNVar lookupCasEvalMap(java.lang.String) -> a
    void clearCasEvalMap(java.lang.String) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isListValue() -> j
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    java.lang.String getLabelForAssignment() -> c
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    boolean initIneqs(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionalNVar) -> a
    boolean initIneqs(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.IneqTree,boolean) -> a
    geogebra.common.plugin.Operation adjustOp(geogebra.common.plugin.Operation,boolean) -> a
    boolean updateIneqs() -> p
    double evaluate(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean evaluateBoolean(geogebra.common.kernel.geos.GeoPoint2) -> a
    void translate(double,double) -> a
    void translateX(geogebra.common.kernel.arithmetic.ExpressionNode,double,int) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode shiftXnode(double,int) -> a
    void matrixTransform(double,double,double,double) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.FunctionVariable -> geogebra.common.i.c.k:
    java.lang.String varStr -> a
    boolean isConstant() -> b_
    void setVarString(java.lang.String) -> a
    java.lang.String getSetVarString() -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
geogebra.common.kernel.arithmetic.Functional -> geogebra.common.i.c.l:
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
geogebra.common.kernel.arithmetic.Functional2Var -> geogebra.common.i.c.m:
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
geogebra.common.kernel.arithmetic.FunctionalNVar -> geogebra.common.i.c.n:
    double evaluate(double[]) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.arithmetic.IneqTree -> geogebra.common.i.c.o:
    geogebra.common.kernel.arithmetic.IneqTree left -> a
    geogebra.common.kernel.arithmetic.IneqTree right -> b
    geogebra.common.kernel.arithmetic.Inequality ineq -> a
    geogebra.common.plugin.Operation operation -> a
    int size -> a
    void setRight(geogebra.common.kernel.arithmetic.IneqTree) -> a
    geogebra.common.kernel.arithmetic.IneqTree getRight() -> a
    void setLeft(geogebra.common.kernel.arithmetic.IneqTree) -> b
    geogebra.common.kernel.arithmetic.IneqTree getLeft() -> b
    void setOperation(geogebra.common.plugin.Operation) -> a
    geogebra.common.plugin.Operation getOperation() -> a
    void setIneq(geogebra.common.kernel.arithmetic.Inequality) -> a
    geogebra.common.kernel.arithmetic.Inequality getIneq() -> a
    boolean updateCoef() -> a
    int getSize() -> a
    geogebra.common.kernel.arithmetic.Inequality get(int) -> a
    void recomputeSize() -> a
    void getZeros(java.util.Set) -> a
geogebra.common.kernel.arithmetic.Inequality -> geogebra.common.i.c.p:
    geogebra.common.plugin.Operation op -> a
    int type -> a
    geogebra.common.kernel.geos.GeoConic conicBorder -> a
    geogebra.common.kernel.geos.GeoFunction funBorder -> a
    geogebra.common.kernel.geos.GeoElement border -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean isAboveBorder -> a
    geogebra.common.kernel.arithmetic.ExpressionNode normal -> a
    geogebra.common.kernel.arithmetic.FunctionVariable[] fv -> a
    geogebra.common.kernel.arithmetic.MyDouble coef -> a
    geogebra.common.kernel.geos.GeoPoint2[] zeros -> a
    geogebra.common.kernel.arithmetic.MyDouble zeroDummy0 -> b
    geogebra.common.kernel.arithmetic.MyDouble zeroDummy1 -> c
    void update() -> b
    void setAboveBorderFromConic() -> c
    void init1varFunction(int) -> a
    void updateCoef() -> a
    java.lang.String toString() -> toString
    boolean isStrict() -> a
    geogebra.common.kernel.geos.GeoFunction getFunBorder() -> a
    boolean isAboveBorder() -> b
    geogebra.common.kernel.geos.GeoElement getBorder() -> a
    int getType() -> a
    geogebra.common.kernel.geos.GeoConic getConicBorder() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getZeros() -> a
geogebra.common.kernel.arithmetic.ListValue -> geogebra.common.i.c.q:
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    double[] toDouble() -> a
    int size() -> b_
geogebra.common.kernel.arithmetic.MyArbitraryConstant -> geogebra.common.i.c.r:
    java.util.ArrayList consts -> a
    java.util.ArrayList ints -> b
    java.util.ArrayList complexNumbers -> c
    geogebra.common.kernel.algos.ConstructionElement ce -> a
    int position -> a
    geogebra.common.kernel.arithmetic.ExpressionValue nextConst() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue nextInt() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue nextComplex() -> c
    geogebra.common.kernel.arithmetic.ExpressionValue nextConst(java.util.ArrayList,java.lang.String) -> a
    void reset() -> a
geogebra.common.kernel.arithmetic.MyArbitraryConstant$AlgoDependentArbconst -> geogebra.common.i.c.r$a:
    geogebra.common.kernel.geos.GeoElement constant -> a
    geogebra.common.kernel.algos.ConstructionElement outCE -> a
    java.util.ArrayList updateList -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant this$0 -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.arithmetic.MyBoolean -> geogebra.common.i.c.s:
    boolean value -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setValue(boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    void resolveVariables() -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    boolean getBoolean() -> a
    boolean isVector3DValue() -> k
    double getDouble() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.MyDouble -> geogebra.common.i.c.t:
    double val -> b
    boolean isAngle -> b
    geogebra.common.kernel.Kernel kernel -> a
    double LARGEST_INTEGER -> a
    java.lang.StringBuilder sb -> a
    boolean $assertionsDisabled -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void set(double) -> a
    void resolveVariables() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void setAngle() -> b
    boolean isAngle() -> m
    void add(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void sub(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> b
    void mult(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> c
    void mult(geogebra.common.kernel.arithmetic.MyDouble,double,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void div(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> d
    void pow(geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble,geogebra.common.kernel.arithmetic.MyDouble) -> e
    geogebra.common.kernel.arithmetic.MyDouble cos() -> a
    geogebra.common.kernel.arithmetic.MyDouble sin() -> b
    void checkZero() -> c
    geogebra.common.kernel.arithmetic.MyDouble tan() -> c
    geogebra.common.kernel.arithmetic.MyDouble acos() -> d
    geogebra.common.kernel.arithmetic.MyDouble asin() -> e
    geogebra.common.kernel.arithmetic.MyDouble atan() -> f
    geogebra.common.kernel.arithmetic.MyDouble atan2(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.MyDouble log() -> g
    geogebra.common.kernel.arithmetic.MyDouble log(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.arithmetic.MyDouble erf() -> h
    geogebra.common.kernel.arithmetic.MyDouble polygamma(geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.arithmetic.MyDouble psi() -> i
    geogebra.common.kernel.arithmetic.MyDouble log10() -> j
    geogebra.common.kernel.arithmetic.MyDouble log2() -> k
    geogebra.common.kernel.arithmetic.MyDouble exp() -> l
    geogebra.common.kernel.arithmetic.MyDouble sqrt() -> m
    geogebra.common.kernel.arithmetic.MyDouble cbrt() -> n
    geogebra.common.kernel.arithmetic.MyDouble abs() -> o
    geogebra.common.kernel.arithmetic.MyDouble floor() -> p
    geogebra.common.kernel.arithmetic.MyDouble ceil() -> q
    geogebra.common.kernel.arithmetic.MyDouble round() -> r
    double round(double) -> a
    geogebra.common.kernel.arithmetic.MyDouble sgn() -> s
    geogebra.common.kernel.arithmetic.MyDouble cosh() -> t
    geogebra.common.kernel.arithmetic.MyDouble sinh() -> u
    geogebra.common.kernel.arithmetic.MyDouble tanh() -> v
    geogebra.common.kernel.arithmetic.MyDouble acosh() -> w
    geogebra.common.kernel.arithmetic.MyDouble asinh() -> x
    geogebra.common.kernel.arithmetic.MyDouble csc() -> y
    geogebra.common.kernel.arithmetic.MyDouble sec() -> z
    geogebra.common.kernel.arithmetic.MyDouble cot() -> A
    geogebra.common.kernel.arithmetic.MyDouble csch() -> B
    geogebra.common.kernel.arithmetic.MyDouble sech() -> C
    geogebra.common.kernel.arithmetic.MyDouble coth() -> D
    geogebra.common.kernel.arithmetic.MyDouble atanh() -> E
    geogebra.common.kernel.arithmetic.MyDouble cosineIntegral() -> F
    geogebra.common.kernel.arithmetic.MyDouble sineIntegral() -> G
    geogebra.common.kernel.arithmetic.MyDouble expIntegral() -> H
    geogebra.common.kernel.arithmetic.MyDouble factorial() -> I
    geogebra.common.kernel.arithmetic.MyDouble gamma() -> J
    geogebra.common.kernel.arithmetic.MyDouble apply(geogebra.common.kernel.arithmetic.Evaluatable) -> a
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    boolean isConstant() -> b_
    java.util.HashSet getVariables() -> a
    boolean isLeaf() -> b
    double getDouble() -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    double parsePercentage(geogebra.common.main.AbstractApplication,java.lang.String) -> a
    double parseDouble(geogebra.common.main.AbstractApplication,java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue gammaIncompleteRegularized(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue gammaIncomplete(geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue beta(geogebra.common.kernel.arithmetic.NumberValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue betaIncomplete(geogebra.common.kernel.arithmetic.VectorValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue betaIncompleteRegularized(geogebra.common.kernel.arithmetic.VectorValue) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    int compareTo(java.lang.Object) -> compareTo
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.util.ArrayList getSpreadsheetTraceList() -> a
    java.util.ArrayList getColumnHeadings() -> b
geogebra.common.kernel.arithmetic.MyList -> geogebra.common.i.c.u:
    geogebra.common.kernel.Kernel kernel -> a
    int matrixRows -> a
    int matrixCols -> b
    java.util.ArrayList listElements -> a
    boolean isDefined -> a
    void addListElement(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    double[] toDouble() -> a
    int replaceVariables(java.lang.String,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    int replacePolynomials(geogebra.common.kernel.arithmetic.FunctionVariable) -> a
    void applyRight(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    void applyLeft(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> b
    void matrixMultiply(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList) -> a
    void apply(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue,boolean,geogebra.common.kernel.StringTemplate) -> a
    void setIdentityMatrix() -> c
    int getMatrixRows() -> b
    int getMatrixCols() -> c
    geogebra.common.kernel.arithmetic.MyList invert() -> b
    boolean isMatrix() -> m
    void clear() -> b
    boolean isEquation(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    boolean isMatrix(geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCell(geogebra.common.kernel.arithmetic.MyList,int,int) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    int size() -> b_
    void resolveVariables() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getListElement(int) -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    boolean isVector3DValue() -> k
    boolean isElementOf(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.MyList) -> a
    boolean listContains(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList) -> a
    boolean listContainsStrict(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyList setDifference(geogebra.common.kernel.Kernel,geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.MyList) -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void vectorProduct(geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean isDefined() -> n
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.arithmetic.MyList getCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
geogebra.common.kernel.arithmetic.MyNumberPair -> geogebra.common.i.c.v:
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
geogebra.common.kernel.arithmetic.MySpecialDouble -> geogebra.common.i.c.w:
    java.lang.String strToString -> a
    boolean keepOriginalString -> b
    boolean isLetterConstant -> c
    boolean scientificNotation -> d
    geogebra.common.kernel.arithmetic.MySpecialDouble eulerConstant -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.MySpecialDouble getEulerConstant(geogebra.common.kernel.Kernel) -> a
    boolean isEulerConstant() -> n
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.MyStringBuffer -> geogebra.common.i.c.x:
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.Kernel kernel -> a
    void append(java.lang.String) -> a
    void insert(int,java.lang.String) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void resolveVariables() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.MyVecNode -> geogebra.common.i.c.y:
    geogebra.common.kernel.arithmetic.ExpressionValue x -> a
    geogebra.common.kernel.arithmetic.ExpressionValue y -> b
    int mode -> a
    geogebra.common.kernel.Kernel kernel -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getX() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getY() -> b
    void setPolarCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean hasPolarCoords() -> m
    void setCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    double[] getCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    boolean isVectorValue() -> d
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isListValue() -> j
    boolean isExpressionNode() -> i_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic.NumberValue -> geogebra.common.i.c.z:
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
geogebra.common.kernel.arithmetic.Parametric -> geogebra.common.i.c.A:
    geogebra.common.kernel.arithmetic.ExpressionNode P -> a
    geogebra.common.kernel.arithmetic.ExpressionNode v -> b
    java.lang.String parameter -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getP() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getv() -> b
    java.lang.String getParameter() -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.util.HashSet getVariables() -> a
    boolean isBooleanValue() -> j_
    boolean isConstant() -> b_
    boolean isExpressionNode() -> i_
    boolean isLeaf() -> b
    boolean isListValue() -> j
    boolean isNumberValue() -> c
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isVectorValue() -> d
    void resolveVariables() -> a
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.PolyFunction -> geogebra.common.i.c.B:
    double[] coeffs -> a
    int degree -> a
    geogebra.common.kernel.arithmetic.PolyFunction derivative -> a
    double[] getCoeffs() -> a
    double[] getCoeffsCopy() -> b
    boolean updateCoeffValues() -> a
    int getDegree() -> a
    geogebra.common.kernel.arithmetic.PolyFunction getDerivative() -> a
    geogebra.common.kernel.arithmetic.PolyFunction buildDerivative() -> b
    double[] evaluateDerivFunc(double) -> a
    double evaluateDerivative(double) -> b
    double evaluate(double) -> a
geogebra.common.kernel.arithmetic.Polynomial -> geogebra.common.i.c.C:
    java.util.ArrayList terms -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.Term getTerm(int) -> a
    int length() -> a
    void append(geogebra.common.kernel.arithmetic.Term) -> a
    void add(geogebra.common.kernel.arithmetic.Polynomial) -> a
    void sub(geogebra.common.kernel.arithmetic.Polynomial) -> b
    void multiply(geogebra.common.kernel.arithmetic.Polynomial) -> c
    void multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    void divide(geogebra.common.kernel.arithmetic.Polynomial) -> d
    void multiply(double) -> a
    void power(int) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getConstantCoefficient() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCoefficient(java.lang.String) -> a
    double getCoeffValue(java.lang.String) -> a
    double getConstantCoeffValue() -> a
    void simplify() -> b
    boolean contains(java.lang.String) -> a
    int degree() -> b
    boolean isFreeOf(char) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[][] getCoeff() -> a
    java.util.HashSet getVariables() -> a
    void resolveVariables() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> j_
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.ReplaceChildrenByValues -> geogebra.common.i.c.D:
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.arithmetic.SymbolicPolyFunction -> geogebra.common.i.c.E:
    geogebra.common.kernel.arithmetic.ExpressionNode[] symbCoeffs -> a
    geogebra.common.kernel.arithmetic.ExpressionNode[] getSymbolicCoeffs() -> a
    boolean updateCoeffValues() -> a
geogebra.common.kernel.arithmetic.Term -> geogebra.common.i.c.F:
    geogebra.common.kernel.arithmetic.ExpressionValue coefficient -> a
    java.lang.StringBuilder variables -> a
    geogebra.common.kernel.Kernel kernel -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    boolean $assertionsDisabled -> a
    geogebra.common.kernel.arithmetic.ExpressionValue getCoefficient() -> a
    java.lang.String getVars() -> a
    int degree() -> a
    int degree(char) -> a
    void addToCoefficient(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue add(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue sub(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    void multiply(geogebra.common.kernel.arithmetic.Term) -> a
    void multiply(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue multiply(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    void divide(geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue divide(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    void sort(java.lang.StringBuilder) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean contains(java.lang.String) -> a
    int compareTo(java.lang.Object) -> compareTo
    java.lang.String toString() -> toString
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String coeffString(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String variableString() -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.arithmetic.TextValue -> geogebra.common.i.c.G:
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
geogebra.common.kernel.arithmetic.Traversing -> geogebra.common.i.c.H:
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer -> geogebra.common.i.c.H$a:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$ArbconstReplacer getReplacer(geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
geogebra.common.kernel.arithmetic.Traversing$CommandCollector -> geogebra.common.i.c.H$b:
    java.util.Set commands -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandCollector collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$CommandCollector getCollector(java.util.Set) -> a
geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector -> geogebra.common.i.c.H$c:
    java.util.List derivativeFunctions -> a
    java.util.List derivativeDegrees -> b
    java.util.Set signatures -> a
    geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector collector -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$DerivativeCollector getCollector() -> a
    java.util.List getFunctions() -> a
    java.util.List getDegrees() -> b
geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer -> geogebra.common.i.c.H$d:
    java.lang.String var -> a
    geogebra.common.kernel.arithmetic.ExpressionValue newObj -> a
    boolean didReplacement -> a
    geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$GeoDummyReplacer getReplacer(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean didReplacement() -> a
geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer -> geogebra.common.i.c.H$e:
    boolean toRoot -> a
    geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$PowerRootReplacer getReplacer(boolean) -> a
geogebra.common.kernel.arithmetic.Traversing$Replacer -> geogebra.common.i.c.H$f:
    geogebra.common.kernel.arithmetic.ExpressionValue oldObj -> a
    geogebra.common.kernel.arithmetic.ExpressionValue newObj -> b
    geogebra.common.kernel.arithmetic.Traversing$Replacer replacer -> a
    geogebra.common.kernel.arithmetic.ExpressionValue process(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.arithmetic.Traversing$Replacer getReplacer(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.arithmetic.ValidExpression -> geogebra.common.i.c.I:
    java.util.Vector labels -> a
    boolean inTree -> a
    boolean keepInputUsed -> b
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    void addLabel(java.lang.String) -> b
    void initLabels() -> b
    void addLabel(java.util.Vector) -> a
    int labelCount() -> d
    java.lang.String getLabel(int) -> b
    java.lang.String[] getLabels() -> a
    java.lang.String getLabel() -> e
    void setLabel(java.lang.String) -> c
    void setLabels(java.lang.String[]) -> a
    boolean isVariable() -> y
    boolean isInTree() -> z
    void setInTree(boolean) -> b
    boolean isGeoElement() -> h_
    boolean isTopLevelCommand() -> l
    geogebra.common.kernel.arithmetic.Command getTopLevelCommand() -> a
    java.lang.String getLabelForAssignment() -> c
    java.lang.String toAssignmentString(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String toAssignmentLaTeXString() -> f
    java.lang.String getAssignmentOperator() -> a
    java.lang.String getAssignmentOperatorLaTeX() -> b
    boolean isKeepInputUsed() -> A
    void setKeepInputUsed(boolean) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    java.lang.String toString() -> toString
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
geogebra.common.kernel.arithmetic.Variable -> geogebra.common.i.c.J:
    java.lang.String name -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    java.lang.String getName(geogebra.common.kernel.StringTemplate) -> f
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    geogebra.common.kernel.geos.GeoElement resolve() -> a
    geogebra.common.kernel.geos.GeoElement resolve(boolean) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue resolveAsExpressionValue() -> a
    java.util.HashSet getVariables() -> a
    void resolveVariables() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isVariable() -> y
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
geogebra.common.kernel.arithmetic.VectorValue -> geogebra.common.i.c.K:
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
geogebra.common.kernel.arithmetic3D.MyVec3DNode -> geogebra.common.i.d.a:
    geogebra.common.kernel.arithmetic.ExpressionValue x -> a
    geogebra.common.kernel.arithmetic.ExpressionValue y -> b
    geogebra.common.kernel.arithmetic.ExpressionValue z -> c
    geogebra.common.kernel.Kernel kernel -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables() -> a
    void setCoords(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    double[] getCoords() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    double[] getPointAsDouble() -> b
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    boolean isVectorValue() -> d
    boolean isNumberValue() -> c
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isListValue() -> j
    boolean isExpressionNode() -> i_
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.arithmetic3D.Vector3DValue -> geogebra.common.i.d.b:
    double[] getPointAsDouble() -> b
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
geogebra.common.kernel.barycentric.AlgoBarycenter -> geogebra.common.i.e.a:
    geogebra.common.kernel.geos.GeoList poly -> a
    geogebra.common.kernel.geos.GeoList list -> b
    geogebra.common.kernel.geos.GeoPoint2 point -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoKimberling -> geogebra.common.i.e.b:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.geos.GeoPoint2 M -> d
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getResult() -> a
    double p(double,double) -> a
    double u(double) -> a
    void compute() -> b
    double weight(int,double,double,double) -> a
    double weight0to1000(int,double,double,double) -> b
    double weight1000to1499(int,double,double,double) -> c
    double weight1500to1999(int,double,double,double) -> d
    double weight2000to2500(int,double,double,double) -> e
    double weight2500to2799(int,double,double,double) -> f
    double weight2800plus(int,double,double,double) -> g
geogebra.common.kernel.barycentric.AlgoTriangleCubic -> geogebra.common.i.e.c:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly poly -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoTriangleCurve -> geogebra.common.i.e.d:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoPoint2 C -> c
    geogebra.common.kernel.implicit.GeoImplicitPoly n -> a
    geogebra.common.kernel.geos.GeoElement poly -> a
    geogebra.common.kernel.arithmetic.Equation eq -> a
    geogebra.common.kernel.geos.GeoNumeric[] xcoef -> a
    geogebra.common.kernel.geos.GeoNumeric[] ycoef -> b
    geogebra.common.kernel.geos.GeoNumeric[] constant -> c
    geogebra.common.kernel.implicit.AlgoDependentImplicitPoly dd -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
geogebra.common.kernel.barycentric.AlgoTrilinear -> geogebra.common.i.e.e:
    geogebra.common.kernel.geos.GeoPoint2 P1 -> a
    geogebra.common.kernel.geos.GeoPoint2 P2 -> b
    geogebra.common.kernel.geos.GeoPoint2 P3 -> c
    geogebra.common.kernel.arithmetic.NumberValue v1 -> a
    geogebra.common.kernel.arithmetic.NumberValue v2 -> b
    geogebra.common.kernel.arithmetic.NumberValue v3 -> c
    geogebra.common.kernel.geos.GeoPoint2 point -> d
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoPoint2 getResult() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoCasBase -> geogebra.common.i.f.a:
    geogebra.common.kernel.geos.CasEvaluableFunction f -> a
    geogebra.common.kernel.geos.CasEvaluableFunction g -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void compute() -> b
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoCoefficients -> geogebra.common.i.f.b:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    java.lang.String casInput -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String getCasInput() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void handleCASoutput(java.lang.String,int) -> a
    void handleException(java.lang.Throwable,int) -> a
    boolean useCacheing() -> l
geogebra.common.kernel.cas.AlgoDegree -> geogebra.common.i.f.c:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoDependentCasCell -> geogebra.common.i.f.d:
    geogebra.common.kernel.geos.GeoCasCell casCell -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void initInput() -> e
    void remove() -> c
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoCasCell getCasCell() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getExpXML(geogebra.common.kernel.StringTemplate) -> f
geogebra.common.kernel.cas.AlgoDerivative -> geogebra.common.i.f.e:
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.NumberValue order -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoExpand -> geogebra.common.i.f.f:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoFactor -> geogebra.common.i.f.g:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoFactors -> geogebra.common.i.f.h:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoList g -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoIntegral -> geogebra.common.i.f.i:
    geogebra.common.kernel.geos.GeoNumeric var -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoIntegralDefinite -> geogebra.common.i.f.j:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.geos.GeoBoolean evaluate -> a
    geogebra.common.kernel.geos.GeoElement ageo -> a
    geogebra.common.kernel.geos.GeoElement bgeo -> b
    geogebra.common.kernel.geos.GeoNumeric n -> a
    geogebra.common.kernel.geos.GeoFunction symbIntegral -> b
    org.apache.commons.math.analysis.integration.LegendreGaussIntegrator firstGauss -> a
    org.apache.commons.math.analysis.integration.LegendreGaussIntegrator secondGauss -> b
    int adaptiveGaussQuadCounter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getIntegral() -> a
    geogebra.common.kernel.geos.GeoFunction getFunction() -> a
    geogebra.common.kernel.arithmetic.NumberValue getA() -> a
    geogebra.common.kernel.arithmetic.NumberValue getB() -> b
    void compute() -> b
    double numericIntegration(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
    double doAdaptiveGaussQuad(geogebra.common.kernel.roots.RealRootFunction,double,double) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
    boolean evaluateOnly() -> l
geogebra.common.kernel.cas.AlgoIntegralDefiniteInterface -> geogebra.common.i.f.k:
    boolean evaluateOnly() -> l
geogebra.common.kernel.cas.AlgoLengthCurve -> geogebra.common.i.f.l:
    geogebra.common.kernel.geos.GeoNumeric t0 -> a
    geogebra.common.kernel.geos.GeoNumeric t1 -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> c
    geogebra.common.kernel.roots.RealRootFunction lengthCurve -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthCurve$LengthCurve -> geogebra.common.i.f.l$a:
    geogebra.common.kernel.cas.AlgoLengthCurve this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthCurve2Points -> geogebra.common.i.f.m:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoCurveCartesian c -> b
    geogebra.common.kernel.geos.GeoCurveCartesian derivative -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.roots.RealRootFunction lengthCurve -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthCurve2Points$LengthCurve -> geogebra.common.i.f.m$a:
    double[] f1eval -> a
    geogebra.common.kernel.cas.AlgoLengthCurve2Points this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthFunction -> geogebra.common.i.f.n:
    geogebra.common.kernel.geos.GeoNumeric A -> a
    geogebra.common.kernel.geos.GeoNumeric B -> b
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> c
    geogebra.common.kernel.roots.RealRootFunction lengthFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthFunction$LengthFunction -> geogebra.common.i.f.n$a:
    geogebra.common.kernel.cas.AlgoLengthFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLengthFunction2Points -> geogebra.common.i.f.o:
    geogebra.common.kernel.geos.GeoPoint2 A -> a
    geogebra.common.kernel.geos.GeoPoint2 B -> b
    geogebra.common.kernel.geos.GeoFunction f -> b
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoNumeric length -> a
    geogebra.common.kernel.roots.RealRootFunction lengthFunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoLengthFunction2Points$LengthFunction -> geogebra.common.i.f.o$a:
    geogebra.common.kernel.cas.AlgoLengthFunction2Points this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.cas.AlgoLimit -> geogebra.common.i.f.p:
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoNumeric outNum -> a
    java.lang.StringBuilder sb -> a
    java.lang.String limitString -> a
    void init(java.lang.String) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    java.lang.String getCasInput() -> c
    int getDirection() -> f
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void handleCASoutput(java.lang.String,int) -> a
    void handleException(java.lang.Throwable,int) -> a
    boolean useCacheing() -> l
geogebra.common.kernel.cas.AlgoLimitAbove -> geogebra.common.i.f.q:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getDirection() -> f
geogebra.common.kernel.cas.AlgoLimitBelow -> geogebra.common.i.f.r:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getDirection() -> f
geogebra.common.kernel.cas.AlgoPartialFractions -> geogebra.common.i.f.s:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialDiv -> geogebra.common.i.f.t:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoPolynomialMod -> geogebra.common.i.f.u:
    geogebra.common.kernel.geos.GeoFunction f1 -> a
    geogebra.common.kernel.geos.GeoFunction f2 -> b
    geogebra.common.kernel.geos.GeoFunction g -> c
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getResult() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoSimplify -> geogebra.common.i.f.v:
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void applyCasCommand(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTangentCurve -> geogebra.common.i.f.w:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoCurveCartesian f -> a
    geogebra.common.kernel.geos.GeoCurveCartesian df -> b
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoPoint2 T -> b
    boolean pointOnCurve -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
geogebra.common.kernel.cas.AlgoTangentFunctionNumber -> geogebra.common.i.f.x:
    geogebra.common.kernel.arithmetic.NumberValue n -> a
    geogebra.common.kernel.geos.GeoElement ngeo -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoPoint2 T -> a
    geogebra.common.kernel.geos.GeoFunction deriv -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoTangentFunctionPoint -> geogebra.common.i.f.y:
    geogebra.common.kernel.geos.GeoPoint2 P -> a
    geogebra.common.kernel.geos.GeoLine tangent -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint2 T -> b
    boolean pointOnFunction -> a
    geogebra.common.kernel.geos.GeoFunction deriv -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getTangent() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.cas.AlgoUsingTempCASalgo -> geogebra.common.i.f.z:
    geogebra.common.kernel.algos.AlgoElement algoCAS -> a
    void remove() -> c
geogebra.common.kernel.cas.AsynchronousCommand -> geogebra.common.i.f.A:
    void handleCASoutput(java.lang.String,int) -> a
    void handleException(java.lang.Throwable,int) -> a
    boolean useCacheing() -> l
    java.lang.String getCasInput() -> c
geogebra.common.kernel.cas.CASGenericInterface -> geogebra.common.i.f.B:
    java.lang.String getTranslatedCASCommand(java.lang.String) -> c
    java.util.Set getAvailableCommandNames() -> a
    java.lang.String toAssignment(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.StringTemplate) -> a
    void initCAS() -> a
geogebra.common.kernel.cas.CASParserInterface -> geogebra.common.i.f.C:
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> b
geogebra.common.kernel.cas.GeoGebraCasInterface -> geogebra.common.i.f.D:
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getCurrentCASstringType() -> a
    java.lang.String evaluateRaw(java.lang.String) -> a
    geogebra.common.kernel.cas.CASGenericInterface getCurrentCAS() -> a
    java.lang.String evaluateGeoGebraCAS(geogebra.common.kernel.arithmetic.ValidExpression,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    geogebra.common.kernel.cas.CASParserInterface getCASparser() -> a
    boolean isStructurallyEqual(geogebra.common.kernel.arithmetic.ValidExpression,java.lang.String) -> a
    boolean isCommandAvailable(geogebra.common.kernel.arithmetic.Command) -> a
    java.lang.String[] getPolynomialCoeffs(java.lang.String,java.lang.String) -> a
    java.lang.String evaluateGeoGebraCAS(java.lang.String,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    void unbindVariable(java.lang.String) -> a
    void setSignificantFiguresForNumeric(int) -> a
    java.lang.String getCASCommand(java.lang.String,java.util.ArrayList,boolean,geogebra.common.kernel.StringTemplate) -> a
    void evaluateGeoGebraCASAsync(geogebra.common.kernel.cas.AsynchronousCommand) -> a
geogebra.common.kernel.commands.AlgebraProcessor -> geogebra.common.i.g.a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.parser.ParserInterface parser -> a
    geogebra.common.kernel.commands.CommandDispatcher cmdDispatcher -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    java.util.Set getPublicCommandSet() -> a
    java.lang.String getSubCommandSetName(int) -> a
    boolean isCommandAvailable(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processCommand(geogebra.common.kernel.arithmetic.Command,boolean) -> a
    void processCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    geogebra.common.kernel.geos.GeoElement changeGeoElement(geogebra.common.kernel.geos.GeoElement,java.lang.String,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement changeGeoElementNoExceptionHandling(geogebra.common.kernel.geos.GeoElement,java.lang.String,boolean,boolean) -> b
    geogebra.common.kernel.geos.GeoElement changeGeoElementNoExceptionHandling(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.arithmetic.ValidExpression,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommand(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommandNoExceptions(java.lang.String,boolean) -> b
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommandNoExceptionsOrErrors(java.lang.String,boolean) -> c
    geogebra.common.kernel.geos.GeoElement[] processAlgebraCommandNoExceptionHandling(java.lang.String,boolean,boolean,boolean) -> a
    double evaluateToDouble(java.lang.String) -> a
    double evaluateToDouble(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoBoolean evaluateToBoolean(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoList evaluateToList(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoFunction evaluateToFunction(java.lang.String,boolean) -> a
    geogebra.common.kernel.arithmetic.NumberValue evaluateToNumeric(java.lang.String,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND evaluateToPoint(java.lang.String,boolean) -> a
    geogebra.common.kernel.geos.GeoText evaluateToText(java.lang.String,boolean,boolean) -> a
    java.lang.String parseLabel(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processValidExpression(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    geogebra.common.kernel.geos.GeoElement[] processValidExpression(geogebra.common.kernel.arithmetic.ValidExpression,boolean) -> a
    boolean compatibleTypes(geogebra.common.plugin.GeoClass,geogebra.common.plugin.GeoClass) -> a
    geogebra.common.kernel.geos.GeoElement[] doProcessValidExpression(geogebra.common.kernel.arithmetic.ValidExpression) -> b
    geogebra.common.kernel.geos.GeoElement[] processFunction(geogebra.common.kernel.arithmetic.Function) -> a
    geogebra.common.kernel.geos.GeoElement[] processFunctionNVar(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.geos.GeoElement[] processEquation(geogebra.common.kernel.arithmetic.Equation) -> a
    void checkNoTermsInZ(geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoElement[] processLine(geogebra.common.kernel.arithmetic.Equation) -> b
    geogebra.common.kernel.geos.GeoElement[] processConic(geogebra.common.kernel.arithmetic.Equation) -> c
    geogebra.common.kernel.geos.GeoElement[] processImplicitPoly(geogebra.common.kernel.arithmetic.Equation) -> d
    geogebra.common.kernel.geos.GeoElement[] processParametric(geogebra.common.kernel.arithmetic.Parametric) -> a
    geogebra.common.kernel.geos.GeoElement[] processExpressionNode(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] processNumber(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    geogebra.common.kernel.geos.GeoElement[] processList(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.MyList) -> a
    geogebra.common.kernel.geos.GeoElement[] processText(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> c
    geogebra.common.kernel.geos.GeoElement[] processBoolean(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> d
    geogebra.common.kernel.geos.GeoElement[] processPointVector(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> e
    geogebra.common.kernel.geos.GeoElement[] processPointVector3D(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.geos.GeoElement[] processGeoCopy(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    void enableCAS() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra.common.kernel.commands.CmdANOVA -> geogebra.common.i.g.b:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAffineRatio -> geogebra.common.i.g.c:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAngle -> geogebra.common.i.g.d:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAngularBisector -> geogebra.common.i.g.e:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAppend -> geogebra.common.i.g.f:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdApplyMatrix -> geogebra.common.i.g.g:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdArc -> geogebra.common.i.g.h:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAreCollinear -> geogebra.common.i.g.i:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAreConcyclic -> geogebra.common.i.g.j:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAreParallel -> geogebra.common.i.g.k:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdArea -> geogebra.common.i.g.l:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAsymptote -> geogebra.common.i.g.m:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAxes -> geogebra.common.i.g.n:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAxisStepX -> geogebra.common.i.g.o:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdAxisStepY -> geogebra.common.i.g.p:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBarChart -> geogebra.common.i.g.q:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBarycenter -> geogebra.common.i.g.r:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBernoulli -> geogebra.common.i.g.s:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBinomial -> geogebra.common.i.g.t:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdBinomialDist -> geogebra.common.i.g.u:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdBoxPlot -> geogebra.common.i.g.v:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdButton -> geogebra.common.i.g.w:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCauchy -> geogebra.common.i.g.x:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCell -> geogebra.common.i.g.y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCellRange -> geogebra.common.i.g.z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCenter -> geogebra.common.i.g.A:
geogebra.common.kernel.commands.CmdCentroid -> geogebra.common.i.g.B:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCheckbox -> geogebra.common.i.g.C:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdChiSquared -> geogebra.common.i.g.D:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircle -> geogebra.common.i.g.E:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircleArc -> geogebra.common.i.g.F:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircleSector -> geogebra.common.i.g.G:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumcircleArc -> geogebra.common.i.g.H:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumcircleSector -> geogebra.common.i.g.I:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCircumference -> geogebra.common.i.g.J:
geogebra.common.kernel.commands.CmdClasses -> geogebra.common.i.g.K:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdClosestPoint -> geogebra.common.i.g.L:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCoefficients -> geogebra.common.i.g.M:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdColumn -> geogebra.common.i.g.N:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdColumnName -> geogebra.common.i.g.O:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCompleteSquare -> geogebra.common.i.g.P:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdComplexRoot -> geogebra.common.i.g.Q:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdConic -> geogebra.common.i.g.R:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdConstructionStep -> geogebra.common.i.g.S:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdConvexHull -> geogebra.common.i.g.T:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdCopyFreeObject -> geogebra.common.i.g.U:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCorner -> geogebra.common.i.g.V:
geogebra.common.kernel.commands.CmdCountIf -> geogebra.common.i.g.W:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCovariance -> geogebra.common.i.g.X:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdCrossRatio -> geogebra.common.i.g.Y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCurvature -> geogebra.common.i.g.Z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCurvatureVector -> geogebra.common.i.g.aa:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdCurveCartesian -> geogebra.common.i.g.ab:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDefined -> geogebra.common.i.g.ac:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDegree -> geogebra.common.i.g.ad:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDelauneyTriangulation -> geogebra.common.i.g.ae:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdDelete -> geogebra.common.i.g.af:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDenominator -> geogebra.common.i.g.ag:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDerivative -> geogebra.common.i.g.ah:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    java.lang.String getDerivLabel(geogebra.common.kernel.geos.GeoElement,int) -> a
geogebra.common.kernel.commands.CmdDeterminant -> geogebra.common.i.g.ai:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdDiameter -> geogebra.common.i.g.aj:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDilate -> geogebra.common.i.g.ak:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDirection -> geogebra.common.i.g.al:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDirectrix -> geogebra.common.i.g.am:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDistance -> geogebra.common.i.g.an:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDiv -> geogebra.common.i.g.ao:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdDotPlot -> geogebra.common.i.g.ap:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdDynamicCoordinates -> geogebra.common.i.g.aq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdEccentricity -> geogebra.common.i.g.ar:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdElement -> geogebra.common.i.g.as:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdEllipse -> geogebra.common.i.g.at:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdErlang -> geogebra.common.i.g.au:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExcentricity -> geogebra.common.i.g.av:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExecute -> geogebra.common.i.g.aw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExpand -> geogebra.common.i.g.ax:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExponential -> geogebra.common.i.g.ay:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdExtremum -> geogebra.common.i.g.az:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFDistribution -> geogebra.common.i.g.aA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFactor -> geogebra.common.i.g.aB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFactors -> geogebra.common.i.g.aC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFillCells -> geogebra.common.i.g.aD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFillColumn -> geogebra.common.i.g.aE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFillRow -> geogebra.common.i.g.aF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFirst -> geogebra.common.i.g.aG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFirstAxis -> geogebra.common.i.g.aH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFirstAxisLength -> geogebra.common.i.g.aI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFit -> geogebra.common.i.g.aJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFitExp -> geogebra.common.i.g.aK:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitGrowth -> geogebra.common.i.g.aL:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitLineX -> geogebra.common.i.g.aM:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitLineY -> geogebra.common.i.g.aN:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitLog -> geogebra.common.i.g.aO:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitLogistic -> geogebra.common.i.g.aP:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitPoly -> geogebra.common.i.g.aQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFitPow -> geogebra.common.i.g.aR:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFitSin -> geogebra.common.i.g.aS:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdFlatten -> geogebra.common.i.g.aT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFocus -> geogebra.common.i.g.aU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFractionText -> geogebra.common.i.g.aV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFrequency -> geogebra.common.i.g.aW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFrequencyPolygon -> geogebra.common.i.g.aX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFrequencyTable -> geogebra.common.i.g.aY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdFunction -> geogebra.common.i.g.aZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdGCD -> geogebra.common.i.g.ba:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdGamma -> geogebra.common.i.g.bb:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdGeometricMean -> geogebra.common.i.g.bc:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdGetTime -> geogebra.common.i.g.bd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdHarmonicMean -> geogebra.common.i.g.be:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdHideLayer -> geogebra.common.i.g.bf:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdHistogram -> geogebra.common.i.g.bg:
    boolean right -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdHistogramRight -> geogebra.common.i.g.bh:
geogebra.common.kernel.commands.CmdHull -> geogebra.common.i.g.bi:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdHyperGeometric -> geogebra.common.i.g.bj:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdHyperbola -> geogebra.common.i.g.bk:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIdentity -> geogebra.common.i.g.bl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIf -> geogebra.common.i.g.bm:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoFunction resolveFunction(geogebra.common.kernel.arithmetic.Command,int,geogebra.common.kernel.arithmetic.FunctionVariable) -> a
geogebra.common.kernel.commands.CmdImplicitPoly -> geogebra.common.i.g.bn:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIncircle -> geogebra.common.i.g.bo:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIndexOf -> geogebra.common.i.g.bp:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInsert -> geogebra.common.i.g.bq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIntegral -> geogebra.common.i.g.br:
    java.lang.String internalCommandName -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIntersect -> geogebra.common.i.g.bs:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIntersectRegion -> geogebra.common.i.g.bt:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIntersection -> geogebra.common.i.g.bu:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIntersectionPaths -> geogebra.common.i.g.bv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseBinomial -> geogebra.common.i.g.bw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseCauchy -> geogebra.common.i.g.bx:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseChiSquared -> geogebra.common.i.g.by:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseExponential -> geogebra.common.i.g.bz:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseFDistribution -> geogebra.common.i.g.bA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseGamma -> geogebra.common.i.g.bB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseHyperGeometric -> geogebra.common.i.g.bC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseNormal -> geogebra.common.i.g.bD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInversePascal -> geogebra.common.i.g.bE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInversePoisson -> geogebra.common.i.g.bF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseTDistribution -> geogebra.common.i.g.bG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseWeibull -> geogebra.common.i.g.bH:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInverseZipf -> geogebra.common.i.g.bI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdInvert -> geogebra.common.i.g.bJ:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdIsInRegion -> geogebra.common.i.g.bK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIsInteger -> geogebra.common.i.g.bL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIteration -> geogebra.common.i.g.bM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdIterationList -> geogebra.common.i.g.bN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdJoin -> geogebra.common.i.g.bO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdKeepIf -> geogebra.common.i.g.bP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdKimberling -> geogebra.common.i.g.bQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLCM -> geogebra.common.i.g.bR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLaTeX -> geogebra.common.i.g.bS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLast -> geogebra.common.i.g.bT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLeftSum -> geogebra.common.i.g.bU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLength -> geogebra.common.i.g.bV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLetterToUnicode -> geogebra.common.i.g.bW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLimit -> geogebra.common.i.g.bX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLimitAbove -> geogebra.common.i.g.bY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLimitBelow -> geogebra.common.i.g.bZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLine -> geogebra.common.i.g.ca:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLineBisector -> geogebra.common.i.g.cb:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLineStyle -> geogebra.common.i.g.cc:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLocus -> geogebra.common.i.g.cd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLogNormal -> geogebra.common.i.g.ce:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLogistic -> geogebra.common.i.g.cf:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdLowerSum -> geogebra.common.i.g.cg:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMax -> geogebra.common.i.g.ch:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMaximize -> geogebra.common.i.g.ci:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMean -> geogebra.common.i.g.cj:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdMeanX -> geogebra.common.i.g.ck:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdMeanY -> geogebra.common.i.g.cl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdMedian -> geogebra.common.i.g.cm:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdMidpoint -> geogebra.common.i.g.cn:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMin -> geogebra.common.i.g.co:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMinimize -> geogebra.common.i.g.cp:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMinimumSpanningTree -> geogebra.common.i.g.cq:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdMirror -> geogebra.common.i.g.cr:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMod -> geogebra.common.i.g.cs:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdMode -> geogebra.common.i.g.ct:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdName -> geogebra.common.i.g.cu:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdNormal -> geogebra.common.i.g.cv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdNormalQuantilePlot -> geogebra.common.i.g.cw:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdNumerator -> geogebra.common.i.g.cx:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdObject -> geogebra.common.i.g.cy:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOneListFunction -> geogebra.common.i.g.cz:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdOneOrTwoListsFunction -> geogebra.common.i.g.cA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdOrdinal -> geogebra.common.i.g.cB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOrdinalRank -> geogebra.common.i.g.cC:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdOrthogonalLine -> geogebra.common.i.g.cD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOrthogonalVector -> geogebra.common.i.g.cE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdOsculatingCircle -> geogebra.common.i.g.cF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPMCC -> geogebra.common.i.g.cG:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdPan -> geogebra.common.i.g.cH:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdParabola -> geogebra.common.i.g.cI:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdParameter -> geogebra.common.i.g.cJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdParseToFunction -> geogebra.common.i.g.cK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdParseToNumber -> geogebra.common.i.g.cL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPartialFractions -> geogebra.common.i.g.cM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPascal -> geogebra.common.i.g.cN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPathParameter -> geogebra.common.i.g.cO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPercentile -> geogebra.common.i.g.cP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPerimeter -> geogebra.common.i.g.cQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPlaySound -> geogebra.common.i.g.cR:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPoint -> geogebra.common.i.g.cS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPointIn -> geogebra.common.i.g.cT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPointList -> geogebra.common.i.g.cU:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdPoisson -> geogebra.common.i.g.cV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPolar -> geogebra.common.i.g.cW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPolyLine -> geogebra.common.i.g.cX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPolygon -> geogebra.common.i.g.cY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPolynomial -> geogebra.common.i.g.cZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdPrimeFactors -> geogebra.common.i.g.da:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdProduct -> geogebra.common.i.g.db:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdProve -> geogebra.common.i.g.dc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdQ1 -> geogebra.common.i.g.dd:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdQ3 -> geogebra.common.i.g.de:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRSquare -> geogebra.common.i.g.df:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRadius -> geogebra.common.i.g.dg:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRandom -> geogebra.common.i.g.dh:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdRandomBinomial -> geogebra.common.i.g.di:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdRandomElement -> geogebra.common.i.g.dj:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRandomNormal -> geogebra.common.i.g.dk:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdRandomPoisson -> geogebra.common.i.g.dl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRandomUniform -> geogebra.common.i.g.dm:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdRay -> geogebra.common.i.g.dn:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRectangleSum -> geogebra.common.i.g.do:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdReducedRowEchelonForm -> geogebra.common.i.g.dp:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRelation -> geogebra.common.i.g.dq:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRemoveUndefined -> geogebra.common.i.g.dr:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRename -> geogebra.common.i.g.ds:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdResidualPlot -> geogebra.common.i.g.dt:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdReverse -> geogebra.common.i.g.du:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRigidPolygon -> geogebra.common.i.g.dv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRoot -> geogebra.common.i.g.dw:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRootList -> geogebra.common.i.g.dx:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRootMeanSquare -> geogebra.common.i.g.dy:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdRoots -> geogebra.common.i.g.dz:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRotate -> geogebra.common.i.g.dA:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRotateText -> geogebra.common.i.g.dB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdRow -> geogebra.common.i.g.dC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSD -> geogebra.common.i.g.dD:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSDX -> geogebra.common.i.g.dE:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSDY -> geogebra.common.i.g.dF:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSXX -> geogebra.common.i.g.dG:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSXY -> geogebra.common.i.g.dH:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSYY -> geogebra.common.i.g.dI:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSample -> geogebra.common.i.g.dJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSampleSD -> geogebra.common.i.g.dK:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSampleSDX -> geogebra.common.i.g.dL:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSampleSDY -> geogebra.common.i.g.dM:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSampleVariance -> geogebra.common.i.g.dN:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdScripting -> geogebra.common.i.g.dO:
    geogebra.common.kernel.geos.GeoElement[] arg -> a
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
    void performAndClean(geogebra.common.kernel.arithmetic.Command) -> b
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSecondAxis -> geogebra.common.i.g.dP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSecondAxisLength -> geogebra.common.i.g.dQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSector -> geogebra.common.i.g.dR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSegment -> geogebra.common.i.g.dS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSelectObjects -> geogebra.common.i.g.dT:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSelectedElement -> geogebra.common.i.g.dU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSelectedIndex -> geogebra.common.i.g.dV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSemicircle -> geogebra.common.i.g.dW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSequence -> geogebra.common.i.g.dX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetActiveView -> geogebra.common.i.g.dY:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetAxesRatio -> geogebra.common.i.g.dZ:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetBackgroundColor -> geogebra.common.i.g.ea:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetCaption -> geogebra.common.i.g.eb:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetColor -> geogebra.common.i.g.ec:
    boolean background -> a
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetConditionToShowObject -> geogebra.common.i.g.ed:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetCoords -> geogebra.common.i.g.ee:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetDynamicColor -> geogebra.common.i.g.ef:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetFilling -> geogebra.common.i.g.eg:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetFixed -> geogebra.common.i.g.eh:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetLabelMode -> geogebra.common.i.g.ei:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetLayer -> geogebra.common.i.g.ej:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetLineThickness -> geogebra.common.i.g.ek:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetPointSize -> geogebra.common.i.g.el:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetPointStyle -> geogebra.common.i.g.em:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetTooltipMode -> geogebra.common.i.g.en:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetTrace -> geogebra.common.i.g.eo:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetValue -> geogebra.common.i.g.ep:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSetVisibleInView -> geogebra.common.i.g.eq:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShear -> geogebra.common.i.g.er:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShortestDistance -> geogebra.common.i.g.es:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShowAxes -> geogebra.common.i.g.et:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShowGrid -> geogebra.common.i.g.eu:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShowLabel -> geogebra.common.i.g.ev:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShowLayer -> geogebra.common.i.g.ew:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdShuffle -> geogebra.common.i.g.ex:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSigmaXX -> geogebra.common.i.g.ey:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSigmaXY -> geogebra.common.i.g.ez:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSigmaYY -> geogebra.common.i.g.eA:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdSimplify -> geogebra.common.i.g.eB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSlider -> geogebra.common.i.g.eC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSlope -> geogebra.common.i.g.eD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSlowPlot -> geogebra.common.i.g.eE:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSolveODE -> geogebra.common.i.g.eF:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSort -> geogebra.common.i.g.eG:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSpearman -> geogebra.common.i.g.eH:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdStartAnimation -> geogebra.common.i.g.eI:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdStemPlot -> geogebra.common.i.g.eJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdStretch -> geogebra.common.i.g.eK:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSum -> geogebra.common.i.g.eL:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSumSquaredErrors -> geogebra.common.i.g.eM:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdSurdText -> geogebra.common.i.g.eN:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTDistribution -> geogebra.common.i.g.eO:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTMean2Estimate -> geogebra.common.i.g.eP:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTMeanEstimate -> geogebra.common.i.g.eQ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTTest -> geogebra.common.i.g.eR:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTTest2 -> geogebra.common.i.g.eS:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTTestPaired -> geogebra.common.i.g.eT:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTableText -> geogebra.common.i.g.eU:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTake -> geogebra.common.i.g.eV:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTangent -> geogebra.common.i.g.eW:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTaylorSeries -> geogebra.common.i.g.eX:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdText -> geogebra.common.i.g.eY:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTextToUnicode -> geogebra.common.i.g.eZ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTextfield -> geogebra.common.i.g.fa:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTiedRank -> geogebra.common.i.g.fb:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdToolImage -> geogebra.common.i.g.fc:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTranslate -> geogebra.common.i.g.fd:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTranspose -> geogebra.common.i.g.fe:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdTrapezoidalSum -> geogebra.common.i.g.ff:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTravelingSalesman -> geogebra.common.i.g.fg:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdTriangleCubic -> geogebra.common.i.g.fh:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTriangleCurve -> geogebra.common.i.g.fi:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement resArg(geogebra.common.kernel.arithmetic.Command,int) -> a
geogebra.common.kernel.commands.CmdTriangular -> geogebra.common.i.g.fj:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTrilinear -> geogebra.common.i.g.fk:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTurningPoint -> geogebra.common.i.g.fl:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdTwoNumFunction -> geogebra.common.i.g.fm:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.commands.CmdUnicodeToLetter -> geogebra.common.i.g.fn:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnicodeToText -> geogebra.common.i.g.fo:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUniform -> geogebra.common.i.g.fp:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnion -> geogebra.common.i.g.fq:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnique -> geogebra.common.i.g.fr:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnitOrthogonalVector -> geogebra.common.i.g.fs:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUnitVector -> geogebra.common.i.g.ft:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUpdateConstruction -> geogebra.common.i.g.fu:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdUpperSum -> geogebra.common.i.g.fv:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVariance -> geogebra.common.i.g.fw:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdVector -> geogebra.common.i.g.fx:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVertex -> geogebra.common.i.g.fy:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVerticalText -> geogebra.common.i.g.fz:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdVoronoi -> geogebra.common.i.g.fA:
    geogebra.common.kernel.geos.GeoElement doCommand(java.lang.String,geogebra.common.kernel.geos.GeoList) -> a
geogebra.common.kernel.commands.CmdWeibull -> geogebra.common.i.g.fB:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdZip -> geogebra.common.i.g.fC:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement resArgsForZip(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoList[]) -> a
geogebra.common.kernel.commands.CmdZipf -> geogebra.common.i.g.fD:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdZoomIn -> geogebra.common.i.g.fE:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CmdZoomOut -> geogebra.common.i.g.fF:
    void perform(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.CommandDispatcher -> geogebra.common.i.g.fG:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.main.AbstractApplication app -> a
    boolean isCasActive -> a
    java.util.HashMap cmdTable -> a
    java.util.HashMap casTable -> b
    java.util.HashMap internalCmdTable -> c
    geogebra.common.kernel.commands.MacroProcessor macroProc -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    java.lang.String getSubCommandSetName(int) -> a
    java.util.Set getPublicCommandSet() -> a
    boolean isCommandAvailable(java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] processCommand(geogebra.common.kernel.arithmetic.Command,boolean) -> a
    void initCmdTable() -> a
    void initCASCommands() -> b
    void fillInternalCmdTable() -> c
    geogebra.common.kernel.commands.CommandProcessor commandTableSwitch(java.lang.String) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra.common.kernel.commands.CommandProcessor -> geogebra.common.i.g.fH:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Kernel kernelA -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> a
    java.lang.StringBuilder sb -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] resArgs(geogebra.common.kernel.arithmetic.Command) -> b
    geogebra.common.kernel.geos.GeoElement[] resArg(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.geos.GeoElement[] resArgsLocalNumVar(geogebra.common.kernel.arithmetic.Command,int,int) -> a
    geogebra.common.kernel.geos.GeoElement[] resArgsLocalNumVar(geogebra.common.kernel.arithmetic.Command,int[],int[]) -> a
    geogebra.common.main.MyError argErr(geogebra.common.main.AbstractApplication,java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.main.MyError argNumErr(geogebra.common.main.AbstractApplication,java.lang.String,int) -> a
    void getCommandSyntax(java.lang.StringBuilder,geogebra.common.main.AbstractApplication,java.lang.String,int) -> a
    geogebra.common.kernel.geos.GeoElement getBadArg(boolean[],geogebra.common.kernel.geos.GeoElement[]) -> a
    geogebra.common.kernel.geos.GeoList wrapInList(geogebra.common.kernel.Kernel,geogebra.common.kernel.geos.GeoElement[],int,geogebra.common.plugin.GeoClass) -> a
    geogebra.common.kernel.geos.GeoList wrapFreehandFunctionArgInList(geogebra.common.kernel.Kernel,geogebra.common.kernel.algos.AlgoFunctionFreehand) -> a
geogebra.common.kernel.commands.Commands -> geogebra.common.i.g.fI:
    geogebra.common.kernel.commands.Commands Mod -> a
    geogebra.common.kernel.commands.Commands Div -> b
    geogebra.common.kernel.commands.Commands Min -> c
    geogebra.common.kernel.commands.Commands Max -> d
    geogebra.common.kernel.commands.Commands LCM -> e
    geogebra.common.kernel.commands.Commands GCD -> f
    geogebra.common.kernel.commands.Commands Expand -> g
    geogebra.common.kernel.commands.Commands Factor -> h
    geogebra.common.kernel.commands.Commands Simplify -> i
    geogebra.common.kernel.commands.Commands PrimeFactors -> j
    geogebra.common.kernel.commands.Commands CompleteSquare -> k
    geogebra.common.kernel.commands.Commands Line -> l
    geogebra.common.kernel.commands.Commands Ray -> m
    geogebra.common.kernel.commands.Commands AngularBisector -> n
    geogebra.common.kernel.commands.Commands OrthogonalLine -> o
    geogebra.common.kernel.commands.Commands Tangent -> p
    geogebra.common.kernel.commands.Commands Segment -> q
    geogebra.common.kernel.commands.Commands Slope -> r
    geogebra.common.kernel.commands.Commands Angle -> s
    geogebra.common.kernel.commands.Commands Direction -> t
    geogebra.common.kernel.commands.Commands Point -> u
    geogebra.common.kernel.commands.Commands Midpoint -> v
    geogebra.common.kernel.commands.Commands LineBisector -> w
    geogebra.common.kernel.commands.Commands Intersect -> x
    geogebra.common.kernel.commands.Commands IntersectRegion -> y
    geogebra.common.kernel.commands.Commands Distance -> z
    geogebra.common.kernel.commands.Commands Length -> A
    geogebra.common.kernel.commands.Commands Radius -> B
    geogebra.common.kernel.commands.Commands CircleArc -> C
    geogebra.common.kernel.commands.Commands Arc -> D
    geogebra.common.kernel.commands.Commands Sector -> E
    geogebra.common.kernel.commands.Commands CircleSector -> F
    geogebra.common.kernel.commands.Commands CircumcircleSector -> G
    geogebra.common.kernel.commands.Commands CircumcircleArc -> H
    geogebra.common.kernel.commands.Commands Polygon -> I
    geogebra.common.kernel.commands.Commands RigidPolygon -> J
    geogebra.common.kernel.commands.Commands Area -> K
    geogebra.common.kernel.commands.Commands Union -> L
    geogebra.common.kernel.commands.Commands Circumference -> M
    geogebra.common.kernel.commands.Commands Perimeter -> N
    geogebra.common.kernel.commands.Commands Locus -> O
    geogebra.common.kernel.commands.Commands Centroid -> P
    geogebra.common.kernel.commands.Commands TriangleCenter -> Q
    geogebra.common.kernel.commands.Commands Barycenter -> R
    geogebra.common.kernel.commands.Commands Trilinear -> S
    geogebra.common.kernel.commands.Commands TriangleCubic -> T
    geogebra.common.kernel.commands.Commands TriangleCurve -> U
    geogebra.common.kernel.commands.Commands Vertex -> V
    geogebra.common.kernel.commands.Commands PolyLine -> W
    geogebra.common.kernel.commands.Commands PointIn -> X
    geogebra.common.kernel.commands.Commands AffineRatio -> Y
    geogebra.common.kernel.commands.Commands CrossRatio -> Z
    geogebra.common.kernel.commands.Commands ClosestPoint -> aa
    geogebra.common.kernel.commands.Commands Prove -> ab
    geogebra.common.kernel.commands.Commands AreCollinear -> ac
    geogebra.common.kernel.commands.Commands AreParallel -> ad
    geogebra.common.kernel.commands.Commands AreConcyclic -> ae
    geogebra.common.kernel.commands.Commands Text -> af
    geogebra.common.kernel.commands.Commands LaTeX -> ag
    geogebra.common.kernel.commands.Commands LetterToUnicode -> ah
    geogebra.common.kernel.commands.Commands TextToUnicode -> ai
    geogebra.common.kernel.commands.Commands UnicodeToText -> aj
    geogebra.common.kernel.commands.Commands UnicodeToLetter -> ak
    geogebra.common.kernel.commands.Commands FractionText -> al
    geogebra.common.kernel.commands.Commands SurdText -> am
    geogebra.common.kernel.commands.Commands TableText -> an
    geogebra.common.kernel.commands.Commands VerticalText -> ao
    geogebra.common.kernel.commands.Commands RotateText -> ap
    geogebra.common.kernel.commands.Commands Ordinal -> aq
    geogebra.common.kernel.commands.Commands If -> ar
    geogebra.common.kernel.commands.Commands CountIf -> as
    geogebra.common.kernel.commands.Commands IsInteger -> at
    geogebra.common.kernel.commands.Commands KeepIf -> au
    geogebra.common.kernel.commands.Commands Relation -> av
    geogebra.common.kernel.commands.Commands Defined -> aw
    geogebra.common.kernel.commands.Commands IsInRegion -> ax
    geogebra.common.kernel.commands.Commands Root -> ay
    geogebra.common.kernel.commands.Commands Roots -> az
    geogebra.common.kernel.commands.Commands TurningPoint -> aA
    geogebra.common.kernel.commands.Commands Polynomial -> aB
    geogebra.common.kernel.commands.Commands Function -> aC
    geogebra.common.kernel.commands.Commands Extremum -> aD
    geogebra.common.kernel.commands.Commands CurveCartesian -> aE
    geogebra.common.kernel.commands.Commands Derivative -> aF
    geogebra.common.kernel.commands.Commands Integral -> aG
    geogebra.common.kernel.commands.Commands IntegralBetween -> aH
    geogebra.common.kernel.commands.Commands LowerSum -> aI
    geogebra.common.kernel.commands.Commands LeftSum -> aJ
    geogebra.common.kernel.commands.Commands RectangleSum -> aK
    geogebra.common.kernel.commands.Commands TaylorSeries -> aL
    geogebra.common.kernel.commands.Commands UpperSum -> aM
    geogebra.common.kernel.commands.Commands TrapezoidalSum -> aN
    geogebra.common.kernel.commands.Commands Limit -> aO
    geogebra.common.kernel.commands.Commands LimitBelow -> aP
    geogebra.common.kernel.commands.Commands LimitAbove -> aQ
    geogebra.common.kernel.commands.Commands Factors -> aR
    geogebra.common.kernel.commands.Commands Degree -> aS
    geogebra.common.kernel.commands.Commands Coefficients -> aT
    geogebra.common.kernel.commands.Commands PartialFractions -> aU
    geogebra.common.kernel.commands.Commands Numerator -> aV
    geogebra.common.kernel.commands.Commands Denominator -> aW
    geogebra.common.kernel.commands.Commands ComplexRoot -> aX
    geogebra.common.kernel.commands.Commands SolveODE -> aY
    geogebra.common.kernel.commands.Commands Iteration -> aZ
    geogebra.common.kernel.commands.Commands PathParameter -> ba
    geogebra.common.kernel.commands.Commands Asymptote -> bb
    geogebra.common.kernel.commands.Commands CurvatureVector -> bc
    geogebra.common.kernel.commands.Commands Curvature -> bd
    geogebra.common.kernel.commands.Commands OsculatingCircle -> be
    geogebra.common.kernel.commands.Commands IterationList -> bf
    geogebra.common.kernel.commands.Commands RootList -> bg
    geogebra.common.kernel.commands.Commands ImplicitCurve -> bh
    geogebra.common.kernel.commands.Commands Ellipse -> bi
    geogebra.common.kernel.commands.Commands Hyperbola -> bj
    geogebra.common.kernel.commands.Commands SecondAxisLength -> bk
    geogebra.common.kernel.commands.Commands SecondAxis -> bl
    geogebra.common.kernel.commands.Commands Directrix -> bm
    geogebra.common.kernel.commands.Commands Diameter -> bn
    geogebra.common.kernel.commands.Commands Conic -> bo
    geogebra.common.kernel.commands.Commands FirstAxis -> bp
    geogebra.common.kernel.commands.Commands Circle -> bq
    geogebra.common.kernel.commands.Commands Incircle -> br
    geogebra.common.kernel.commands.Commands Semicircle -> bs
    geogebra.common.kernel.commands.Commands FirstAxisLength -> bt
    geogebra.common.kernel.commands.Commands Parabola -> bu
    geogebra.common.kernel.commands.Commands Focus -> bv
    geogebra.common.kernel.commands.Commands Parameter -> bw
    geogebra.common.kernel.commands.Commands Center -> bx
    geogebra.common.kernel.commands.Commands Polar -> by
    geogebra.common.kernel.commands.Commands Excentricity -> bz
    geogebra.common.kernel.commands.Commands Eccentricity -> bA
    geogebra.common.kernel.commands.Commands Axes -> bB
    geogebra.common.kernel.commands.Commands Sort -> bC
    geogebra.common.kernel.commands.Commands First -> bD
    geogebra.common.kernel.commands.Commands Last -> bE
    geogebra.common.kernel.commands.Commands Take -> bF
    geogebra.common.kernel.commands.Commands RemoveUndefined -> bG
    geogebra.common.kernel.commands.Commands Reverse -> bH
    geogebra.common.kernel.commands.Commands Element -> bI
    geogebra.common.kernel.commands.Commands IndexOf -> bJ
    geogebra.common.kernel.commands.Commands Append -> bK
    geogebra.common.kernel.commands.Commands Join -> bL
    geogebra.common.kernel.commands.Commands Flatten -> bM
    geogebra.common.kernel.commands.Commands Insert -> bN
    geogebra.common.kernel.commands.Commands Sequence -> bO
    geogebra.common.kernel.commands.Commands SelectedElement -> bP
    geogebra.common.kernel.commands.Commands SelectedIndex -> bQ
    geogebra.common.kernel.commands.Commands RandomElement -> bR
    geogebra.common.kernel.commands.Commands Product -> bS
    geogebra.common.kernel.commands.Commands Frequency -> bT
    geogebra.common.kernel.commands.Commands Unique -> bU
    geogebra.common.kernel.commands.Commands Classes -> bV
    geogebra.common.kernel.commands.Commands Zip -> bW
    geogebra.common.kernel.commands.Commands Intersection -> bX
    geogebra.common.kernel.commands.Commands PointList -> bY
    geogebra.common.kernel.commands.Commands OrdinalRank -> bZ
    geogebra.common.kernel.commands.Commands TiedRank -> ca
    geogebra.common.kernel.commands.Commands BarChart -> cb
    geogebra.common.kernel.commands.Commands BoxPlot -> cc
    geogebra.common.kernel.commands.Commands Histogram -> cd
    geogebra.common.kernel.commands.Commands HistogramRight -> ce
    geogebra.common.kernel.commands.Commands DotPlot -> cf
    geogebra.common.kernel.commands.Commands StemPlot -> cg
    geogebra.common.kernel.commands.Commands ResidualPlot -> ch
    geogebra.common.kernel.commands.Commands FrequencyPolygon -> ci
    geogebra.common.kernel.commands.Commands NormalQuantilePlot -> cj
    geogebra.common.kernel.commands.Commands FrequencyTable -> ck
    geogebra.common.kernel.commands.Commands Sum -> cl
    geogebra.common.kernel.commands.Commands Mean -> cm
    geogebra.common.kernel.commands.Commands Variance -> cn
    geogebra.common.kernel.commands.Commands SD -> co
    geogebra.common.kernel.commands.Commands SampleVariance -> cp
    geogebra.common.kernel.commands.Commands SampleSD -> cq
    geogebra.common.kernel.commands.Commands Median -> cr
    geogebra.common.kernel.commands.Commands Q1 -> cs
    geogebra.common.kernel.commands.Commands Q3 -> ct
    geogebra.common.kernel.commands.Commands Mode -> cu
    geogebra.common.kernel.commands.Commands SigmaXX -> cv
    geogebra.common.kernel.commands.Commands SigmaXY -> cw
    geogebra.common.kernel.commands.Commands SigmaYY -> cx
    geogebra.common.kernel.commands.Commands Covariance -> cy
    geogebra.common.kernel.commands.Commands SXY -> cz
    geogebra.common.kernel.commands.Commands SXX -> cA
    geogebra.common.kernel.commands.Commands SYY -> cB
    geogebra.common.kernel.commands.Commands MeanX -> cC
    geogebra.common.kernel.commands.Commands MeanY -> cD
    geogebra.common.kernel.commands.Commands PMCC -> cE
    geogebra.common.kernel.commands.Commands SampleSDX -> cF
    geogebra.common.kernel.commands.Commands SampleSDY -> cG
    geogebra.common.kernel.commands.Commands SDX -> cH
    geogebra.common.kernel.commands.Commands SDY -> cI
    geogebra.common.kernel.commands.Commands FitLineY -> cJ
    geogebra.common.kernel.commands.Commands FitLineX -> cK
    geogebra.common.kernel.commands.Commands FitPoly -> cL
    geogebra.common.kernel.commands.Commands FitExp -> cM
    geogebra.common.kernel.commands.Commands FitLog -> cN
    geogebra.common.kernel.commands.Commands FitPow -> cO
    geogebra.common.kernel.commands.Commands Fit -> cP
    geogebra.common.kernel.commands.Commands FitGrowth -> cQ
    geogebra.common.kernel.commands.Commands FitSin -> cR
    geogebra.common.kernel.commands.Commands FitLogistic -> cS
    geogebra.common.kernel.commands.Commands SumSquaredErrors -> cT
    geogebra.common.kernel.commands.Commands RSquare -> cU
    geogebra.common.kernel.commands.Commands Sample -> cV
    geogebra.common.kernel.commands.Commands Shuffle -> cW
    geogebra.common.kernel.commands.Commands Spearman -> cX
    geogebra.common.kernel.commands.Commands TTest -> cY
    geogebra.common.kernel.commands.Commands TTestPaired -> cZ
    geogebra.common.kernel.commands.Commands TTest2 -> da
    geogebra.common.kernel.commands.Commands TMeanEstimate -> db
    geogebra.common.kernel.commands.Commands TMean2Estimate -> dc
    geogebra.common.kernel.commands.Commands ANOVA -> dd
    geogebra.common.kernel.commands.Commands Percentile -> de
    geogebra.common.kernel.commands.Commands GeometricMean -> df
    geogebra.common.kernel.commands.Commands HarmonicMean -> dg
    geogebra.common.kernel.commands.Commands RootMeanSquare -> dh
    geogebra.common.kernel.commands.Commands Random -> di
    geogebra.common.kernel.commands.Commands RandomNormal -> dj
    geogebra.common.kernel.commands.Commands RandomUniform -> dk
    geogebra.common.kernel.commands.Commands RandomBinomial -> dl
    geogebra.common.kernel.commands.Commands RandomPoisson -> dm
    geogebra.common.kernel.commands.Commands Normal -> dn
    geogebra.common.kernel.commands.Commands LogNormal -> do
    geogebra.common.kernel.commands.Commands Logistic -> dp
    geogebra.common.kernel.commands.Commands InverseNormal -> dq
    geogebra.common.kernel.commands.Commands Binomial -> dr
    geogebra.common.kernel.commands.Commands BinomialDist -> ds
    geogebra.common.kernel.commands.Commands Bernoulli -> dt
    geogebra.common.kernel.commands.Commands InverseBinomial -> du
    geogebra.common.kernel.commands.Commands TDistribution -> dv
    geogebra.common.kernel.commands.Commands InverseTDistribution -> dw
    geogebra.common.kernel.commands.Commands FDistribution -> dx
    geogebra.common.kernel.commands.Commands InverseFDistribution -> dy
    geogebra.common.kernel.commands.Commands Gamma -> dz
    geogebra.common.kernel.commands.Commands InverseGamma -> dA
    geogebra.common.kernel.commands.Commands Cauchy -> dB
    geogebra.common.kernel.commands.Commands InverseCauchy -> dC
    geogebra.common.kernel.commands.Commands ChiSquared -> dD
    geogebra.common.kernel.commands.Commands InverseChiSquared -> dE
    geogebra.common.kernel.commands.Commands Exponential -> dF
    geogebra.common.kernel.commands.Commands InverseExponential -> dG
    geogebra.common.kernel.commands.Commands HyperGeometric -> dH
    geogebra.common.kernel.commands.Commands InverseHyperGeometric -> dI
    geogebra.common.kernel.commands.Commands Pascal -> dJ
    geogebra.common.kernel.commands.Commands InversePascal -> dK
    geogebra.common.kernel.commands.Commands Poisson -> dL
    geogebra.common.kernel.commands.Commands InversePoisson -> dM
    geogebra.common.kernel.commands.Commands Weibull -> dN
    geogebra.common.kernel.commands.Commands InverseWeibull -> dO
    geogebra.common.kernel.commands.Commands Zipf -> dP
    geogebra.common.kernel.commands.Commands InverseZipf -> dQ
    geogebra.common.kernel.commands.Commands Triangular -> dR
    geogebra.common.kernel.commands.Commands Uniform -> dS
    geogebra.common.kernel.commands.Commands Erlang -> dT
    geogebra.common.kernel.commands.Commands ApplyMatrix -> dU
    geogebra.common.kernel.commands.Commands UnitVector -> dV
    geogebra.common.kernel.commands.Commands Vector -> dW
    geogebra.common.kernel.commands.Commands UnitOrthogonalVector -> dX
    geogebra.common.kernel.commands.Commands OrthogonalVector -> dY
    geogebra.common.kernel.commands.Commands Invert -> dZ
    geogebra.common.kernel.commands.Commands Transpose -> ea
    geogebra.common.kernel.commands.Commands ReducedRowEchelonForm -> eb
    geogebra.common.kernel.commands.Commands Determinant -> ec
    geogebra.common.kernel.commands.Commands Identity -> ed
    geogebra.common.kernel.commands.Commands Mirror -> ee
    geogebra.common.kernel.commands.Commands Dilate -> ef
    geogebra.common.kernel.commands.Commands Rotate -> eg
    geogebra.common.kernel.commands.Commands Translate -> eh
    geogebra.common.kernel.commands.Commands Shear -> ei
    geogebra.common.kernel.commands.Commands Stretch -> ej
    geogebra.common.kernel.commands.Commands CellRange -> ek
    geogebra.common.kernel.commands.Commands Row -> el
    geogebra.common.kernel.commands.Commands Column -> em
    geogebra.common.kernel.commands.Commands ColumnName -> en
    geogebra.common.kernel.commands.Commands FillRow -> eo
    geogebra.common.kernel.commands.Commands FillColumn -> ep
    geogebra.common.kernel.commands.Commands FillCells -> eq
    geogebra.common.kernel.commands.Commands Cell -> er
    geogebra.common.kernel.commands.Commands CopyFreeObject -> es
    geogebra.common.kernel.commands.Commands SetColor -> et
    geogebra.common.kernel.commands.Commands SetBackgroundColor -> eu
    geogebra.common.kernel.commands.Commands SetDynamicColor -> ev
    geogebra.common.kernel.commands.Commands SetConditionToShowObject -> ew
    geogebra.common.kernel.commands.Commands SetFilling -> ex
    geogebra.common.kernel.commands.Commands SetLineThickness -> ey
    geogebra.common.kernel.commands.Commands SetLineStyle -> ez
    geogebra.common.kernel.commands.Commands SetPointStyle -> eA
    geogebra.common.kernel.commands.Commands SetPointSize -> eB
    geogebra.common.kernel.commands.Commands SetFixed -> eC
    geogebra.common.kernel.commands.Commands SetTrace -> eD
    geogebra.common.kernel.commands.Commands Rename -> eE
    geogebra.common.kernel.commands.Commands HideLayer -> eF
    geogebra.common.kernel.commands.Commands ShowLayer -> eG
    geogebra.common.kernel.commands.Commands SetCoords -> eH
    geogebra.common.kernel.commands.Commands Pan -> eI
    geogebra.common.kernel.commands.Commands ZoomIn -> eJ
    geogebra.common.kernel.commands.Commands ZoomOut -> eK
    geogebra.common.kernel.commands.Commands SetActiveView -> eL
    geogebra.common.kernel.commands.Commands SelectObjects -> eM
    geogebra.common.kernel.commands.Commands SetLayer -> eN
    geogebra.common.kernel.commands.Commands SetCaption -> eO
    geogebra.common.kernel.commands.Commands SetLabelMode -> eP
    geogebra.common.kernel.commands.Commands SetTooltipMode -> eQ
    geogebra.common.kernel.commands.Commands UpdateConstruction -> eR
    geogebra.common.kernel.commands.Commands SetValue -> eS
    geogebra.common.kernel.commands.Commands PlaySound -> eT
    geogebra.common.kernel.commands.Commands ParseToNumber -> eU
    geogebra.common.kernel.commands.Commands ParseToFunction -> eV
    geogebra.common.kernel.commands.Commands StartAnimation -> eW
    geogebra.common.kernel.commands.Commands Delete -> eX
    geogebra.common.kernel.commands.Commands Slider -> eY
    geogebra.common.kernel.commands.Commands Checkbox -> eZ
    geogebra.common.kernel.commands.Commands Textfield -> fa
    geogebra.common.kernel.commands.Commands Button -> fb
    geogebra.common.kernel.commands.Commands Execute -> fc
    geogebra.common.kernel.commands.Commands GetTime -> fd
    geogebra.common.kernel.commands.Commands ShowLabel -> fe
    geogebra.common.kernel.commands.Commands SetAxesRatio -> ff
    geogebra.common.kernel.commands.Commands SetVisibleInView -> fg
    geogebra.common.kernel.commands.Commands ShowAxes -> fh
    geogebra.common.kernel.commands.Commands ShowGrid -> fi
    geogebra.common.kernel.commands.Commands Voronoi -> fj
    geogebra.common.kernel.commands.Commands Hull -> fk
    geogebra.common.kernel.commands.Commands ConvexHull -> fl
    geogebra.common.kernel.commands.Commands MinimumSpanningTree -> fm
    geogebra.common.kernel.commands.Commands DelauneyTriangulation -> fn
    geogebra.common.kernel.commands.Commands TravelingSalesman -> fo
    geogebra.common.kernel.commands.Commands ShortestDistance -> fp
    geogebra.common.kernel.commands.Commands Corner -> fq
    geogebra.common.kernel.commands.Commands AxisStepX -> fr
    geogebra.common.kernel.commands.Commands AxisStepY -> fs
    geogebra.common.kernel.commands.Commands ConstructionStep -> ft
    geogebra.common.kernel.commands.Commands Object -> fu
    geogebra.common.kernel.commands.Commands Name -> fv
    geogebra.common.kernel.commands.Commands SlowPlot -> fw
    geogebra.common.kernel.commands.Commands ToolImage -> fx
    geogebra.common.kernel.commands.Commands BarCode -> fy
    geogebra.common.kernel.commands.Commands DynamicCoordinates -> fz
    geogebra.common.kernel.commands.Commands Maximize -> fA
    geogebra.common.kernel.commands.Commands Minimize -> fB
    geogebra.common.kernel.commands.Commands Curve -> fC
    geogebra.common.kernel.commands.Commands FormulaText -> fD
    geogebra.common.kernel.commands.Commands IsDefined -> fE
    geogebra.common.kernel.commands.Commands ConjugateDiameter -> fF
    geogebra.common.kernel.commands.Commands LinearEccentricity -> fG
    geogebra.common.kernel.commands.Commands MajorAxis -> fH
    geogebra.common.kernel.commands.Commands SemiMajorAxisLength -> fI
    geogebra.common.kernel.commands.Commands PerpendicularBisector -> fJ
    geogebra.common.kernel.commands.Commands PerpendicularLine -> fK
    geogebra.common.kernel.commands.Commands PerpendicularVector -> fL
    geogebra.common.kernel.commands.Commands MinorAxis -> fM
    geogebra.common.kernel.commands.Commands SemiMinorAxisLength -> fN
    geogebra.common.kernel.commands.Commands UnitPerpendicularVector -> fO
    geogebra.common.kernel.commands.Commands CorrelationCoefficient -> fP
    geogebra.common.kernel.commands.Commands FitLine -> fQ
    geogebra.common.kernel.commands.Commands BinomialCoefficient -> fR
    geogebra.common.kernel.commands.Commands RandomBetween -> fS
    geogebra.common.kernel.commands.Commands Bottom -> fT
    geogebra.common.kernel.commands.Commands Cone -> fU
    geogebra.common.kernel.commands.Commands Cube -> fV
    geogebra.common.kernel.commands.Commands Cylinder -> fW
    geogebra.common.kernel.commands.Commands Dodecahedron -> fX
    geogebra.common.kernel.commands.Commands Ends -> fY
    geogebra.common.kernel.commands.Commands Icosahedron -> fZ
    geogebra.common.kernel.commands.Commands InfiniteCone -> ga
    geogebra.common.kernel.commands.Commands InfiniteCylinder -> gb
    geogebra.common.kernel.commands.Commands Octahedron -> gc
    geogebra.common.kernel.commands.Commands Plane -> gd
    geogebra.common.kernel.commands.Commands QuadricSide -> ge
    geogebra.common.kernel.commands.Commands SurfaceCartesian -> gf
    geogebra.common.kernel.commands.Commands Tetrahedron -> gg
    geogebra.common.kernel.commands.Commands Top -> gh
    geogebra.common.kernel.commands.Commands CylinderInfinite -> gi
    geogebra.common.kernel.commands.Commands Sphere -> gj
    geogebra.common.kernel.commands.Commands OrthogonalPlane -> gk
    geogebra.common.kernel.commands.Commands PerpendicularPlane -> gl
    geogebra.common.kernel.commands.Commands Prism -> gm
    geogebra.common.kernel.commands.Commands Pyramid -> gn
    geogebra.common.kernel.commands.Commands PlaneBisector -> go
    geogebra.common.kernel.commands.Commands IntersectionPaths -> gp
    geogebra.common.kernel.commands.Commands ConeInfinite -> gq
    int table -> a
    geogebra.common.kernel.commands.Commands[] ENUM$VALUES -> a
    int getTable() -> a
    geogebra.common.kernel.commands.Commands[] values() -> values
    geogebra.common.kernel.commands.Commands valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.commands.MacroProcessor -> geogebra.common.i.g.fJ:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra.common.kernel.commands.MyException -> geogebra.common.i.g.fK:
    int errorType -> a
    int getErrorType() -> a
geogebra.common.kernel.discrete.AlgoConvexHull -> geogebra.common.i.h.a:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.discrete.AlgoDelauneyTriangulation -> geogebra.common.i.h.b:
    java.util.Comparator lineComparator -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    java.util.Comparator getComparator() -> a
geogebra.common.kernel.discrete.AlgoDelauneyTriangulation$1 -> geogebra.common.i.h.c:
    int compare(geogebra.common.kernel.discrete.MyLine,geogebra.common.kernel.discrete.MyLine) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.AlgoHull -> geogebra.common.i.h.d:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric percentage -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    java.util.ArrayList vl -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoNumeric access$0(geogebra.common.kernel.discrete.AlgoHull) -> a
geogebra.common.kernel.discrete.AlgoHull$1 -> geogebra.common.i.h.e:
    geogebra.common.kernel.discrete.AlgoHull this$0 -> a
    int calculateCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation) -> a
geogebra.common.kernel.discrete.AlgoHull$TestRepresentationWrapper -> geogebra.common.i.h.d$a:
    java.util.ArrayList circleevents -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface innerrepresentation -> a
    geogebra.common.kernel.discrete.AlgoHull this$0 -> a
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
geogebra.common.kernel.discrete.AlgoMinimumSpanningTree -> geogebra.common.i.h.f:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoShortestDistance -> geogebra.common.i.h.g:
    geogebra.common.kernel.kernelND.GeoPointND start -> a
    geogebra.common.kernel.kernelND.GeoPointND end -> b
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    geogebra.common.kernel.geos.GeoBoolean weighted -> a
    java.util.ArrayList al -> a
    int edgeCount -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoShortestDistance$1 -> geogebra.common.i.h.h:
    geogebra.common.kernel.discrete.AlgoShortestDistance this$0 -> a
geogebra.common.kernel.discrete.AlgoShortestDistance$MyLink -> geogebra.common.i.h.g$a:
    geogebra.common.kernel.discrete.MyNode n1 -> a
    geogebra.common.kernel.discrete.MyNode n2 -> b
    double capacity -> a
    double weight -> b
    int id -> a
    geogebra.common.kernel.discrete.AlgoShortestDistance this$0 -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.AlgoTravelingSalesman -> geogebra.common.i.h.i:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.discrete.AlgoVoronoi -> geogebra.common.i.h.j:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.ArrayList al -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLocus getResult() -> a
    void compute() -> b
geogebra.common.kernel.discrete.MyLine -> geogebra.common.i.h.k:
    geogebra.common.awt.Point2D p1 -> a
    geogebra.common.awt.Point2D p2 -> b
    double lengthSquared() -> a
geogebra.common.kernel.discrete.MyNode -> geogebra.common.i.h.l:
    geogebra.common.kernel.kernelND.GeoPointND id -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.delauney.ArraySet -> geogebra.common.i.h.a.a:
    java.util.ArrayList items -> a
    boolean add(java.lang.Object) -> add
    java.util.Iterator iterator() -> iterator
    int size() -> size
geogebra.common.kernel.discrete.delauney.Graph -> geogebra.common.i.h.a.b:
    java.util.Map theNeighbors -> a
    java.util.Set theNodeSet -> a
    void add(java.lang.Object) -> a
    void add(java.lang.Object,java.lang.Object) -> a
    void remove(java.lang.Object) -> b
    java.util.Set neighbors(java.lang.Object) -> a
    java.util.Set nodeSet() -> a
geogebra.common.kernel.discrete.delauney.Pnt -> geogebra.common.i.h.a.c:
    double[] coordinates -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    double coord(int) -> a
    int dimension() -> a
    int dimCheck(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    geogebra.common.kernel.discrete.delauney.Pnt extend(double[]) -> a
    double dot(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    geogebra.common.kernel.discrete.delauney.Pnt subtract(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    geogebra.common.kernel.discrete.delauney.Pnt add(geogebra.common.kernel.discrete.delauney.Pnt) -> b
    geogebra.common.kernel.discrete.delauney.Pnt bisector(geogebra.common.kernel.discrete.delauney.Pnt) -> c
    double determinant(geogebra.common.kernel.discrete.delauney.Pnt[]) -> a
    double determinant(geogebra.common.kernel.discrete.delauney.Pnt[],int,boolean[]) -> a
    geogebra.common.kernel.discrete.delauney.Pnt cross(geogebra.common.kernel.discrete.delauney.Pnt[]) -> a
    double content(geogebra.common.kernel.discrete.delauney.Pnt[]) -> b
    int[] relation(geogebra.common.kernel.discrete.delauney.Pnt[]) -> a
    geogebra.common.kernel.discrete.delauney.Pnt isOutside(geogebra.common.kernel.discrete.delauney.Pnt[]) -> b
    int vsCircumcircle(geogebra.common.kernel.discrete.delauney.Pnt[]) -> a
    geogebra.common.kernel.discrete.delauney.Pnt circumcenter(geogebra.common.kernel.discrete.delauney.Pnt[]) -> c
geogebra.common.kernel.discrete.delauney.Triangle -> geogebra.common.i.h.a.d:
    int idNumber -> a
    geogebra.common.kernel.discrete.delauney.Pnt circumcenter -> a
    int idGenerator -> b
    boolean moreInfo -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.discrete.delauney.Pnt getVertexButNot(geogebra.common.kernel.discrete.delauney.Pnt[]) -> a
    boolean isNeighbor(geogebra.common.kernel.discrete.delauney.Triangle) -> a
    geogebra.common.kernel.discrete.delauney.ArraySet facetOpposite(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    geogebra.common.kernel.discrete.delauney.Pnt getCircumcenter() -> a
    boolean add(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    java.util.Iterator iterator() -> iterator
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    boolean add(java.lang.Object) -> add
    java.util.Iterator access$1(geogebra.common.kernel.discrete.delauney.Triangle) -> a
geogebra.common.kernel.discrete.delauney.Triangle$1 -> geogebra.common.i.h.a.e:
    java.util.Iterator it -> a
    geogebra.common.kernel.discrete.delauney.Triangle this$0 -> a
    boolean hasNext() -> hasNext
    geogebra.common.kernel.discrete.delauney.Pnt next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
geogebra.common.kernel.discrete.delauney.Triangulation -> geogebra.common.i.h.a.f:
    geogebra.common.kernel.discrete.delauney.Triangle mostRecent -> a
    geogebra.common.kernel.discrete.delauney.Graph triGraph -> a
    java.util.Iterator iterator() -> iterator
    int size() -> size
    java.lang.String toString() -> toString
    boolean contains(java.lang.Object) -> contains
    geogebra.common.kernel.discrete.delauney.Triangle neighborOpposite(geogebra.common.kernel.discrete.delauney.Pnt,geogebra.common.kernel.discrete.delauney.Triangle) -> a
    java.util.Set neighbors(geogebra.common.kernel.discrete.delauney.Triangle) -> a
    java.util.List surroundingTriangles(geogebra.common.kernel.discrete.delauney.Pnt,geogebra.common.kernel.discrete.delauney.Triangle) -> a
    geogebra.common.kernel.discrete.delauney.Triangle locate(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    void delaunayPlace(geogebra.common.kernel.discrete.delauney.Pnt) -> a
    java.util.Set getCavity(geogebra.common.kernel.discrete.delauney.Pnt,geogebra.common.kernel.discrete.delauney.Triangle) -> a
    geogebra.common.kernel.discrete.delauney.Triangle update(geogebra.common.kernel.discrete.delauney.Pnt,java.util.Set) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint -> geogebra.common.i.h.b.a.a:
    double x -> a
    double y -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.VoronoiAlgorithm -> geogebra.common.i.h.b.a.b:
    void generateVoronoi(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface,java.util.Collection) -> a
    void generateVoronoi(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface,java.util.Collection,java.lang.Object,geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint,int) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.VoronoiShared -> geogebra.common.i.h.b.a.c:
    double[] solveQuadratic(double,double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent calculateCenter(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue -> geogebra.common.i.h.b.a.a.a:
    java.util.Comparator PRIORITY_COMPARATOR -> a
    java.util.TreeMap queue -> a
    void addEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    boolean removeEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent getFirstEvent() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent getAndRemoveFirstEvent() -> b
    boolean isEventQueueEmpty() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue$1 -> geogebra.common.i.h.b.a.a.b:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent -> geogebra.common.i.h.b.a.a.c:
    int x -> c
    int y -> d
    int center_y -> e
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode leafnode -> a
    double getX() -> a
    void setX(int) -> a
    double getY() -> b
    void setY(int) -> b
    int getCenterY() -> a
    void setCenterY(int) -> c
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VEvent -> geogebra.common.i.h.b.a.a.d:
    int uniqueid -> a
    int id -> b
    double getX() -> a
    double getY() -> b
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String getID() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent -> geogebra.common.i.h.b.a.a.e:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint point -> a
    double a -> a
    double b -> b
    double c -> c
    void calcParabolaConstants(double) -> a
    double getX() -> a
    double getY() -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint getPoint() -> a
    boolean isSiteEvent() -> a
    boolean isCircleEvent() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.AbstractRepresentation -> geogebra.common.i.h.b.a.b.a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint createPoint(double,double) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationFactory -> geogebra.common.i.h.b.a.b.b:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.AbstractRepresentation createTriangulationRepresentation() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.AbstractRepresentation createSimpleTriangulationRepresentation() -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.RepresentationInterface -> geogebra.common.i.h.b.a.b.c:
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.simpletriangulation.SimpleTriangulationRepresentation -> geogebra.common.i.h.b.a.b.a.a:
    java.util.ArrayList triangles -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint createPoint(double,double) -> a
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.simpletriangulation.VTriangle -> geogebra.common.i.h.b.a.b.a.b:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint p1 -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint p2 -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint p3 -> c
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval -> geogebra.common.i.h.b.a.b.b.a:
    java.util.Comparator EDGELENGTH_COMPARATOR -> a
    void removeEdgesInOrderFromOuterBoundary(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,int) -> a
    void removeSingleOuterEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$OrderedEdgeList) -> a
    java.util.Comparator access$0() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$1 -> geogebra.common.i.h.b.a.b.b.b:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedEdgeRemoval$OrderedEdgeList -> geogebra.common.i.h.b.a.b.b.a$a:
    void addOuterEdges(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    void addEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree -> geogebra.common.i.h.b.a.b.b.c:
    java.util.Comparator VERTEX_COMPARATOR -> a
    java.util.Comparator PATH_COMPARATOR -> b
    int determineMSTUsingPrimsAlgorithm(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    int determineMSTUsingPrimsAlgorithm(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex,double,java.util.ArrayList) -> a
    int determineClusterCutOffByGradient(java.util.TreeMap,int) -> a
    java.util.Comparator access$0() -> a
    java.util.Comparator access$1() -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$1 -> geogebra.common.i.h.b.a.b.b.d:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$2 -> geogebra.common.i.h.b.a.b.b.e:
    int compare(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge,geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$FuturePathList -> geogebra.common.i.h.b.a.b.b.c$a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge popBestNextPath() -> a
    void addPath(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$VertexList -> geogebra.common.i.h.b.a.b.b.c$b:
    boolean hasVertexBeenConsidered(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    void addVertex(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation -> geogebra.common.i.h.b.a.b.b.f:
    boolean SHOW_INTERNAL_TRIANGLES -> a
    boolean SHOW_EDGE_LENGTHS -> b
    boolean SHOW_DEBUG_INFO -> c
    int MAX_EDGES_TO_REMOVE -> a
    int MODE_REDUCE_OUTER_BOUNDARIES -> b
    int MODE_GETSTATS_EXCLUDINGMSTSTATS -> c
    int MODE_DETERMINE_MINSPANNINGTREE -> d
    int MODE_DETERMINE_CLUSTERS -> e
    int mode -> f
    int vertexnumber -> g
    java.util.Collection vertexpoints -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff calccutoff -> a
    int length_cutoff -> h
    double gradient_diff_before_cluster_cutoff -> a
    java.util.ArrayList clusters -> a
    boolean update_statistics -> d
    int max_length -> i
    int min_length -> j
    int max_length_of_smallesttriangleedge -> k
    int max_length_from_minimumspanningtree -> l
    void setReduceOuterBoundariesMode() -> a
    void setDetermineMinSpanningTreeMode() -> b
    int calculateLengthCutoff() -> a
    void setCalcCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff) -> a
    int getMaxLength() -> b
    int getMinLength() -> c
    geogebra.common.kernel.discrete.signalprocessor.voronoi.VPoint createPoint(double,double) -> a
    void beginAlgorithm(java.util.Collection) -> a
    void siteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    void circleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,int,int) -> a
    void endAlgorithm(java.util.Collection,double,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge createOuterEdge() -> b
    java.util.ArrayList getPointsFormingOutterBoundary() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge findOuterEdge() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation$CalcCutOff -> geogebra.common.i.h.b.a.b.b.f$a:
    int calculateCutOff(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.TriangulationRepresentation) -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VCluster -> geogebra.common.i.h.b.a.b.b.g:
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge -> geogebra.common.i.h.b.a.b.b.h:
    int vertexnumber -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge next -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex vertex -> a
    int length -> b
    boolean shownonminimumspanningtree -> a
    boolean isOuterEdge() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex getConnectedVertex() -> a
    int getLength() -> a
    double getX() -> a
    double getY() -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex -> geogebra.common.i.h.b.a.b.b.i:
    int uniqueid -> a
    int id -> b
    java.util.ArrayList edges -> a
    boolean hasEdges() -> a
    void clearEdges() -> a
    void addEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    java.util.ArrayList getEdges() -> a
    boolean removeEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge) -> a
    double distanceTo(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge getEdge(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge getEdge(int) -> a
    boolean isConnectedTo(geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex) -> a
    java.lang.String toString() -> toString
    java.lang.String getConnectedVertexString() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.AbstractStatusStructure -> geogebra.common.i.h.b.a.c.a:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.AbstractStatusStructure createDefaultStatusStructure() -> a
    boolean isStatusStructureEmpty() -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode insertNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void removeNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getHeadNode() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode -> geogebra.common.i.h.b.a.c.b:
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent siteevent -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode prev -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode next -> b
    java.util.ArrayList circleevents -> a
    void removeCircleEvents(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue) -> a
    void addCircleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue) -> b
    void addCircleEvent(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VCircleEvent) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getPrev() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNext() -> b
    void setNext(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    boolean isLeafNode() -> a
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.BSTStatusStructure -> geogebra.common.i.h.b.a.c.a.a:
    int uniqueid -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode rootnode -> a
    boolean isStatusStructureEmpty() -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void setRootNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode insertNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    void removeNode(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.EventQueue,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getSuccessor(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getPredecessor(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getNodeAboveSiteEvent(double,double) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.VLinkedNode getHeadNode() -> a
    java.lang.String toString() -> toString
    java.lang.String strDoublyLinkedList(int) -> a
    java.lang.String strTreeStructure(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode,int) -> a
    java.lang.String printGap(int) -> b
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode -> geogebra.common.i.h.b.a.c.a.b:
    int id -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode parent -> a
    int depth -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode left -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode right -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent v1 -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent v2 -> b
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getParent() -> a
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode getLeft() -> a
    void setLeft(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode getRight() -> b
    void setRight(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode) -> b
    void setDepthForRootNode() -> a
    void correctDepthValues(int,geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    void setSiteEvents(geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent,geogebra.common.kernel.discrete.signalprocessor.voronoi.eventqueue.VSiteEvent) -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VLeafNode -> geogebra.common.i.h.b.a.c.a.c:
    int id -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode parent -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode getParent() -> a
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
    geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VLeafNode cloneLeafNode() -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VNode -> geogebra.common.i.h.b.a.c.a.d:
    void setParent(geogebra.common.kernel.discrete.signalprocessor.voronoi.statusstructure.binarysearchtreeimpl.VInternalNode) -> a
    boolean isLeafNode() -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound -> geogebra.common.i.h.c.a.a.a:
    int limit -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.TspImprovement opt -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Circuit branch(java.lang.Object,double[][],double[],boolean[][],boolean[][],boolean[][],double,int,double) -> a
    int[] compressTableToArray(boolean[][]) -> a
    void copy(boolean[][],boolean[][]) -> a
    double[][] createTable(geogebra.common.kernel.discrete.tsp.model.Node[]) -> a
    double getCost(int[],double[][]) -> a
    double getLowerCost(double[][],double[],boolean[][]) -> a
    void getOneTree(boolean[][],double[][],double[],boolean[][],boolean[][]) -> a
    boolean hasCircuitPossibility(boolean[][],boolean[][]) -> a
    int[] method(geogebra.common.kernel.discrete.tsp.model.Node[]) -> a
    java.lang.String toString() -> toString
    void updateConstraint(boolean[][],boolean[][]) -> b
    boolean updateMulipliers(double,boolean[][],double[]) -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Circuit -> geogebra.common.i.h.c.a.a.a$a:
    double cost -> a
    int[] route -> a
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound this$0 -> a
    double getCost() -> a
    int[] getRoute() -> a
geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Entry -> geogebra.common.i.h.c.a.a.a$b:
    double cost -> a
    int s -> a
    int t -> b
    geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound this$0 -> a
    int compareTo(geogebra.common.kernel.discrete.tsp.method.tsp.BranchBound$Entry) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.discrete.tsp.method.tsp.Opt3 -> geogebra.common.i.h.c.a.a.b:
    boolean method(int[],double[][]) -> a
    void reverse(int[],int,int) -> a
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.tsp.method.tsp.TspImprovement -> geogebra.common.i.h.c.a.a.c:
    boolean method(int[],double[][]) -> a
geogebra.common.kernel.discrete.tsp.model.Node -> geogebra.common.i.h.c.b.a:
    double x -> a
    double y -> b
    boolean equals(java.lang.Object) -> equals
    double getDistance(geogebra.common.kernel.discrete.tsp.model.Node) -> a
    double getX() -> a
    double getY() -> b
    java.lang.String toString() -> toString
geogebra.common.kernel.discrete.tsp.util.Heap -> geogebra.common.i.h.c.c.a:
    java.lang.Object[] entries -> a
    int size -> a
    java.util.Map table -> a
    java.util.Comparator comparator -> a
    boolean add(java.lang.Object) -> a
    void swap(int,int) -> a
    java.lang.Object poll() -> a
    void clear() -> a
    void fixDown(int) -> a
    void fixUp(int) -> b
    void grow(int) -> c
    java.lang.String toString() -> toString
    int size() -> a
geogebra.common.kernel.discrete.tsp.util.IntegerSet -> geogebra.common.i.h.c.c.b:
    int[] bitset -> a
    int[] list -> b
    int size -> a
    int[] index -> c
    int size() -> a
    boolean add(int) -> a
    int get(int) -> a
    boolean remove(int) -> b
    void swap(int,int) -> a
geogebra.common.kernel.geos.AbsoluteScreenLocateable -> geogebra.common.i.i.a:
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    void setAbsoluteScreenLocActive(boolean) -> a
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
geogebra.common.kernel.geos.Animatable -> geogebra.common.i.i.b:
    boolean doAnimationStep(double) -> a
    boolean isAnimating() -> f_
geogebra.common.kernel.geos.CasEvaluableFunction -> geogebra.common.i.i.c:
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.geos.ChangeableCoordParent -> geogebra.common.i.i.d:
    geogebra.common.kernel.geos.GeoNumeric changeableCoordNumber -> a
    geogebra.common.kernel.geos.GeoElement changeableCoordDirector -> a
    double startValue -> a
    geogebra.common.kernel.Matrix.Coords direction -> a
    geogebra.common.kernel.geos.GeoElement child -> b
    geogebra.common.kernel.geos.GeoNumeric getNumber() -> a
    double getValue() -> a
    geogebra.common.kernel.geos.GeoElement getDirector() -> a
    void record() -> a
    double getStartValue() -> b
    boolean move(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
geogebra.common.kernel.geos.ConicMirrorable -> geogebra.common.i.i.e:
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
geogebra.common.kernel.geos.Dilateable -> geogebra.common.i.i.f:
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
geogebra.common.kernel.geos.FromMeta -> geogebra.common.i.i.g:
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
geogebra.common.kernel.geos.GeoAngle -> geogebra.common.i.i.h:
    int arcSize -> l
    boolean emphasizeRightAngle -> i
    double rawValue -> f
    int angleStyle -> m
    java.lang.String[] INTERVAL_MIN -> a
    java.lang.String[] INTERVAL_MAX -> b
    int[] INTERVAL_TO_STYLE -> a
    int[] STYLE_TO_INTERVAL -> b
    java.lang.Integer[] getDecoTypes() -> a
    void setAngleInterval(int) -> a
    int getAngleInterval() -> f
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isGeoAngle() -> l
    boolean isAngle() -> m
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setValue(double,boolean) -> a
    double calcAngleValue(double) -> a
    void setIntervalMax(double) -> a
    void setIntervalMin(double) -> b
    void setEuclidianVisible(boolean) -> c
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setAllowReflexAngle(boolean) -> d
    void setForceReflexAngle(boolean) -> e
    void setAngleStyle(int) -> b
    int getAngleStyle() -> g
    boolean hasOrientation() -> n
    double getRawAngle() -> d
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    int getArcSize() -> h
    void setArcSize(int) -> c
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    void getXMLAllowReflexAngleTag(java.lang.StringBuilder) -> n
    void getXMLEmphasizeRightAngleTag(java.lang.StringBuilder) -> o
    void setDecorationType(int) -> e
    boolean isEmphasizeRightAngle() -> p
    void setEmphasizeRightAngle(boolean) -> f
    void setZero() -> g_
    boolean isDrawable() -> q
    boolean hasDrawable3D() -> r
    boolean canHaveClickScript() -> s
geogebra.common.kernel.geos.GeoAxis -> geogebra.common.i.i.i:
    geogebra.common.kernel.geos.GeoPoint2 origin -> c
    int type -> l
    java.lang.String axisLabel -> c
    geogebra.common.util.NumberFormatAdapter numberFormat -> a
    double numbersDistance -> a
    int numbersXOffset -> m
    int numbersYOffset -> n
    int ticksize -> o
    int getType() -> c
    boolean isAvailableAtConstructionStep(int) -> a
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setAxisLabel(java.lang.String) -> a
    java.lang.String getAxisLabel() -> d
    java.lang.String getUnitLabel() -> e
    int getTickStyle() -> f
    boolean getShowNumbers() -> n
    geogebra.common.util.NumberFormatAdapter getNumberFormat() -> a
    double getNumbersDistance() -> c
    int getTickSize() -> g
    void updateDecorations(double,geogebra.common.util.NumberFormatAdapter,int,int,int,int) -> a
    int getNumbersXOffset() -> h
    int getNumbersYOffset() -> i
    boolean isLabelSet() -> g_
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
geogebra.common.kernel.geos.GeoBoolean -> geogebra.common.i.i.j:
    boolean value -> g
    boolean isDefined -> h
    boolean checkboxFixed -> i
    java.util.ArrayList condListenersShowObject -> c
    int lastLocY -> l
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    java.lang.String getClassName() -> b
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setValue(boolean) -> d
    boolean getBoolean() -> a
    geogebra.common.kernel.arithmetic.MyBoolean getMyBoolean() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void registerConditionListener(geogebra.common.kernel.geos.GeoElement) -> c
    void unregisterConditionListener(geogebra.common.kernel.geos.GeoElement) -> d
    void update() -> i
    void doRemove() -> d
    void resolveVariables() -> a
    boolean showInEuclidianView() -> c_
    void initLocation() -> e
    boolean showInAlgebraView() -> t
    boolean isFixable() -> u
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    boolean isDefined() -> v
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isBooleanValue() -> j_
    boolean isGeoBoolean() -> w
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    void setAbsoluteScreenLocActive(boolean) -> a
    void setRealWorldLoc(double,double) -> a
    boolean isCheckboxFixed() -> x
    void setCheckboxFixed(boolean) -> e
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> k
    boolean isNumberValue() -> c
    double getDouble() -> a
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    boolean isLabelValueShowable() -> z
    boolean canHaveClickScript() -> s
    boolean isCasEvaluableObject() -> A
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoButton -> geogebra.common.i.i.k:
    boolean buttonFixed -> g
    int fontSize -> l
    int fontStyle -> m
    boolean serifFont -> h
    java.lang.String getClassName() -> b
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isGeoButton() -> k_
    void resolveVariables() -> a
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    boolean isFixable() -> u
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    boolean isDefined() -> v
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    void setAbsoluteScreenLocActive(boolean) -> a
    void setRealWorldLoc(double,double) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> k
    boolean isLabelValueShowable() -> z
    int getFontSize() -> f
    void setFontSize(int) -> a
    int getFontStyle() -> g
    void setFontStyle(int) -> b
    int getPrintDecimals() -> h
    int getPrintFigures() -> i
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean isSerifFont() -> B
    void setSerifFont(boolean) -> d
    boolean useSignificantFigures() -> t_
    boolean justFontSize() -> l_
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean hasBackgroundColor() -> E
    boolean isFillable() -> F
    int getFillType() -> j
geogebra.common.kernel.geos.GeoCasCell -> geogebra.common.i.i.l:
    geogebra.common.kernel.arithmetic.ValidExpression inputVE -> a
    geogebra.common.kernel.arithmetic.ValidExpression evalVE -> b
    geogebra.common.kernel.arithmetic.ValidExpression outputVE -> c
    java.lang.String input -> c
    java.lang.String prefix -> d
    java.lang.String postfix -> e
    java.lang.String error -> f
    java.lang.String latex -> g
    java.lang.String localizedInput -> h
    java.lang.String currentLanguage -> i
    boolean suppressOutput -> g
    java.util.TreeSet invars -> a
    java.util.TreeSet functionvars -> b
    java.util.TreeSet inGeos -> c
    boolean isCircularDefinition -> h
    geogebra.common.kernel.geos.GeoElement twinGeo -> a
    geogebra.common.kernel.geos.GeoElement lastOutputEvaluationGeo -> b
    boolean firstComputeOutput -> i
    boolean ignoreTwinGeoUpdate -> j
    java.util.HashSet commands -> a
    java.lang.String assignmentVar -> j
    boolean includesRowReferences -> k
    boolean includesNumericCommand -> l
    boolean useGeoGebraFallback -> m
    java.lang.String evalCmd -> k
    java.lang.String evalComment -> l
    int row -> l
    boolean useAsText -> n
    geogebra.common.kernel.geos.GeoText commentText -> a
    java.lang.String[] functionCommands -> a
    geogebra.common.kernel.arithmetic.MyArbitraryConstant arbconst -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getInput(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getOutput(geogebra.common.kernel.StringTemplate) -> g
    java.lang.String getEvalText() -> d
    geogebra.common.kernel.arithmetic.ValidExpression getEvalVE() -> a
    geogebra.common.kernel.arithmetic.ValidExpression getInputVE() -> b
    java.lang.String getLaTeXOutput() -> e
    boolean isUseAsText() -> B
    void setUseAsText(boolean) -> a
    void setFontStyle(int) -> a
    geogebra.common.awt.Color getFontColor() -> a
    void setFontColor(geogebra.common.awt.Color) -> a
    int getFontStyle() -> c
    void setFontSize(int) -> b
    int getFontSize() -> f
    geogebra.common.kernel.geos.GeoText getGeoText() -> a
    boolean isEmpty() -> C
    boolean isInputEmpty() -> D
    boolean isOutputEmpty() -> G
    boolean showOutput() -> n_
    boolean suppressOutput() -> bt
    boolean isSendingUpdatesToCAS() -> I
    void setInputFromTwinGeo() -> e
    boolean setInput(java.lang.String) -> a
    void updateLocalizedInput(geogebra.common.kernel.StringTemplate) -> a
    void setRowNumber(int) -> c
    int getRowNumber() -> g
    void updateInputStringWithRowReferences() -> g
    void setProcessingInformation(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean isStructurallyEqualToLocalizedInput(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCASInputAndResolveDummyVars(java.lang.String) -> a
    void updateInputVariables(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    boolean isFunction(geogebra.common.kernel.arithmetic.Command) -> a
    void internalizeInput() -> H
    java.lang.String localizeInput(java.lang.String,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String translate(java.lang.String,boolean) -> b
    java.lang.String replaceAllCommands(java.lang.String,java.lang.String,java.lang.String) -> a
    void setAssignmentVar(java.lang.String) -> m
    void unbindVariableInCAS() -> h
    void changeAssignmentVar(java.lang.String,java.lang.String) -> a
    java.util.TreeSet getInVars() -> g
    java.util.TreeSet getFunctionVars() -> h
    void clearInVars() -> I
    java.lang.String getInVar(int) -> a
    java.util.TreeSet getGeoElementVariables() -> b
    java.util.TreeSet updateInputGeoElements(java.util.TreeSet) -> a
    geogebra.common.kernel.arithmetic.ValidExpression resolveInputReferences(geogebra.common.kernel.arithmetic.ValidExpression,java.util.TreeSet) -> a
    void resolveFunctionVariableReferences(geogebra.common.kernel.arithmetic.ValidExpression) -> b
    void resolveGeoElementReferences(geogebra.common.kernel.arithmetic.ValidExpression) -> c
    boolean includesOnlyDefinedVariables() -> J
    boolean includesOnlyDefinedVariables(boolean) -> a
    boolean includesXYVariables() -> K
    boolean isInputVariable(java.lang.String) -> c
    boolean isFunctionVariable(java.lang.String) -> d
    java.lang.String getFunctionVariable() -> f
    java.lang.String getAssignmentVariable() -> g
    boolean isAssignmentVariableDefined() -> L
    java.lang.String getEvalCommand() -> h
    void setEvalCommand(java.lang.String) -> a
    void setKeepInputUsed(boolean) -> d
    void setEvalComment(java.lang.String) -> b
    java.lang.String getEvalComment() -> i
    void setOutput(java.lang.String) -> c
    void updateTwinGeo() -> j
    void createTwinGeo() -> J
    boolean setLabelOfTwinGeo() -> M
    void simpleUpdateTwinGeo() -> K
    void updateCascade() -> k
    geogebra.common.kernel.geos.GeoElement silentEvalInGeoGebra(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    boolean computeOutput() -> N
    boolean computeOutput(boolean) -> b
    void setError(java.lang.String) -> d
    boolean isError() -> O
    boolean isCircularDefinition() -> P
    void getElementOpenTagXML(java.lang.StringBuilder) -> c
    void getElementCloseTagXML(java.lang.StringBuilder) -> d
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getTypeString() -> c
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getClassName() -> b
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void doRemove() -> d
    void setTwinGeo(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoElement getTwinGeo() -> c
    void addToUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> b
    geogebra.common.kernel.arithmetic.ValidExpression getOutputValidExpression() -> c
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    void setInputVE(geogebra.common.kernel.arithmetic.ValidExpression) -> d
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoConic -> geogebra.common.i.i.m:
    geogebra.common.kernel.Matrix.CoordSys coordSys -> a
    java.lang.String getClassName() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    void setCircle(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void mirror(double) -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getDirection3D(int) -> b
    geogebra.common.kernel.Matrix.Coords getOrigin3D(int) -> c
    boolean isCasEvaluableObject() -> A
    char getLabelDelimiter() -> a
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    void setCoeffs(geogebra.common.kernel.arithmetic.ExpressionValue[][]) -> a
    double evalCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][],int,int) -> a
    void fromLine(geogebra.common.kernel.geos.GeoLine) -> b
geogebra.common.kernel.geos.GeoConicPart -> geogebra.common.i.i.n:
    double paramStart -> h
    double paramEnd -> i
    double paramExtent -> j
    boolean posOrientation -> j
    int conic_part_type -> m
    double value -> k
    double area -> l
    boolean value_defined -> k
    geogebra.common.kernel.integration.EllipticArcLength ellipticArcLength -> a
    boolean allowOutlyingIntersections -> l
    boolean keepTypeOnGeometricTransform -> m
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.PathParameter tempPP -> a
    java.lang.String getClassName() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    int getConicPartType() -> c
    double getParameterStart() -> c
    double getParameterEnd() -> d
    double getParameterExtent() -> e
    boolean positiveOrientation() -> G
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setParameters(double,double,boolean) -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    double getValue() -> f
    double getArea() -> g
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    geogebra.common.kernel.PathParameter getTempPathParameter() -> a
    boolean isClosedPath() -> u_
    void pointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    void setEllipseParameter(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> c
    void clipEllipseParameter(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> d
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isNumberValue() -> c
    boolean isGeoConicPart() -> r_
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isInRegion(double,double) -> a
    double computeArg(double,double) -> b
    void moveBackToRegion(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.RegionParameters) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean hasDrawable3D() -> r
    boolean isAllEndpointsLabelsSet() -> M
    geogebra.common.kernel.geos.GeoPoint2 getPointParam(double) -> a
geogebra.common.kernel.geos.GeoCurveCartesian -> geogebra.common.i.i.o:
    geogebra.common.kernel.arithmetic.Function funX -> a
    geogebra.common.kernel.arithmetic.Function funY -> b
    boolean isClosedPath -> h
    boolean trace -> i
    double CURVATURE_COLOR -> a
    geogebra.common.kernel.ParametricCurveDistanceFunction distFun -> a
    boolean hideRangeInFormula -> j
    geogebra.common.kernel.geos.GeoCurveCartesian derivGeoFun -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    java.lang.String translatedTypeString() -> b_
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setFunctionX(geogebra.common.kernel.arithmetic.Function) -> a
    void setFunctionY(geogebra.common.kernel.arithmetic.Function) -> b
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setInterval(double,double) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    geogebra.common.kernel.geos.GeoCurveCartesian getGeoDerivative(int) -> a
    void setDerivative(geogebra.common.kernel.geos.GeoCurveCartesian,int) -> a
    java.lang.String getFunX(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getFunY(geogebra.common.kernel.StringTemplate) -> g
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    boolean isMatrixTransformable() -> s_
    void translate(double,double) -> b
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void matrixTransform(double,double,double,double) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    double getClosestParameter(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isClosedPath() -> u_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isTraceable() -> m_
    boolean getTrace() -> C
    void setTrace(boolean) -> a
    void evaluateCurve(double,double[]) -> a
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    double evaluateCurvature(double) -> a
    boolean isCasEvaluableObject() -> A
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isFunctionInX() -> J
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    boolean isVector3DValue() -> k
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void setFromPolyLine(geogebra.common.kernel.kernelND.GeoPointND[],boolean) -> a
    void setHideRangeInFormula(boolean) -> d
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
geogebra.common.kernel.geos.GeoDummyVariable -> geogebra.common.i.i.p:
    java.lang.String varName -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
geogebra.common.kernel.geos.GeoElement -> geogebra.common.i.i.q:
    java.util.ArrayList spreadsheetTraceList -> a
    java.util.ArrayList spreadsheetColumnHeadings -> b
    char[] complexLabels -> a
    char[] pointLabels -> b
    char[] functionLabels -> c
    char[] lineLabels -> d
    char[] vectorLabels -> e
    char[] conicLabels -> f
    char[] lowerCaseLabels -> g
    char[] integerLabels -> h
    char[] greekLowerCase -> i
    char[] arabic -> j
    char[] greekUpperCase -> k
    int tooltipMode -> l
    java.lang.String label -> a
    java.lang.String realLabel -> c
    java.lang.String oldLabel -> d
    java.lang.String caption -> e
    boolean labelWanted -> a
    boolean labelSet -> b
    boolean localVarLabelSet -> g
    boolean euclidianVisible -> h
    boolean forceEuclidianVisible -> i
    boolean algebraVisible -> j
    boolean labelVisible -> k
    boolean isConsProtBreakpoint -> l
    boolean isAlgoMacroOutput -> m
    boolean fixed -> c
    int labelMode -> a
    int toStringMode -> b
    geogebra.common.awt.Color objColor -> a
    geogebra.common.awt.Color bgColor -> b
    geogebra.common.awt.Color selColor -> c
    geogebra.common.awt.Color labelColor -> d
    geogebra.common.awt.Color fillColor -> e
    int layer -> m
    geogebra.common.kernel.arithmetic.NumberValue animationIncrement -> a
    geogebra.common.kernel.arithmetic.NumberValue animationSpeedObj -> b
    geogebra.common.kernel.geos.GeoCasCell correspondingCasCell -> a
    boolean animating -> n
    int animationType -> n
    int animationDirection -> o
    float alphaValue -> a
    int hatchingAngle -> c
    int hatchingDistance -> d
    boolean inverseFill -> o
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter graphicsadapter -> a
    int fillType -> e
    int colorSpace -> p
    java.util.List viewFlags -> a
    int defaultGeoType -> q
    int labelOffsetX -> f
    int labelOffsetY -> g
    boolean auxiliaryObject -> p
    boolean selectionAllowed -> q
    geogebra.common.awt.Point spreadsheetCoords -> a
    geogebra.common.awt.Point oldSpreadsheetCoords -> b
    int cellRangeUsers -> r
    int casAlgoUsers -> s
    geogebra.common.kernel.geos.GeoBoolean condShowObject -> a
    geogebra.common.kernel.geos.GeoList colFunction -> a
    boolean useVisualDefaults -> r
    boolean isColorSet -> d
    boolean highlighted -> e
    boolean selected -> s
    java.lang.String strAlgebraDescription -> f
    java.lang.String strAlgebraDescTextOrHTML -> g
    java.lang.String strAlgebraDescriptionHTML -> h
    java.lang.String strLabelTextOrHTML -> i
    java.lang.String strLaTeX -> b
    boolean strAlgebraDescriptionNeedsUpdate -> t
    boolean strAlgebraDescTextOrHTMLneedsUpdate -> u
    boolean strAlgebraDescriptionHTMLneedsUpdate -> v
    boolean strLabelTextOrHTMLUpdate -> w
    boolean strLaTeXneedsUpdate -> f
    int lineThickness -> h
    int lineType -> i
    int lineTypeHidden -> j
    int decorationType -> k
    geogebra.common.kernel.algos.AlgoElement algoParent -> a
    geogebra.common.kernel.algos.AlgoElement algoDraw -> b
    java.util.ArrayList algorithmList -> c
    geogebra.common.kernel.algos.AlgorithmSet algoUpdateSet -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim viewForValueString -> a
    geogebra.common.util.LaTeXCache latexCache -> a
    geogebra.common.kernel.geos.GeoElement[] myGeoElements -> a
    java.lang.String subBegin -> j
    java.lang.String subEnd -> k
    java.lang.String strHasIndexLabel -> l
    boolean hasIndexLabel -> x
    geogebra.common.kernel.geos.GeoElement$ScriptType updateScriptType -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType clickScriptType -> b
    java.util.ArrayList moveObjectsUpdateList -> d
    java.util.TreeSet tempSet -> a
    java.util.Comparator algoComparator -> a
    java.util.ArrayList tempMoveObjectList -> e
    boolean spreadsheetTrace -> y
    geogebra.common.util.SpreadsheetTraceSettings traceSettings -> a
    boolean inTree -> z
    java.lang.String clickScript -> m
    java.lang.String updateScript -> n
    boolean showTrimmedIntersectionLines -> A
    boolean isRandomGeo -> B
    geogebra.common.kernel.Matrix.Coords mainDirection -> a
    boolean isPickable -> C
    boolean needsReplacingInExpressionNode -> D
    java.util.Stack tempClone -> a
    boolean cloneInUse -> E
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType -> b
    boolean isVector3DValue() -> k
    geogebra.common.kernel.geos.GeoElement$ScriptType getUpdateScriptType() -> a
    void setUpdateScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType getClickScriptType() -> b
    void setClickScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> b
    int getColorSpace() -> k
    void setColorSpace(int) -> f
    int getDefaultGeoType() -> l
    void setDefaultGeoType(int) -> g
    java.lang.String getLabelSimple() -> j
    void setLabelSimple(java.lang.String) -> e
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    void copyLabel(geogebra.common.kernel.geos.GeoElement) -> f
    void setLabelMode(int) -> h
    int getLabelMode() -> m
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPoint2[] copyPoints(geogebra.common.kernel.Construction,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] copyPointsND(geogebra.common.kernel.Construction,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables() -> a
    boolean isInfinite() -> Q
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void setViewForValueString(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    geogebra.common.euclidian.EuclidianViewInterfaceSlim getViewForValueString() -> a
    boolean hasValueStringChangeableRegardingView() -> R
    java.lang.String getRedefineString(boolean,boolean) -> a
    char getLabelDelimiter() -> a
    java.lang.String getDefinitionForInputBar() -> k
    java.lang.String getValueForInputBar() -> l
    void setZero() -> g_
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void setConstructionDefaults() -> n
    void setObjColor(geogebra.common.awt.Color) -> b
    boolean isColorSet() -> S
    geogebra.common.awt.Color getRGBFromList(float) -> a
    geogebra.common.awt.Color getRGBFromList(int) -> a
    geogebra.common.awt.Color getSelColor() -> b
    geogebra.common.awt.Color getFillColor() -> c
    geogebra.common.awt.Color getAlgebraColor() -> d
    geogebra.common.awt.Color getLabelColor() -> e
    void setLabelColor(geogebra.common.awt.Color) -> c
    geogebra.common.awt.Color getBackgroundColor() -> f
    void setBackgroundColor(geogebra.common.awt.Color) -> d
    geogebra.common.awt.Color getObjectColor() -> g
    void setLayer(int) -> i
    int getLayer() -> n
    long getDrawingPriority() -> b
    void setAlphaValue(float) -> a
    float getAlphaValue() -> a
    boolean isLimitedPath() -> o_
    boolean isPath() -> T
    boolean isRegion() -> U
    boolean isGeoList() -> V
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setVisualStyleForTransformations(geogebra.common.kernel.geos.GeoElement) -> g
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setAdvancedVisualStyle(geogebra.common.kernel.geos.GeoElement) -> h
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter getGraphicsAdapter() -> a
    void setLabelOffset(int,int) -> b
    boolean isVisible() -> W
    boolean isEuclidianVisible() -> X
    void setEuclidianVisible(boolean) -> c
    void forceEuclidianVisible(boolean) -> g
    boolean isSetEuclidianVisible() -> Y
    boolean isConsProtocolBreakpoint() -> g
    void setConsProtocolBreakpoint(boolean) -> h
    boolean isDrawable() -> q
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    boolean isTraceable() -> m_
    boolean isFixed() -> Z
    void setFixed(boolean) -> i
    boolean isFixable() -> u
    void removeOrSetUndefinedIfHasFixedDescendent() -> o
    boolean isAuxiliaryObject() -> aa
    boolean isAuxiliaryObjectByDefault() -> ab
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    void setAuxiliaryObject(boolean) -> j
    void setLabelVisible(boolean) -> k
    boolean isLabelVisible() -> ac
    boolean isLabelShowable() -> ad
    boolean isLabelValueShowable() -> z
    boolean isAlgebraVisible() -> ae
    boolean showToolTipText() -> af
    java.lang.String getTooltipText(boolean,boolean) -> b
    int getTooltipMode() -> o
    void setTooltipMode(int) -> j
    void setAlgebraVisible(boolean) -> l
    boolean isSetAlgebraVisible() -> ag
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    boolean isAlgebraViewEditable() -> ah
    boolean isEuclidianShowable() -> ai
    boolean isAlgebraShowable() -> aj
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    geogebra.common.kernel.algos.AlgoElement getParentAlgorithm() -> a
    void setDrawAlgorithm(geogebra.common.kernel.algos.AlgoDrawInformation) -> a
    geogebra.common.kernel.algos.AlgoElement getDrawAlgorithm() -> b
    java.util.ArrayList getAlgorithmList() -> c
    boolean isIndependent() -> h
    boolean isChangeable() -> ak
    boolean isPointOnPath() -> al
    boolean isRedefineable() -> am
    boolean isMoveable() -> an
    boolean isMoveable(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean hasOnlyFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> c
    boolean containsOnlyMoveableGeos(java.util.ArrayList) -> a
    boolean isTranslateable() -> q_
    boolean isRotateMoveable() -> ao
    boolean hasProperties() -> ap
    void setAnimationStep(double) -> c
    void setAnimationStep(geogebra.common.kernel.arithmetic.NumberValue) -> b
    double getAnimationStep() -> h
    geogebra.common.kernel.geos.GeoElement getAnimationStepObject() -> d
    geogebra.common.kernel.geos.GeoElement getAnimationSpeedObject() -> e
    double getAnimationSpeed() -> i
    void setAnimationSpeedObject(geogebra.common.kernel.arithmetic.NumberValue) -> c
    void setAnimationSpeed(double) -> d
    void initAnimationSpeedObject() -> e
    int getAnimationType() -> p
    void setAnimationType(int) -> k
    int getAnimationDirection() -> q
    void changeAnimationDirection() -> p
    void setAnimating(boolean) -> m
    boolean isAnimating() -> f_
    boolean isAnimatable() -> aq
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toCasAssignment(geogebra.common.kernel.StringTemplate) -> h
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> i
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    void addCellRangeUser() -> q
    void removeCellRangeUser() -> r
    boolean isRenameable() -> ar
    void addCasAlgoUser() -> s
    void removeCasAlgoUser() -> t
    void unbindVariableInCAS() -> h
    boolean isSendingUpdatesToCAS() -> I
    boolean rename(java.lang.String) -> f
    boolean isLabelSet() -> g_
    void setLabel(java.lang.String) -> f
    void setLoadedLabel(java.lang.String) -> g
    boolean setCaption(java.lang.String) -> g
    java.lang.String getCaption(geogebra.common.kernel.StringTemplate) -> j
    java.lang.String getRawCaption() -> m
    java.lang.String getCaptionDescription(geogebra.common.kernel.StringTemplate) -> k
    void setLocalVariableLabel(java.lang.String) -> h
    void undoLocalVariableLabel() -> u
    boolean isLocalVariable() -> as
    void doSetLabel(java.lang.String) -> a
    void updateSpreadsheetCoordinates() -> g
    java.lang.String getSpreadsheetLabelWithDollars(boolean,boolean) -> c
    int compareLabels(java.lang.String,java.lang.String) -> a
    void doRenameLabel(java.lang.String) -> b
    java.lang.String getOldLabel() -> n
    void setLabels(java.lang.String,geogebra.common.kernel.geos.GeoElement[]) -> a
    void setLabels(java.lang.String[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void setLabels(java.lang.String[],geogebra.common.kernel.geos.GeoElement[],boolean) -> a
    java.lang.String getFreeLabel(java.lang.String) -> a
    java.lang.String getDefaultLabel(boolean) -> a
    java.lang.String getDefaultLabel() -> o
    java.lang.String getDefaultLabel(char[],boolean) -> a
    java.lang.String defaultNumberedLabel(java.lang.String) -> e
    java.lang.String getIndexLabel(java.lang.String) -> b
    boolean isGeoTextField() -> at
    void remove() -> c
    void doRemove() -> d
    geogebra.common.util.LaTeXCache getLaTeXCache() -> a
    void notifyAdd() -> l
    void notifyRemove() -> m
    void notifyUpdate() -> v
    void notifyUpdateAuxiliaryObject() -> w
    void addAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> d
    void addToAlgorithmListOnly(geogebra.common.kernel.algos.AlgoElement) -> e
    void addToUpdateSetOnly(geogebra.common.kernel.algos.AlgoElement) -> f
    void removeAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> g
    geogebra.common.kernel.algos.AlgorithmSet getAlgoUpdateSet() -> a
    void addToUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> a
    void removeFromUpdateSets(geogebra.common.kernel.algos.AlgoElement) -> b
    void update() -> i
    void updateGeo() -> j
    boolean sendValueToCAS() -> au
    void algebraStringsNeedUpdate() -> H
    void updateCascade() -> k
    void updateDependentObjects() -> I
    void updateAlgoUpdateSetWith(geogebra.common.kernel.geos.GeoElement) -> i
    void updateCascade(java.util.ArrayList,java.util.TreeSet,boolean) -> a
    void updateCascadeUntil(java.util.ArrayList,java.util.TreeSet,geogebra.common.kernel.algos.AlgoElement) -> a
    void updateRepaint() -> x
    void updateVisualStyle() -> y
    java.lang.String toString() -> toString
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> d
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    geogebra.common.kernel.arithmetic.NumberValue evaluateNum() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    java.util.TreeSet getAllPredecessors() -> c
    java.util.TreeSet getAllIndependentPredecessors() -> a
    void addPredecessorsToSet(java.util.TreeSet,boolean) -> a
    java.util.TreeSet getAllRandomizablePredecessors() -> d
    void addRandomizablePredecessorsToSet(java.util.TreeSet) -> a
    boolean isParentOf(geogebra.common.kernel.geos.GeoElement) -> b
    boolean hasChildren() -> av
    boolean isChildOf(geogebra.common.kernel.geos.GeoElement) -> c
    boolean isChildOrEqual(geogebra.common.kernel.geos.GeoElement) -> d
    java.util.TreeSet getAllChildren() -> e
    geogebra.common.kernel.geos.GeoElement[] getGeoElements() -> d
    boolean isAlgoElement() -> e
    boolean isGeoElement() -> h_
    int getConstructionIndex() -> a_
    int getMinConstructionIndex() -> d
    int getMaxConstructionIndex() -> e
    java.lang.String getDefinitionDescription(geogebra.common.kernel.StringTemplate) -> l
    java.lang.String getDefinitionDescriptionHTML(boolean) -> b
    java.lang.String getCommandDescription(geogebra.common.kernel.StringTemplate) -> m
    java.lang.String getCommandDescriptionHTML(boolean) -> c
    int getRelatedModeID() -> a
    java.lang.String convertIndicesToHTML(java.lang.String) -> c
    java.lang.String addLabelTextOrHTML(java.lang.String) -> d
    java.lang.String getCaptionDescriptionHTML(boolean,geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getTypeString() -> c
    java.lang.String getObjectType() -> p
    java.lang.String translatedTypeString() -> b_
    java.lang.String getLongDescription() -> q
    java.lang.String getLongDescriptionHTML(boolean,boolean) -> d
    java.lang.String getToolTipDescriptionHTML(java.util.ArrayList,boolean,boolean,boolean) -> a
    java.lang.String getLabelDescription() -> r
    java.lang.String toDefinedValueString(geogebra.common.kernel.StringTemplate) -> n
    java.lang.String getAlgebraDescriptionTextOrHTML(geogebra.common.kernel.StringTemplate) -> o
    java.lang.String getAlgebraDescriptionHTML(geogebra.common.kernel.StringTemplate) -> p
    java.lang.String getLabelTextOrHTML() -> s
    java.lang.String getAlgebraDescription(geogebra.common.kernel.StringTemplate) -> q
    java.lang.String getAlgebraDescriptionRegrOut(geogebra.common.kernel.StringTemplate) -> r
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String getLaTeXdescription() -> t
    java.lang.String getLaTeXAlgebraDescription(boolean,geogebra.common.kernel.StringTemplate) -> c
    java.lang.String getLaTeXAlgebraDescription(geogebra.common.kernel.geos.GeoElement,boolean,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String indicesToHTML(java.lang.String,boolean) -> a
    java.lang.String getNameDescription() -> a
    java.lang.String getNameDescriptionTextOrHTML() -> u
    boolean hasIndexLabel() -> aw
    java.lang.String getNameDescriptionHTML(boolean,boolean) -> e
    java.lang.String getClassName() -> b
    java.lang.String getXMLtypeString() -> v
    java.lang.String getXML() -> w
    void getXML(java.lang.StringBuilder) -> a
    void getElementOpenTagXML(java.lang.StringBuilder) -> c
    void getElementCloseTagXML(java.lang.StringBuilder) -> d
    void getScriptTags(java.lang.StringBuilder) -> e
    boolean clickGGBScript() -> ax
    boolean updateGGBScript() -> ay
    boolean clickJavaScript() -> az
    boolean updateJavaScript() -> aA
    boolean clickPythonScript() -> aB
    boolean updatePythonScript() -> C
    void getCaptionXML(java.lang.StringBuilder) -> f
    void getAuxiliaryXML(java.lang.StringBuilder) -> g
    void getXMLvisualTags(java.lang.StringBuilder) -> h
    void getXMLvisualTags(java.lang.StringBuilder,boolean) -> a
    void getXMLanimationTags(java.lang.StringBuilder) -> i
    void getXMLfixedTag(java.lang.StringBuilder) -> j
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> t
    java.lang.String regrFormat(double) -> a
    void getLineStyleXML(java.lang.StringBuilder) -> k
    void getBreakpointXML(java.lang.StringBuilder) -> l
    java.lang.String getShowObjectConditionXML() -> e
    int getLineThickness() -> r
    int getMinimumLineThickness() -> s
    int getLineType() -> t
    int getLineTypeHidden() -> u
    void setLineThickness(int) -> l
    void setLineType(int) -> m
    void setLineTypeHidden(int) -> n
    void setDecorationType(int) -> e
    boolean isGeoElement3D() -> aC
    boolean hasDrawable3D() -> r
    boolean hasLevelOfDetail() -> aD
    boolean isGeoAngle() -> l
    boolean isGeoBoolean() -> w
    boolean isGeoPolyLine() -> aE
    boolean isGeoImplicitPoly() -> aF
    boolean isGeoConic() -> aG
    boolean isGeoConicPart() -> r_
    boolean isGeoFunction() -> aH
    boolean isGeoFunctionNVar() -> aI
    boolean isGeoFunctionBoolean() -> aJ
    boolean isGeoFunctionConditional() -> aK
    boolean isGeoFunctionable() -> aL
    boolean isGeoImage() -> aM
    boolean isGeoTurtle() -> aN
    boolean isGeoLine() -> aO
    boolean isGeoPlane() -> aP
    boolean isGeoLocus() -> aQ
    boolean isGeoNumeric() -> aR
    boolean isGeoPoint() -> aS
    boolean isGeoPolygon() -> aT
    boolean isGeoRay() -> aU
    boolean isGeoSegment() -> aV
    boolean isGeoText() -> aW
    boolean isGeoVector() -> aX
    boolean isGeoCurveCartesian() -> aY
    boolean isCasEvaluableObject() -> A
    boolean isExpressionNode() -> i_
    boolean isVariable() -> y
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void setSelected(boolean) -> n
    void setHighlighted(boolean) -> o
    boolean doHighlighting() -> aZ
    boolean isSelected() -> ba
    boolean isNumberValue() -> c
    boolean isAngle() -> m
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isListValue() -> j
    boolean isGeoButton() -> k_
    void setUseVisualDefaults(boolean) -> p
    boolean isAbsoluteScreenLocateable() -> i
    geogebra.common.kernel.geos.GeoBoolean getShowObjectCondition() -> a
    void setShowObjectCondition(geogebra.common.kernel.geos.GeoBoolean) -> a
    void removeCondition(geogebra.common.kernel.geos.GeoBoolean) -> b
    geogebra.common.kernel.geos.GeoList getColorFunction() -> a
    void setColorFunction(geogebra.common.kernel.geos.GeoList) -> a
    void removeColorFunction() -> z
    boolean moveObjects(java.util.ArrayList,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    java.util.TreeSet getTempSet() -> f
    boolean movePoint(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean moveObject(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList) -> a
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    boolean hasChangeableCoordParentNumbers() -> bb
    void recordChangeableCoordParentNumbers() -> A
    void addChangeableCoordParentNumberToUpdateList(geogebra.common.kernel.geos.GeoElement,java.util.ArrayList,java.util.ArrayList) -> a
    geogebra.common.awt.Point getSpreadsheetCoords() -> a
    geogebra.common.awt.Point getOldSpreadsheetCoords() -> b
    boolean isAlgoMacroOutput() -> bc
    void setAlgoMacroOutput(boolean) -> q
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDifferenceZeroInCAS(geogebra.common.kernel.geos.GeoElement) -> e
    java.lang.String getFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> b
    java.lang.String getRealFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> c
    boolean getSpreadsheetTrace() -> bd
    void setSpreadsheetTrace(boolean) -> r
    void resetTraceColumns() -> B
    boolean isSpreadsheetTraceable() -> be
    geogebra.common.util.SpreadsheetTraceSettings getTraceSettings() -> a
    void setTraceSettings(geogebra.common.util.SpreadsheetTraceSettings) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElementForPropertiesDialog() -> f
    boolean isTextCommand() -> bf
    void setInTree(boolean) -> b
    boolean isLetterOrDigit(char) -> a
    java.lang.String[] splitScriptByCommands(java.lang.String) -> a
    java.lang.String script2LocalizedScript(java.lang.String) -> f
    java.lang.String localizedScript2Script(java.lang.String) -> g
    void setPythonEventHandler(geogebra.common.kernel.geos.GeoElement$ScriptType,java.lang.String,java.lang.String) -> a
    void setClickScript(java.lang.String,boolean) -> a
    void setUpdateScript(java.lang.String,boolean) -> b
    boolean canHaveUpdateScript() -> bg
    java.lang.String getUpdateScript() -> x
    java.lang.String getClickScript() -> y
    void getXMLUpdateScript(java.lang.StringBuilder) -> m
    void getXMLClickScript(java.lang.StringBuilder) -> n
    void runGgbScript(java.lang.String,boolean) -> c
    void runJavaScript(java.lang.String,boolean) -> d
    void runScripts(java.lang.String) -> i
    void runUpdateScripts() -> C
    void setShowTrimmedIntersectionLines(boolean) -> s
    boolean getShowTrimmedIntersectionLines() -> bh
    boolean isPointInRegion() -> bi
    void setRandomGeo(boolean) -> t
    boolean isRandomGeo() -> bj
    void updateRandomGeo() -> D
    boolean isMatrixTransformable() -> s_
    void setVisibility(int,boolean) -> c
    boolean isVisibleInView(int) -> b
    void addView(int) -> o
    void removeView(int) -> p
    void setViewFlags(java.util.List) -> a
    java.util.List getViewSet() -> a
    boolean isVisibleInView3D() -> bk
    void setSelectionAllowed(boolean) -> u
    boolean isSelectionAllowed() -> bl
    void setRealLabel(java.lang.String) -> j
    java.lang.String getRealLabel(geogebra.common.kernel.StringTemplate) -> u
    boolean isHatchingEnabled() -> bm
    void setHatchingAngle(int) -> q
    double getHatchingAngle() -> j
    void setHatchingDistance(int) -> r
    int getHatchingDistance() -> v
    geogebra.common.awt.BufferedImage getFillImage() -> a
    void setFillImage(java.lang.String) -> k
    int getFillType() -> j
    void setFillType(int) -> s
    void setImageFileName(java.lang.String) -> l
    java.lang.String getImageFileName() -> z
    void setInverseFill(boolean) -> v
    boolean isInverseFill() -> bn
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean canHaveClickScript() -> s
    void setIsPickable(boolean) -> w
    boolean isPickable() -> bo
    boolean needsReplacingInExpressionNode() -> bp
    boolean isGeoInterval() -> bq
    double getMeasure() -> k
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    void storeClone() -> E
    void recoverFromClone() -> F
    void randomizeForProbabilisticChecking() -> G
    boolean isRandomizable() -> br
    geogebra.common.kernel.geos.GeoCasCell getCorrespondingCasCell() -> a
    void setCorrespondingCasCell(geogebra.common.kernel.geos.GeoCasCell) -> a
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    boolean isLaTeXneeded(java.lang.String) -> h
    boolean hasBackgroundColor() -> E
    boolean algoUpdateSetContains(geogebra.common.kernel.algos.AlgoElement) -> a
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.arithmetic.ExpressionValue traverse(geogebra.common.kernel.arithmetic.Traversing) -> a
    boolean isFromMeta() -> bs
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType() -> c
geogebra.common.kernel.geos.GeoElement$1 -> geogebra.common.i.i.r:
    int compare(geogebra.common.kernel.algos.AlgoElement,geogebra.common.kernel.algos.AlgoElement) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoElement$ScriptType -> geogebra.common.i.i.q$a:
    geogebra.common.kernel.geos.GeoElement$ScriptType GGBSCRIPT -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType JAVASCRIPT -> b
    geogebra.common.kernel.geos.GeoElement$ScriptType PYTHON -> c
    geogebra.common.kernel.geos.GeoElement$ScriptType[] ENUM$VALUES -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType[] values() -> values
    geogebra.common.kernel.geos.GeoElement$ScriptType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.GeoElementGraphicsAdapter -> geogebra.common.i.i.s:
    java.lang.String imageFileName -> a
    geogebra.common.awt.BufferedImage image -> a
    geogebra.common.awt.BufferedImage getImageOnly() -> a
    void setImageOnly(geogebra.common.awt.BufferedImage) -> a
    void setImageFileNameOnly(java.lang.String) -> a
    java.lang.String getImageFileName() -> a
    geogebra.common.awt.BufferedImage getFillImage() -> b
    void setImageFileName(java.lang.String) -> b
    void setFillImage(java.lang.String) -> c
geogebra.common.kernel.geos.GeoElementSpreadsheet -> geogebra.common.i.i.t:
    com.google.gwt.regexp.shared.RegExp spreadsheetPattern -> a
    com.google.gwt.regexp.shared.RegExp spreadsheetPatternPart -> b
    java.lang.StringBuilder sb -> a
    java.lang.String getSpreadsheetColumnName(int) -> a
    java.lang.String getSpreadsheetColumnName(java.lang.String) -> a
    java.lang.String getSpreadsheetCellName(int,int) -> a
    geogebra.common.awt.Point spreadsheetIndices(java.lang.String) -> a
    boolean isSpreadsheetLabel(java.lang.String) -> a
    int getSpreadsheetColumn(com.google.gwt.regexp.shared.MatchResult) -> a
    int getSpreadsheetRow(com.google.gwt.regexp.shared.MatchResult) -> b
    geogebra.common.awt.Point getSpreadsheetCoordsForLabel(java.lang.String) -> b
    void setSpreadsheetCell(geogebra.common.main.AbstractApplication,int,int,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement autoCreate(java.lang.String,geogebra.common.kernel.Construction) -> a
geogebra.common.kernel.geos.GeoFunction -> geogebra.common.i.i.u:
    geogebra.common.kernel.arithmetic.Function fun -> a
    boolean isDefined -> g
    boolean trace -> i
    boolean includesDivisionByVar -> j
    boolean interval -> h
    double intervalMin -> a
    double intervalMax -> b
    boolean evalSwapped -> k
    java.lang.Boolean isInequality -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly iPoly -> a
    geogebra.common.kernel.geos.GeoFunction[] substituteFunctions -> a
    int FUNCTION_DIRECT -> l
    int FUNCTION_COMPOSITE_IPOLY_FUNCS -> m
    int geoFunctionType -> n
    geogebra.common.kernel.geos.GeoFunction derivGeoFun -> a
    geogebra.common.kernel.arithmetic.Function includesDivisionByVarFun -> b
    java.lang.StringBuilder sbToString -> a
    boolean showOnAxis -> l
    java.lang.StringBuilder sb -> b
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setFunction(geogebra.common.kernel.arithmetic.Function) -> a
    void initFunction() -> e
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    boolean setInterval(double,double) -> b
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.arithmetic.Function getFunction(double) -> a
    void setDerivative(geogebra.common.kernel.geos.CasEvaluableFunction,int) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    double evaluate(double) -> a
    double evaluate(double[]) -> a
    double getIntervalMin() -> c
    double getIntervalMax() -> d
    boolean hasInterval() -> M
    boolean evaluateBoolean(double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void translate(double,double) -> a
    boolean isPolynomialFunction(boolean,boolean) -> a
    boolean isPolynomialFunction(boolean) -> a
    boolean includesDivisionByVar() -> N
    boolean isDefined() -> v
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    void setDefined(boolean) -> d
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void getXML(java.lang.StringBuilder) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pointChangedBoolean(boolean,geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isPath() -> T
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isClosedPath() -> u_
    boolean isCasEvaluableObject() -> A
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isTraceable() -> m_
    boolean getTrace() -> C
    void setTrace(boolean) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunction() -> aH
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> i
    boolean isGeoFunctionable() -> aL
    boolean isBooleanFunction() -> O
    void swapEval() -> g
    void evaluateCurve(double,double[]) -> a
    double evaluateCurvature(double) -> b
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isFunctionInX() -> J
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoFunction add(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar operationSymb(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.FunctionalNVar) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar fromExpr(geogebra.common.kernel.arithmetic.ExpressionNode,java.util.HashMap,java.util.TreeSet) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode toExpr(geogebra.common.kernel.arithmetic.FunctionalNVar,java.util.HashMap,geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar applyNumberSymb(geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.FunctionalNVar,geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    geogebra.common.kernel.geos.GeoFunction subtract(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction) -> b
    geogebra.common.kernel.geos.GeoFunction mult(geogebra.common.kernel.geos.GeoFunction,double,geogebra.common.kernel.geos.GeoFunction) -> a
    boolean isVector3DValue() -> k
    boolean evaluateCondition(double) -> b
    java.lang.String getLimit(double,int) -> a
    void getVerticalAsymptotes(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getHorizontalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void getHorizontalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> b
    void getDiagonalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> c
    void getDiagonalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> d
    void getDiagonalAsymptoteStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getHorizontalAsymptoteStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> b
    char getLabelDelimiter() -> a
    void getVerticalAsymptotesStatic(geogebra.common.kernel.geos.GeoFunction,geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> c
    boolean CASError(java.lang.String,boolean) -> a
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    java.lang.String[] getTempVarCASString(boolean) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.geos.GeoFunction threadSafeCopy() -> b
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isInRegion(double,double) -> a
    boolean isFunctionOfY() -> P
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    boolean isRegion() -> U
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void resetIneqs() -> j
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    boolean showOnAxis() -> bt
    void setShowOnAxis(boolean) -> e
    void update() -> i
    boolean isGeoFunctionBoolean() -> aJ
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.lang.String getFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> b
    java.lang.String getRealFormulaString(geogebra.common.kernel.StringTemplate,boolean) -> c
    int getMinimumLineThickness() -> s
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
geogebra.common.kernel.geos.GeoFunction$1 -> geogebra.common.i.i.v:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$2 -> geogebra.common.i.i.w:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$3 -> geogebra.common.i.i.x:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$4 -> geogebra.common.i.i.y:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunction$5 -> geogebra.common.i.i.z:
    geogebra.common.kernel.geos.GeoFunction this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.geos.GeoFunctionConditional -> geogebra.common.i.i.A:
    geogebra.common.kernel.geos.GeoFunction condFun -> a
    geogebra.common.kernel.geos.GeoFunction ifFun -> b
    geogebra.common.kernel.geos.GeoFunction elseFun -> c
    geogebra.common.kernel.arithmetic.Function uncondFun -> b
    geogebra.common.kernel.geos.GeoFunctionConditional derivGeoFun -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isDefined() -> v
    geogebra.common.kernel.geos.GeoFunction getIfFunction() -> c
    geogebra.common.kernel.geos.GeoFunction getCondFunction() -> d
    geogebra.common.kernel.geos.GeoFunction getElseFunction() -> e
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setDerivative(geogebra.common.kernel.geos.CasEvaluableFunction,int) -> a
    double evaluate(double) -> a
    void translate(double,double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.arithmetic.Function getFunction(double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    boolean isPolynomialFunction(boolean,boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate,boolean) -> d
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isGeoFunction() -> aH
    boolean isGeoFunctionConditional() -> aK
    boolean isBooleanFunction() -> O
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean evaluateCondition(double) -> b
    java.lang.String getLimit(double,int) -> a
    void getVerticalAsymptotes(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder,boolean) -> a
    void getDiagonalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> c
    void getDiagonalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> d
    void getHorizontalPositiveAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void getHorizontalNegativeAsymptote(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> b
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    java.lang.String conditionalLaTeX(boolean,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String conditionalMathML(boolean,geogebra.common.kernel.StringTemplate) -> e
    boolean collectCases(java.util.ArrayList,java.util.ArrayList,geogebra.common.kernel.geos.GeoFunctionConditional$Bounds) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.geos.GeoFunction threadSafeCopy() -> b
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
geogebra.common.kernel.geos.GeoFunctionConditional$Bounds -> geogebra.common.i.i.A$a:
    boolean lowerSharp -> a
    boolean upperSharp -> b
    java.lang.Double lower -> a
    java.lang.Double upper -> b
    geogebra.common.kernel.arithmetic.ExpressionNode condition -> a
    geogebra.common.kernel.geos.GeoFunctionConditional this$0 -> a
    geogebra.common.kernel.geos.GeoFunctionConditional$Bounds addRestriction(geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    java.lang.String toLaTeXString(boolean,java.lang.String,geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.geos.GeoFunctionNVar -> geogebra.common.i.i.B:
    geogebra.common.kernel.arithmetic.FunctionNVar fun -> a
    boolean isInequality -> g
    boolean isDefined -> h
    double[] from -> a
    double[] to -> b
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.kernelND.LevelOfDetail levelOfDetail -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setFunction(geogebra.common.kernel.arithmetic.FunctionNVar) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar getFunction() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode getFunctionExpression() -> a
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    double evaluate(double[]) -> a
    double evaluate(double,double,double) -> a
    void setUsingCasCommand(java.lang.String,geogebra.common.kernel.geos.CasEvaluableFunction,boolean,geogebra.common.kernel.arithmetic.MyArbitraryConstant) -> a
    boolean isDefined() -> v
    void setDefined(boolean) -> a
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toXMLString(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getAssignmentLHS(geogebra.common.kernel.StringTemplate) -> i
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    char getLabelDelimiter() -> a
    void getXML(java.lang.StringBuilder) -> a
    boolean isCasEvaluableObject() -> A
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isBooleanFunction() -> C
    java.lang.String getVarString(geogebra.common.kernel.StringTemplate) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> k
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    void setInterval(double[],double[]) -> a
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    int getVarNumber() -> c
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    geogebra.common.kernel.arithmetic.IneqTree getIneqs() -> a
    void update() -> i
    boolean isRegion() -> U
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void tryLocateInEV(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean isInequality() -> J
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void matrixTransform(double,double,double,double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void mirror(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isGeoFunctionNVar() -> aI
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.LevelOfDetail getLevelOfDetail() -> a
    boolean hasLevelOfDetail() -> aD
    boolean needsLevelOfDetail() -> M
    int getMinimumLineThickness() -> s
geogebra.common.kernel.geos.GeoFunctionable -> geogebra.common.i.i.C:
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.geos.GeoImage -> geogebra.common.i.i.D:
    geogebra.common.kernel.geos.GeoPoint2[] corners -> a
    int pixelWidth -> l
    int pixelHeight -> m
    boolean inBackground -> g
    boolean defined -> h
    boolean hasAbsoluteLocation -> i
    boolean interpolate -> j
    int screenX -> n
    int screenY -> o
    boolean hasAbsoluteScreenLocation -> k
    geogebra.common.kernel.geos.GeoPoint2[] tempPoints -> b
    java.util.Vector instances -> a
    double[] tempCoords -> a
    java.util.ArrayList al -> c
    geogebra.common.kernel.geos.GeoElement copy() -> b
    int getRelatedModeID() -> a
    void initTempPoints() -> j
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void updateInstances() -> e
    boolean showToolTipText() -> af
    boolean isInBackground() -> C
    void setInBackground(boolean) -> d
    void setImageFileName(java.lang.String) -> l
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void setCorner(geogebra.common.kernel.geos.GeoPoint2,int) -> a
    void updateHasAbsoluteLocation() -> H
    void doRemove() -> d
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getStartPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2 getCorner(int) -> a
    boolean hasAbsoluteLocation() -> J
    boolean isInterpolate() -> M
    void setInterpolate(boolean) -> e
    void setWaitForStartPoint() -> b_
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isMoveable() -> an
    boolean isRotateMoveable() -> ao
    boolean isFillable() -> F
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isGeoImage() -> aM
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getXMLabsScreenLoc() -> e
    java.lang.String getCornerPointXML(int) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    void setAbsoluteScreenLocActive(boolean) -> a
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
    void calculateCornerPoint(geogebra.common.kernel.geos.GeoPoint2,int) -> b
    void getInternalCornerPointCoords(double[],int) -> a
    boolean initTransformPoints() -> N
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void matrixTransform(double,double,double,double) -> a
    boolean isMatrixTransformable() -> s_
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isAlwaysFixed() -> a
    boolean isVector3DValue() -> k
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean isAuxiliaryObjectByDefault() -> ab
    boolean isAlgebraViewEditable() -> ah
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void clearFillImage() -> g
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
geogebra.common.kernel.geos.GeoInterval -> geogebra.common.i.i.E:
    java.lang.StringBuilder sbToString2 -> b
    double rightBound -> c
    double leftBound -> d
    java.lang.String rightStr -> c
    java.lang.String leftStr -> d
    char rightInequality -> a
    char leftInequality -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(boolean,geogebra.common.kernel.StringTemplate) -> d
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void updateBoundaries() -> H
    void setLeftBound(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void setRightBound(geogebra.common.kernel.arithmetic.ExpressionValue) -> b
    double getMin() -> e
    double getMax() -> f
    double getMidPoint() -> g
    boolean isGeoInterval() -> bq
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    int getMinimumLineThickness() -> s
geogebra.common.kernel.geos.GeoLine -> geogebra.common.i.i.F:
    boolean showUndefinedInAlgebraView -> h
    java.lang.String parameter -> c
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 endPoint -> b
    boolean KEEP_LEADING_SIGN -> i
    java.lang.String[] vars -> a
    geogebra.common.kernel.PathParameter tempPP -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.lang.StringBuilder sbToStringLHS -> c
    java.util.ArrayList pointsOnLine -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setCoords(double,double,double) -> a
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    boolean isOnFullLine(geogebra.common.kernel.geos.GeoPoint2,double) -> b
    boolean isOnFullLine(geogebra.common.kernel.Matrix.Coords,double) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    double getPossibleParameter(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.PathParameter getTempPathParameter() -> a
    boolean isParallel(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isSameDirection(geogebra.common.kernel.geos.GeoLine) -> b
    boolean isPerpendicular(geogebra.common.kernel.geos.GeoLine) -> c
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    double distanceHom(geogebra.common.kernel.Matrix.Coords) -> b
    double distance(geogebra.common.kernel.geos.GeoLine) -> a
    void getDirection(geogebra.common.kernel.geos.GeoVec3D) -> b
    void getDirection(double[]) -> a
    void getInhomPointOnLine(double[]) -> b
    void getPointOnLine(geogebra.common.kernel.geos.GeoPoint2) -> b
    void setStandardStartPoint() -> e
    void setStartPoint(geogebra.common.kernel.geos.GeoPoint2) -> c
    void setEndPoint(geogebra.common.kernel.geos.GeoPoint2) -> d
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2 getEndPoint() -> b
    boolean isDefined() -> v
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefinedTangent(geogebra.common.kernel.geos.GeoConic) -> a
    boolean isDefinedAsymptote(geogebra.common.kernel.geos.GeoConic) -> b
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void setToParametric(java.lang.String) -> b
    void setToExplicit() -> g
    void setToImplicit() -> j
    void setMode(int) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.StringBuilder getSbToString() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.StringBuilder getSbBuildValueString() -> b
    void toStringLHS(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isClosedPath() -> u_
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void doPointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> e
    void doPointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    boolean isPath() -> T
    boolean isGeoLine() -> aO
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void setZero() -> g_
    boolean isVector3DValue() -> k
    void matrixTransform(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunctionable() -> aL
    boolean isMatrixTransformable() -> s_
    void toGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    double evaluate(double) -> a
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    geogebra.common.kernel.Matrix.Coords getStartCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getDirectionInD(int) -> b
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    geogebra.common.kernel.Matrix.Coords getCartesianEquationVector(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getStartInhomCoords() -> c
    geogebra.common.kernel.Matrix.Coords getEndInhomCoords() -> d
    boolean isCasEvaluableObject() -> A
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    java.util.ArrayList getPointsOnLine() -> d
    void addPointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void doRemove() -> d
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
    geogebra.common.kernel.geos.GeoFunction getGeoDerivative(int) -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND getEndPoint() -> b
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra.common.kernel.geos.GeoLine$PathMoverLine -> geogebra.common.i.i.F$a:
    geogebra.common.kernel.geos.GeoLine this$0 -> a
    void init(geogebra.common.kernel.geos.GeoPoint2) -> a
geogebra.common.kernel.geos.GeoList -> geogebra.common.i.i.G:
    geogebra.common.plugin.GeoClass ELEMENT_TYPE_MIXED -> a
    boolean trace -> g
    java.lang.String STR_OPEN -> c
    java.lang.String STR_CLOSE -> d
    java.util.ArrayList geoList -> c
    java.util.ArrayList cacheList -> d
    boolean isDefined -> h
    boolean isDrawable -> i
    geogebra.common.plugin.GeoClass elementType -> b
    boolean showAllProperties -> j
    java.util.ArrayList colorFunctionListener -> e
    java.lang.StringBuilder sbBuildValueString -> a
    int pointSize -> l
    int pointStyle -> m
    boolean serifFont -> k
    int fontStyle -> n
    int fontSize -> o
    int printDecimals -> p
    int printFigures -> q
    boolean useSignificantFigures -> l
    int selectedIndex -> r
    int closestPointIndex -> s
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.plugin.GeoClass getElementType() -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setShowAllProperties(boolean) -> e
    void copyListElements(geogebra.common.kernel.geos.GeoList) -> b
    geogebra.common.kernel.geos.GeoElement getCopyForList(geogebra.common.kernel.geos.GeoElement) -> a
    void applyVisualStyle(geogebra.common.kernel.geos.GeoElement) -> l
    void removeColorFunction() -> z
    void setColorFunction(geogebra.common.kernel.geos.GeoList) -> a
    void setColorSpace(int) -> f
    void setShowObjectCondition(geogebra.common.kernel.geos.GeoBoolean) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setObjColor(geogebra.common.awt.Color) -> b
    void setBackgroundColor(geogebra.common.awt.Color) -> d
    void setEuclidianVisible(boolean) -> c
    void setElementEuclidianVisible(geogebra.common.kernel.geos.GeoElement,boolean) -> b
    void setVisibility(int,boolean) -> c
    geogebra.common.kernel.arithmetic.MyList getMyList() -> a
    boolean isDefined() -> v
    void setDefined(boolean) -> f
    void setUndefined() -> f
    boolean showInEuclidianView() -> c_
    boolean isDrawable() -> q
    boolean showInAlgebraView() -> t
    void clear() -> e
    void clearCache() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> c
    void remove(geogebra.common.kernel.geos.GeoElement) -> d
    void remove(int) -> c
    geogebra.common.kernel.geos.GeoElement get(int) -> a
    geogebra.common.kernel.geos.GeoElement get(int,int) -> a
    double[] toDouble() -> a
    void ensureCapacity(int) -> t
    int size() -> b_
    int getCacheSize() -> c
    geogebra.common.kernel.geos.GeoElement getCached(int) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    boolean isGeoList() -> V
    boolean isListValue() -> j
    void getXML(java.lang.StringBuilder) -> a
    void registerColorFunctionListener(geogebra.common.kernel.geos.GeoElement) -> j
    void unregisterColorFunctionListener(geogebra.common.kernel.geos.GeoElement) -> k
    void update() -> i
    void doRemove() -> d
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setZero() -> g_
    void setLineThickness(int) -> l
    int getLineThickness() -> r
    int getMinimumLineThickness() -> s
    void setLineType(int) -> m
    int getLineType() -> t
    void setPointSize(int) -> u
    int getPointSize() -> w
    void setPointStyle(int) -> v
    float getAlphaValue() -> a
    void setAlphaValue(float) -> a
    int getPointStyle() -> x
    boolean isFillable() -> F
    geogebra.common.kernel.geos.GeoElement getGeoElementForPropertiesDialog() -> f
    boolean isMatrix() -> J
    int getFontSize() -> f
    void setFontSize(int) -> a
    int getFontStyle() -> g
    void setFontStyle(int) -> b
    int getPrintDecimals() -> h
    int getPrintFigures() -> i
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean useSignificantFigures() -> t_
    boolean isSerifFont() -> B
    void setSerifFont(boolean) -> d
    void setHatchingAngle(int) -> q
    void setHatchingDistance(int) -> r
    void setFillType(int) -> s
    void setFillImage(java.lang.String) -> k
    void setImageFileName(java.lang.String) -> l
    boolean showLineProperties() -> M
    boolean showPointProperties() -> N
    boolean isVector3DValue() -> k
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    int getSelectedIndex() -> y
    void setSelectedIndex(int) -> w
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.geos.GeoElement getSelectedElement() -> c
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    boolean isTraceable() -> m_
    boolean isLimitedPath() -> o_
    boolean isPath() -> T
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void getNearestPoint(geogebra.common.kernel.kernelND.GeoPointND) -> c
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> u_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean justFontSize() -> l_
    boolean hasMoveableInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    java.util.ArrayList getFreeInputPoints(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> a
    boolean isCasEvaluableObject() -> A
    java.lang.String getCASString(geogebra.common.kernel.StringTemplate,boolean) -> a
    boolean listContains(geogebra.common.kernel.geos.GeoElement) -> f
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    int performScriptActions() -> z
    int find(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.geos.GeoLocus -> geogebra.common.i.i.H:
    boolean defined -> g
    java.util.ArrayList myPointList -> c
    java.lang.StringBuilder sbToString -> a
    double closestPointDist -> a
    int closestPointIndex -> l
    double closestPointParameter -> b
    boolean trace -> h
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    int getPointLength() -> c
    void clearPoints() -> e
    void insertPoint(double,double,boolean) -> a
    java.util.ArrayList getPoints() -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> t
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isDefined() -> v
    void setDefined(boolean) -> d
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInEuclidianView() -> c_
    boolean isGeoLocus() -> aQ
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    geogebra.common.kernel.MyPoint getClosestPoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    geogebra.common.kernel.geos.GeoLine getClosestLine(geogebra.common.kernel.geos.GeoPoint2) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isPath() -> T
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isVector3DValue() -> k
    boolean isLabelValueShowable() -> z
    void setPoints(java.util.ArrayList) -> a
    boolean isAuxiliaryObjectByDefault() -> ab
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    boolean isTraceable() -> m_
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
geogebra.common.kernel.geos.GeoNumeric -> geogebra.common.i.i.I:
    int DEFAULT_SLIDER_WIDTH_RW -> l
    int DEFAULT_SLIDER_WIDTH_PIXEL -> m
    int DEFAULT_SLIDER_WIDTH_PIXEL_ANGLE -> n
    double DEFAULT_SLIDER_MIN -> a
    double DEFAULT_SLIDER_MAX -> b
    double DEFAULT_SLIDER_INCREMENT -> c
    double DEFAULT_SLIDER_SPEED -> d
    double value -> e
    boolean isDrawable -> g
    int slopeTriangleSize -> o
    boolean intervalMinActive -> i
    boolean intervalMaxActive -> j
    geogebra.common.kernel.arithmetic.NumberValue intervalMin -> a
    geogebra.common.kernel.arithmetic.NumberValue intervalMax -> b
    double sliderWidth -> f
    double sliderX -> g
    double sliderY -> h
    boolean sliderFixed -> k
    boolean sliderHorizontal -> l
    double animationValue -> i
    boolean hasAbsoluteScreenLocation -> h
    java.lang.StringBuilder sbToString -> a
    java.util.ArrayList minMaxListeners -> c
    boolean randomSlider -> m
    java.util.Comparator comparator -> a
    java.util.ArrayList evListeners -> d
    java.lang.String getClassName() -> b
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void setZero() -> g_
    boolean isDrawable() -> q
    boolean isFillable() -> F
    void setDrawable(boolean) -> x
    void setEuclidianVisible(boolean) -> c
    int countSliders() -> f
    boolean isSlider() -> C
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    boolean isDefined() -> v
    boolean isInfinite() -> Q
    java.lang.String getLaTeXdescription() -> t
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    double getAnimationStep() -> h
    double getAnimationSpeed() -> i
    void setValue(double) -> e
    void setValue(double,boolean) -> a
    double getValue() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isSliderable() -> J
    boolean isFixable() -> u
    void getXMLsliderTag(java.lang.StringBuilder) -> m
    boolean isNumberValue() -> c
    boolean isGeoNumeric() -> aR
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    int getSlopeTriangleSize() -> i
    void setSlopeTriangleSize(int) -> t
    boolean isTextValue() -> e_
    void setIntervalMax(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void setIntervalMin(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void setSliderWidth(double) -> f
    void setSliderLocation(double,double,boolean) -> a
    double getIntervalMax() -> f
    double getIntervalMin() -> g
    double getSliderWidth() -> l
    double getSliderX() -> m
    double getSliderY() -> n
    boolean isIntervalMaxActive() -> M
    boolean isIntervalMinActive() -> N
    boolean isSliderFixed() -> O
    void setSliderFixed(boolean) -> y
    boolean isSliderHorizontal() -> P
    void setSliderHorizontal(boolean) -> z
    void setAbsoluteScreenLoc(int,int,boolean) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    void setRealWorldLoc(double,double) -> a
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    void setAbsoluteScreenLocActive(boolean) -> a
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
    geogebra.common.kernel.geos.GeoFunction getGeoFunction() -> a
    boolean isGeoFunctionable() -> aL
    void doRemove() -> d
    void registerMinMaxListener(geogebra.common.kernel.geos.GeoNumeric) -> a
    void unregisterMinMaxListener(geogebra.common.kernel.geos.GeoNumeric) -> b
    java.util.List getMinMaxListeners() -> b
    void setRandom(boolean) -> A
    boolean isRandom() -> bt
    void updateRandom() -> e
    double getRandom() -> d
    void update() -> i
    void resolveMinMax() -> g
    boolean isAnimatable() -> aq
    void setAnimating(boolean) -> m
    boolean doAnimationStep(double) -> a
    java.util.Comparator getComparator() -> a
    void updateRandomGeo() -> D
    boolean isVector3DValue() -> k
    int getMinimumLineThickness() -> s
    void setIntervalMin(double) -> b
    void setIntervalMax(double) -> a
    geogebra.common.kernel.geos.GeoElement getIntervalMinObject() -> c
    geogebra.common.kernel.geos.GeoElement getIntervalMaxObject() -> g
    boolean canHaveClickScript() -> s
    boolean isCasEvaluableObject() -> A
    void addEVSizeListener(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> b
    void removeEVSizeListener(geogebra.common.euclidian.EuclidianViewInterfaceSlim) -> c
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.util.ArrayList getSpreadsheetTraceList() -> a
geogebra.common.kernel.geos.GeoNumeric$1 -> geogebra.common.i.i.J:
    int compare(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoPoint2 -> geogebra.common.i.i.K:
    int pointSize -> l
    int pointStyle -> m
    double animationValue -> f
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.PathParameter pathParameter -> a
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.RegionParameters regionParameters -> a
    double x2D -> g
    double y2D -> h
    double inhomX -> a
    double inhomY -> b
    boolean isInfinite -> h
    boolean isDefined -> i
    boolean showUndefinedInAlgebraView -> j
    geogebra.common.kernel.prover.Variable variableCoordinate1 -> a
    geogebra.common.kernel.prover.Variable variableCoordinate2 -> b
    geogebra.common.kernel.prover.Variable[] botanaVars -> a
    geogebra.common.kernel.LocateableList locateableList -> a
    java.util.ArrayList changeableCoordNumbers -> c
    boolean hasPolarParentNumbers -> k
    geogebra.common.kernel.PathParameter tempPathParameter -> b
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.util.TreeSet tempSet -> a
    java.util.Comparator comparatorX -> a
    java.util.ArrayList incidenceList -> d
    java.util.ArrayList nonIncidenceList -> e
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    void setZero() -> g_
    geogebra.common.kernel.PathParameter getPathParameter() -> a
    geogebra.common.kernel.RegionParameters getRegionParameters() -> a
    java.lang.String getClassName() -> b
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void set(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoPoint2 copy() -> a
    void setPointSize(int) -> u
    int getPointSize() -> w
    int getPointStyle() -> x
    void setPointStyle(int) -> v
    boolean isChangeable() -> ak
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    boolean hasChangeableCoordParentNumbers() -> bb
    java.util.ArrayList getCoordParentNumbers() -> d
    boolean hasPolarParentNumbers() -> J
    geogebra.common.kernel.geos.GeoNumeric getCoordNumber(geogebra.common.kernel.arithmetic.ExpressionValue,boolean) -> a
    boolean isPointOnPath() -> al
    boolean isAnimatable() -> aq
    boolean hasPath() -> M
    geogebra.common.kernel.Path getPath() -> a
    void setPath(geogebra.common.kernel.Path) -> a
    void addToPathParameter(double) -> a
    boolean isInfinite() -> Q
    boolean isFinite() -> N
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    boolean isDefined() -> v
    void setUndefined() -> f
    boolean isFixable() -> u
    void setCoords2D(double,double,double) -> b
    void setCoords(double,double,double) -> a
    void setCoords(geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra.common.kernel.PathParameter getTempPathparameter() -> b
    void updateCoords() -> e
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    void setCoords(geogebra.common.kernel.geos.GeoVec2D) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void getInhomCoords(double[]) -> a_
    double getInhomX() -> c
    double getInhomY() -> d
    double[] vectorTo(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    double distanceSqr(geogebra.common.kernel.geos.GeoPoint2) -> b
    boolean collinear(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    double det(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    double affineRatio(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> t
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getStartPointXML() -> e
    boolean isAbsoluteStartPoint() -> O
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    void update() -> i
    java.util.TreeSet getTempSet() -> f
    geogebra.common.kernel.LocateableList getLocateableList() -> a
    void doRemove() -> d
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isGeoPoint() -> aS
    void showUndefinedInAlgebraView(boolean) -> d
    java.util.Comparator getComparatorX() -> a
    boolean isPointInRegion() -> bi
    boolean hasRegion() -> P
    geogebra.common.kernel.Region getRegion() -> a
    boolean isVector3DValue() -> k
    void updateCoords2D() -> g
    double getX2D() -> e
    double getY2D() -> f
    void updateCoordsFrom2D(boolean,geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> c
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD2(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> b
    boolean isMatrixTransformable() -> s_
    void matrixTransform(double,double,double,double) -> a
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> u_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean doAnimationStep(double) -> a
    void switchMoveMode() -> j
    int getMoveMode() -> c
    boolean isCasEvaluableObject() -> A
    boolean isFixed() -> Z
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void removePath() -> H
    void setCoords(double,double,double,double) -> b
    void moveDependencies(geogebra.common.kernel.geos.GeoElement) -> e
    java.util.ArrayList getIncidenceList() -> e
    java.util.ArrayList getNonIncidenceList() -> f
    void createIncidenceList() -> I
    void createNonIncidenceList() -> J
    void addIncidence(geogebra.common.kernel.geos.GeoElement) -> c
    void addNonIncidence(geogebra.common.kernel.geos.GeoElement) -> d
    void removeIncidence(geogebra.common.kernel.geos.GeoElement) -> j
    boolean addIncidenceWithProbabilisticChecking(geogebra.common.kernel.geos.GeoElement) -> f
    boolean isRandomizable() -> br
    void randomizeForProbabilisticChecking() -> G
    void randomizeForErrorEstimation() -> K
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    boolean movePoint(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void setX(double) -> b
    void setY(double) -> e
    void setZ(double) -> f
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
    geogebra.common.kernel.kernelND.GeoPointND copy() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoPoint2$1 -> geogebra.common.i.i.L:
    int compare(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoPolyLine -> geogebra.common.i.i.M:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    double length -> a
    boolean defined -> g
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.geos.GeoSegment seg -> a
    boolean trace -> h
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    int getNumPoints() -> c
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isFillable() -> F
    boolean isDefined() -> v
    void setDefined() -> e
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getLength() -> c
    double getDouble() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    boolean showInEuclidianView() -> c_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isGeoPolygon() -> aT
    boolean isGeoPolyLine() -> aE
    boolean isPath() -> T
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void setSegmentPoints(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
    geogebra.common.kernel.kernelND.GeoPointND getPointND(int) -> a
    void calcLength() -> g
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void matrixTransform(double,double,double,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isAllVertexLabelsSet() -> J
    boolean isVertexCountFixed() -> M
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint(int) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.Path getBoundary() -> a
geogebra.common.kernel.geos.GeoPolyLineInterface -> geogebra.common.i.i.N:
    boolean isAllVertexLabelsSet() -> J
    boolean isVertexCountFixed() -> M
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint(int) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    geogebra.common.kernel.Path getBoundary() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
geogebra.common.kernel.geos.GeoPolygon -> geogebra.common.i.i.O:
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.kernelND.GeoSegmentND[] segments -> a
    geogebra.common.kernel.geos.GeoPoint2 p0 -> a
    geogebra.common.kernel.geos.GeoPoint2 p1 -> b
    geogebra.common.kernel.geos.GeoPoint2 p2 -> c
    int numCS -> l
    double area -> a
    boolean defined -> g
    boolean initLabelsCalled -> h
    boolean createSegments -> i
    java.lang.StringBuilder sbToString -> a
    boolean asBoundary -> j
    boolean trace -> k
    geogebra.common.kernel.geos.ChangeableCoordParent changeableCoordParent -> a
    geogebra.common.kernel.Matrix.Coords interiorPoint -> a
    void setCoordSys(geogebra.common.kernel.Matrix.CoordSys) -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND[],geogebra.common.kernel.Matrix.CoordSys,boolean) -> a
    int getPointsLength() -> c
    double getPointX(int) -> a
    double getPointY(int) -> b
    void initLabels(java.lang.String[]) -> a
    boolean wasInitLabelsCalled() -> N
    void defaultSegmentLabels() -> H
    void setLabel(geogebra.common.kernel.kernelND.GeoSegmentND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void updateSegments() -> I
    void removeSegment(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoSegmentND,boolean) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoPolygon newGeoPolygon(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] copyPoints(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint() -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint(int) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getPointsND() -> b
    geogebra.common.kernel.kernelND.GeoSegmentND[] getSegments() -> a
    void setSegments(geogebra.common.kernel.kernelND.GeoSegmentND[]) -> a
    boolean isFillable() -> F
    boolean isInverseFillable() -> p_
    void calcArea() -> e
    double getArea() -> c
    double getMeasure() -> k
    geogebra.common.kernel.Path getBoundary() -> a
    double calcArea(geogebra.common.kernel.geos.GeoPoint2[]) -> a
    double calcAreaWithSign(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void calcCentroid(geogebra.common.kernel.geos.GeoPoint2) -> b
    double pointsClosedX(int) -> c
    double pointsClosedY(int) -> d
    double getAreaWithSign() -> d
    boolean isDefined() -> v
    void setDefined() -> g
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setEuclidianVisible(boolean) -> c
    void setEuclidianVisible(boolean,boolean) -> a
    void setObjColor(geogebra.common.awt.Color) -> b
    void setLineType(int) -> m
    void setLineType(int,boolean) -> a
    void setLineTypeHidden(int) -> n
    void setLineTypeHidden(int,boolean) -> b
    void setLineThickness(int) -> l
    void setLineThickness(int,boolean) -> d
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    boolean showInEuclidianView() -> c_
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isGeoPolygon() -> aT
    boolean isPath() -> T
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    boolean isRegion() -> U
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void setRegionChanged(geogebra.common.kernel.kernelND.GeoPointND,double,double) -> a
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void updateRegionCS(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void updateRegionCS() -> j
    int intersectOx(double,double,double,double) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isVector3DValue() -> k
    int getMinimumLineThickness() -> s
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    geogebra.common.kernel.Matrix.Coords getPoint3D(int) -> a
    boolean isPartOfClosedSurface() -> O
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    geogebra.common.kernel.Matrix.Coords getPoint(double,double) -> a_
    geogebra.common.kernel.Matrix.Coords[] getNormalProjection(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] getProjection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void setChangeableCoordParent(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoElement) -> a
    boolean hasChangeableCoordParentNumbers() -> bb
    void recordChangeableCoordParentNumbers() -> A
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void matrixTransform(double,double,double,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isAllVertexLabelsSet() -> J
    boolean isVertexCountFixed() -> M
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    java.lang.String getDefaultLabel(char[],boolean) -> a
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    void setInteriorPoint(geogebra.common.kernel.Matrix.Coords) -> b
geogebra.common.kernel.geos.GeoRay -> geogebra.common.i.i.P:
    boolean allowOutlyingIntersections -> h
    boolean keepTypeOnGeometricTransform -> i
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVec3D) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isGeoRay() -> aU
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    boolean isAllEndpointsLabelsSet() -> M
geogebra.common.kernel.geos.GeoScriptAction -> geogebra.common.i.i.Q:
    geogebra.common.kernel.commands.CmdScripting action -> a
    geogebra.common.kernel.arithmetic.Command command -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getTypeString() -> c
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getClassName() -> b
    void perform() -> e
geogebra.common.kernel.geos.GeoSegment -> geogebra.common.i.i.R:
    double length -> a
    boolean defined -> h
    boolean allowOutlyingIntersections -> i
    boolean keepTypeOnGeometricTransform -> j
    java.lang.StringBuilder sbToString -> a
    boolean forceSimpleTransform -> k
    geogebra.common.kernel.geos.GeoElement meta -> a
    java.lang.Integer[] getDecoTypes() -> a
    void setDecorationType(int) -> e
    void setPoints(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void setTwoPointsCoords(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVec3D) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void calcLength() -> H
    double getLength() -> c
    boolean isDefined() -> v
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    boolean isLimitedPath() -> o_
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    geogebra.common.kernel.geos.GeoElement getStartPointAsGeoElement() -> c
    geogebra.common.kernel.geos.GeoElement getEndPointAsGeoElement() -> g
    double getPointX(double) -> b
    double getPointY(double) -> c
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isGeoSegment() -> aV
    void setZero() -> g_
    boolean hasDrawable3D() -> r
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    double getParameter(double,double) -> a
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    boolean checkOnPath(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,boolean,double) -> a
    boolean isAllEndpointsLabelsSet() -> M
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isFromMeta() -> bs
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
    void setFromMeta(geogebra.common.kernel.geos.GeoElement) -> c
geogebra.common.kernel.geos.GeoSurfaceFinite -> geogebra.common.i.i.S:
geogebra.common.kernel.geos.GeoText -> geogebra.common.i.i.T:
    java.lang.String str -> c
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    boolean isLaTeX -> i
    geogebra.common.awt.Rectangle2D boundingBox -> a
    boolean needsUpdatedBoundingBox -> j
    boolean serifFont -> k
    int fontStyle -> l
    int fontSize -> m
    int printDecimals -> n
    int printFigures -> o
    boolean useSignificantFigures -> l
    boolean hasAbsoluteScreenLocation -> m
    java.lang.StringBuilder sbToString -> a
    boolean isTextCommand -> g
    boolean alwaysFixed -> h
    geogebra.common.kernel.StringTemplate tpl -> a
    java.util.Comparator comparator -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setTextString(java.lang.String) -> a
    java.lang.String getTextString() -> e
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void doRemove() -> d
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    boolean hasAbsoluteLocation() -> J
    void setWaitForStartPoint() -> b_
    void update() -> i
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    int getRelatedModeID() -> a
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isMoveable() -> an
    void setIsTextCommand(boolean) -> e
    boolean isTextCommand() -> bf
    boolean isLaTeXTextCommand() -> M
    void setAlgoMacroOutput(boolean) -> q
    void setAlwaysFixed(boolean) -> f
    boolean isFixable() -> u
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isGeoText() -> aW
    geogebra.common.kernel.arithmetic.MyStringBuffer getText() -> a
    void getXML(java.lang.StringBuilder) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getXMLlocation() -> f
    void setAllVisualProperties(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setSameLocation(geogebra.common.kernel.geos.GeoText) -> a
    boolean isLaTeX() -> N
    void setLaTeX(boolean,boolean) -> a
    void setAbsoluteScreenLoc(int,int) -> a
    int getAbsoluteScreenLocX() -> b
    int getAbsoluteScreenLocY() -> c
    double getRealWorldLocX() -> b
    double getRealWorldLocY() -> c
    void setRealWorldLoc(double,double) -> a
    void setAbsoluteScreenLocActive(boolean) -> a
    boolean isAbsoluteScreenLocActive() -> f
    boolean isAbsoluteScreenLocateable() -> i
    int getFontSize() -> f
    int getRelativeFontSize(int) -> a
    int getFontSizeIndex(int) -> b
    void setFontSize(int) -> a
    int getFontStyle() -> g
    void setFontStyle(int) -> b
    int getPrintDecimals() -> h
    int getPrintFigures() -> i
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean useSignificantFigures() -> t_
    boolean isSerifFont() -> B
    void setSerifFont(boolean) -> d
    void calculateCornerPoint(geogebra.common.kernel.geos.GeoPoint2,int) -> a
    geogebra.common.awt.Rectangle2D getBoundingBox() -> a
    void setBoundingBox(double,double,double,double) -> a
    boolean isNeedsUpdatedBoundingBox() -> O
    void setNeedsUpdatedBoundingBox(boolean) -> x
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void setZero() -> g_
    java.util.Comparator getComparator() -> a
    void updateTemplate() -> e
    boolean isAlwaysFixed() -> a
    boolean isAuxiliaryObjectByDefault() -> ab
    boolean justFontSize() -> l_
    boolean isRedefineable() -> am
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    boolean hasDrawable3D() -> r
    boolean hasBackgroundColor() -> E
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.common.kernel.geos.GeoText$1 -> geogebra.common.i.i.U:
    int compare(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.geos.GeoTextField -> geogebra.common.i.i.V:
    int defaultLength -> l
    int length -> m
    geogebra.common.kernel.geos.GeoElement linkedGeo -> a
    java.lang.String text -> c
    java.lang.String getClassName() -> b
    boolean isChangeable() -> ak
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    void setLinkedGeo(geogebra.common.kernel.geos.GeoElement) -> c
    geogebra.common.kernel.geos.GeoElement getLinkedGeo() -> c
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void setText(java.lang.String) -> a
    java.lang.String getText() -> e
    boolean isGeoTextField() -> at
    void setLength(int) -> c
    int getLength() -> w
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void updateLinkedGeo(java.lang.String) -> b
    void updateText(geogebra.common.util.TextObject) -> a
    void textObjectUpdated(geogebra.common.util.TextObject) -> b
    void textSubmitted() -> e
geogebra.common.kernel.geos.GeoTurtle -> geogebra.common.i.i.W:
    boolean defined -> g
    java.util.ArrayList turtleImageList -> c
    java.util.ArrayList cmdList -> d
    java.util.ArrayList timeList -> e
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    double[] position -> a
    geogebra.common.kernel.kernelND.GeoPointND currentPoint -> b
    geogebra.common.awt.Color penColor -> f
    int penThickness -> l
    boolean penDown -> h
    double turnAngle -> a
    double sinAngle -> b
    double cosAngle -> c
    int turtleImageIndex -> m
    int nCompletedCommands -> n
    double currentCommandProgress -> d
    double speed -> e
    boolean autoUpdate -> i
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.util.ArrayList getTurtleCommandList() -> d
    double getTurnAngle() -> a
    void setTurnAngle(double) -> a
    geogebra.common.kernel.kernelND.GeoPointND getPosition() -> a
    int getPenThickness() -> c
    geogebra.common.awt.Color getPenColor() -> a
    boolean getPenDown() -> C
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> b
    java.util.ArrayList getTurtleImageList() -> e
    int getTurtle() -> f
    void setTurtle(int) -> a
    double getSpeed() -> b
    void setSpeed(double) -> b
    int getNumberOfCompletedCommands() -> g
    double getCurrentCommandProgress() -> c
    void resetProgress() -> e
    void stepTurtle() -> g
    void stepTurtle(double) -> e
    void forward(double) -> f
    void setPosition(double,double) -> a
    void turn(double) -> g
    void setPenDown(boolean) -> a
    void setPenColor(geogebra.common.awt.Color) -> a
    void clear() -> j
    void doUpdate() -> H
    boolean isGeoTurtle() -> aN
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.geos.GeoUserInputElement -> geogebra.common.i.i.X:
    geogebra.common.kernel.arithmetic.ValidExpression userInput -> a
    boolean inputForm -> g
    boolean validInputForm -> h
    void setInputForm() -> e
    void setExtendedForm() -> g
    boolean isInputForm() -> J
    void setUserInput(geogebra.common.kernel.arithmetic.ValidExpression) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String toRawValueString(geogebra.common.kernel.StringTemplate) -> f
    void setValidInputForm(boolean) -> d
    boolean isValidInputForm() -> M
geogebra.common.kernel.geos.GeoVec2D -> geogebra.common.i.i.Y:
    double x -> a
    double y -> b
    int mode -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.StringBuilder sbToString -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    boolean isImaginaryUnit() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables() -> a
    void setX(double) -> a
    void setY(double) -> b
    void setCoords(geogebra.common.kernel.geos.GeoVec2D) -> a
    double getX() -> a
    double getY() -> b
    double[] getCoords() -> a
    double length() -> c
    void makeUnitVector() -> b
    double inner(geogebra.common.kernel.geos.GeoVec2D) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoVec2D) -> a
    void rotate(double) -> c
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(double) -> d
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> a
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.ListValue,geogebra.common.kernel.geos.GeoVec2D) -> a
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.ListValue,geogebra.common.kernel.geos.GeoVec2D,boolean) -> a
    void sub(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> b
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void mult(double) -> e
    void mult(geogebra.common.kernel.geos.GeoVec2D,double,geogebra.common.kernel.geos.GeoVec2D) -> a
    void complexDivide(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexDivide(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexMultiply(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> d
    void complexPower(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexSqrt(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> a
    void complexCbrt(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexConjugate(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    double arg(geogebra.common.kernel.geos.GeoVec2D) -> b
    void complexPower(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexExp(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> d
    void complexLog(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> e
    double complexAbs(geogebra.common.kernel.geos.GeoVec2D) -> c
    void complexPower(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D) -> e
    void vectorProduct(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void inner(geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.geos.GeoVec2D,geogebra.common.kernel.arithmetic.MyDouble) -> b
    void div(geogebra.common.kernel.geos.GeoVec2D,double,geogebra.common.kernel.geos.GeoVec2D) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    int getMode() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.StringTemplate) -> a
    java.util.HashSet getVariables() -> a
    void setMode(int) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void multiplyMatrix(geogebra.common.kernel.arithmetic.MyList) -> a
    void matrixTransform(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
    void multiplyMatrixAffine(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.GeoVec3D -> geogebra.common.i.i.Z:
    double x -> c
    double y -> d
    double z -> e
    boolean trace -> h
    boolean hasUpdatePrevilege -> g
    java.lang.StringBuilder sbToString -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setCoords(double,double,double) -> a
    double getX() -> g
    double getY() -> l
    double getZ() -> m
    void getCoords(double[]) -> c
    geogebra.common.kernel.Matrix.Coords getCoords() -> e
    void getInhomCoords(double[]) -> a_
    boolean isPolar() -> bt
    int getMode() -> y
    void setMode(int) -> a
    void setPolar() -> L
    void setCartesian() -> M
    void setComplex() -> N
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    boolean linDep(geogebra.common.kernel.geos.GeoVec3D) -> a
    boolean isZero() -> bu
    void cross(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D) -> a
    geogebra.common.kernel.Matrix.Coords cross(geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoVec3D) -> a
    void lineThroughPoints(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> a
    void lineThroughPointVector(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVec3D,geogebra.common.kernel.geos.GeoLine) -> a
    void cross(geogebra.common.kernel.geos.GeoVec3D,double,double,double,geogebra.common.kernel.geos.GeoVec3D) -> a
    void cross(double,double,double,double,double,double,geogebra.common.kernel.geos.GeoVec3D) -> a
    void changeSign() -> O
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    void getXMLtags(java.lang.StringBuilder) -> b
    void getXMLtagsMinimal(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    void setZero() -> g_
    void rotateXY(geogebra.common.kernel.arithmetic.NumberValue) -> d
    void mirrorXY(double) -> g
geogebra.common.kernel.geos.GeoVector -> geogebra.common.i.i.aa:
    geogebra.common.kernel.geos.GeoPoint2 startPoint -> a
    geogebra.common.kernel.geos.GeoSegment pathSegment -> a
    geogebra.common.kernel.geos.GeoPoint2 pathStartPoint -> b
    geogebra.common.kernel.geos.GeoPoint2 pathEndPoint -> c
    boolean waitingForStartPoint -> h
    java.util.HashSet waitingPointSet -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.lang.StringBuilder sb -> c
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isCasEvaluableObject() -> A
    void setCoords(double,double,double) -> a
    void setCoords(double[]) -> b
    void setCoords(geogebra.common.kernel.geos.GeoVec3D) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.geos.GeoVec2D getInhomVec() -> b
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint() -> a
    geogebra.common.kernel.geos.GeoPoint2[] getStartPoints() -> a
    boolean hasAbsoluteLocation() -> J
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    void setWaitForStartPoint() -> b_
    void doRemove() -> d
    boolean isFinite() -> M
    boolean isInfinite() -> Q
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void matrixTransform(double,double,double,double) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoVec2D getVector() -> a
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isClosedPath() -> u_
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isPath() -> T
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.PathMover createPathMover() -> a
    void initPathSegment() -> g
    void updatePathSegment() -> j
    boolean isGeoVector() -> aX
    boolean isAlwaysFixed() -> a
    boolean isVector3DValue() -> k
    boolean isMatrixTransformable() -> s_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> a
    boolean hasDrawable3D() -> r
    void updateStartPointPosition() -> e
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    geogebra.common.kernel.algos.SymbolicParameters getSymbolicParameters() -> a
    int[] getFreeVariablesAndDegrees(java.util.HashSet) -> a
    java.math.BigInteger[] getExactCoordinates(java.util.HashMap) -> a
    geogebra.common.kernel.prover.Polynomial[] getPolynomials() -> a
    geogebra.common.kernel.prover.Variable[] getBotanaVars() -> a
    geogebra.common.kernel.prover.Polynomial[] getBotanaPolynomials() -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.geos.LabelManager -> geogebra.common.i.i.ab:
    java.util.Set invalidFunctionNames -> a
    boolean checkName(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
geogebra.common.kernel.geos.LimitedPath -> geogebra.common.i.i.ac:
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isAllEndpointsLabelsSet() -> M
geogebra.common.kernel.geos.LineProperties -> geogebra.common.i.i.ad:
geogebra.common.kernel.geos.Mirrorable -> geogebra.common.i.i.ae:
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
geogebra.common.kernel.geos.ParametricCurve -> geogebra.common.i.i.af:
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionX() -> a
    geogebra.common.kernel.roots.RealRootFunction getRealRootFunctionY() -> b
    void evaluateCurve(double,double[]) -> a
    geogebra.common.kernel.geos.GeoVec2D evaluateCurve(double) -> a
    boolean isFunctionInX() -> J
geogebra.common.kernel.geos.PointProperties -> geogebra.common.i.i.ag:
    void setPointSize(int) -> u
    int getPointSize() -> w
    void setPointStyle(int) -> v
    int getPointStyle() -> x
    void updateRepaint() -> x
geogebra.common.kernel.geos.PointRotateable -> geogebra.common.i.i.ah:
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
geogebra.common.kernel.geos.Rotateable -> geogebra.common.i.i.ai:
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.common.kernel.geos.SpreadsheetTraceable -> geogebra.common.i.i.aj:
    java.util.ArrayList getSpreadsheetTraceList() -> a
    java.util.ArrayList getColumnHeadings() -> b
geogebra.common.kernel.geos.Test -> geogebra.common.i.i.ak:
    geogebra.common.kernel.geos.Test GEOANGLE -> a
    geogebra.common.kernel.geos.Test GEODUMMYVARIABLE -> b
    geogebra.common.kernel.geos.Test GEONUMERIC -> c
    geogebra.common.kernel.geos.Test GEOAXIS -> d
    geogebra.common.kernel.geos.Test GEOSEGMENT -> e
    geogebra.common.kernel.geos.Test GEORAY -> f
    geogebra.common.kernel.geos.Test GEOLINE -> g
    geogebra.common.kernel.geos.Test GEOVECTOR -> h
    geogebra.common.kernel.geos.Test GEOBOOLEAN -> i
    geogebra.common.kernel.geos.Test GEOTEXTFIELD -> j
    geogebra.common.kernel.geos.Test GEOBUTTON -> k
    geogebra.common.kernel.geos.Test GEOCASCELL -> l
    geogebra.common.kernel.geos.Test GEOCONICPART -> m
    geogebra.common.kernel.geos.Test GEOCONIC -> n
    geogebra.common.kernel.geos.Test GEOCURVECARTESIAN -> o
    geogebra.common.kernel.geos.Test GEOFUNCTIONCONDITIONAL -> p
    geogebra.common.kernel.geos.Test GEOINTERVAL -> q
    geogebra.common.kernel.geos.Test GEOFUNCTION -> r
    geogebra.common.kernel.geos.Test GEOFUNCTIONNVAR -> s
    geogebra.common.kernel.geos.Test GEOIMAGE -> t
    geogebra.common.kernel.geos.Test GEOLIST -> u
    geogebra.common.kernel.geos.Test GEOLOCUS -> v
    geogebra.common.kernel.geos.Test GEOPOINT2 -> w
    geogebra.common.kernel.geos.Test GEOPOLYGON -> x
    geogebra.common.kernel.geos.Test GEOPOLYLINE -> y
    geogebra.common.kernel.geos.Test GEOSCRIPTACTION -> z
    geogebra.common.kernel.geos.Test GEOTEXT -> A
    geogebra.common.kernel.geos.Test GEOIMPLICITPOLY -> B
    geogebra.common.kernel.geos.Test GEOUSERINPUTELEMENT -> C
    geogebra.common.kernel.geos.Test GEOCONICND -> D
    geogebra.common.kernel.geos.Test GEOQUADRICND -> E
    geogebra.common.kernel.geos.Test MOVEABLE -> F
    geogebra.common.kernel.geos.Test ROTATEMOVEABLE -> G
    geogebra.common.kernel.geos.Test GEOELEMENT -> H
    geogebra.common.kernel.geos.Test GEOCOORDSYS2D -> I
    geogebra.common.kernel.geos.Test GEOSEGMENTND -> J
    geogebra.common.kernel.geos.Test GEOLINEND -> K
    geogebra.common.kernel.geos.Test GEOVECTORND -> L
    geogebra.common.kernel.geos.Test GEODIRECTIONND -> M
    geogebra.common.kernel.geos.Test GEOPOINTND -> N
    geogebra.common.kernel.geos.Test NUMBERVALUE -> O
    geogebra.common.kernel.geos.Test PATH -> P
    geogebra.common.kernel.geos.Test TRANSLATEABLE -> Q
    geogebra.common.kernel.geos.Test GEOQUADRIC3D -> R
    geogebra.common.kernel.geos.Test GEOPOLYGON3D -> S
    geogebra.common.kernel.geos.Test GEOCOORDSYS1D -> T
    geogebra.common.kernel.geos.Test TRANSFORMABLE -> U
    geogebra.common.kernel.geos.Test DILATEABLE -> V
    geogebra.common.kernel.geos.Test REGION3D -> W
    geogebra.common.kernel.geos.Test OBJECT -> X
    geogebra.common.kernel.geos.Test[] ENUM$VALUES -> a
    boolean check(java.lang.Object) -> a
    geogebra.common.kernel.geos.Test getSpecificTest(java.lang.Object) -> a
    geogebra.common.kernel.geos.Test[] values() -> values
    geogebra.common.kernel.geos.Test valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.geos.Test$1 -> geogebra.common.i.i.al:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$10 -> geogebra.common.i.i.am:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$11 -> geogebra.common.i.i.an:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$12 -> geogebra.common.i.i.ao:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$13 -> geogebra.common.i.i.ap:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$14 -> geogebra.common.i.i.aq:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$15 -> geogebra.common.i.i.ar:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$16 -> geogebra.common.i.i.as:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$17 -> geogebra.common.i.i.at:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$18 -> geogebra.common.i.i.au:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$19 -> geogebra.common.i.i.av:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$2 -> geogebra.common.i.i.aw:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$20 -> geogebra.common.i.i.ax:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$21 -> geogebra.common.i.i.ay:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$22 -> geogebra.common.i.i.az:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$23 -> geogebra.common.i.i.aA:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$24 -> geogebra.common.i.i.aB:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$25 -> geogebra.common.i.i.aC:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$26 -> geogebra.common.i.i.aD:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$27 -> geogebra.common.i.i.aE:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$28 -> geogebra.common.i.i.aF:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$29 -> geogebra.common.i.i.aG:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$3 -> geogebra.common.i.i.aH:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$30 -> geogebra.common.i.i.aI:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$31 -> geogebra.common.i.i.aJ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$32 -> geogebra.common.i.i.aK:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$33 -> geogebra.common.i.i.aL:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$34 -> geogebra.common.i.i.aM:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$35 -> geogebra.common.i.i.aN:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$36 -> geogebra.common.i.i.aO:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$37 -> geogebra.common.i.i.aP:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$38 -> geogebra.common.i.i.aQ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$39 -> geogebra.common.i.i.aR:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$4 -> geogebra.common.i.i.aS:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$40 -> geogebra.common.i.i.aT:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$41 -> geogebra.common.i.i.aU:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$42 -> geogebra.common.i.i.aV:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$43 -> geogebra.common.i.i.aW:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$44 -> geogebra.common.i.i.aX:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$45 -> geogebra.common.i.i.aY:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$46 -> geogebra.common.i.i.aZ:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$47 -> geogebra.common.i.i.ba:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$48 -> geogebra.common.i.i.bb:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$49 -> geogebra.common.i.i.bc:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$5 -> geogebra.common.i.i.bd:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$50 -> geogebra.common.i.i.be:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$6 -> geogebra.common.i.i.bf:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$7 -> geogebra.common.i.i.bg:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$8 -> geogebra.common.i.i.bh:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.Test$9 -> geogebra.common.i.i.bi:
    boolean check(java.lang.Object) -> a
geogebra.common.kernel.geos.TextProperties -> geogebra.common.i.i.bj:
    int getFontSize() -> f
    void setFontSize(int) -> a
    int getFontStyle() -> g
    void setFontStyle(int) -> b
    int getPrintDecimals() -> h
    int getPrintFigures() -> i
    void setPrintDecimals(int,boolean) -> a
    void setPrintFigures(int,boolean) -> b
    boolean isSerifFont() -> B
    void setSerifFont(boolean) -> d
    boolean useSignificantFigures() -> t_
    boolean justFontSize() -> l_
geogebra.common.kernel.geos.ToGeoElement -> geogebra.common.i.i.bk:
    geogebra.common.kernel.geos.GeoElement toGeoElement() -> a_
geogebra.common.kernel.geos.Traceable -> geogebra.common.i.i.bl:
    boolean getTrace() -> C
    void setTrace(boolean) -> a
    void updateRepaint() -> x
geogebra.common.kernel.geos.Transformable -> geogebra.common.i.i.bm:
geogebra.common.kernel.geos.Translateable -> geogebra.common.i.i.bn:
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
geogebra.common.kernel.implicit.AlgoAsymptoteImplicitPoly -> geogebra.common.i.j.a:
    geogebra.common.kernel.implicit.GeoImplicitPoly ip -> a
    geogebra.common.kernel.geos.GeoList g -> a
    geogebra.common.kernel.EquationSolverInterface solver -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void makeLines(java.util.ArrayList,double,double) -> a
    void compute() -> b
geogebra.common.kernel.implicit.AlgoDependentImplicitPoly -> geogebra.common.i.j.b:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[][] coeff -> a
    geogebra.common.kernel.geos.GeoElement geoElement -> a
    java.util.Set dependentFromFunctions -> a
    void compute() -> b
    void replaceGeoElement(geogebra.common.kernel.geos.GeoElement) -> d
    geogebra.common.kernel.arithmetic.Equation getEquation() -> a
    void compute(boolean) -> c
    void setLine() -> e
    void setConic() -> f
    void addAllFunctionalDescendents(geogebra.common.kernel.algos.AlgoElement,java.util.Set,java.util.Set) -> a
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRealString(geogebra.common.kernel.StringTemplate) -> c
    java.lang.String toExpString(geogebra.common.kernel.StringTemplate) -> g
geogebra.common.kernel.implicit.AlgoImplicitPolyFunction -> geogebra.common.i.j.c:
    geogebra.common.kernel.geos.GeoFunctionNVar function -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getImplicitPoly() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.implicit.AlgoImplicitPolyTangentCurve -> geogebra.common.i.j.d:
    geogebra.common.kernel.implicit.GeoImplicitPoly poly -> a
    geogebra.common.kernel.geos.GeoPoint2 point -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly tangentPoly -> b
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getTangentCurve() -> a
geogebra.common.kernel.implicit.AlgoImplicitPolyThroughPoints -> geogebra.common.i.j.e:
    geogebra.common.kernel.geos.GeoList P -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly implicitPoly -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly getImplicitPoly() -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.implicit.AlgoIntersectImplicitpolyParametric -> geogebra.common.i.j.f:
    org.apache.commons.math.analysis.polynomials.PolynomialFunction tx -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction ty -> b
    geogebra.common.kernel.implicit.GeoImplicitPoly p -> a
    geogebra.common.kernel.geos.GeoLine l -> a
    geogebra.common.kernel.geos.GeoFunction f -> a
    geogebra.common.kernel.geos.GeoPoint2[] tangentPoints -> a
    double getYValue(double) -> a
    double getXValue(double) -> b
    void compute() -> b
    void mergeWithTangentPoints() -> f
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys -> geogebra.common.i.j.g:
    geogebra.common.kernel.implicit.GeoImplicitPoly p1 -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly p2 -> b
    geogebra.common.kernel.geos.GeoConic c1 -> a
    java.util.List valPairs -> a
    int univarType -> a
    java.util.List hints -> b
    double getYValue(double) -> a
    void compute() -> b
    int getNearRoots(double[],geogebra.common.kernel.EquationSolverInterface,double) -> a
    void insert(double[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
geogebra.common.kernel.implicit.AlgoTangentImplicitpoly -> geogebra.common.i.j.h:
    geogebra.common.kernel.implicit.GeoImplicitPoly p -> a
    geogebra.common.kernel.geos.GeoPoint2 R -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.geos.GeoPoint2[] ip -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler tangents -> a
    boolean pointOnPath -> a
    geogebra.common.kernel.implicit.AlgoIntersectImplicitpolys algoIntersect -> a
    java.lang.String[] labels -> a
    void setInputOutput() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    geogebra.common.kernel.geos.GeoLine[] getTangents() -> a
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.geos.GeoPoint2[] getTangentPoints() -> a
geogebra.common.kernel.implicit.AlgoTangentImplicitpoly$1 -> geogebra.common.i.j.i:
    geogebra.common.kernel.implicit.AlgoTangentImplicitpoly this$0 -> a
    geogebra.common.kernel.geos.GeoLine newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra.common.kernel.implicit.GeoImplicitPoly -> geogebra.common.i.j.j:
    double[][] coeff -> a
    double[][] coeffSquarefree -> b
    int degX -> l
    int degY -> m
    boolean defined -> g
    boolean isConstant -> h
    boolean calcPath -> i
    boolean trace -> j
    geogebra.common.kernel.geos.GeoLocus locus -> a
    java.util.List singularitiesCollection -> a
    java.util.List boundaryIntersectCollection -> b
    boolean[][] remember -> a
    geogebra.common.kernel.implicit.GeoImplicitPoly$GridRect[][] grid -> a
    int gridWidth -> n
    int gridHeight -> o
    double scaleX -> a
    double scaleY -> b
    double minGap -> c
    void preventPathCreation() -> j
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isDefined() -> v
    boolean isOnScreen() -> N
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isGeoImplicitPoly() -> aF
    boolean isPath() -> T
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    void setDefined() -> H
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    void addPow(java.lang.StringBuilder,int,geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toRawValueString(geogebra.common.kernel.StringTemplate) -> f
    java.lang.String getClassName() -> b
    boolean isVector3DValue() -> k
    void setCoeff(double[][]) -> a
    void setCoeff(double[][],boolean) -> a
    void setCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][]) -> a
    void setCoeff(geogebra.common.kernel.arithmetic.ExpressionValue[][],boolean) -> a
    double[][] getCoeff(boolean) -> a
    double[][] getCoeff() -> a
    double evalPolyAt(double,double) -> a
    double evalPolyAt(double,double,boolean) -> a
    double evalPolyCoeffAt(double,double,double[][]) -> a
    double evalDiffXPolyAt(double,double) -> b
    double evalDiffXPolyAt(double,double,boolean) -> b
    double evalDiffYPolyAt(double,double) -> c
    double evalDiffYPolyAt(double,double,boolean) -> c
    void plugInRatPoly(double[][],double[][],double[][],double[][]) -> a
    void plugInPoly(double[][],double[][]) -> a
    void polyMult(double[][],double[][],int,int,int,int) -> a
    boolean isConstant() -> b_
    int getDegX() -> c
    int getDegY() -> f
    void getFactors() -> J
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    void throughPoints(geogebra.common.kernel.geos.GeoList) -> b
    void throughPoints(java.util.ArrayList) -> a
    void polishPointOnPath(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isClosedPath() -> u_
    geogebra.common.kernel.PathMover createPathMover() -> a
    boolean isTraceable() -> m_
    void setTrace(boolean) -> a
    boolean getTrace() -> C
    int getDeg() -> g
    void mirror(geogebra.common.kernel.geos.GeoConic) -> a
    void mirror(geogebra.common.kernel.geos.GeoPoint2) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void translate(double,double) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    boolean isTranslateable() -> q_
    char getLabelDelimiter() -> a
    boolean euclidianViewUpdate() -> a
    int epsSignum(double) -> a
    void updatePath() -> I
    void updatePath(double,double,double,double,double) -> a
    double scaledNormSquared(double,double) -> d
    void startPath(int,int,double,double,geogebra.common.kernel.geos.GeoLocus) -> a
    double bisec(double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoLocus getLocus() -> a
geogebra.common.kernel.implicit.GeoImplicitPoly$GridRect -> geogebra.common.i.j.j$a:
    double x -> a
    double y -> b
    double width -> c
    double height -> d
    int[] eval -> a
geogebra.common.kernel.implicit.PolynomialUtils -> geogebra.common.i.j.k:
    double[] polynomialDivision(double[],double[]) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction polynomialDivision(org.apache.commons.math.analysis.polynomials.PolynomialFunction,org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    int getDegree(double[]) -> a
    double getLeadingCoeff(double[]) -> a
    double getLeadingCoeff(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    double eval(double[],double) -> a
    double[][] coeffMinDeg(double[][]) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,double[]) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    boolean rootPolishing(double[],geogebra.common.kernel.implicit.GeoImplicitPoly,geogebra.common.kernel.implicit.GeoImplicitPoly,double[]) -> a
geogebra.common.kernel.integration.EllipticArcLength -> geogebra.common.i.k.a:
    double[] halfAxes -> a
    geogebra.common.kernel.roots.RealRootFunction arcLengthFunction -> a
    double compute(double,double) -> a
geogebra.common.kernel.integration.EllipticArcLength$EllipticArcLengthFunction -> geogebra.common.i.k.a$a:
    geogebra.common.kernel.integration.EllipticArcLength this$0 -> a
    double evaluate(double) -> a
geogebra.common.kernel.kernelND.AlgoIntersectND -> geogebra.common.i.l.a:
    int numberOfUsers -> a
    boolean[] didSetIntersectionPoint -> a
    void avoidDoubleTangentPoint() -> a
    void noUndefinedPointsInAlgebraView() -> q
    void addUser() -> r
    void removeUser() -> s
    geogebra.common.kernel.kernelND.GeoPointND[] getIntersectionPoints() -> b
    geogebra.common.kernel.kernelND.GeoPointND[] getLastDefinedIntersectionPoints() -> a
    void setIntersectionPoint(int,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean didSetIntersectionPoint(int) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void remove() -> c
geogebra.common.kernel.kernelND.AlgoMidpointND -> geogebra.common.i.l.b:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.kernelND.GeoPointND M -> c
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    void compute() -> b
    void copyCoords(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void computeMidCoords() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND getP() -> b
    geogebra.common.kernel.kernelND.GeoPointND getQ() -> c
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.kernelND.Geo3DVec -> geogebra.common.i.l.c:
    boolean isEqual(geogebra.common.kernel.kernelND.Geo3DVec) -> a
    double getX() -> a
    double getY() -> b
    double getZ() -> c
    void multiplyMatrix(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
geogebra.common.kernel.kernelND.GeoAxisND -> geogebra.common.i.l.d:
    java.lang.String getAxisLabel() -> d
    java.lang.String getUnitLabel() -> e
    int getTickStyle() -> f
    boolean getShowNumbers() -> n
    geogebra.common.util.NumberFormatAdapter getNumberFormat() -> a
    double getNumbersDistance() -> c
    int getTickSize() -> g
    void updateDecorations(double,geogebra.common.util.NumberFormatAdapter,int,int,int,int) -> a
    int getNumbersXOffset() -> h
    int getNumbersYOffset() -> i
    int getType() -> c
geogebra.common.kernel.kernelND.GeoConicND -> geogebra.common.i.l.e:
    java.lang.String[] vars -> a
    java.lang.String[] varsLateX -> b
    java.lang.String[] varsCAS -> c
    boolean KEEP_LEADING_SIGN -> g
    geogebra.common.kernel.geos.GeoPoint2 singlePoint -> a
    geogebra.common.kernel.geos.GeoLine[] lines -> a
    geogebra.common.kernel.geos.GeoVec2D[] eigenvec -> a
    double eigenvecX -> a
    double eigenvecY -> b
    double maxCoeffAbs -> c
    geogebra.common.awt.AffineTransform transform -> a
    geogebra.common.awt.AffineTransform oldTransform -> b
    boolean trace -> h
    geogebra.common.kernel.geos.GeoVec2D b -> a
    geogebra.common.kernel.geos.GeoPoint2[] startPoints -> a
    java.util.ArrayList pointsOnConic -> c
    double detS -> h
    double length -> i
    double temp -> j
    double temp1 -> k
    double temp2 -> l
    double nx -> m
    double ny -> n
    double lambda -> o
    int index -> m
    double[] eigenval -> e
    double[] mu -> a
    geogebra.common.kernel.geos.GeoVec2D c -> b
    double errDetS -> d
    double[] coeffs -> f
    boolean eigenvectorsSetOnLoad -> j
    double area -> p
    boolean isEndOfQuadric -> k
    geogebra.common.kernel.kernelND.GeoConicND$HitType lastHitType -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec(int) -> d
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    geogebra.common.kernel.Matrix.Coords getDirection3D(int) -> b
    geogebra.common.kernel.Matrix.Coords getOrigin3D(int) -> c
    geogebra.common.kernel.Matrix.CoordMatrix getSymetricMatrix(double[]) -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isPath() -> T
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pointChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> a
    double[] getPerpendicularParams(double,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean compatibleType(int) -> c
    void pathChanged(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.PathParameter) -> b
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnFullConic(geogebra.common.kernel.kernelND.GeoPointND,double) -> b
    boolean isOnFullConic(geogebra.common.kernel.Matrix.Coords,double) -> a
    geogebra.common.kernel.PathMover createPathMover() -> a
    void coordsEVtoRW(geogebra.common.kernel.Matrix.Coords) -> b
    void coordsRWtoEV(geogebra.common.kernel.Matrix.Coords) -> d
    boolean isFillable() -> F
    void setMatrix(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    java.util.ArrayList getPointsOnConic() -> d
    void setPointsOnConic(java.util.ArrayList) -> a
    void addPointOnConic(geogebra.common.kernel.kernelND.GeoPointND) -> e
    void removePointOnConic(geogebra.common.kernel.kernelND.GeoPointND) -> f
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void update() -> i
    void setToStringMode(int) -> a
    int getToStringMode() -> f
    boolean isCircle() -> N
    void setToSpecific() -> e
    void setToImplicit() -> g
    void setToExplicit() -> j
    boolean isSpecificPossible() -> O
    boolean isExplicitPossible() -> P
    boolean checkDefined() -> C
    boolean showInEuclidianView() -> c_
    boolean showInAlgebraView() -> t
    boolean isLineConic() -> bt
    boolean isDegenerate() -> bu
    void setCoeffs(double[]) -> a
    void setCoeffs(double,double,double,double,double,double) -> a
    java.lang.String toValueStringMinimal(geogebra.common.kernel.StringTemplate) -> t
    java.lang.String toStringMinimal(geogebra.common.kernel.StringTemplate) -> s
    java.lang.String getXMLtagsMinimal() -> e
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate,double[]) -> a
    double[] getHalfAxes() -> a
    geogebra.common.kernel.geos.GeoLine[] getLines() -> a
    geogebra.common.kernel.geos.GeoPoint2 getSinglePoint() -> a
    geogebra.common.awt.AffineTransform getAffineTransform() -> a
    void setAffineTransform() -> H
    geogebra.common.kernel.geos.GeoVec2D getTranslationVector() -> a
    double getCircleRadius() -> l
    void coordsEVtoRW(geogebra.common.kernel.geos.GeoPoint2) -> b
    void coordsRWtoEV(geogebra.common.kernel.geos.GeoPoint2) -> a
    double[] getMatrix() -> b
    void setMatrix(double[]) -> b
    void setDegenerateMatrixFromArray(double[]) -> c
    void setMatrix(double[][]) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setCircle(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoSegment) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCircleMatrix(geogebra.common.kernel.geos.GeoPoint2,double) -> b
    void setParabola(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> a
    void setEllipseHyperbola(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
    void translate(double,double) -> a
    void doTranslate(geogebra.common.kernel.Matrix.Coords) -> c
    void doTranslate(double,double) -> b
    void translateMatrix(double[],double,double) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void rotate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> b
    boolean isMatrixTransformable() -> s_
    void matrixTransform(double,double,double,double) -> a
    void rotate(double) -> a
    void rotateMatrix(double[],double) -> a
    void dilate(geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoPoint2) -> a
    void doDilate(double) -> b
    void updateDegenerates() -> I
    void setEigenvectors(double,double,double,double,double,double) -> b
    void setFirstEigenvector(double[]) -> d
    void setEigenvectors() -> J
    void setParabolicEigenvectors() -> Q
    void makePathParametersInvalid() -> R
    void classifyConic() -> S
    void classifyConic(boolean) -> f
    boolean isDetSzero() -> J
    void classifyMidpointConic(boolean) -> a
    void singlePoint() -> K
    void intersectingLines(double[]) -> g
    void ellipse(double[]) -> h
    void hyperbola(double[]) -> i
    void classifyParabolicConic(boolean) -> d
    void doubleLine() -> T
    void enforceDoubleLine() -> L
    void handleSzero() -> U
    void parallelLines(double[]) -> e
    void setStartPointsForLines() -> V
    void parabola() -> W
    boolean hasPositiveEigenvectorOrientation() -> bv
    void setPositiveEigenvectorOrientation(boolean) -> x
    boolean isIntersectionPointIncident(geogebra.common.kernel.geos.GeoPoint2,double) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    double evaluate(double,double) -> a
    void polarLine(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> b
    void diameterLine(geogebra.common.kernel.geos.GeoVector,geogebra.common.kernel.geos.GeoLine) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getSpecificEquation() -> f
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isGeoConic() -> aG
    void setZero() -> g_
    boolean isVector3DValue() -> k
    void setMidpoint(double[]) -> f
    boolean isRegion() -> U
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isInRegion(double,double) -> a
    double evaluateInSignificantPoint() -> m
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void moveBackToRegion(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.RegionParameters) -> a
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void toGeoImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    boolean keepsType() -> bw
    double distance(geogebra.common.kernel.geos.GeoPoint2) -> a
    java.lang.String getTypeString() -> c
    void calcArea() -> M
    double getArea() -> g
    void setIsEndOfQuadric(boolean) -> y
    boolean isEndOfQuadric() -> bx
    void doRemove() -> d
    void setLastHitType(geogebra.common.kernel.kernelND.GeoConicND$HitType) -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType getLastHitType() -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.kernelND.GeoConicND$HitType -> geogebra.common.i.l.e$a:
    geogebra.common.kernel.kernelND.GeoConicND$HitType NONE -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType ON_BOUNDARY -> b
    geogebra.common.kernel.kernelND.GeoConicND$HitType ON_FILLING -> c
    geogebra.common.kernel.kernelND.GeoConicND$HitType[] ENUM$VALUES -> a
    geogebra.common.kernel.kernelND.GeoConicND$HitType[] values() -> values
    geogebra.common.kernel.kernelND.GeoConicND$HitType valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.kernelND.GeoCoordSys -> geogebra.common.i.l.f:
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
geogebra.common.kernel.kernelND.GeoCoordSys1DInterface -> geogebra.common.i.l.g:
geogebra.common.kernel.kernelND.GeoCoordSys2D -> geogebra.common.i.l.h:
geogebra.common.kernel.kernelND.GeoCurveCartesianND -> geogebra.common.i.l.i:
    geogebra.common.kernel.arithmetic.Function[] fun -> a
    double startParam -> b
    double endParam -> c
    boolean isDefined -> g
    boolean isGeoCurveCartesian() -> aY
    void replaceChildrenByValues(geogebra.common.kernel.geos.GeoElement) -> c
    void setInterval(double,double) -> a
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isPath() -> T
    boolean isDefined() -> v
    void setDefined(boolean) -> e
    void setUndefined() -> f
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toSymbolicString(geogebra.common.kernel.StringTemplate) -> b_
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.kernelND.GeoDirectionND -> geogebra.common.i.l.j:
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
geogebra.common.kernel.kernelND.GeoElementND -> geogebra.common.i.l.k:
    void setLabel(java.lang.String) -> f
    void update() -> i
    void setObjColor(geogebra.common.awt.Color) -> b
    void setEuclidianVisible(boolean) -> c
    boolean isEuclidianVisible() -> X
    boolean isLabelSet() -> g_
    java.lang.String getLabel(geogebra.common.kernel.StringTemplate) -> e
    boolean isInfinite() -> Q
    void updateVisualStyle() -> y
    void remove() -> c
    boolean getSpreadsheetTrace() -> bd
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    boolean isIndependent() -> h
    geogebra.common.kernel.algos.AlgoElement getParentAlgorithm() -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    void setLineType(int) -> m
    void setLineThickness(int) -> l
    void setLabelVisible(boolean) -> k
    boolean isPointOnPath() -> al
    boolean isPointInRegion() -> bi
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
geogebra.common.kernel.kernelND.GeoLevelOfDetail -> geogebra.common.i.l.l:
    geogebra.common.kernel.kernelND.LevelOfDetail getLevelOfDetail() -> a
geogebra.common.kernel.kernelND.GeoLineND -> geogebra.common.i.l.m:
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    boolean getTrace() -> C
    geogebra.common.kernel.Matrix.Coords getCartesianEquationVector(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getStartInhomCoords() -> c
    geogebra.common.kernel.Matrix.Coords getEndInhomCoords() -> d
    double getMinParameter() -> b
    double getMaxParameter() -> a_
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    geogebra.common.kernel.kernelND.GeoPointND getEndPoint() -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void addPointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> c
geogebra.common.kernel.kernelND.GeoPlaneND -> geogebra.common.i.l.n:
    void setFading(float) -> a_
    float getFading() -> a_
geogebra.common.kernel.kernelND.GeoPointND -> geogebra.common.i.l.o:
    boolean hasChangeableCoordParentNumbers() -> bb
    geogebra.common.kernel.RegionParameters getRegionParameters() -> a
    void updateCoords2D() -> g
    double getX2D() -> e
    double getY2D() -> f
    void updateCoordsFrom2D(boolean,geogebra.common.kernel.Matrix.CoordSys) -> a
    int getMode() -> y
    boolean isFinite() -> N
    void set(geogebra.common.kernel.kernelND.GeoPointND) -> c
    java.lang.String getStartPointXML() -> e
    geogebra.common.kernel.LocateableList getLocateableList() -> a
    double[] vectorTo(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> c
    void getInhomCoords(double[]) -> a_
    boolean hasPath() -> M
    geogebra.common.kernel.PathParameter getPathParameter() -> a
    boolean hasRegion() -> P
    void setCoords(double,double,double) -> a
    void setCoords(double,double,double,double) -> b
    void setCoords(geogebra.common.kernel.Matrix.Coords,boolean) -> a
    void setCoords2D(double,double,double) -> b
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> b
    geogebra.common.kernel.Matrix.Coords getCoordsInD2(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Path getPath() -> a
    geogebra.common.kernel.Region getRegion() -> a
    void switchMoveMode() -> j
    int getMoveMode() -> c
    void updateCoords() -> e
    void showUndefinedInAlgebraView(boolean) -> d
    geogebra.common.kernel.kernelND.GeoPointND copy() -> a
    boolean isAbsoluteStartPoint() -> O
    boolean showInEuclidianView() -> c_
    boolean getTrace() -> C
geogebra.common.kernel.kernelND.GeoPolygon3DInterface -> geogebra.common.i.l.p:
geogebra.common.kernel.kernelND.GeoQuadric3DInterface -> geogebra.common.i.l.q:
geogebra.common.kernel.kernelND.GeoQuadricND -> geogebra.common.i.l.r:
    int dimension -> m
    int matrixDim -> n
    int type -> l
    double[] matrix -> b
    double[] halfAxes -> c
    double linearEccentricity -> e
    double eccentricity -> f
    double p -> g
    boolean defined -> i
    geogebra.common.kernel.Matrix.Coords midpoint -> a
    geogebra.common.kernel.Matrix.Coords[] eigenvecND -> a
    double[] diagonal -> d
    char[] VAR_STRING -> a
    geogebra.common.kernel.geos.ChangeableCoordParent changeableCoordParent -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    geogebra.common.kernel.Matrix.CoordMatrix getSymetricMatrix(double[]) -> a
    geogebra.common.kernel.Matrix.CoordMatrix getSymetricMatrix() -> a
    void setMatrixFromEigen() -> N
    void setMatrix(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void setSphereND(geogebra.common.kernel.Matrix.Coords,double) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setSphereNDMatrix(geogebra.common.kernel.Matrix.Coords,double) -> b
    void empty() -> O
    void setUndefined() -> f
    void setDefined() -> P
    void setMidpoint(double[]) -> f
    geogebra.common.kernel.Matrix.Coords getMidpoint2D() -> c
    geogebra.common.kernel.Matrix.Coords getMidpoint() -> d
    geogebra.common.kernel.Matrix.Coords getMidpoint3D() -> e
    double getHalfAxis(int) -> c
    boolean isDefined() -> v
    int getType() -> g
    void setType(int) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void buildSphereNDString(java.lang.StringBuilder,geogebra.common.kernel.StringTemplate) -> b
    void setFirstEigenvector(double[]) -> d
    void setEigenvectors() -> J
    void singlePoint() -> K
    void setAffineTransform() -> H
    void setChangeableCoordParent(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoElement) -> a
    boolean hasChangeableCoordParentNumbers() -> bb
    void recordChangeableCoordParentNumbers() -> A
    boolean moveFromChangeableCoordParentNumbers(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,java.util.ArrayList,java.util.ArrayList) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$arithmetic$ExpressionNodeConstants$StringType() -> a
geogebra.common.kernel.kernelND.GeoRayND -> geogebra.common.i.l.s:
    boolean keepsTypeOnGeometricTransform() -> J
geogebra.common.kernel.kernelND.GeoSegmentND -> geogebra.common.i.l.t:
    void setTwoPointsCoords(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    double getLength() -> c
    geogebra.common.kernel.geos.GeoElement getStartPointAsGeoElement() -> c
    geogebra.common.kernel.geos.GeoElement getEndPointAsGeoElement() -> g
    double getPointX(double) -> b
    double getPointY(double) -> c
geogebra.common.kernel.kernelND.GeoSurfaceCartesianND -> geogebra.common.i.l.u:
    geogebra.common.kernel.arithmetic.FunctionNVar[] fun -> a
    double[] startParam -> a
    double[] endParam -> b
    boolean isDefined -> g
    void setIntervals(double[],double[]) -> a
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
geogebra.common.kernel.kernelND.GeoVectorND -> geogebra.common.i.l.v:
    void setLabel(java.lang.String) -> f
    void setUndefined() -> f
    void setCoords(double[]) -> b
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> a
    void updateStartPointPosition() -> e
    boolean isFinite() -> M
    boolean getTrace() -> C
geogebra.common.kernel.kernelND.LevelOfDetail -> geogebra.common.i.l.w:
    int LEVEL_OF_DETAIL_DEFAULT -> a
    int value -> b
    void setValue(int) -> a
    int getValue() -> a
geogebra.common.kernel.kernelND.Region3D -> geogebra.common.i.l.x:
    geogebra.common.kernel.Matrix.Coords getPoint(double,double) -> a_
    geogebra.common.kernel.Matrix.Coords[] getNormalProjection(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] getProjection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
geogebra.common.kernel.kernelND.SurfaceEvaluable -> geogebra.common.i.l.y:
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
geogebra.common.kernel.kernelND.ViewCreator -> geogebra.common.i.l.z:
    void createView2D() -> b
geogebra.common.kernel.optimization.ExtremumFinder -> geogebra.common.i.m.a:
    int MAX_ITERATIONS -> a
    double findMaximum(double,double,geogebra.common.kernel.roots.RealRootFunction,double) -> a
    double findMinimum(double,double,geogebra.common.kernel.roots.RealRootFunction,double) -> b
geogebra.common.kernel.optimization.FitRealFunction -> geogebra.common.i.m.b:
    geogebra.common.kernel.Kernel kernel -> a
    int numberOfParameters -> a
    java.lang.Object[] gliders -> a
    geogebra.common.kernel.arithmetic.Function newf -> a
    double lastvalue -> a
    geogebra.common.kernel.arithmetic.MyDouble[] mydoubles -> a
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
    void setFunction(geogebra.common.kernel.arithmetic.Function) -> a
    double[] getStartValues() -> a
    geogebra.common.kernel.arithmetic.Function getFunction() -> a
geogebra.common.kernel.optimization.NegativeRealRootFunction -> geogebra.common.i.m.c:
    geogebra.common.kernel.roots.RealRootFunction f -> a
    double evaluate(double) -> a
geogebra.common.kernel.optimization.RealRootFunctionVariable -> geogebra.common.i.m.d:
    geogebra.common.kernel.arithmetic.NumberValue geodep -> a
    geogebra.common.kernel.geos.GeoNumeric geoindep -> a
    double evaluate(double) -> a
geogebra.common.kernel.parser.ParseException -> geogebra.common.i.n.a:
    geogebra.common.kernel.parser.Token currentToken -> a
    int[][] expectedTokenSequences -> a
    java.lang.String[] tokenImage -> a
    java.lang.String eol -> a
    java.lang.String initialise(geogebra.common.kernel.parser.Token,int[][],java.lang.String[]) -> a
    java.lang.String add_escapes(java.lang.String) -> a
geogebra.common.kernel.parser.Parser -> geogebra.common.i.n.b:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    boolean GeoGebraCASParsing -> a
    boolean ExternalCASParsing -> b
    boolean MPReduceParsing -> c
    geogebra.common.kernel.parser.ParserTokenManager token_source -> a
    geogebra.common.kernel.parser.SimpleCharStream jj_input_stream -> a
    geogebra.common.kernel.parser.Token token -> a
    geogebra.common.kernel.parser.Token jj_nt -> b
    int jj_ntk -> a
    geogebra.common.kernel.parser.Token jj_scanpos -> c
    geogebra.common.kernel.parser.Token jj_lastpos -> d
    int jj_la -> b
    int jj_gen -> c
    int[] jj_la1 -> a
    int[] jj_la1_0 -> b
    int[] jj_la1_1 -> c
    int[] jj_la1_2 -> d
    int[] jj_la1_3 -> e
    int[] jj_la1_4 -> f
    geogebra.common.kernel.parser.Parser$JJCalls[] jj_2_rtns -> a
    boolean jj_rescan -> d
    int jj_gc -> d
    geogebra.common.kernel.parser.Parser$LookaheadSuccess jj_ls -> a
    java.util.List jj_expentries -> a
    int[] jj_expentry -> g
    int jj_kind -> e
    int[] jj_lasttokens -> h
    int jj_endpos -> f
    void myReInit(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraExpression(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraCAS(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseMPReduce(java.lang.String) -> c
    geogebra.common.kernel.arithmetic.Function parseFunction(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.FunctionNVar parseFunctionNVar(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode parseCmdExpression(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ExpressionNode parseExpression(java.lang.String) -> b
    java.lang.String parseLabel(java.lang.String) -> a
    geogebra.common.kernel.arithmetic.ValidExpression buildValidExpression() -> a
    geogebra.common.kernel.arithmetic.ValidExpression buildCASExpression() -> b
    geogebra.common.kernel.arithmetic.ValidExpression buildMPReduceExpression() -> c
    geogebra.common.kernel.parser.Token label() -> a
    geogebra.common.kernel.parser.Token casVar() -> b
    geogebra.common.kernel.arithmetic.Command command() -> a
    java.util.Vector labellist() -> a
    geogebra.common.kernel.arithmetic.Parametric parametric() -> a
    geogebra.common.kernel.arithmetic.Equation equation() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode expression() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode cmdexpression() -> b
    geogebra.common.kernel.arithmetic.Function function() -> a
    geogebra.common.kernel.arithmetic.FunctionNVar functionNVar() -> a
    geogebra.common.kernel.arithmetic.ExpressionNode functionExpressionnode() -> c
    geogebra.common.kernel.arithmetic.FunctionNVar casFunction() -> b
    geogebra.common.kernel.arithmetic.ExpressionNode expressionnode() -> d
    geogebra.common.kernel.arithmetic.ExpressionNode expressionOrEquation() -> e
    geogebra.common.kernel.arithmetic.ExpressionValue ANDterm() -> a
    geogebra.common.kernel.arithmetic.ExpressionValue ORterm() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue COMPAREterm() -> c
    geogebra.common.kernel.arithmetic.ExpressionValue plusminusnode() -> d
    geogebra.common.kernel.arithmetic.ExpressionValue multterm() -> e
    geogebra.common.kernel.arithmetic.ExpressionValue divterm() -> f
    geogebra.common.kernel.arithmetic.ExpressionValue powerdivterm() -> g
    geogebra.common.kernel.arithmetic.ExpressionValue enunary() -> h
    geogebra.common.kernel.arithmetic.ExpressionValue enpower() -> i
    geogebra.common.kernel.arithmetic.ExpressionValue enfactorial() -> j
    geogebra.common.kernel.arithmetic.ExpressionValue NOTterm() -> k
    geogebra.common.kernel.arithmetic.ExpressionValue enelement() -> l
    geogebra.common.kernel.arithmetic.ExpressionValue list() -> m
    geogebra.common.kernel.arithmetic.ExpressionValue matrixReduce() -> n
    geogebra.common.kernel.arithmetic.ExpressionValue matrixRowReduce() -> o
    geogebra.common.kernel.arithmetic.ExpressionValue numVecVariable() -> p
    geogebra.common.kernel.arithmetic.Command spreadsheetRange() -> b
    geogebra.common.kernel.arithmetic.ExpressionValue myDouble() -> q
    geogebra.common.kernel.arithmetic.ExpressionNode numberFunction() -> f
    geogebra.common.kernel.arithmetic.VectorValue cartesianvector() -> a
    geogebra.common.kernel.arithmetic3D.Vector3DValue cartesianvector3D() -> a
    geogebra.common.kernel.arithmetic.VectorValue polarvector() -> b
    geogebra.common.kernel.arithmetic.ExpressionNode cartesianvector_special() -> g
    geogebra.common.kernel.arithmetic.ExpressionNode polarvector_special() -> h
    boolean jj_2_1(int) -> a
    boolean jj_2_2(int) -> b
    boolean jj_2_3(int) -> c
    boolean jj_2_4(int) -> d
    boolean jj_2_5(int) -> e
    boolean jj_2_6(int) -> f
    boolean jj_2_7(int) -> g
    boolean jj_2_8(int) -> h
    boolean jj_2_9(int) -> i
    boolean jj_2_10(int) -> j
    boolean jj_2_11(int) -> k
    boolean jj_2_12(int) -> l
    boolean jj_2_13(int) -> m
    boolean jj_2_14(int) -> n
    boolean jj_2_15(int) -> o
    boolean jj_2_16(int) -> p
    boolean jj_2_17(int) -> q
    boolean jj_2_18(int) -> r
    boolean jj_2_19(int) -> s
    boolean jj_2_20(int) -> t
    boolean jj_2_21(int) -> u
    boolean jj_2_22(int) -> v
    boolean jj_2_23(int) -> w
    boolean jj_2_24(int) -> x
    boolean jj_2_25(int) -> y
    boolean jj_2_26(int) -> z
    boolean jj_2_27(int) -> A
    boolean jj_2_28(int) -> B
    boolean jj_2_29(int) -> C
    boolean jj_2_30(int) -> D
    boolean jj_2_31(int) -> E
    boolean jj_2_32(int) -> F
    boolean jj_2_33(int) -> G
    boolean jj_2_34(int) -> H
    boolean jj_2_35(int) -> I
    boolean jj_3R_23() -> a
    boolean jj_3R_52() -> b
    boolean jj_3R_33() -> c
    boolean jj_3R_171() -> d
    boolean jj_3R_168() -> e
    boolean jj_3R_130() -> f
    boolean jj_3R_191() -> g
    boolean jj_3R_129() -> h
    boolean jj_3R_48() -> i
    boolean jj_3R_190() -> j
    boolean jj_3R_134() -> k
    boolean jj_3R_189() -> l
    boolean jj_3R_133() -> m
    boolean jj_3R_47() -> n
    boolean jj_3R_27() -> o
    boolean jj_3R_188() -> p
    boolean jj_3R_132() -> q
    boolean jj_3R_131() -> r
    boolean jj_3R_187() -> s
    boolean jj_3R_50() -> t
    boolean jj_3R_186() -> u
    boolean jj_3R_49() -> v
    boolean jj_3R_46() -> w
    boolean jj_3R_28() -> x
    boolean jj_3R_26() -> y
    boolean jj_3R_185() -> z
    boolean jj_3R_184() -> A
    boolean jj_3R_176() -> B
    boolean jj_3R_32() -> C
    boolean jj_3R_51() -> D
    boolean jj_3R_193() -> E
    boolean jj_3R_173() -> F
    boolean jj_3R_22() -> G
    boolean jj_3R_192() -> H
    boolean jj_3R_183() -> I
    boolean jj_3R_182() -> J
    boolean jj_3R_172() -> K
    boolean jj_3R_169() -> L
    boolean jj_3R_153() -> M
    boolean jj_3R_135() -> N
    boolean jj_3R_42() -> O
    boolean jj_3R_21() -> P
    boolean jj_3R_31() -> Q
    boolean jj_3R_113() -> R
    boolean jj_3R_148() -> S
    boolean jj_3R_147() -> T
    boolean jj_3R_146() -> U
    boolean jj_3R_138() -> V
    boolean jj_3R_112() -> W
    boolean jj_3R_111() -> X
    boolean jj_3R_110() -> Y
    boolean jj_3R_109() -> Z
    boolean jj_3R_108() -> aa
    boolean jj_3R_107() -> ab
    boolean jj_3R_154() -> ac
    boolean jj_3R_106() -> ad
    boolean jj_3R_43() -> ae
    boolean jj_3R_105() -> af
    boolean jj_3R_149() -> ag
    boolean jj_3R_104() -> ah
    boolean jj_3R_102() -> ai
    boolean jj_3R_103() -> aj
    boolean jj_3R_101() -> ak
    boolean jj_3R_100() -> al
    boolean jj_3R_139() -> am
    boolean jj_3R_117() -> an
    boolean jj_3R_99() -> ao
    boolean jj_3_28() -> ap
    boolean jj_3R_125() -> aq
    boolean jj_3_33() -> ar
    boolean jj_3R_98() -> as
    boolean jj_3R_97() -> at
    boolean jj_3R_96() -> au
    boolean jj_3R_116() -> av
    boolean jj_3R_141() -> aw
    boolean jj_3R_20() -> ax
    boolean jj_3_32() -> ay
    boolean jj_3R_115() -> az
    boolean jj_3R_140() -> aA
    boolean jj_3R_126() -> aB
    boolean jj_3_31() -> aC
    boolean jj_3R_40() -> aD
    boolean jj_3_30() -> aE
    boolean jj_3R_34() -> aF
    boolean jj_3R_114() -> aG
    boolean jj_3R_152() -> aH
    boolean jj_3_29() -> aI
    boolean jj_3_15() -> aJ
    boolean jj_3R_95() -> aK
    boolean jj_3_14() -> aL
    boolean jj_3R_94() -> aM
    boolean jj_3_13() -> aN
    boolean jj_3R_93() -> aO
    boolean jj_3R_155() -> aP
    boolean jj_3R_92() -> aQ
    boolean jj_3R_144() -> aR
    boolean jj_3_12() -> aS
    boolean jj_3R_150() -> aT
    boolean jj_3R_91() -> aU
    boolean jj_3_11() -> aV
    boolean jj_3R_90() -> aW
    boolean jj_3R_89() -> aX
    boolean jj_3R_88() -> aY
    boolean jj_3R_87() -> aZ
    boolean jj_3R_145() -> ba
    boolean jj_3R_86() -> bb
    boolean jj_3_10() -> bc
    boolean jj_3R_85() -> bd
    boolean jj_3R_84() -> be
    boolean jj_3R_137() -> bf
    boolean jj_3R_83() -> bg
    boolean jj_3R_82() -> bh
    boolean jj_3R_167() -> bi
    boolean jj_3_9() -> bj
    boolean jj_3R_81() -> bk
    boolean jj_3_8() -> bl
    boolean jj_3R_80() -> bm
    boolean jj_3R_166() -> bn
    boolean jj_3_7() -> bo
    boolean jj_3R_79() -> bp
    boolean jj_3R_119() -> bq
    boolean jj_3R_78() -> br
    boolean jj_3R_77() -> bs
    boolean jj_3R_136() -> bt
    boolean jj_3R_165() -> bu
    boolean jj_3R_76() -> bv
    boolean jj_3R_75() -> bw
    boolean jj_3R_164() -> bx
    boolean jj_3R_74() -> by
    boolean jj_3R_73() -> bz
    boolean jj_3R_44() -> bA
    boolean jj_3R_163() -> bB
    boolean jj_3R_118() -> bC
    boolean jj_3R_72() -> bD
    boolean jj_3_16() -> bE
    boolean jj_3R_71() -> bF
    boolean jj_3R_162() -> bG
    boolean jj_3R_70() -> bH
    boolean jj_3R_35() -> bI
    boolean jj_3_27() -> bJ
    boolean jj_3R_69() -> bK
    boolean jj_3R_25() -> bL
    boolean jj_3R_161() -> bM
    boolean jj_3R_68() -> bN
    boolean jj_3R_67() -> bO
    boolean jj_3R_181() -> bP
    boolean jj_3R_160() -> bQ
    boolean jj_3R_66() -> bR
    boolean jj_3R_30() -> bS
    boolean jj_3R_65() -> bT
    boolean jj_3R_159() -> bU
    boolean jj_3_5() -> bV
    boolean jj_3R_64() -> bW
    boolean jj_3_6() -> bX
    boolean jj_3_26() -> bY
    boolean jj_3R_63() -> bZ
    boolean jj_3R_158() -> ca
    boolean jj_3R_62() -> cb
    boolean jj_3R_41() -> cc
    boolean jj_3_25() -> cd
    boolean jj_3R_61() -> ce
    boolean jj_3R_157() -> cf
    boolean jj_3R_60() -> cg
    boolean jj_3R_29() -> ch
    boolean jj_3_24() -> ci
    boolean jj_3_2() -> cj
    boolean jj_3_4() -> ck
    boolean jj_3R_59() -> cl
    boolean jj_3_3() -> cm
    boolean jj_3_23() -> cn
    boolean jj_3R_58() -> co
    boolean jj_3R_156() -> cp
    boolean jj_3R_57() -> cq
    boolean jj_3R_151() -> cr
    boolean jj_3_22() -> cs
    boolean jj_3R_56() -> ct
    boolean jj_3R_24() -> cu
    boolean jj_3_1() -> cv
    boolean jj_3R_55() -> cw
    boolean jj_3R_142() -> cx
    boolean jj_3_21() -> cy
    boolean jj_3R_123() -> cz
    boolean jj_3R_122() -> cA
    boolean jj_3_20() -> cB
    boolean jj_3_19() -> cC
    boolean jj_3R_38() -> cD
    boolean jj_3R_128() -> cE
    boolean jj_3_18() -> cF
    boolean jj_3R_45() -> cG
    boolean jj_3R_180() -> cH
    boolean jj_3R_179() -> cI
    boolean jj_3_35() -> cJ
    boolean jj_3R_121() -> cK
    boolean jj_3R_178() -> cL
    boolean jj_3R_177() -> cM
    boolean jj_3R_54() -> cN
    boolean jj_3R_37() -> cO
    boolean jj_3R_143() -> cP
    boolean jj_3R_127() -> cQ
    boolean jj_3_34() -> cR
    boolean jj_3R_120() -> cS
    boolean jj_3R_53() -> cT
    boolean jj_3R_175() -> cU
    boolean jj_3R_36() -> cV
    boolean jj_3R_39() -> cW
    boolean jj_3R_174() -> cX
    boolean jj_3R_170() -> cY
    boolean jj_3R_124() -> cZ
    boolean jj_3_17() -> da
    void jj_la1_init_0() -> a
    void jj_la1_init_1() -> b
    void jj_la1_init_2() -> c
    void jj_la1_init_3() -> d
    void jj_la1_init_4() -> e
    void ReInit(java.io.Reader) -> a
    geogebra.common.kernel.parser.Token jj_consume_token(int) -> a
    boolean jj_scan_token(int) -> J
    int jj_ntk() -> a
    void jj_add_error_token(int,int) -> a
    geogebra.common.kernel.parser.ParseException generateParseException() -> a
    void jj_rescan_token() -> f
    void jj_save(int,int) -> b
geogebra.common.kernel.parser.Parser$JJCalls -> geogebra.common.i.n.b$a:
    int gen -> a
    geogebra.common.kernel.parser.Token first -> a
    int arg -> b
    geogebra.common.kernel.parser.Parser$JJCalls next -> a
geogebra.common.kernel.parser.Parser$LookaheadSuccess -> geogebra.common.i.n.b$b:
geogebra.common.kernel.parser.ParserConstants -> geogebra.common.i.n.c:
    java.lang.String[] tokenImage -> a
geogebra.common.kernel.parser.ParserInterface -> geogebra.common.i.n.d:
    geogebra.common.kernel.arithmetic.ExpressionNode parseExpression(java.lang.String) -> b
    geogebra.common.kernel.arithmetic.ValidExpression parseGeoGebraExpression(java.lang.String) -> a
    java.lang.String parseLabel(java.lang.String) -> a
geogebra.common.kernel.parser.ParserTokenManager -> geogebra.common.i.n.e:
    java.io.PrintStream debugStream -> a
    long[] jjbitVec0 -> a
    long[] jjbitVec1 -> b
    long[] jjbitVec2 -> c
    long[] jjbitVec3 -> d
    long[] jjbitVec4 -> e
    long[] jjbitVec5 -> f
    long[] jjbitVec6 -> g
    long[] jjbitVec7 -> h
    long[] jjbitVec8 -> i
    long[] jjbitVec9 -> j
    long[] jjbitVec10 -> k
    long[] jjbitVec11 -> l
    long[] jjbitVec12 -> m
    long[] jjbitVec13 -> n
    long[] jjbitVec14 -> o
    long[] jjbitVec15 -> p
    long[] jjbitVec16 -> q
    long[] jjbitVec17 -> r
    long[] jjbitVec18 -> s
    long[] jjbitVec19 -> t
    long[] jjbitVec20 -> u
    long[] jjbitVec22 -> v
    long[] jjbitVec23 -> w
    long[] jjbitVec24 -> x
    long[] jjbitVec25 -> y
    long[] jjbitVec26 -> z
    long[] jjbitVec27 -> A
    long[] jjbitVec28 -> B
    long[] jjbitVec29 -> C
    long[] jjbitVec30 -> D
    long[] jjbitVec31 -> E
    long[] jjbitVec32 -> F
    long[] jjbitVec33 -> G
    long[] jjbitVec34 -> H
    long[] jjbitVec35 -> I
    long[] jjbitVec36 -> J
    long[] jjbitVec37 -> K
    long[] jjbitVec38 -> L
    long[] jjbitVec39 -> M
    long[] jjbitVec40 -> N
    long[] jjbitVec41 -> O
    long[] jjbitVec42 -> P
    long[] jjbitVec43 -> Q
    long[] jjbitVec44 -> R
    long[] jjbitVec45 -> S
    long[] jjbitVec46 -> T
    long[] jjbitVec47 -> U
    long[] jjbitVec48 -> V
    long[] jjbitVec49 -> W
    long[] jjbitVec50 -> X
    long[] jjbitVec51 -> Y
    long[] jjbitVec52 -> Z
    int[] jjnextStates -> a
    java.lang.String[] jjstrLiteralImages -> b
    java.lang.String[] lexStateNames -> c
    long[] jjtoToken -> aa
    long[] jjtoSkip -> ab
    geogebra.common.kernel.parser.SimpleCharStream input_stream -> a
    int[] jjrounds -> b
    int[] jjstateSet -> c
    char curChar -> a
    int curLexState -> a
    int defaultLexState -> b
    int jjnewStateCnt -> c
    int jjround -> d
    int jjmatchedPos -> e
    int jjmatchedKind -> f
    int jjStopStringLiteralDfa_0(int,long,long,long) -> a
    int jjStartNfa_0(int,long,long,long) -> b
    int jjStopAtPos(int,int) -> a
    int jjMoveStringLiteralDfa0_0() -> a
    int jjMoveStringLiteralDfa1_0(long,long) -> a
    int jjMoveStringLiteralDfa2_0(long,long,long,long) -> a
    int jjMoveStringLiteralDfa3_0(long,long,long,long) -> b
    int jjMoveStringLiteralDfa4_0(long,long,long,long) -> c
    int jjMoveStringLiteralDfa5_0(long,long) -> b
    int jjMoveStringLiteralDfa6_0(long,long) -> c
    int jjMoveStringLiteralDfa7_0(long,long) -> d
    int jjMoveStringLiteralDfa8_0(long,long) -> e
    int jjMoveStringLiteralDfa9_0(long,long) -> f
    int jjMoveStringLiteralDfa10_0(long,long) -> g
    int jjMoveStringLiteralDfa11_0(long,long) -> h
    int jjMoveStringLiteralDfa12_0(long,long) -> i
    int jjMoveStringLiteralDfa13_0(long,long) -> j
    int jjStartNfaWithStates_0(int,int,int) -> a
    int jjMoveNfa_0(int,int) -> b
    boolean jjCanMove_0(int,int,int,long,long) -> a
    boolean jjCanMove_1(int,int,int,long,long) -> b
    boolean jjCanMove_2(int,int,int,long,long) -> c
    boolean jjCanMove_3(int,int,int,long,long) -> d
    boolean jjCanMove_4(int,int,int,long,long) -> e
    boolean jjCanMove_5(int,int,int,long,long) -> f
    boolean jjCanMove_6(int,int,int,long,long) -> g
    boolean jjCanMove_7(int,int,int,long,long) -> h
    boolean jjCanMove_8(int,int,int,long,long) -> i
    boolean jjCanMove_9(int,int,int,long,long) -> j
    boolean jjCanMove_10(int,int,int,long,long) -> k
    boolean jjCanMove_11(int,int,int,long,long) -> l
    boolean jjCanMove_12(int,int,int,long,long) -> m
    boolean jjCanMove_13(int,int,int,long,long) -> n
    boolean jjCanMove_14(int,int,int,long,long) -> o
    boolean jjCanMove_15(int,int,int,long,long) -> p
    boolean jjCanMove_16(int,int,int,long,long) -> q
    boolean jjCanMove_17(int,int,int,long,long) -> r
    boolean jjCanMove_18(int,int,int,long,long) -> s
    boolean jjCanMove_19(int,int,int,long,long) -> t
    boolean jjCanMove_20(int,int,int,long,long) -> u
    boolean jjCanMove_21(int,int,int,long,long) -> v
    void ReInit(geogebra.common.kernel.parser.SimpleCharStream) -> a
    void ReInitRounds() -> a
    geogebra.common.kernel.parser.Token jjFillToken() -> a
    geogebra.common.kernel.parser.Token getNextToken() -> b
    void jjCheckNAdd(int) -> a
    void jjAddStates(int,int) -> a
    void jjCheckNAddTwoStates(int,int) -> b
    void jjCheckNAddStates(int,int) -> c
geogebra.common.kernel.parser.SimpleCharStream -> geogebra.common.i.n.f:
    int bufsize -> a
    int available -> b
    int tokenBegin -> c
    int bufpos -> d
    int[] bufline -> a
    int[] bufcolumn -> b
    int column -> e
    int line -> f
    boolean prevCharIsCR -> a
    boolean prevCharIsLF -> b
    java.io.Reader inputStream -> a
    char[] buffer -> a
    int maxNextCharInd -> g
    int inBuf -> h
    int tabSize -> i
    void ExpandBuff(boolean) -> a
    void FillBuff() -> a
    char BeginToken() -> a
    void UpdateLineColumn(char) -> a
    char readChar() -> b
    int getEndColumn() -> a
    int getEndLine() -> b
    int getBeginColumn() -> c
    int getBeginLine() -> d
    void backup(int) -> a
    void ReInit(java.io.Reader,int,int,int) -> a
    void ReInit(java.io.Reader,int,int) -> a
    java.lang.String GetImage() -> a
geogebra.common.kernel.parser.Token -> geogebra.common.i.n.g:
    int kind -> a
    int beginLine -> b
    int beginColumn -> c
    int endLine -> d
    int endColumn -> e
    java.lang.String image -> a
    geogebra.common.kernel.parser.Token next -> a
    java.lang.String toString() -> toString
    geogebra.common.kernel.parser.Token newToken(int,java.lang.String) -> a
geogebra.common.kernel.parser.TokenMgrError -> geogebra.common.i.n.h:
    int errorCode -> a
    java.lang.String addEscapes(java.lang.String) -> a
    java.lang.String LexicalError(boolean,int,int,int,java.lang.String,char) -> a
    java.lang.String getMessage() -> getMessage
geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce -> geogebra.common.i.n.a.a:
    int[] $SWITCH_TABLE$geogebra$common$kernel$parser$cashandlers$CommandDispatcherMPReduce$commands -> a
    geogebra.common.kernel.arithmetic.ExpressionNode processCommand(java.lang.String,geogebra.common.kernel.arithmetic.MyList) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$parser$cashandlers$CommandDispatcherMPReduce$commands() -> a
geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands -> geogebra.common.i.n.a.a$a:
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbcomplex -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbconst -> b
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands arbint -> c
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands df -> d
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands addition -> e
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands multiplication -> f
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands subtraction -> g
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands logb -> h
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands si -> i
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ci -> j
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands ei -> k
    geogebra.common.plugin.Operation op -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands[] ENUM$VALUES -> a
    geogebra.common.plugin.Operation getOperation() -> a
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands[] values() -> values
    geogebra.common.kernel.parser.cashandlers.CommandDispatcherMPReduce$commands valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.prover.NoSymbolicParametersException -> geogebra.common.i.o.a:
geogebra.common.kernel.prover.Polynomial -> geogebra.common.i.o.b:
    java.util.TreeMap terms -> a
    java.util.TreeMap getTerms() -> a
    geogebra.common.kernel.prover.Polynomial add(geogebra.common.kernel.prover.Polynomial) -> a
    geogebra.common.kernel.prover.Polynomial negate() -> a
    geogebra.common.kernel.prover.Polynomial subtract(geogebra.common.kernel.prover.Polynomial) -> b
    geogebra.common.kernel.prover.Polynomial multiply(geogebra.common.kernel.prover.Polynomial) -> c
    int compareTo(geogebra.common.kernel.prover.Polynomial) -> a
    java.lang.String toString() -> toString
    java.util.HashSet getVars() -> a
    java.util.HashSet getVars(geogebra.common.kernel.prover.Polynomial[]) -> a
    java.lang.String getVarsAsCommaSeparatedString(geogebra.common.kernel.prover.Polynomial[]) -> a
    java.lang.String getPolysAsCommaSeparatedString(geogebra.common.kernel.prover.Polynomial[]) -> b
    geogebra.common.kernel.prover.Polynomial setCollinear(geogebra.common.kernel.prover.Variable,geogebra.common.kernel.prover.Variable,geogebra.common.kernel.prover.Variable,geogebra.common.kernel.prover.Variable,geogebra.common.kernel.prover.Variable,geogebra.common.kernel.prover.Variable) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    boolean isZero() -> a
    java.lang.String getSingularGroebner(java.lang.String,java.lang.String,geogebra.common.kernel.prover.Polynomial[]) -> a
    java.lang.Boolean solvable(geogebra.common.kernel.prover.Polynomial[]) -> a
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.prover.Prover -> geogebra.common.i.o.c:
    int timeout -> a
    geogebra.common.kernel.prover.Prover$ProverEngine engine -> a
    geogebra.common.kernel.Construction construction -> a
    geogebra.common.kernel.geos.GeoElement statement -> a
    geogebra.common.kernel.prover.Prover$ProofResult result -> a
    void setTimeout(int) -> a
    void setProverEngine(geogebra.common.kernel.prover.Prover$ProverEngine) -> a
    void setConstruction(geogebra.common.kernel.Construction) -> a
    void setStatement(geogebra.common.kernel.geos.GeoElement) -> a
    void compute() -> a
    java.lang.Boolean getYesNoAnswer() -> a
    java.lang.String simplifiedXML(geogebra.common.kernel.Construction) -> a
geogebra.common.kernel.prover.Prover$ProofResult -> geogebra.common.i.o.c$a:
    geogebra.common.kernel.prover.Prover$ProofResult TRUE -> a
    geogebra.common.kernel.prover.Prover$ProofResult FALSE -> b
    geogebra.common.kernel.prover.Prover$ProofResult UNKNOWN -> c
    geogebra.common.kernel.prover.Prover$ProofResult[] ENUM$VALUES -> a
    geogebra.common.kernel.prover.Prover$ProofResult[] values() -> values
    geogebra.common.kernel.prover.Prover$ProofResult valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.prover.Prover$ProverEngine -> geogebra.common.i.o.c$b:
    geogebra.common.kernel.prover.Prover$ProverEngine RECIOS_PROVER -> a
    geogebra.common.kernel.prover.Prover$ProverEngine BOTANAS_PROVER -> b
    geogebra.common.kernel.prover.Prover$ProverEngine OPENGEOPROVER -> c
    geogebra.common.kernel.prover.Prover$ProverEngine PURE_SYMBOLIC_PROVER -> d
    geogebra.common.kernel.prover.Prover$ProverEngine AUTO -> e
    geogebra.common.kernel.prover.Prover$ProverEngine[] ENUM$VALUES -> a
    geogebra.common.kernel.prover.Prover$ProverEngine[] values() -> values
    geogebra.common.kernel.prover.Prover$ProverEngine valueOf(java.lang.String) -> valueOf
geogebra.common.kernel.prover.ProverBotanasMethod -> geogebra.common.i.o.d:
    java.util.HashSet getFreePoints(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.prover.Polynomial[] create3FreePointsNeverCollinearNDG(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.prover.Polynomial[] fixValues(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.prover.Prover$ProofResult prove(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.prover.ProverPureSymbolicMethod -> geogebra.common.i.o.e:
    geogebra.common.kernel.prover.Prover$ProofResult prove(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.common.kernel.prover.ProverReciosMethod -> geogebra.common.i.o.f:
    geogebra.common.kernel.prover.Prover$ProofResult prove(geogebra.common.kernel.algos.SymbolicParameters) -> a
    geogebra.common.kernel.prover.Prover$ProofResult compute0d(java.util.HashMap,geogebra.common.kernel.algos.SymbolicParameters) -> a
    geogebra.common.kernel.prover.Prover$ProofResult compute1d(java.util.HashSet,java.util.HashMap,int,geogebra.common.kernel.algos.SymbolicParameters) -> a
    geogebra.common.kernel.prover.Prover$ProofResult compute2d(java.util.HashSet,java.util.HashMap,int,geogebra.common.kernel.algos.SymbolicParameters) -> b
geogebra.common.kernel.prover.Term -> geogebra.common.i.o.g:
    java.util.TreeMap variables -> a
    java.util.HashMap comparisons -> a
    geogebra.common.kernel.prover.Term times(geogebra.common.kernel.prover.Term) -> a
    java.util.TreeMap getTerm() -> a
    int compareTo(geogebra.common.kernel.prover.Term) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    java.util.HashSet getVars() -> a
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.prover.Variable -> geogebra.common.i.o.h:
    int n -> a
    java.util.TreeMap names -> a
    geogebra.common.kernel.prover.Variable twin -> a
    int id -> b
    int getId() -> a
    java.lang.String toString() -> toString
    int compareTo(geogebra.common.kernel.prover.Variable) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String getName() -> a
    void setName(java.lang.String) -> a
    int hashCode() -> hashCode
    geogebra.common.kernel.prover.Variable getTwin() -> a
    void setTwin(geogebra.common.kernel.prover.Variable) -> a
    int compareTo(java.lang.Object) -> compareTo
geogebra.common.kernel.roots.RealRootAdapter -> geogebra.common.i.p.a:
    geogebra.common.kernel.roots.RealRootFunction fun -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivAdapter -> geogebra.common.i.p.b:
    geogebra.common.kernel.roots.RealRootDerivFunction derivFun -> a
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivAdapter$1 -> geogebra.common.i.p.c:
    geogebra.common.kernel.roots.RealRootDerivAdapter this$0 -> a
    double value(double) -> a
geogebra.common.kernel.roots.RealRootDerivFunction -> geogebra.common.i.p.d:
    double evaluateDerivative(double) -> b
geogebra.common.kernel.roots.RealRootFunction -> geogebra.common.i.p.e:
    double evaluate(double) -> a
geogebra.common.kernel.roots.RealRootUtil -> geogebra.common.i.p.f:
    int ITER_MAX -> a
    double[] getDefinedInterval(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
    double getDefinitionBorder(geogebra.common.kernel.roots.RealRootFunction,double,double) -> a
geogebra.common.kernel.statistics.AlgoANOVA -> geogebra.common.i.q.a:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoList result -> b
    java.util.ArrayList categoryData -> a
    double p -> a
    double testStat -> b
    org.apache.commons.math.stat.inference.OneWayAnovaImpl anovaImpl -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoBernoulliBarChart -> geogebra.common.i.q.b:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.AlgoBinomialDist -> geogebra.common.i.q.c:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoBinomialDistBarChart -> geogebra.common.i.q.d:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.AlgoCauchy -> geogebra.common.i.q.e:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoChiSquared -> geogebra.common.i.q.f:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoDistribution -> geogebra.common.i.q.g:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.arithmetic.NumberValue b -> b
    geogebra.common.kernel.arithmetic.NumberValue c -> c
    geogebra.common.kernel.arithmetic.NumberValue d -> d
    geogebra.common.kernel.geos.GeoBoolean isCumulative -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    org.apache.commons.math.distribution.TDistribution t -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution chisquared -> a
    org.apache.commons.math.distribution.FDistribution f -> a
    org.apache.commons.math.distribution.GammaDistribution gamma -> a
    org.apache.commons.math.distribution.CauchyDistribution cauchy -> a
    org.apache.commons.math.distribution.ExponentialDistribution exponential -> a
    org.apache.commons.math.distribution.HypergeometricDistribution hypergeometric -> a
    org.apache.commons.math.distribution.PascalDistribution pascal -> a
    org.apache.commons.math.distribution.BinomialDistribution binomial -> a
    org.apache.commons.math.distribution.WeibullDistribution weibull -> a
    org.apache.commons.math.distribution.ZipfDistribution zipf -> a
    org.apache.commons.math.distribution.NormalDistribution normal -> a
    org.apache.commons.math.distribution.PoissonDistribution poisson -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
    org.apache.commons.math.distribution.TDistribution getTDistribution(double) -> a
    org.apache.commons.math.distribution.FDistribution getFDistribution(double,double) -> a
    org.apache.commons.math.distribution.GammaDistribution getGammaDistribution(double,double) -> a
    org.apache.commons.math.distribution.CauchyDistribution getCauchyDistribution(double,double) -> a
    org.apache.commons.math.distribution.ChiSquaredDistribution getChiSquaredDistribution(double) -> a
    org.apache.commons.math.distribution.ExponentialDistribution getExponentialDistribution(double) -> a
    org.apache.commons.math.distribution.HypergeometricDistribution getHypergeometricDistribution(int,int,int) -> a
    org.apache.commons.math.distribution.PascalDistribution getPascalDistribution(int,double) -> a
    org.apache.commons.math.distribution.PoissonDistribution getPoissonDistribution(double) -> a
    org.apache.commons.math.distribution.BinomialDistribution getBinomialDistribution(int,double) -> a
    org.apache.commons.math.distribution.WeibullDistribution getWeibullDistribution(double,double) -> a
    org.apache.commons.math.distribution.NormalDistribution getNormalDistribution(double,double) -> a
    org.apache.commons.math.distribution.ZipfDistribution getZipfDistribution(int,double) -> a
geogebra.common.kernel.statistics.AlgoDoubleListCovariance -> geogebra.common.i.q.h:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListPMCC -> geogebra.common.i.q.i:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSXX -> geogebra.common.i.q.j:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSXY -> geogebra.common.i.q.k:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoDoubleListSigmaXY -> geogebra.common.i.q.l:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoExponential -> geogebra.common.i.q.m:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFDistribution -> geogebra.common.i.q.n:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFit -> geogebra.common.i.q.o:
    geogebra.common.kernel.geos.GeoList pointlist -> a
    geogebra.common.kernel.geos.GeoList functionlist -> b
    geogebra.common.kernel.geos.GeoFunction fitfunction -> a
    int datasize -> a
    int functionsize -> b
    geogebra.common.kernel.geos.GeoFunction[] functionarray -> a
    org.apache.commons.math.linear.RealMatrix M -> a
    org.apache.commons.math.linear.RealMatrix Y -> b
    org.apache.commons.math.linear.RealMatrix P -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFit() -> a
    void compute() -> b
    void makeMatrixes() -> e
    geogebra.common.kernel.geos.GeoFunction makeFunction() -> b
    void errorMsg(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoFitExp -> geogebra.common.i.q.p:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitExp() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitGrowth -> geogebra.common.i.q.q:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitGrowth() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLineX -> geogebra.common.i.q.r:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getFitLineX() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLineY -> geogebra.common.i.q.s:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoLine g -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoLine getFitLineY() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLog -> geogebra.common.i.q.t:
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitLog() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoFitLogistic -> geogebra.common.i.q.u:
    geogebra.common.main.AbstractApplication app -> b
    geogebra.common.kernel.Kernel k -> b
    double a -> a
    double b -> b
    double c -> c
    double[] xd -> a
    double[] yd -> b
    int size -> a
    int iterations -> b
    boolean error -> a
    geogebra.common.kernel.statistics.RegressionMath regMath -> a
    boolean allplus -> b
    boolean allneg -> c
    geogebra.common.kernel.geos.GeoList geolist -> a
    geogebra.common.kernel.geos.GeoFunction geofunction -> a
    double x1 -> d
    double y1 -> e
    double x2 -> f
    double y2 -> g
    double ymult -> h
    double e1 -> i
    double e2 -> j
    double emult -> k
    double ydiff -> l
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitLogistic() -> a
    void compute() -> b
    void doReg() -> e
    void findParameters() -> f
    void Logistic_Reg() -> p
    double f(double,double,double,double) -> a
    double f(double,double) -> a
    double df_c(double,double,double) -> b
    double df_a(double,double,double,double) -> b
    double df_b(double,double,double,double) -> c
    double beta(double,double,double,double,double) -> a
    double beta(double,double,double) -> a
    double beta2(double[],double[],double,double,double) -> a
    double beta2(double[],double[],double) -> a
    double c(double,double,double,double,double) -> b
    double a(double,double,double,double,double) -> c
    void getPoints() -> q
    void errorMsg(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoFitNL -> geogebra.common.i.q.v:
    geogebra.common.kernel.geos.GeoList pointlist -> a
    geogebra.common.kernel.geos.GeoFunction inputfunction -> a
    geogebra.common.kernel.geos.GeoFunction outputfunction -> b
    int datasize -> a
    double[] xdata -> a
    double[] ydata -> b
    geogebra.common.kernel.optimization.FitRealFunction prfunction -> a
    org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer LMO -> a
    org.apache.commons.math.optimization.fitting.CurveFitter curvefitter -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoFunction getFitNL() -> a
    void compute() -> b
    void makeDataArrays() -> e
    void errorMsg(java.lang.String) -> a
geogebra.common.kernel.statistics.AlgoGamma -> geogebra.common.i.q.w:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoGeometricMean -> geogebra.common.i.q.x:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHarmonicMean -> geogebra.common.i.q.y:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    double sum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHyperGeometric -> geogebra.common.i.q.z:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoHyperGeometricBarChart -> geogebra.common.i.q.A:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.AlgoInverseBinomial -> geogebra.common.i.q.B:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseCauchy -> geogebra.common.i.q.C:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseChiSquared -> geogebra.common.i.q.D:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseExponential -> geogebra.common.i.q.E:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseFDistribution -> geogebra.common.i.q.F:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseGamma -> geogebra.common.i.q.G:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseHyperGeometric -> geogebra.common.i.q.H:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseNormal -> geogebra.common.i.q.I:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInversePascal -> geogebra.common.i.q.J:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInversePoisson -> geogebra.common.i.q.K:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseTDistribution -> geogebra.common.i.q.L:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseWeibull -> geogebra.common.i.q.M:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoInverseZipf -> geogebra.common.i.q.N:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoListCovariance -> geogebra.common.i.q.O:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListMeanX -> geogebra.common.i.q.P:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListMeanY -> geogebra.common.i.q.Q:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListPMCC -> geogebra.common.i.q.R:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSDX -> geogebra.common.i.q.S:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSDY -> geogebra.common.i.q.T:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSXX -> geogebra.common.i.q.U:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSXY -> geogebra.common.i.q.V:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSYY -> geogebra.common.i.q.W:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSampleSDX -> geogebra.common.i.q.X:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSampleSDY -> geogebra.common.i.q.Y:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaXX -> geogebra.common.i.q.Z:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaXY -> geogebra.common.i.q.aa:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoListSigmaYY -> geogebra.common.i.q.ab:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoMean -> geogebra.common.i.q.ac:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoMedian -> geogebra.common.i.q.ad:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric median -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getMedian() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoMode -> geogebra.common.i.q.ae:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.statistics.AlgoNormal -> geogebra.common.i.q.af:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoOrdinalRank -> geogebra.common.i.q.ag:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    java.util.Comparator comparator -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    java.util.Comparator getComparator() -> a
geogebra.common.kernel.statistics.AlgoOrdinalRank$1 -> geogebra.common.i.q.ah:
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.common.kernel.statistics.AlgoOrdinalRank$OrderedPair -> geogebra.common.i.q.ag$a:
    double x -> a
    int y -> a
    geogebra.common.kernel.statistics.AlgoOrdinalRank this$0 -> a
geogebra.common.kernel.statistics.AlgoPascal -> geogebra.common.i.q.ai:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPascalBarChart -> geogebra.common.i.q.aj:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.AlgoPercentile -> geogebra.common.i.q.ak:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric value -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    int size -> a
    org.apache.commons.math.stat.descriptive.rank.Percentile percentile -> a
    double[] inputArray -> a
    double val -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPoisson -> geogebra.common.i.q.al:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoPoissonBarChart -> geogebra.common.i.q.am:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.AlgoProduct -> geogebra.common.i.q.an:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoQ1 -> geogebra.common.i.q.ao:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric Q1 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getQ1() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoQ3 -> geogebra.common.i.q.ap:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric Q3 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getQ3() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRSquare -> geogebra.common.i.q.aq:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoNumeric r2 -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getRSquare() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoRandom -> geogebra.common.i.q.ar:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    double random(double,double) -> a
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRandomBinomial -> geogebra.common.i.q.as:
    double halflog2pi -> a
    double[] logtable -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    void setRandomValue(double) -> a
    int randomBinomial(double,double) -> a
geogebra.common.kernel.statistics.AlgoRandomNormal -> geogebra.common.i.q.at:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    double randomNormal(double,double) -> a
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRandomPoisson -> geogebra.common.i.q.au:
    geogebra.common.kernel.arithmetic.NumberValue a -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    double halflog2pi -> a
    double[] logtable -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    int randomPoisson(double) -> a
    int randomPoissonTRS(double) -> b
    double logOfKFactorial(int) -> a
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRandomUniform -> geogebra.common.i.q.av:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
    void setRandomValue(double) -> a
geogebra.common.kernel.statistics.AlgoRootMeanSquare -> geogebra.common.i.q.aw:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int size -> a
    double sum -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoSXX -> geogebra.common.i.q.ax:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSample -> geogebra.common.i.q.ay:
    int SAMPLE_MAXSIZE -> a
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoBoolean replacement -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
    void setListElement(int,double) -> a
geogebra.common.kernel.statistics.AlgoSampleStandardDeviation -> geogebra.common.i.q.az:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSampleVariance -> geogebra.common.i.q.aA:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoShuffle -> geogebra.common.i.q.aB:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoSigmaXX -> geogebra.common.i.q.aC:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSpearman -> geogebra.common.i.q.aD:
    geogebra.common.kernel.geos.GeoList geoListPts -> a
    geogebra.common.kernel.geos.GeoList geoListX -> b
    geogebra.common.kernel.geos.GeoList geoListY -> c
    geogebra.common.kernel.geos.GeoNumeric result -> a
    org.apache.commons.math.stat.correlation.SpearmansCorrelation sp -> a
    double[] valX -> a
    double[] valY -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoStandardDeviation -> geogebra.common.i.q.aE:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoStats1D -> geogebra.common.i.q.aF:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric Truncate -> a
    geogebra.common.kernel.geos.GeoNumeric result -> b
    int stat -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoStats2D -> geogebra.common.i.q.aG:
    geogebra.common.kernel.geos.GeoList geoListx -> a
    geogebra.common.kernel.geos.GeoList geoListy -> b
    geogebra.common.kernel.geos.GeoNumeric result -> a
    int mode -> a
    int stat -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoSum -> geogebra.common.i.q.aH:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoSumSquaredErrors -> geogebra.common.i.q.aI:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoFunctionable function -> a
    geogebra.common.kernel.geos.GeoNumeric sse -> a
    int size -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getsse() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTDistribution -> geogebra.common.i.q.aJ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTMean2Estimate -> geogebra.common.i.q.aK:
    geogebra.common.kernel.geos.GeoList geoList1 -> a
    geogebra.common.kernel.geos.GeoList geoList2 -> b
    geogebra.common.kernel.geos.GeoNumeric geoLevel -> a
    geogebra.common.kernel.geos.GeoNumeric geoMean1 -> b
    geogebra.common.kernel.geos.GeoNumeric geoSD1 -> c
    geogebra.common.kernel.geos.GeoNumeric geoN1 -> d
    geogebra.common.kernel.geos.GeoNumeric geoMean2 -> e
    geogebra.common.kernel.geos.GeoNumeric geoSD2 -> f
    geogebra.common.kernel.geos.GeoNumeric geoN2 -> g
    geogebra.common.kernel.geos.GeoBoolean geoPooled -> a
    geogebra.common.kernel.geos.GeoList result -> c
    double[] val1 -> a
    double[] val2 -> b
    int size1 -> a
    int size2 -> b
    double level -> a
    double mean1 -> b
    double var1 -> c
    double n1 -> d
    double mean2 -> e
    double var2 -> f
    double n2 -> g
    double me -> h
    boolean pooled -> a
    org.apache.commons.math.stat.descriptive.SummaryStatistics stats -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    double difference -> i
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getDegreeOfFreedom(double,double,double,double,boolean) -> a
    double getMarginOfError(double,double,double,double,double,boolean) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTMeanEstimate -> geogebra.common.i.q.aL:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric geoLevel -> a
    geogebra.common.kernel.geos.GeoNumeric geoMean -> b
    geogebra.common.kernel.geos.GeoNumeric geoSD -> c
    geogebra.common.kernel.geos.GeoNumeric geoN -> d
    geogebra.common.kernel.geos.GeoList result -> b
    double[] val -> a
    double level -> a
    double mean -> b
    double sd -> c
    double n -> d
    double me -> e
    org.apache.commons.math.stat.descriptive.SummaryStatistics stats -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double getMarginOfError(double,double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTest -> geogebra.common.i.q.aM:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra.common.kernel.geos.GeoNumeric hypMean -> a
    geogebra.common.kernel.geos.GeoNumeric mean -> b
    geogebra.common.kernel.geos.GeoNumeric sd -> c
    geogebra.common.kernel.geos.GeoNumeric n -> d
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> b
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val -> a
    double p -> a
    double testStat -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTest2 -> geogebra.common.i.q.aN:
    geogebra.common.kernel.geos.GeoList geoList0 -> a
    geogebra.common.kernel.geos.GeoList geoList1 -> b
    geogebra.common.kernel.geos.GeoNumeric mean0 -> a
    geogebra.common.kernel.geos.GeoNumeric mean1 -> b
    geogebra.common.kernel.geos.GeoNumeric sd0 -> c
    geogebra.common.kernel.geos.GeoNumeric sd1 -> d
    geogebra.common.kernel.geos.GeoNumeric n0 -> e
    geogebra.common.kernel.geos.GeoNumeric n1 -> f
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoBoolean pooled -> a
    geogebra.common.kernel.geos.GeoList result -> c
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val0 -> a
    double[] val1 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTTestPaired -> geogebra.common.i.q.aO:
    geogebra.common.kernel.geos.GeoList geoList0 -> a
    geogebra.common.kernel.geos.GeoList geoList1 -> b
    geogebra.common.kernel.geos.GeoText tail -> a
    geogebra.common.kernel.geos.GeoList result -> c
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    double[] val0 -> a
    double[] val1 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    double adjustedPValue(double,double) -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoTiedRank -> geogebra.common.i.q.aP:
    geogebra.common.kernel.geos.GeoList inputList -> a
    geogebra.common.kernel.geos.GeoList outputList -> b
    int size -> a
    org.apache.commons.math.stat.ranking.NaturalRanking rankingAlgorithm -> a
    double[] inputArray -> a
    double[] outputArray -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoList getResult() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoVariance -> geogebra.common.i.q.aQ:
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra.common.kernel.statistics.AlgoWeibull -> geogebra.common.i.q.aR:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZipf -> geogebra.common.i.q.aS:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void compute() -> b
geogebra.common.kernel.statistics.AlgoZipfBarChart -> geogebra.common.i.q.aT:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.algos.AlgoDrawInformation copy() -> a
geogebra.common.kernel.statistics.RegressionMath -> geogebra.common.i.q.aU:
    boolean error -> a
    double p1 -> a
    double p2 -> b
    double p3 -> c
    double p4 -> d
    double p5 -> e
    double sigmax -> f
    double sigmax2 -> g
    double sigmax3 -> h
    double sigmax4 -> i
    double sigmax5 -> j
    double sigmax6 -> k
    double sigmax7 -> l
    double sigmax8 -> m
    double sigmay -> n
    double sigmay2 -> o
    double sigmaxy -> p
    double sigmax2y -> q
    double sigmax3y -> r
    double sigmax4y -> s
    geogebra.common.kernel.geos.GeoList geolist -> a
    double[] xlist -> a
    double[] ylist -> b
    int size -> a
    double[][] marray -> a
    double[][] yarray -> b
    double[] pararray -> c
    double getP1() -> a
    double getP2() -> b
    double getP3() -> c
    double getP4() -> d
    double getP5() -> e
    double[] getPar() -> a
    boolean doPolyN(geogebra.common.kernel.geos.GeoList,int) -> a
    boolean doLinear(geogebra.common.kernel.geos.GeoList) -> a
    boolean doQuad(geogebra.common.kernel.geos.GeoList) -> b
    boolean doCubic(geogebra.common.kernel.geos.GeoList) -> c
    boolean doQuart(geogebra.common.kernel.geos.GeoList) -> d
    boolean doExp(geogebra.common.kernel.geos.GeoList) -> e
    boolean doLog(geogebra.common.kernel.geos.GeoList) -> f
    boolean doPow(geogebra.common.kernel.geos.GeoList) -> g
    double det22(double,double,double,double) -> a
    double det33(double,double,double,double,double,double,double,double,double) -> a
    double det44(double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double) -> a
    double det55(double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double,double) -> a
    void doSums(int) -> a
    void getPoints() -> a
    void makeMatrixArrays(int) -> b
geogebra.common.kernel.statistics.SetRandomValue -> geogebra.common.i.q.aV:
    void setRandomValue(double) -> a
geogebra.common.main.AbstractApplication -> geogebra.common.j.a:
    geogebra.common.plugin.ScriptManagerCommon scriptManager -> a
    boolean hasFullPermissions -> a
    boolean isSaved -> b
    boolean showResetIcon -> y
    boolean runningInFrame -> c
    java.util.HashMap specialLanguageNames -> a
    int capturingThreshold -> a
    boolean showInputTop -> d
    boolean showAlgebraInput -> e
    boolean showInputHelpToggle -> f
    boolean showAuxiliaryObjects -> g
    java.lang.String CASVersionString -> d
    java.lang.String proverEngine -> a
    int proverTimeout -> b
    int maxTerms -> c
    java.lang.String proverMethod -> b
    boolean freePointsNeverCollinear -> h
    boolean useFixCoordinates -> i
    boolean useSingularWebService -> j
    java.lang.String singularWebServiceRemoteURL -> c
    int singularWebServiceTimeout -> d
    geogebra.common.io.MyXMLio myXMLio -> a
    int guiFontSize -> l
    int appFontSize -> m
    char unicodeDecimalPoint -> a
    char unicodeComma -> b
    char unicodeZero -> c
    int maxLayerUsed -> e
    int booleanSize -> f
    int rightAngleStyle -> g
    boolean useJavaFontsForLaTeX -> k
    java.util.ArrayList selectedGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    boolean isOnTheFlyPointCreationActive -> l
    geogebra.common.main.settings.Settings settings -> a
    boolean antialiasing -> m
    boolean[] showAxes -> a
    boolean showGrid -> n
    boolean initing -> o
    boolean labelDragsEnabled -> p
    java.util.HashMap translateCommandTable -> b
    java.util.HashMap translateCommandTableScripting -> c
    geogebra.common.util.LowerCaseDictionary commandDict -> a
    geogebra.common.util.LowerCaseDictionary commandDictCAS -> b
    geogebra.common.euclidian.AbstractEuclidianView euclidianView -> a
    geogebra.common.euclidian.AbstractEuclidianController euclidianController -> a
    geogebra.common.main.GeoElementSelectionListener currentSelectionListener -> a
    boolean showMenuBar -> q
    geogebra.common.util.LowerCaseDictionary[] subCommandDict -> a
    java.lang.String oldScriptLanguage -> e
    java.lang.String scriptingLanguage -> f
    boolean blockUpdateScripts -> z
    boolean useBrowserForJavaScript -> A
    java.lang.String[] fontSizeStrings -> a
    int[] roundingMenuLookup -> a
    int[] decimalsLookup -> b
    int[] figuresLookup -> c
    java.lang.String[] strDecimalSpacesAC -> b
    java.lang.StringBuilder sbOrdinal -> a
    boolean useLocalizedDigits -> B
    boolean reverseNameDescription -> C
    boolean isAutoCompletePossible -> D
    boolean rightToLeftReadingOrder -> E
    boolean rightToLeftDigits -> F
    geogebra.common.util.GeoGebraLogger logger -> a
    geogebra.common.cas.singularws.SingularWebService singularWS -> a
    boolean miniPropertiesActive -> G
    int[] version -> d
    geogebra.common.kernel.Macro macro -> a
    int labelingStyle -> n
    boolean scriptingDisabled -> H
    boolean reverseMouseWheel -> r
    boolean useLocalizedLabels -> I
    java.util.ArrayList tmpPerspectives -> b
    boolean showToolBar -> s
    geogebra.common.gui.view.properties.PropertiesView propertiesView -> a
    boolean shiftDragZoomEnabled -> t
    boolean tooltipFlag -> u
    boolean useTransparentCursorWhenDragging -> v
    int dataParamWidth -> h
    int dataParamHeight -> i
    boolean useFullGui -> w
    java.lang.StringBuilder sbPlain -> b
    boolean useFullAppGui -> x
    int appCanvasHeight -> j
    int appCanvasWidth -> k
    void setCASVersionString(java.lang.String) -> a
    java.lang.String getCASVersionString() -> a
    boolean useJavaFontsForLaTeX() -> a
    void fillCommandDictScripting() -> Q
    boolean isCommandChanged() -> b
    void setCommandChanged(boolean) -> a
    boolean isCommandNull() -> c
    geogebra.common.util.LowerCaseDictionary newLowerCaseDictionary() -> a
    void fillCasCommandDict() -> a
    geogebra.common.util.LowerCaseDictionary getCommandDictionaryCAS() -> b
    geogebra.common.util.LowerCaseDictionary[] getSubCommandDictionary() -> a
    void initTranslatedCommands() -> b
    geogebra.common.util.LowerCaseDictionary getCommandDictionary() -> c
    void initCommand() -> c
    void fillCommandDict() -> d
    boolean tableVisible(int) -> a
    java.lang.String translateCommand(java.lang.String) -> a
    void updateCommandDictionary() -> e
    void addMacroCommands() -> f
    void removeMacroCommands() -> g
    void initScriptingBundle() -> h
    java.lang.String getScriptingCommand(java.lang.String) -> b
    java.lang.String getCommand(java.lang.String) -> c
    java.lang.String getPlain(java.lang.String) -> d
    java.lang.String getMenu(java.lang.String) -> e
    java.lang.String getError(java.lang.String) -> f
    java.lang.String getSymbol(int) -> a
    java.lang.String getSymbolTooltip(int) -> b
    void setTooltipFlag() -> i
    boolean isApplet() -> d
    void storeUndoInfo() -> j
    boolean isUsingFullGui() -> e
    boolean showView(int) -> b
    java.lang.String getLanguage() -> b
    boolean languageIs(java.lang.String) -> a
    boolean letRename() -> f
    boolean letDelete() -> g
    boolean letRedefine() -> h
    java.lang.String translationFix(java.lang.String) -> g
    java.lang.String translationFixHu(java.lang.String) -> m
    java.lang.String translationFixPronouncedPrevChars(java.lang.String,int,int) -> a
    java.lang.String translationFixHuAffixChange(java.lang.String,int,java.lang.String,java.lang.String,java.lang.String) -> a
    void traceToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> a
    void resetTraceColumn(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isBlockUpdateScripts() -> i
    void setBlockUpdateScripts(boolean) -> b
    java.lang.String getInternalCommand(java.lang.String) -> h
    void showError(java.lang.String) -> b
    void setUseBrowserForJavaScript(boolean) -> c
    boolean useBrowserForJavaScript() -> j
    void initJavaScriptViewWithoutJavascript() -> k
    geogebra.common.plugin.ScriptManagerCommon getScriptManager() -> a
    java.lang.String getTraceXML(geogebra.common.kernel.geos.GeoElement) -> a
    void updateMaxLayerUsed(int) -> a
    boolean is3D() -> k
    java.lang.String[] getFontSizeStrings() -> a
    geogebra.common.kernel.geos.GeoElement getLastCreatedGeoElement() -> a
    java.lang.String[] getRoundingMenu() -> b
    boolean isZeroPlural(java.lang.String) -> b
    void deleteSelectedObjects() -> l
    void setSelectedGeos(java.util.ArrayList) -> a
    void selectAll(int) -> b
    void invertSelection() -> m
    void selectAllPredecessors() -> n
    void showHideSelection() -> o
    void showHideSelectionLabels() -> p
    boolean showAuxiliaryObjects() -> l
    void selectAllDescendants() -> q
    void getKeyboardXML(java.lang.StringBuilder) -> a
    boolean freeMemoryIsCritical() -> m
    long freeMemory() -> a
    java.lang.String getOrdinalNumber(int) -> c
    java.lang.String getOrdinalNumberEn(int) -> d
    boolean isUsingLocalizedDigits() -> n
    void setUseLocalizedDigits(boolean) -> d
    boolean isReverseNameDescriptionLanguage() -> o
    boolean isAutoCompletePossible() -> p
    boolean isRightToLeftReadingOrder() -> q
    boolean isRightToLeftDigits(geogebra.common.kernel.StringTemplate) -> a
    void updateReverseLanguage(java.lang.String) -> c
    void updateRightAngleStyle() -> r
    int getMaxLayerUsed() -> a
    double countPixels(double,double) -> a
    geogebra.common.gui.view.algebra.AlgebraView getAlgebraView() -> a
    geogebra.common.euclidian.AbstractEuclidianView getEuclidianView1() -> a
    void resetMaxLayerUsed() -> s
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getActiveEuclidianView() -> a
    void getEuclidianViewXML(java.lang.StringBuilder,boolean) -> a
    boolean hasEuclidianView3D() -> r
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getEuclidianView3D() -> b
    boolean hasEuclidianView2EitherShowingOrNot() -> s
    boolean isShowingEuclidianView2() -> t
    geogebra.common.util.AbstractImageManager getImageManager() -> a
    geogebra.common.gui.GuiManager getGuiManager() -> a
    geogebra.common.gui.dialog.DialogManager getDialogManager() -> a
    void initGuiManager() -> t
    void printStacktrace(java.lang.String) -> d
    void initializeSingularWS() -> u
    void debug(java.lang.Object) -> a
    void debug(java.lang.String) -> e
    void notice(java.lang.String) -> f
    void info(java.lang.String) -> g
    void error(java.lang.String) -> h
    void warn(java.lang.String) -> i
    void trace(java.lang.String) -> j
    boolean isMacOS() -> u
    boolean isWindows() -> v
    java.lang.String getScriptingLanguage() -> c
    void setScriptingLanguage(java.lang.String) -> k
    boolean isWhitespace(char) -> a
    void evalJavaScript(geogebra.common.main.AbstractApplication,java.lang.String,java.lang.String) -> a
    boolean fileVersionBefore(int[]) -> a
    void setFileVersion(java.lang.String) -> l
    int[] getSubValues(java.lang.String) -> a
    geogebra.common.euclidian.AbstractEuclidianView createEuclidianView() -> b
    int getMode() -> b
    int getCurrentLabelingStyle() -> c
    java.lang.String reverseGetColor(java.lang.String) -> i
    java.lang.String getColor(java.lang.String) -> j
    int getMD5folderLength(java.lang.String) -> a
    geogebra.common.awt.BufferedImage getExternalImageAdapter(java.lang.String) -> a
    java.lang.String getSyntaxString() -> d
    java.lang.String getCommandSyntax(java.lang.String) -> k
    void clearSelectedGeos() -> v
    void clearSelectedGeos(boolean) -> e
    boolean isLabelDragsEnabled() -> w
    void setLabelDragsEnabled(boolean) -> f
    void setScrollToShow(boolean) -> g
    void setUnsaved() -> w
    void setActiveView(int) -> c
    void refreshViews() -> x
    void openMacro(geogebra.common.kernel.Macro) -> a
    geogebra.common.kernel.Macro getMacro() -> a
    java.lang.String getMacroXML() -> e
    boolean hasEuclidianView2() -> x
    void showRelation(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void showError(geogebra.common.main.MyError) -> a
    java.lang.String getXML() -> f
    void showError(java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.View getView(int) -> a
    java.lang.String getCompleteUserInterfaceXML(boolean) -> a
    void getScriptingXML(java.lang.StringBuilder,boolean) -> c
    geogebra.common.main.settings.Settings getSettings() -> a
    java.lang.String getUniqueId() -> g
    void setUniqueId(java.lang.String) -> m
    void setShowAuxiliaryObjects(boolean) -> h
    void setLabelingStyle(int) -> d
    int getLabelingStyle() -> d
    boolean isScriptingDisabled() -> y
    void setScriptingDisabled(boolean) -> i
    boolean isMouseWheelReversed() -> z
    void reverseMouseWheel(boolean) -> j
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    int getTooltipTimeout() -> e
    boolean isUsingLocalizedLabels() -> A
    void setUseLocalizedLabels(boolean) -> k
    void setTooltipLanguage(java.lang.String) -> n
    geogebra.common.euclidian.DrawEquationInterface getDrawEquation() -> a
    void setShowConstructionProtocolNavigation(boolean) -> l
    void setTmpPerspectives(java.util.ArrayList) -> b
    java.util.ArrayList getTmpPerspectives() -> a
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    void setTooltipTimeout(int) -> e
    geogebra.common.euclidian.AbstractEuclidianView getEuclidianView2() -> c
    double getWidth() -> a
    double getHeight() -> b
    geogebra.common.awt.Font getFontCommon(boolean,int,int) -> a
    geogebra.common.awt.Font getPlainFontCommon() -> a
    boolean isExporting() -> B
    java.util.ArrayList getSelectedGeos() -> b
    void setShowToolBarNoUpdate(boolean) -> m
    void addSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> c
    void addSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void addSelectedGeos(java.util.ArrayList,boolean) -> a
    void initKernel() -> y
    void initEuclidianViews() -> z
    geogebra.common.euclidian.AbstractEuclidianView newEuclidianView(boolean[],boolean) -> a
    geogebra.common.euclidian.AbstractEuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.AbstractUndoManager getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.AbstractAnimationManager newAnimationManager(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter newGeoElementGraphicsAdapter() -> a
    void repaintSpreadsheet() -> A
    boolean isOnTheFlyPointCreationActive() -> C
    geogebra.common.gui.view.spreadsheet.SpreadsheetTraceManager getTraceManager() -> a
    void setDefaultCursor() -> B
    void setWaitCursor() -> C
    geogebra.common.kernel.algos.AlgoElement newAlgoShortestDistance(geogebra.common.kernel.Construction,java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.geos.GeoBoolean) -> a
    void updateStyleBars() -> D
    void toggleSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> d
    void toggleSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean) -> b
    void setMoveMode() -> E
    geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel getSpreadsheetTableModel() -> a
    void setMode(int) -> f
    void addToEuclidianView(geogebra.common.kernel.geos.GeoElement) -> e
    void removeFromEuclidianView(geogebra.common.kernel.geos.GeoElement) -> f
    void setXML(java.lang.String,boolean) -> a
    geogebra.common.plugin.GgbAPI getGgbApi() -> a
    geogebra.common.sound.SoundManager getSoundManager() -> a
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.kernel.commands.CommandProcessor newCmdBarCode() -> a
    int selectedGeosSize() -> f
    boolean isRightClick(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean isControlDown(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean isMiddleClick(geogebra.common.euclidian.event.AbstractEvent) -> c
    boolean showAlgebraInput() -> D
    geogebra.common.main.GlobalKeyDispatcher getGlobalKeyDispatcher() -> a
    void callAppletJavaScript(java.lang.String,java.lang.Object[]) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> c
    void setPropertiesView(geogebra.common.gui.view.properties.PropertiesView) -> a
    void setSelectionListenerMode(geogebra.common.main.GeoElementSelectionListener) -> a
    void updateSelection() -> F
    boolean containsSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void removeSelectedGeo(geogebra.common.kernel.geos.GeoElement) -> g
    void removeSelectedGeo(geogebra.common.kernel.geos.GeoElement,boolean) -> d
    void selectNextGeo() -> G
    void selectLastGeo() -> H
    boolean isIniting() -> E
    boolean isRightClickEnabled() -> F
    boolean isShiftDragZoomEnabled() -> G
    void setShiftDragZoomEnabled(boolean) -> n
    void updateMenubar() -> I
    int getFontSize() -> g
    void setFontSize(int) -> g
    void setFontSize(int,boolean) -> a
    void updateUI() -> J
    void clearTooltipFlag() -> K
    void resetFonts() -> L
    int getGUIFontSize() -> h
    void setGUIFontSize(int) -> h
    geogebra.common.main.AbstractFontManager getFontManager() -> a
    void updateFonts() -> M
    geogebra.common.awt.Font getFontCanDisplay(java.lang.String) -> a
    geogebra.common.awt.Font getFontCanDisplay(java.lang.String,int) -> a
    geogebra.common.awt.Font getFontCanDisplay(java.lang.String,boolean,int,int) -> a
    java.lang.String getGuiXML(boolean) -> b
    java.lang.String getConsProtocolXML() -> h
    java.lang.String getTooltipLanguageString() -> i
    void getWindowLayoutXML(java.lang.StringBuilder,boolean) -> b
    void reset() -> N
    geogebra.common.plugin.jython.PythonBridge getPythonBridge() -> a
    java.lang.String getPlainTooltip(java.lang.String) -> l
    geogebra.common.main.GeoElementSelectionListener getCurrentSelectionListener() -> a
    void setCurrentSelectionListener(geogebra.common.main.GeoElementSelectionListener) -> b
    void setShowResetIcon(boolean) -> o
    boolean showResetIcon() -> H
    boolean isUndoActive() -> I
    boolean isHTML5Applet() -> J
    void setOnTheFlyPointCreationActive(boolean) -> p
    void setUseTransparentCursorWhenDragging(boolean) -> q
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getFormulaRenderingType() -> a
    void doAfterRedefine(geogebra.common.kernel.geos.GeoElement) -> h
    java.lang.String getLocaleStr() -> j
    void showURLinBrowser(java.lang.String) -> o
    void uploadToGeoGebraTube() -> O
    int getDataParamWidth() -> i
    int getDataParamHeight() -> j
    boolean getUseFullGui() -> K
    void setUndoActive(boolean) -> r
    java.lang.String getPlain(java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getPlain(java.lang.String,java.lang.String[]) -> a
    boolean isFullAppGui() -> L
    int getAppCanvasWidth() -> k
    int getAppCanvasHeight() -> l
    geogebra.common.awt.Image getInternalImageAdapter(java.lang.String) -> a
    boolean showInputTop() -> M
    void setShowInputTop(boolean,boolean) -> a
    boolean showInputHelpToggle() -> N
    void setShowInputHelpToggle(boolean) -> s
    void updateTopBottomPanels() -> P
    java.lang.String getToolNameOrHelp(int,boolean) -> a
    java.lang.String getToolName(int) -> e
    java.lang.String getToolHelp(int) -> f
geogebra.common.main.AbstractApplication$CasType -> geogebra.common.j.a$a:
    geogebra.common.main.AbstractApplication$CasType NO_CAS -> a
    geogebra.common.main.AbstractApplication$CasType MATHPIPER -> b
    geogebra.common.main.AbstractApplication$CasType MAXIMA -> c
    geogebra.common.main.AbstractApplication$CasType MPREDUCE -> d
    geogebra.common.main.AbstractApplication$CasType[] ENUM$VALUES -> a
    geogebra.common.main.AbstractApplication$CasType[] values() -> values
    geogebra.common.main.AbstractApplication$CasType valueOf(java.lang.String) -> valueOf
geogebra.common.main.AbstractFontManager -> geogebra.common.j.b:
    void setFontSize(int) -> a
    geogebra.common.awt.Font getFontCanDisplay(java.lang.String,boolean,int,int) -> a
geogebra.common.main.GeoElementSelectionListener -> geogebra.common.j.c:
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
geogebra.common.main.GeoGebraColorConstants -> geogebra.common.j.d:
    geogebra.common.awt.Color TABLE_SELECTED_BACKGROUND_COLOR -> a
    geogebra.common.awt.Color TABLE_SELECTED_BACKGROUND_COLOR_HEADER -> b
    geogebra.common.awt.Color TABLE_BACKGROUND_COLOR_HEADER -> c
    geogebra.common.awt.Color TABLE_GRID_COLOR -> d
    geogebra.common.awt.Color RED -> e
    geogebra.common.awt.Color ORANGE -> f
    geogebra.common.awt.Color YELLOW -> g
    geogebra.common.awt.Color GREEN -> h
    geogebra.common.awt.Color CYAN -> i
    geogebra.common.awt.Color BLUE -> j
    geogebra.common.awt.Color VIOLET -> k
    geogebra.common.awt.Color MAGENTA -> l
    geogebra.common.awt.Color LIME -> m
    geogebra.common.awt.Color PINK -> n
    geogebra.common.awt.Color LIGHTORANGE -> o
    geogebra.common.awt.Color LIGHTYELLOW -> p
    geogebra.common.awt.Color AQUA -> q
    geogebra.common.awt.Color LIGHTPURPLE -> r
    geogebra.common.awt.Color LIGHTVIOLET -> s
    geogebra.common.awt.Color TURQUOISE -> t
    geogebra.common.awt.Color LIGHTGREEN -> u
    geogebra.common.awt.Color MAROON -> v
    geogebra.common.awt.Color BROWN -> w
    geogebra.common.awt.Color DARKGREEN -> x
    geogebra.common.awt.Color LIGHTBLUE -> y
    geogebra.common.awt.Color GOLD -> z
    geogebra.common.awt.Color DARKBLUE -> A
    geogebra.common.awt.Color INDIGO -> B
    geogebra.common.awt.Color PURPLE -> C
    geogebra.common.awt.Color CRIMSON -> D
    geogebra.common.awt.Color WHITE -> E
    geogebra.common.awt.Color BLACK -> F
    geogebra.common.awt.Color GRAY7 -> G
    geogebra.common.awt.Color GRAY6 -> H
    geogebra.common.awt.Color GRAY5 -> I
    geogebra.common.awt.Color GRAY4 -> J
    geogebra.common.awt.Color GRAY3 -> K
    geogebra.common.awt.Color GRAY2 -> L
    geogebra.common.awt.Color GRAY1 -> M
    geogebra.common.awt.Color DARKGRAY -> N
    geogebra.common.awt.Color LIGHTGRAY -> O
    geogebra.common.awt.Color SILVER -> P
    java.util.HashMap geogebraColor -> a
    java.util.HashMap geogebraColorReverse -> b
    geogebra.common.awt.Color[] primaryColors -> b
    geogebra.common.awt.Color[] lightPrimaryColors -> c
    geogebra.common.awt.Color[] darkPrimaryColors -> d
    geogebra.common.awt.Color[] grayColors -> e
    geogebra.common.awt.Color[] mainColorSwatchColors -> a
    java.util.HashMap colors -> c
    java.util.HashMap getGeoGebraColors() -> b
    java.util.HashMap getGeoGebraColorReverse() -> c
    geogebra.common.awt.Color getGeogebraColor(geogebra.common.main.AbstractApplication,java.lang.String) -> a
    java.lang.String getGeogebraColorName(geogebra.common.main.AbstractApplication,geogebra.common.awt.Color) -> a
    geogebra.common.awt.Color grayN(int) -> a
    geogebra.common.awt.Color[] getPrimaryColors() -> b
    geogebra.common.awt.Color[] getLightPrimaryColors() -> c
    geogebra.common.awt.Color[] getDarkPrimaryColors() -> d
    geogebra.common.awt.Color[] getGrayColors() -> e
    geogebra.common.awt.Color[] getPopupArray(int) -> a
    geogebra.common.awt.Color[] getPrimarySwatchColors() -> a
    java.util.HashMap htmlColorMap() -> a
geogebra.common.main.GlobalKeyDispatcher -> geogebra.common.j.e:
    geogebra.common.main.AbstractApplication app -> a
    java.util.TreeSet tempSet -> a
    geogebra.common.kernel.Matrix.Coords tempVec -> a
    void handleFunctionKeyForAlgebraInput(int,geogebra.common.kernel.geos.GeoElement) -> a
    java.util.TreeSet getTempSet() -> a
    boolean handleArrowKeyMovement(java.util.ArrayList,double,double,double) -> a
geogebra.common.main.MyError -> geogebra.common.j.f:
    geogebra.common.main.AbstractApplication app -> a
    java.lang.String[] strs -> a
    java.lang.String commandName -> a
    java.lang.String getcommandName() -> a
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    java.lang.String toString() -> toString
geogebra.common.main.MyParseError -> geogebra.common.j.g:
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
geogebra.common.main.settings.AbstractSettings -> geogebra.common.j.a.a:
    boolean isBatch -> a
    boolean settingsChanged -> b
    java.util.LinkedList listeners -> a
    void settingChanged() -> a
    void beginBatch() -> b
    void endBatch() -> c
    void addListener(geogebra.common.main.settings.SettingListener) -> a
    void removeListener(geogebra.common.main.settings.SettingListener) -> b
    java.util.LinkedList getListeners() -> a
geogebra.common.main.settings.AlgebraSettings -> geogebra.common.j.a.b:
geogebra.common.main.settings.ApplicationSettings -> geogebra.common.j.a.c:
geogebra.common.main.settings.CASSettings -> geogebra.common.j.a.d:
    long timeoutMillis -> a
    boolean showExpAsRoots -> a
    void init() -> d
    void setTimeoutMilliseconds(long) -> a
    void setShowExpAsRoots(boolean) -> a
    long getTimeoutMilliseconds() -> a
    boolean getShowExpAsRoots() -> a
geogebra.common.main.settings.ConstructionProtocolSettings -> geogebra.common.j.a.e:
    boolean showConstructionProtocol -> a
    double playDelay -> a
    boolean showPlayButton -> b
    boolean showConsProtButton -> c
    boolean[] defaultCpColumnsVisible -> a
    boolean[] cpColumnsVisible -> b
    boolean showPlayButton() -> a
    void setShowPlayButton(boolean) -> a
    double getPlayDelay() -> a
    void setPlayDelay(double) -> a
    boolean showConstructionProtocol() -> b
    void setShowConstructionProtocol(boolean) -> b
    boolean[] getColsVisibility() -> a
    void setColsVisibility(boolean[]) -> a
geogebra.common.main.settings.EuclidianSettings -> geogebra.common.j.a.f:
    geogebra.common.awt.Color backgroundColor -> a
    geogebra.common.awt.Color axesColor -> b
    geogebra.common.awt.Color gridColor -> c
    int axesLineStyle -> a
    int gridLineStyle -> b
    double[] gridDistances -> a
    double[] axisCross -> b
    boolean[] positiveAxes -> e
    boolean[] drawBorderAxes -> f
    geogebra.common.kernel.arithmetic.NumberValue xminObject -> a
    geogebra.common.kernel.arithmetic.NumberValue xmaxObject -> b
    geogebra.common.kernel.arithmetic.NumberValue yminObject -> c
    geogebra.common.kernel.arithmetic.NumberValue ymaxObject -> d
    int tooltipsInThisView -> c
    geogebra.common.main.settings.EuclidianSettings euclidianSettings1 -> a
    boolean[] showAxes -> a
    boolean[] showAxesNumbers -> b
    java.lang.String[] axesLabels -> a
    java.lang.String[] axesUnitLabels -> b
    boolean[] piAxisUnit -> c
    int[] axesTickStyles -> a
    boolean[] automaticAxesNumberingDistances -> d
    double axisNumberingDistanceX -> a
    double axisNumberingDistanceY -> b
    boolean automaticGridDistance -> a
    double xZero -> c
    double yZero -> d
    double xscale -> e
    double yscale -> f
    geogebra.common.awt.Dimension preferredSize -> a
    boolean showGrid -> b
    boolean gridIsBold -> c
    int gridType -> d
    int pointCapturingMode -> e
    boolean allowShowMouseCoords -> d
    java.lang.Double lockedAxesRatio -> a
    void reset() -> d
    void setBackground(geogebra.common.awt.Color) -> a
    geogebra.common.awt.Color getBackground() -> a
    void setAxesColor(geogebra.common.awt.Color) -> b
    geogebra.common.awt.Color getAxesColor() -> b
    void setGridColor(geogebra.common.awt.Color) -> c
    geogebra.common.awt.Color getGridColor() -> c
    void setAxesLineStyle(int) -> a
    int getAxesLineStyle() -> a
    void setGridLineStyle(int) -> b
    int getGridLineStyle() -> b
    void setGridDistances(double[]) -> a
    double[] getGridDistances() -> a
    void setAutomaticGridDistance(boolean,boolean) -> a
    boolean getAutomaticGridDistance() -> a
    boolean getAllowShowMouseCoords() -> b
    void setAllowShowMouseCoords(boolean) -> a
    void setShowAxis(int,boolean) -> a
    boolean getShowAxis(int) -> a
    void setAxisLabel(int,java.lang.String) -> a
    java.lang.String[] getAxesLabels() -> a
    java.lang.String[] getAxesUnitLabels() -> b
    void setAxesUnitLabels(java.lang.String[]) -> a
    void setShowAxisNumbers(int,boolean) -> b
    boolean[] getShowAxisNumbers() -> a
    double getAxisNumberingDistanceX() -> a
    double getAxisNumberingDistanceY() -> b
    void setAxisNumberingDistanceX(double) -> a
    void setAxisNumberingDistanceY(double) -> b
    void setAutomaticAxesNumberingDistance(boolean,int,boolean) -> a
    boolean getAutomaticAxesNumberingDistance(int) -> b
    int[] getAxesTickStyles() -> a
    void setAxisTickStyle(int,int) -> a
    double[] getAxesCross() -> b
    void setAxisCross(int,double) -> a
    boolean[] getPositiveAxes() -> b
    void setPositiveAxis(int,boolean) -> c
    geogebra.common.kernel.geos.GeoNumeric getXminObject() -> a
    void setXminObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> a
    geogebra.common.kernel.geos.GeoNumeric getXmaxObject() -> b
    void setXmaxObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> b
    geogebra.common.kernel.geos.GeoNumeric getYminObject() -> c
    void setYminObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> c
    geogebra.common.kernel.geos.GeoNumeric getYmaxObject() -> d
    void setYmaxObject(geogebra.common.kernel.arithmetic.NumberValue,boolean) -> d
    double getXZero() -> c
    double getYZero() -> d
    double getXscale() -> e
    double getYscale() -> f
    void setCoordSystem(double,double,double,double) -> a
    void setAxesNumberingDistance(double,int) -> a
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    geogebra.common.awt.Dimension getPreferredSize() -> a
    void setShowAxes(boolean,boolean) -> b
    void showGrid(boolean) -> b
    boolean getShowGrid() -> c
    boolean getGridIsBold() -> d
    void setGridIsBold(boolean) -> c
    int getGridType() -> c
    void setGridType(int) -> c
    int getPointCapturingMode() -> d
    boolean setPointCapturing(int) -> c
    void setAllowToolTips(int) -> d
    int getAllowToolTips() -> e
    void setDrawBorderAxes(int,boolean) -> d
    boolean[] getDrawBorderAxes() -> c
    void setLockedAxesRatio(double) -> c
    java.lang.Double getLockedAxesRatio() -> a
geogebra.common.main.settings.KeyboardSettings -> geogebra.common.j.a.g:
    java.util.ArrayList supportedLocales -> a
    float keyboardOpacity -> a
    int keyboardWidth -> a
    int keyboardHeight -> b
    java.lang.String keyboardLocale -> a
    boolean showKeyboardOnStart -> a
    float getKeyboardOpacity() -> a
    int getKeyboardWidth() -> a
    int getKeyboardHeight() -> b
    java.lang.String getKeyboardLocale() -> a
    void setKeyboardWidth(int) -> a
    void setKeyboardHeight(int) -> b
    void setShowKeyboardOnStart(boolean) -> a
    boolean isShowKeyboardOnStart() -> a
    void setKeyboardOpacity(float) -> a
    void keyboardResized(int,int) -> a
    void setKeyboardLocale(java.lang.String) -> a
geogebra.common.main.settings.LayoutSettings -> geogebra.common.j.a.h:
    boolean showTitleBar -> a
    boolean ignoreDocumentLayout -> b
    boolean allowStyleBar -> c
    boolean showTitleBar() -> a
    void setShowTitleBar(boolean) -> a
    boolean isIgnoringDocumentLayout() -> b
    void setIgnoreDocumentLayout(boolean) -> b
    boolean isAllowingStyleBar() -> c
    void setAllowStyleBar(boolean) -> c
geogebra.common.main.settings.ProbabilityCalculatorSettings -> geogebra.common.j.a.i:
    double[] parameters -> a
    int distributionType -> a
    boolean isCumulative -> a
    void setParameters(double[]) -> a
    double[] getParameters() -> a
    void setDistributionType(int) -> a
    int getDistributionType() -> a
    void setCumulative(boolean) -> a
    boolean isCumulative() -> a
geogebra.common.main.settings.SettingListener -> geogebra.common.j.a.j:
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
geogebra.common.main.settings.Settings -> geogebra.common.j.a.k:
    geogebra.common.main.settings.EuclidianSettings[] euclidianSettings -> a
    geogebra.common.main.settings.AlgebraSettings algebraSettings -> a
    geogebra.common.main.settings.SpreadsheetSettings spreadsheetSettings -> a
    geogebra.common.main.settings.ConstructionProtocolSettings consProtSettings -> a
    geogebra.common.main.settings.LayoutSettings layoutSettings -> a
    geogebra.common.main.settings.ApplicationSettings applicationSettings -> a
    geogebra.common.main.settings.KeyboardSettings keyboardSettings -> a
    geogebra.common.main.settings.CASSettings casSettings -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings probCalcSettings -> a
    void resetSettings() -> a
    void beginBatch() -> b
    void endBatch() -> c
    geogebra.common.main.settings.EuclidianSettings getEuclidian(int) -> a
    geogebra.common.main.settings.SpreadsheetSettings getSpreadsheet() -> a
    geogebra.common.main.settings.ProbabilityCalculatorSettings getProbCalcSettings() -> a
    geogebra.common.main.settings.ConstructionProtocolSettings getConstructionProtocol() -> a
    geogebra.common.main.settings.LayoutSettings getLayout() -> a
    geogebra.common.main.settings.KeyboardSettings getKeyboard() -> a
    geogebra.common.main.settings.CASSettings getCasSettings() -> a
geogebra.common.main.settings.SpreadsheetSettings -> geogebra.common.j.a.l:
    boolean showFormulaBar -> a
    boolean showGrid -> b
    boolean showRowHeader -> c
    boolean showColumnHeader -> d
    boolean showVScrollBar -> e
    boolean showHScrollBar -> f
    boolean showBrowserPanel -> g
    boolean isColumnSelect -> h
    boolean allowSpecialEditor -> i
    boolean allowToolTips -> j
    boolean equalsRequired -> k
    java.lang.String defaultFile -> a
    java.lang.String initialURL -> b
    java.lang.String initialFilePath -> c
    int initialBrowserMode -> a
    boolean isDefaultBrowser -> l
    java.util.HashMap widthMap -> a
    java.util.HashMap heightMap -> b
    int preferredColumnWidth -> b
    int preferredRowHeight -> c
    java.lang.String cellFormat -> d
    geogebra.common.awt.Point scrollPosition -> a
    geogebra.common.awt.Point selectedCell -> b
    geogebra.common.awt.Dimension preferredSize -> a
    java.util.HashMap getWidthMap() -> a
    void addWidth(int,int) -> a
    int preferredColumnWidth() -> a
    void setPreferredColumnWidth(int) -> a
    java.util.HashMap getHeightMap() -> b
    void addHeight(int,int) -> b
    int preferredRowHeight() -> b
    void setPreferredRowHeight(int) -> b
    boolean showFormulaBar() -> a
    void setShowFormulaBar(boolean) -> a
    boolean showGrid() -> b
    void setShowGrid(boolean) -> b
    boolean showRowHeader() -> c
    void setShowRowHeader(boolean) -> c
    boolean showColumnHeader() -> d
    void setShowColumnHeader(boolean) -> d
    boolean showVScrollBar() -> e
    void setShowVScrollBar(boolean) -> e
    boolean showHScrollBar() -> f
    void setShowHScrollBar(boolean) -> f
    boolean showBrowserPanel() -> g
    void setShowFileBrowser(boolean) -> g
    boolean allowSpecialEditor() -> h
    void setAllowSpecialEditor(boolean) -> h
    boolean allowToolTips() -> i
    void setAllowToolTips(boolean) -> i
    boolean equalsRequired() -> j
    void setEqualsRequired(boolean) -> j
    boolean isColumnSelect() -> k
    java.lang.String cellFormat() -> a
    void setCellFormat(java.lang.String) -> a
    void setScrollPosition(geogebra.common.awt.Point) -> a
    geogebra.common.awt.Dimension preferredSize() -> a
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    java.lang.String defaultFile() -> b
    void setDefaultFile(java.lang.String) -> b
    java.lang.String initialURL() -> c
    void setInitialURL(java.lang.String) -> c
    java.lang.String initialFilePath() -> d
    void setInitialFilePath(java.lang.String) -> d
    int initialBrowserMode() -> c
    void setInitialBrowserMode(int) -> c
    void setDefaultBrowser(boolean) -> k
geogebra.common.plugin.EuclidianStyleConstants -> geogebra.common.plugin.EuclidianStyleConstants:
    int LINE_TYPE_FULL -> LINE_TYPE_FULL
    int LINE_TYPE_DASHED_SHORT -> LINE_TYPE_DASHED_SHORT
    int LINE_TYPE_DASHED_LONG -> LINE_TYPE_DASHED_LONG
    int LINE_TYPE_DOTTED -> LINE_TYPE_DOTTED
    int LINE_TYPE_DASHED_DOTTED -> LINE_TYPE_DASHED_DOTTED
    int RIGHT_ANGLE_STYLE_NONE -> RIGHT_ANGLE_STYLE_NONE
    int RIGHT_ANGLE_STYLE_SQUARE -> RIGHT_ANGLE_STYLE_SQUARE
    int RIGHT_ANGLE_STYLE_DOT -> RIGHT_ANGLE_STYLE_DOT
    int RIGHT_ANGLE_STYLE_L -> RIGHT_ANGLE_STYLE_L
    int DEFAULT_POINT_SIZE -> DEFAULT_POINT_SIZE
    int DEFAULT_LINE_THICKNESS -> DEFAULT_LINE_THICKNESS
    int DEFAULT_ANGLE_SIZE -> DEFAULT_ANGLE_SIZE
    int DEFAULT_LINE_TYPE -> DEFAULT_LINE_TYPE
    int LINE_TYPE_HIDDEN_NONE -> LINE_TYPE_HIDDEN_NONE
    int LINE_TYPE_HIDDEN_DASHED -> LINE_TYPE_HIDDEN_DASHED
    int LINE_TYPE_HIDDEN_AS_NOT_HIDDEN -> LINE_TYPE_HIDDEN_AS_NOT_HIDDEN
    int DEFAULT_LINE_TYPE_HIDDEN -> DEFAULT_LINE_TYPE_HIDDEN
    float SELECTION_ADD -> SELECTION_ADD
    int AXES_TICK_STYLE_MAJOR_MINOR -> AXES_TICK_STYLE_MAJOR_MINOR
    int AXES_TICK_STYLE_MAJOR -> AXES_TICK_STYLE_MAJOR
    int AXES_TICK_STYLE_NONE -> AXES_TICK_STYLE_NONE
    int AXES_LINE_TYPE_FULL -> AXES_LINE_TYPE_FULL
    int AXES_LINE_TYPE_ARROW -> AXES_LINE_TYPE_ARROW
    int AXES_LINE_TYPE_FULL_BOLD -> AXES_LINE_TYPE_FULL_BOLD
    int AXES_LINE_TYPE_ARROW_BOLD -> AXES_LINE_TYPE_ARROW_BOLD
    int POINT_STYLE_DOT -> POINT_STYLE_DOT
    int POINT_STYLE_CROSS -> POINT_STYLE_CROSS
    int POINT_STYLE_CIRCLE -> POINT_STYLE_CIRCLE
    int POINT_STYLE_PLUS -> POINT_STYLE_PLUS
    int POINT_STYLE_FILLED_DIAMOND -> POINT_STYLE_FILLED_DIAMOND
    int POINT_STYLE_EMPTY_DIAMOND -> POINT_STYLE_EMPTY_DIAMOND
    int POINT_STYLE_TRIANGLE_NORTH -> POINT_STYLE_TRIANGLE_NORTH
    int POINT_STYLE_TRIANGLE_SOUTH -> POINT_STYLE_TRIANGLE_SOUTH
    int POINT_STYLE_TRIANGLE_EAST -> POINT_STYLE_TRIANGLE_EAST
    int POINT_STYLE_TRIANGLE_WEST -> POINT_STYLE_TRIANGLE_WEST
    int MAX_POINT_STYLE -> MAX_POINT_STYLE
    int MAX_LAYERS -> MAX_LAYERS
    int POINT_CAPTURING_OFF -> POINT_CAPTURING_OFF
    int POINT_CAPTURING_ON -> POINT_CAPTURING_ON
    int POINT_CAPTURING_ON_GRID -> POINT_CAPTURING_ON_GRID
    int POINT_CAPTURING_AUTOMATIC -> POINT_CAPTURING_AUTOMATIC
    int POINT_CAPTURING_STICKY_POINTS -> POINT_CAPTURING_STICKY_POINTS
    int TOOLTIPS_AUTOMATIC -> TOOLTIPS_AUTOMATIC
    int TOOLTIPS_ON -> TOOLTIPS_ON
    int TOOLTIPS_OFF -> TOOLTIPS_OFF
    double DEFAULT_GRID_DIST_FACTOR -> DEFAULT_GRID_DIST_FACTOR
    double automaticGridDistanceFactor -> automaticGridDistanceFactor
geogebra.common.plugin.GeoClass -> geogebra.common.plugin.GeoClass:
    geogebra.common.plugin.GeoClass ANGLE -> ANGLE
    geogebra.common.plugin.GeoClass AXIS -> AXIS
    geogebra.common.plugin.GeoClass BOOLEAN -> BOOLEAN
    geogebra.common.plugin.GeoClass BUTTON -> BUTTON
    geogebra.common.plugin.GeoClass TEXTFIELD -> TEXTFIELD
    geogebra.common.plugin.GeoClass CONIC -> CONIC
    geogebra.common.plugin.GeoClass CONICPART -> CONICPART
    geogebra.common.plugin.GeoClass FUNCTION -> FUNCTION
    geogebra.common.plugin.GeoClass INTERVAL -> INTERVAL
    geogebra.common.plugin.GeoClass FUNCTIONCONDITIONAL -> FUNCTIONCONDITIONAL
    geogebra.common.plugin.GeoClass IMAGE -> IMAGE
    geogebra.common.plugin.GeoClass LINE -> LINE
    geogebra.common.plugin.GeoClass LIST -> LIST
    geogebra.common.plugin.GeoClass LOCUS -> LOCUS
    geogebra.common.plugin.GeoClass NUMERIC -> NUMERIC
    geogebra.common.plugin.GeoClass POINT -> POINT
    geogebra.common.plugin.GeoClass POLYGON -> POLYGON
    geogebra.common.plugin.GeoClass RAY -> RAY
    geogebra.common.plugin.GeoClass SEGMENT -> SEGMENT
    geogebra.common.plugin.GeoClass TEXT -> TEXT
    geogebra.common.plugin.GeoClass VECTOR -> VECTOR
    geogebra.common.plugin.GeoClass CURVE_CARTESIAN -> CURVE_CARTESIAN
    geogebra.common.plugin.GeoClass CURVE_POLAR -> CURVE_POLAR
    geogebra.common.plugin.GeoClass IMPLICIT_POLY -> IMPLICIT_POLY
    geogebra.common.plugin.GeoClass FUNCTION_NVAR -> FUNCTION_NVAR
    geogebra.common.plugin.GeoClass POLYLINE -> POLYLINE
    geogebra.common.plugin.GeoClass LINEAR_INEQUALITY -> LINEAR_INEQUALITY
    geogebra.common.plugin.GeoClass TURTLE -> TURTLE
    geogebra.common.plugin.GeoClass CAS_CELL -> CAS_CELL
    geogebra.common.plugin.GeoClass ANGLE3D -> ANGLE3D
    geogebra.common.plugin.GeoClass POINT3D -> POINT3D
    geogebra.common.plugin.GeoClass VECTOR3D -> VECTOR3D
    geogebra.common.plugin.GeoClass SEGMENT3D -> SEGMENT3D
    geogebra.common.plugin.GeoClass LINE3D -> LINE3D
    geogebra.common.plugin.GeoClass RAY3D -> RAY3D
    geogebra.common.plugin.GeoClass CONIC3D -> CONIC3D
    geogebra.common.plugin.GeoClass AXIS3D -> AXIS3D
    geogebra.common.plugin.GeoClass CURVECARTESIAN3D -> CURVECARTESIAN3D
    geogebra.common.plugin.GeoClass POLYGON3D -> POLYGON3D
    geogebra.common.plugin.GeoClass PLANE3D -> PLANE3D
    geogebra.common.plugin.GeoClass QUADRIC -> QUADRIC
    geogebra.common.plugin.GeoClass QUADRIC_PART -> QUADRIC_PART
    geogebra.common.plugin.GeoClass QUADRIC_LIMITED -> QUADRIC_LIMITED
    geogebra.common.plugin.GeoClass POLYLINE3D -> POLYLINE3D
    geogebra.common.plugin.GeoClass POLYHEDRON -> POLYHEDRON
    geogebra.common.plugin.GeoClass SURFACECARTESIAN3D -> SURFACECARTESIAN3D
    geogebra.common.plugin.GeoClass CLIPPINGCUBE3D -> CLIPPINGCUBE3D
    geogebra.common.plugin.GeoClass DEFAULT -> DEFAULT
    geogebra.common.plugin.GeoClass[] ENUM$VALUES -> ENUM$VALUES
    geogebra.common.plugin.GeoClass[] values() -> values
    geogebra.common.plugin.GeoClass valueOf(java.lang.String) -> valueOf
geogebra.common.plugin.GgbAPI -> geogebra.common.plugin.GgbAPI:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction construction -> a
    geogebra.common.kernel.commands.AlgebraProcessor algebraprocessor -> a
    geogebra.common.main.AbstractApplication app -> a
    java.lang.String[] objNames -> a
    int lastGeoElementsIteratorSize -> a
    geogebra.common.kernel.Construction getConstruction() -> getConstruction
    geogebra.common.kernel.Kernel getKernel() -> getKernel
    geogebra.common.kernel.commands.AlgebraProcessor getAlgebraProcessor() -> getAlgebraProcessor
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    java.lang.String evalGeoGebraCAS(java.lang.String) -> evalGeoGebraCAS
    java.lang.String evalGeoGebraCAS(java.lang.String,boolean) -> evalGeoGebraCAS
    void debug(java.lang.String) -> debug
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    java.lang.String[] getObjNames() -> getObjNames
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setColor(java.lang.String,int,int,int) -> setColor
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    java.lang.String getColor(java.lang.String) -> getColor
    int getLineThickness(java.lang.String) -> getLineThickness
    void setLineThickness(java.lang.String,int) -> setLineThickness
    int getPointStyle(java.lang.String) -> getPointStyle
    void setPointStyle(java.lang.String,int) -> setPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    void setPointSize(java.lang.String,int) -> setPointSize
    double getFilling(java.lang.String) -> getFilling
    void setFilling(java.lang.String,double) -> setFilling
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void initCAS() -> initCAS
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    void registerPenListener(java.lang.String) -> registerPenListener
    void unregisterPenListener(java.lang.String) -> unregisterPenListener
    boolean isMoveable(java.lang.String) -> isMoveable
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    void setMode(int) -> setMode
    int getLineStyle(java.lang.String) -> getLineStyle
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void deleteObject(java.lang.String) -> deleteObject
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    boolean exists(java.lang.String) -> exists
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setAxesCornerCoordsVisible(boolean) -> setAxesCornerCoordsVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getSelectedObjectNames() -> getSelectedObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    void setXML(java.lang.String) -> setXML
    java.lang.String getXML() -> getXML
    geogebra.common.main.AbstractApplication getApplication() -> getApplication
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getBase64() -> getBase64
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
geogebra.common.plugin.JavaScriptAPI -> geogebra.common.plugin.a:
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getXML() -> getXML
    java.lang.String getBase64(boolean) -> getBase64
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    void debug(java.lang.String) -> debug
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void reset() -> reset
    void refreshViews() -> refreshViews
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
    void openFile(java.lang.String) -> openFile
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setLineThickness(java.lang.String,int) -> setLineThickness
    int getLineThickness(java.lang.String) -> getLineThickness
    void setLineStyle(java.lang.String,int) -> setLineStyle
    int getLineStyle(java.lang.String) -> getLineStyle
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    double getFilling(java.lang.String) -> getFilling
    int getPointStyle(java.lang.String) -> getPointStyle
    void setPointSize(java.lang.String,int) -> setPointSize
    int getPointSize(java.lang.String) -> getPointSize
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setColor(java.lang.String,int,int,int) -> setColor
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    java.lang.String getColor(java.lang.String) -> getColor
    void deleteObject(java.lang.String) -> deleteObject
    boolean exists(java.lang.String) -> exists
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    boolean isMoveable(java.lang.String) -> isMoveable
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    void setMode(int) -> setMode
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    void unregisterPenListener(java.lang.String) -> unregisterPenListener
geogebra.common.plugin.Operation -> geogebra.common.plugin.Operation:
    geogebra.common.plugin.Operation NO_OPERATION -> NO_OPERATION
    geogebra.common.plugin.Operation NOT_EQUAL -> NOT_EQUAL
    geogebra.common.plugin.Operation NOT -> NOT
    geogebra.common.plugin.Operation OR -> OR
    geogebra.common.plugin.Operation AND -> AND
    geogebra.common.plugin.Operation IMPLICATION -> IMPLICATION
    geogebra.common.plugin.Operation EQUAL_BOOLEAN -> EQUAL_BOOLEAN
    geogebra.common.plugin.Operation LESS -> LESS
    geogebra.common.plugin.Operation GREATER -> GREATER
    geogebra.common.plugin.Operation LESS_EQUAL -> LESS_EQUAL
    geogebra.common.plugin.Operation GREATER_EQUAL -> GREATER_EQUAL
    geogebra.common.plugin.Operation PARALLEL -> PARALLEL
    geogebra.common.plugin.Operation PERPENDICULAR -> PERPENDICULAR
    geogebra.common.plugin.Operation IS_ELEMENT_OF -> IS_ELEMENT_OF
    geogebra.common.plugin.Operation IS_SUBSET_OF -> IS_SUBSET_OF
    geogebra.common.plugin.Operation IS_SUBSET_OF_STRICT -> IS_SUBSET_OF_STRICT
    geogebra.common.plugin.Operation SET_DIFFERENCE -> SET_DIFFERENCE
    geogebra.common.plugin.Operation PLUS -> PLUS
    geogebra.common.plugin.Operation MINUS -> MINUS
    geogebra.common.plugin.Operation VECTORPRODUCT -> VECTORPRODUCT
    geogebra.common.plugin.Operation MULTIPLY -> MULTIPLY
    geogebra.common.plugin.Operation DIVIDE -> DIVIDE
    geogebra.common.plugin.Operation POWER -> POWER
    geogebra.common.plugin.Operation FREEHAND -> FREEHAND
    geogebra.common.plugin.Operation COS -> COS
    geogebra.common.plugin.Operation SIN -> SIN
    geogebra.common.plugin.Operation TAN -> TAN
    geogebra.common.plugin.Operation EXP -> EXP
    geogebra.common.plugin.Operation LOG -> LOG
    geogebra.common.plugin.Operation ARCCOS -> ARCCOS
    geogebra.common.plugin.Operation ARCSIN -> ARCSIN
    geogebra.common.plugin.Operation ARCTAN -> ARCTAN
    geogebra.common.plugin.Operation ARCTAN2 -> ARCTAN2
    geogebra.common.plugin.Operation SQRT -> SQRT
    geogebra.common.plugin.Operation ABS -> ABS
    geogebra.common.plugin.Operation SGN -> SGN
    geogebra.common.plugin.Operation XCOORD -> XCOORD
    geogebra.common.plugin.Operation YCOORD -> YCOORD
    geogebra.common.plugin.Operation ZCOORD -> ZCOORD
    geogebra.common.plugin.Operation COSH -> COSH
    geogebra.common.plugin.Operation SINH -> SINH
    geogebra.common.plugin.Operation TANH -> TANH
    geogebra.common.plugin.Operation ACOSH -> ACOSH
    geogebra.common.plugin.Operation ASINH -> ASINH
    geogebra.common.plugin.Operation ATANH -> ATANH
    geogebra.common.plugin.Operation CSC -> CSC
    geogebra.common.plugin.Operation SEC -> SEC
    geogebra.common.plugin.Operation COT -> COT
    geogebra.common.plugin.Operation CSCH -> CSCH
    geogebra.common.plugin.Operation SECH -> SECH
    geogebra.common.plugin.Operation COTH -> COTH
    geogebra.common.plugin.Operation FLOOR -> FLOOR
    geogebra.common.plugin.Operation CEIL -> CEIL
    geogebra.common.plugin.Operation FACTORIAL -> FACTORIAL
    geogebra.common.plugin.Operation ROUND -> ROUND
    geogebra.common.plugin.Operation GAMMA -> GAMMA
    geogebra.common.plugin.Operation GAMMA_INCOMPLETE -> GAMMA_INCOMPLETE
    geogebra.common.plugin.Operation GAMMA_INCOMPLETE_REGULARIZED -> GAMMA_INCOMPLETE_REGULARIZED
    geogebra.common.plugin.Operation BETA -> BETA
    geogebra.common.plugin.Operation BETA_INCOMPLETE -> BETA_INCOMPLETE
    geogebra.common.plugin.Operation BETA_INCOMPLETE_REGULARIZED -> BETA_INCOMPLETE_REGULARIZED
    geogebra.common.plugin.Operation ERF -> ERF
    geogebra.common.plugin.Operation PSI -> PSI
    geogebra.common.plugin.Operation POLYGAMMA -> POLYGAMMA
    geogebra.common.plugin.Operation LOG10 -> LOG10
    geogebra.common.plugin.Operation LOG2 -> LOG2
    geogebra.common.plugin.Operation CBRT -> CBRT
    geogebra.common.plugin.Operation RANDOM -> RANDOM
    geogebra.common.plugin.Operation CONJUGATE -> CONJUGATE
    geogebra.common.plugin.Operation ARG -> ARG
    geogebra.common.plugin.Operation FUNCTION -> FUNCTION
    geogebra.common.plugin.Operation FUNCTION_NVAR -> FUNCTION_NVAR
    geogebra.common.plugin.Operation VEC_FUNCTION -> VEC_FUNCTION
    geogebra.common.plugin.Operation DERIVATIVE -> DERIVATIVE
    geogebra.common.plugin.Operation ELEMENT_OF -> ELEMENT_OF
    geogebra.common.plugin.Operation $VAR_ROW -> $VAR_ROW
    geogebra.common.plugin.Operation $VAR_COL -> $VAR_COL
    geogebra.common.plugin.Operation $VAR_ROW_COL -> $VAR_ROW_COL
    geogebra.common.plugin.Operation LOGB -> LOGB
    geogebra.common.plugin.Operation CI -> CI
    geogebra.common.plugin.Operation SI -> SI
    geogebra.common.plugin.Operation EI -> EI
    geogebra.common.plugin.Operation ARBCONST -> ARBCONST
    geogebra.common.plugin.Operation ARBINT -> ARBINT
    geogebra.common.plugin.Operation ARBCOMPLEX -> ARBCOMPLEX
    geogebra.common.plugin.Operation[] ENUM$VALUES -> ENUM$VALUES
    geogebra.common.plugin.Operation[] values() -> values
    geogebra.common.plugin.Operation valueOf(java.lang.String) -> valueOf
geogebra.common.plugin.ScriptManagerCommon -> geogebra.common.plugin.b:
    geogebra.common.main.AbstractApplication app -> a
    boolean listenersEnabled -> a
    java.util.HashMap updateListenerMap -> a
    java.util.ArrayList addListeners -> a
    java.util.ArrayList removeListeners -> b
    java.util.ArrayList renameListeners -> c
    java.util.ArrayList updateListeners -> d
    java.util.ArrayList clearListeners -> e
    java.util.ArrayList penListeners -> f
    geogebra.common.plugin.ScriptManagerCommon$JavaToJavaScriptView javaToJavaScriptView -> a
    void disableListeners() -> a
    void enableListeners() -> b
    void resetListeners() -> c
    void registerAddListener(java.lang.String) -> a
    void registerGlobalListener(java.util.ArrayList,java.lang.String,java.lang.String) -> a
    void unregisterAddListener(java.lang.String) -> b
    void registerRemoveListener(java.lang.String) -> c
    void unregisterRemoveListener(java.lang.String) -> d
    void registerClearListener(java.lang.String) -> e
    void unregisterClearListener(java.lang.String) -> f
    void registerRenameListener(java.lang.String) -> g
    void unregisterRenameListener(java.lang.String) -> h
    void registerUpdateListener(java.lang.String) -> i
    void unregisterUpdateListener(java.lang.String) -> j
    void registerPenListener(java.lang.String) -> k
    void unregisterPenListener(java.lang.String) -> l
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> a
    void unregisterObjectUpdateListener(java.lang.String) -> m
    void initJavaScriptView() -> d
    void initJavaScriptViewWithoutJavascript() -> e
    void ggbOnInit() -> f
    void initJavaScript() -> g
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
geogebra.common.plugin.ScriptManagerCommon$JavaToJavaScriptView -> geogebra.common.plugin.b$a:
    geogebra.common.plugin.ScriptManagerCommon this$0 -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void clearView() -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void notifyListeners(java.util.ArrayList,java.lang.Object[]) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void reset() -> d
    void setMode(int) -> a
    void repaintView() -> c
    int getViewID() -> b
geogebra.common.plugin.jython.PythonBridge -> geogebra.common.plugin.a.a:
    void click(geogebra.common.kernel.geos.GeoElement) -> g
    void setEventListener(geogebra.common.kernel.geos.GeoElement,java.lang.String,java.lang.String) -> a
geogebra.common.sound.SoundManager -> geogebra.common.k.a:
    void pauseResumeSound(boolean) -> a
    void playSequenceNote(int,double,int,int) -> a
    void playSequenceFromString(java.lang.String,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void playMidiFile(java.lang.String) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
geogebra.common.util.AbstractImageManager -> geogebra.common.l.a:
    java.lang.String createImage(java.lang.String,geogebra.common.main.AbstractApplication) -> a
geogebra.common.util.AutoCompleteDictionary -> geogebra.common.l.b:
    java.lang.String lookup(java.lang.String) -> a
    java.util.List getCompletions(java.lang.String) -> a
    java.util.List getCompletionsKorean(java.lang.String) -> b
geogebra.common.util.Base64 -> geogebra.common.l.c:
    java.lang.String encode(byte[],int) -> a
    byte[] decode(java.lang.String) -> a
geogebra.common.util.Cloner -> geogebra.common.l.d:
    double[] clone(double[]) -> a
geogebra.common.util.CopyPaste -> geogebra.common.l.e:
    java.lang.StringBuilder copiedXML -> a
    java.util.ArrayList copiedXMLlabels -> a
    java.lang.StringBuilder copiedXMLforSameWindow -> b
    java.util.ArrayList copiedXMLlabelsforSameWindow -> b
    geogebra.common.euclidian.EuclidianViewInterfaceCommon copySource -> a
    java.lang.Object copyObject -> a
    java.lang.Object copyObject2 -> b
    boolean isEmpty() -> a
    void removeFixedSliders(java.util.ArrayList) -> a
    void removeDependentFromAxes(java.util.ArrayList,geogebra.common.main.AbstractApplication) -> a
    void removeHavingMacroPredecessors(java.util.ArrayList) -> b
    void addSubGeos(java.util.ArrayList) -> c
    java.util.ArrayList addPredecessorGeos(java.util.ArrayList) -> a
    java.util.ArrayList addAlgosDependentFromInside(java.util.ArrayList) -> b
    java.util.ArrayList removeFreeNonselectedGeoNumerics(java.util.ArrayList,java.util.ArrayList) -> a
    void beforeSavingToXML(java.util.ArrayList,java.util.ArrayList,boolean) -> a
    void afterSavingToXML(java.util.ArrayList,java.util.ArrayList) -> a
    void copyToXML(geogebra.common.main.AbstractApplication,java.util.ArrayList) -> a
    void handleLabels(geogebra.common.main.AbstractApplication,java.util.ArrayList) -> b
    boolean pasteFast(geogebra.common.main.AbstractApplication) -> a
    void pasteFromXML(geogebra.common.main.AbstractApplication) -> a
    void pastePutDownCallback(geogebra.common.main.AbstractApplication) -> b
geogebra.common.util.DoubleWithError -> geogebra.common.l.f:
    double value -> a
    double error -> b
    boolean asymmetricError -> a
    double minError -> c
    double getError() -> a
    double getPlusError() -> b
    double getMinError() -> c
    boolean hasAsymmetricError() -> a
    double getValue() -> d
    java.lang.String toString() -> toString
geogebra.common.util.GeoGebraLogger -> geogebra.common.l.g:
    java.util.Set reportedImplementationNeeded -> a
    geogebra.common.util.GeoGebraLogger$Level EMERGENCY -> a
    geogebra.common.util.GeoGebraLogger$Level ALERT -> b
    geogebra.common.util.GeoGebraLogger$Level CRITICAL -> c
    geogebra.common.util.GeoGebraLogger$Level ERROR -> d
    geogebra.common.util.GeoGebraLogger$Level WARN -> e
    geogebra.common.util.GeoGebraLogger$Level NOTICE -> f
    geogebra.common.util.GeoGebraLogger$Level INFO -> g
    geogebra.common.util.GeoGebraLogger$Level DEBUG -> h
    geogebra.common.util.GeoGebraLogger$Level TRACE -> i
    geogebra.common.util.GeoGebraLogger$Level logLevel -> j
    geogebra.common.util.GeoGebraLogger$LogDestination logDestination -> a
    boolean timeShown -> a
    boolean callerShown -> b
    void setLogLevel(java.lang.String) -> a
    void setLogDestination(geogebra.common.util.GeoGebraLogger$LogDestination) -> a
    geogebra.common.util.GeoGebraLogger$LogDestination getLogDestination() -> a
    void setTimeShown(boolean) -> a
    void log(geogebra.common.util.GeoGebraLogger$Level,java.lang.String) -> a
    void print(java.lang.String,geogebra.common.util.GeoGebraLogger$Level) -> a
    void setLogFile(java.lang.String) -> b
    java.lang.String getTimeInfo() -> a
    java.lang.String getCaller() -> b
geogebra.common.util.GeoGebraLogger$Level -> geogebra.common.l.g$a:
    int priority -> a
    java.lang.String text -> a
    geogebra.common.util.GeoGebraLogger this$0 -> a
    int getPriority() -> a
geogebra.common.util.GeoGebraLogger$LogDestination -> geogebra.common.l.g$b:
    geogebra.common.util.GeoGebraLogger$LogDestination FILE -> a
    geogebra.common.util.GeoGebraLogger$LogDestination CONSOLE -> b
    geogebra.common.util.GeoGebraLogger$LogDestination WEB_CONSOLE -> c
    geogebra.common.util.GeoGebraLogger$LogDestination CONSOLES -> d
    geogebra.common.util.GeoGebraLogger$LogDestination[] ENUM$VALUES -> a
    geogebra.common.util.GeoGebraLogger$LogDestination[] values() -> values
    geogebra.common.util.GeoGebraLogger$LogDestination valueOf(java.lang.String) -> valueOf
geogebra.common.util.GgbMat -> geogebra.common.l.h:
    boolean isUndefined -> a
    void inverseImmediate() -> a
    double determinant() -> a
    void reducedRowEchelonFormImmediate() -> b
    void transposeImmediate() -> c
    void getGeoList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.Construction) -> a
    void getMyList(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.Kernel) -> a
    boolean isUndefined() -> a
    void setIsUndefined(boolean) -> a
    boolean hasOnlyIntegers() -> b
geogebra.common.util.HttpRequest -> geogebra.common.l.i:
    int DEFAULT_TIMEOUT -> a
    int timeout -> b
    boolean processed -> a
    java.lang.Boolean success -> a
    java.lang.String responseText -> a
    java.lang.String getResponse() -> a
    void sendRequestPost(java.lang.String,java.lang.String) -> a
    void setTimeout(java.lang.Integer) -> a
    java.lang.String sendRequestGetResponseSync(java.lang.String) -> a
geogebra.common.util.Korean -> geogebra.common.l.j:
    java.lang.StringBuilder sb -> a
    java.util.HashMap koreanLeadToTail -> a
    void init() -> a
    java.lang.String flattenKorean(java.lang.String) -> a
    boolean isKoreanMultiChar(char) -> a
    boolean isKoreanLeadChar(char) -> b
    boolean isKoreanVowelChar(char) -> c
    void appendKoreanMultiChar(java.lang.StringBuilder,char) -> a
    java.lang.String mergeDoubleCharacters(java.lang.String) -> b
geogebra.common.util.LaTeXCache -> geogebra.common.l.k:
    void remove() -> a
    java.lang.Object getCachedLaTeXKey(java.lang.String,int,int,geogebra.common.awt.Color) -> a
geogebra.common.util.LowerCaseDictionary -> geogebra.common.l.l:
    java.util.TreeSet treeSet -> a
    geogebra.common.util.NormalizerMinimal normalizer -> a
    void addEntry(java.lang.String) -> a
    boolean removeEntry(java.lang.String) -> a
    java.util.Iterator getIterator() -> a
    java.lang.String lookup(java.lang.String) -> a
    java.util.List getCompletions(java.lang.String) -> a
    java.util.List getCompletionsKorean(java.lang.String) -> b
geogebra.common.util.MaxSizeHashMap -> geogebra.common.l.m:
    int maxSize -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
geogebra.common.util.MyMath -> geogebra.common.l.n:
    double LOG10 -> a
    double LOG2 -> b
    double cbrt(double) -> a
    double sgn(geogebra.common.kernel.Kernel,double) -> a
    double cosh(double) -> b
    double sinh(double) -> c
    double tanh(double) -> d
    double csch(double) -> e
    double sech(double) -> f
    double coth(double) -> g
    double acosh(double) -> h
    double asinh(double) -> i
    double atanh(double) -> j
    double csc(double) -> k
    double sec(double) -> l
    double cot(double) -> m
    double[][] adjoint(double,double,double,double,double,double,double,double,double) -> a
    double nextMultiple(double,double) -> a
    double nextPrettyNumber(double) -> n
    double length(double,double) -> b
geogebra.common.util.MyMath2 -> geogebra.common.l.o:
    int factorialTop -> a
    double[] factorialTable -> a
    double EULER -> a
    double TMIN -> b
    int MAXIT -> b
    double gammaIncomplete(double,double,geogebra.common.kernel.Kernel) -> a
    double gammaIncompleteRegularized(double,double) -> a
    double beta(double,double) -> b
    double betaIncomplete(double,double,double) -> a
    double betaIncompleteRegularized(double,double,double) -> b
    double factorial(double) -> a
    double gamma(double) -> b
    double erf(double,double,double) -> c
    double psi(double) -> c
    double logGamma(double) -> d
    double polyGamma(geogebra.common.kernel.arithmetic.NumberValue,double) -> a
    org.apache.commons.math.complex.Complex cisi(double) -> a
    double ci(double) -> e
    double si(double) -> f
    double ei(double) -> g
geogebra.common.util.NormalizerMinimal -> geogebra.common.l.p:
    java.lang.String transform(java.lang.String) -> a
geogebra.common.util.NumberFormatAdapter -> geogebra.common.l.q:
    int getMaximumFractionDigits() -> getMaximumFractionDigits
    java.lang.String format(double) -> format
geogebra.common.util.ScientificFormatAdapter -> geogebra.common.l.r:
    int getSigDigits() -> a
    void setSigDigits(int) -> a
    void setMaxWidth(int) -> b
    java.lang.String format(double) -> a
geogebra.common.util.SpreadsheetTraceSettings -> geogebra.common.l.s:
    int traceColumn1 -> a
    int traceColumn2 -> b
    int traceRow1 -> c
    int traceRow2 -> d
    int tracingRow -> e
    int numRows -> f
    int headerOffset -> g
    java.util.ArrayList lastTrace -> a
    boolean doColumnReset -> a
    boolean needsColumnReset -> b
    boolean doRowLimit -> c
    boolean showLabel -> d
    boolean showTraceList -> e
    boolean doTraceGeoCopy -> f
geogebra.common.util.StringUtil -> geogebra.common.l.t:
    java.lang.StringBuilder hexSB -> a
    char[] hexChar -> a
    geogebra.common.util.StringUtil prototype -> a
    java.lang.StringBuilder sb -> b
    java.lang.StringBuilder sbReplaceExp -> c
    java.lang.String convertToHex(byte[]) -> a
    java.lang.String toHexString(char) -> a
    java.lang.String toHexString(geogebra.common.awt.Color) -> a
    java.lang.String toHTMLString(java.lang.String) -> a
    java.lang.String encodeXML(java.lang.String) -> b
    boolean isRightToLeftChar(char) -> a
    java.lang.String toLaTeXString(java.lang.String,boolean) -> a
    java.lang.String string(java.lang.String,int) -> a
    java.lang.String removeSpaces(java.lang.String) -> c
    java.lang.StringBuilder resetStringBuilder(java.lang.StringBuilder) -> a
    boolean isNumber(java.lang.String) -> a
    java.lang.String toLower(java.lang.String) -> d
    java.lang.String toLowerCase(java.lang.String) -> e
geogebra.common.util.TextObject -> geogebra.common.l.u:
    java.lang.String getText() -> getText
    void setText(java.lang.String) -> setText
    void wrapSetText(java.lang.String) -> a_
geogebra.common.util.URLEncoder -> geogebra.common.l.v:
    java.lang.String encode(java.lang.String) -> a
geogebra.common.util.Unicode -> geogebra.common.l.w:
    java.lang.String degree -> a
    java.lang.String PI_STRING -> b
    java.util.HashMap testCharMap -> a
    boolean isSuperscriptDigit(char) -> a
    java.lang.String getTestChar(java.lang.String) -> a
    java.util.Iterator getCharMapIterator() -> a
    void initCharMap() -> a
geogebra.euclidian.DrawEquation -> geogebra.b.a:
    javax.swing.JLabel jl -> a
    boolean drawEquationJLaTeXMathFirstCall -> a
    java.lang.Object initJLaTeXMath -> a
    java.awt.Dimension drawEquationJLaTeXMath(geogebra.main.Application,geogebra.common.kernel.geos.GeoElement,java.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.Font,boolean,java.awt.Color,java.awt.Color,boolean,java.lang.Integer,java.lang.Float) -> a
    void setUseJavaFontsForLaTeX(geogebra.common.main.AbstractApplication,boolean) -> a
    geogebra.common.awt.Dimension drawEquation(geogebra.common.main.AbstractApplication,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.Font,boolean,geogebra.common.awt.Color,geogebra.common.awt.Color,boolean) -> a
    java.awt.Dimension drawEquation(geogebra.main.Application,geogebra.common.kernel.geos.GeoElement,java.awt.Graphics2D,int,int,java.lang.String,geogebra.common.awt.Font,boolean,geogebra.common.awt.Color,geogebra.common.awt.Color,boolean,java.lang.Integer,java.lang.Float) -> a
    void drawLatexImageIcon(geogebra.main.Application,javax.swing.ImageIcon,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
geogebra.euclidian.EuclidianController -> geogebra.b.b:
    void setApplication(geogebra.common.main.AbstractApplication) -> a
    geogebra.main.Application getApplication() -> a
    void setView(geogebra.common.euclidian.AbstractEuclidianView) -> a
    void setPen(geogebra.euclidian.EuclidianPen) -> a
    geogebra.euclidian.EuclidianPen getPen() -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void initToolTipManager() -> f
    void resetToolTipManager() -> o
    geogebra.common.kernel.geos.GeoElement[] createCircle2ForPoints3D(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void mouseWheelMoved(java.awt.event.MouseWheelEvent) -> mouseWheelMoved
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.euclidian.EuclidianPen getPen() -> a
geogebra.euclidian.EuclidianPen -> geogebra.b.c:
    geogebra.main.Application app -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    int penOffsetX -> j
    int penOffsetY -> k
    boolean penUsingOffsets -> a
    java.awt.image.BufferedImage penImage -> a
    geogebra.common.kernel.geos.GeoImage penGeo -> a
    geogebra.common.kernel.geos.GeoImage lastPenImage -> b
    boolean penWritingToExistingImage -> b
    java.util.ArrayList penPoints -> a
    java.util.ArrayList temp -> b
    int minX -> a
    int maxX -> b
    double CIRCLE_MIN_DET -> a
    double CIRCLE_MAX_SCORE -> b
    double score -> c
    double ARROW_MAXSIZE -> d
    double ARROW_ANGLE_MIN -> e
    double ARROW_ANGLE_MAX -> f
    double ARROW_ASYMMETRY_MAX_ANGLE -> g
    double ARROW_ASYMMETRY_MAX_LINEAR -> h
    double ARROW_TIP_LINEAR_TOLERANCE -> i
    double ARROW_SIDEWAYS_GAP_TOLERANCE -> j
    double ARROW_MAIN_LINEAR_GAP_MIN -> k
    double ARROW_MAIN_LINEAR_GAP_MAX -> l
    int[] brk -> a
    int count -> c
    int recognizer_queue_length -> d
    int MAX_POLYGON_SIDES -> e
    double LINE_MAX_DET -> m
    double SLANT_TOLERANCE -> n
    double RECTANGLE_ANGLE_TOLERANCE -> o
    double RECTANGLE_LINEAR_TOLERANCE -> p
    double POLYGON_LINEAR_TOLERANCE -> q
    geogebra.euclidian.Inertia a -> a
    geogebra.euclidian.Inertia b -> b
    geogebra.euclidian.Inertia c -> c
    geogebra.euclidian.Inertia d -> d
    geogebra.euclidian.RecoSegment reco_queue_a -> a
    geogebra.euclidian.RecoSegment reco_queue_b -> b
    geogebra.euclidian.RecoSegment reco_queue_c -> c
    geogebra.euclidian.RecoSegment reco_queue_d -> d
    geogebra.euclidian.RecoSegment reco_queue_e -> e
    int gridSize -> l
    java.awt.Point startPoint -> a
    java.lang.StringBuffer gesture -> a
    int deltaX -> f
    int deltaY -> g
    int absDeltaX -> h
    int absDeltaY -> i
    float absTangent -> a
    boolean erasing -> c
    int penSize -> m
    int eraserSize -> n
    int penLineStyle -> o
    java.awt.Color penColor -> a
    boolean freehand -> d
    int getPenSize() -> a
    void setPenSize(int) -> a
    int getPenLineStyle() -> b
    void setPenLineStyle(int) -> b
    java.awt.Color getPenColor() -> a
    geogebra.common.awt.Color getPenColorCommon() -> a
    void setPenColor(java.awt.Color) -> a
    void setDefaults() -> b
    void setPenGeo(geogebra.common.kernel.geos.GeoImage) -> a
    void resetPenOffsets() -> a
    void handleMousePressedForPenMode(java.awt.event.MouseEvent,geogebra.common.euclidian.Hits) -> a
    void handleMouseReleasedForPenMode(java.awt.event.MouseEvent) -> a
    void doDrawPoints(geogebra.common.kernel.geos.GeoImage,java.util.List) -> a
    void mouseReleasedFreehand() -> d
    void setFreehand(boolean) -> a
    void handleMouseReleasedForPenMode(geogebra.common.euclidian.event.AbstractEvent) -> a
    void handleMousePressedForPenMode(geogebra.common.euclidian.event.AbstractEvent,geogebra.common.euclidian.Hits) -> a
    int findPolygonal(int,int,int,int,int) -> a
    void calc_inertia(int,int,geogebra.euclidian.Inertia) -> a
    double I_det(geogebra.euclidian.Inertia) -> a
    double I_xx(geogebra.euclidian.Inertia) -> b
    double I_xy(geogebra.euclidian.Inertia) -> c
    double I_yy(geogebra.euclidian.Inertia) -> d
    double score_circle(int,int,geogebra.euclidian.Inertia) -> a
    double center_x(geogebra.euclidian.Inertia) -> e
    double center_y(geogebra.euclidian.Inertia) -> f
    double I_rad(geogebra.euclidian.Inertia) -> g
    void makeACircle(double,double,double) -> a
    int getDeltaX(java.awt.Point,java.awt.Point) -> a
    int getDeltaY(java.awt.Point,java.awt.Point) -> b
    void saveMove(java.lang.String) -> a
    java.lang.String getGesture() -> a
    void clearTemporaryInfo() -> c
    void optimize_polygonal(int) -> c
    void incr_inertia(int,geogebra.euclidian.Inertia,int) -> a
    void get_segment_geometry(int,int,geogebra.euclidian.Inertia,geogebra.euclidian.RecoSegment) -> a
    boolean try_rectangle() -> a
    boolean try_arrow() -> b
    boolean try_closed_polygon(int) -> a
    void calc_edge_isect(geogebra.euclidian.RecoSegment,geogebra.euclidian.RecoSegment,double[]) -> a
    void setPenColor(geogebra.common.awt.Color) -> a
geogebra.euclidian.EuclidianStatic -> geogebra.b.d:
    geogebra.common.awt.Rectangle doDrawMultilineLaTeX(geogebra.common.main.AbstractApplication,geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Graphics2D,geogebra.common.awt.Font,geogebra.common.awt.Color,geogebra.common.awt.Color,java.lang.String,int,int,boolean) -> b
    geogebra.common.awt.Rectangle drawMultiLineIndexedText(geogebra.main.Application,java.lang.String,int,int,geogebra.common.awt.Graphics2D,boolean) -> a
    void drawWithValueStrokePure(java.awt.Shape,java.awt.Graphics2D) -> a
    void doDrawWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> d
    void doFillWithValueStrokePure(geogebra.common.awt.Shape,geogebra.common.awt.Graphics2D) -> a
    java.awt.BasicStroke getDefaultStrokeAwt() -> a
    java.lang.Object doSetInterpolationHint(geogebra.common.awt.Graphics2D,boolean) -> b
    void doResetInterpolationHint(geogebra.common.awt.Graphics2D,java.lang.Object) -> b
geogebra.euclidian.EuclidianStyleBar -> geogebra.b.e:
    geogebra.euclidian.EuclidianController ec -> a
    geogebra.common.euclidian.EuclidianViewInterfaceCommon ev -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.color.ColorPopupMenuButton btnColor -> a
    geogebra.gui.color.ColorPopupMenuButton btnBgColor -> b
    geogebra.gui.color.ColorPopupMenuButton btnTextColor -> c
    geogebra.gui.util.PopupMenuButton btnLineStyle -> c
    geogebra.gui.util.PopupMenuButton btnPointStyle -> d
    geogebra.gui.util.PopupMenuButton btnTextSize -> e
    geogebra.gui.util.PopupMenuButton btnMode -> f
    geogebra.gui.util.PopupMenuButton btnTableTextJustify -> a
    geogebra.gui.util.PopupMenuButton btnTableTextBracket -> b
    geogebra.gui.util.PopupMenuButton btnLabelStyle -> g
    geogebra.gui.util.PopupMenuButton btnPointCapture -> h
    geogebra.gui.util.MyToggleButton btnCopyVisualStyle -> d
    geogebra.gui.util.MyToggleButton btnPen -> e
    geogebra.gui.util.MyToggleButton btnShowGrid -> f
    geogebra.gui.util.MyToggleButton btnShowAxes -> g
    geogebra.gui.util.MyToggleButton btnBold -> a
    geogebra.gui.util.MyToggleButton btnItalic -> b
    geogebra.gui.util.MyToggleButton btnDelete -> h
    geogebra.gui.util.MyToggleButton btnLabel -> i
    geogebra.gui.util.MyToggleButton btnPenEraser -> j
    geogebra.gui.util.MyToggleButton btnHideShowLabel -> c
    geogebra.gui.util.MyToggleButton btnTableTextLinesV -> k
    geogebra.gui.util.MyToggleButton btnTableTextLinesH -> l
    geogebra.gui.util.PopupMenuButton[] popupBtnList -> a
    geogebra.gui.util.MyToggleButton[] toggleBtnList -> a
    javax.swing.JButton btnPenDelete -> a
    javax.swing.JButton btnDeleteGeo -> b
    java.util.HashMap defaultGeoMap -> c
    java.util.ArrayList defaultGeos -> a
    geogebra.common.kernel.geos.GeoElement oldDefaultGeo -> a
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    int mode -> b
    boolean isIniting -> a
    boolean needUndo -> b
    java.lang.Integer oldDefaultMode -> a
    boolean modeChanged -> c
    geogebra.common.kernel.algos.AlgoTableText tableText -> a
    java.lang.Integer[] lineStyleArray -> a
    java.lang.Integer[] pointStyleArray -> b
    java.util.HashMap lineStyleMap -> a
    java.util.HashMap pointStyleMap -> b
    java.lang.String[] bracketArray -> a
    java.lang.String[] bracketArray2 -> b
    void setMode(int) -> b
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    void restoreDefaultGeo() -> b
    void updateStyleBar() -> c
    void updateTableText(java.lang.Object[]) -> a
    void createDefaultMap() -> i
    void initGUI() -> j
    void addButtons() -> k
    void addGraphicsDecorationsButtons() -> d
    geogebra.gui.util.PopupMenuButton[] newPopupBtnList() -> a
    geogebra.gui.util.MyToggleButton[] newToggleBtnList() -> a
    void addBtnPointCapture() -> e
    void addBtnRotateView() -> f
    void createButtons() -> g
    void createColorButton() -> l
    void createBgColorButton() -> m
    boolean checkGeoText(java.lang.Object[]) -> a
    void createTextButtons() -> n
    void createTableTextButtons() -> o
    void updateGUI() -> h
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void processSource(java.lang.Object,java.util.ArrayList) -> a
    void updateButtonPointCapture(int) -> a
    void applyLineStyle(java.util.ArrayList) -> b
    void applyPointStyle(java.util.ArrayList) -> c
    void applyColor(java.util.ArrayList) -> d
    void applyBgColor(java.util.ArrayList) -> e
    void applyTextColor(java.util.ArrayList) -> f
    void applyFontStyle(java.util.ArrayList) -> g
    void applyTextSize(java.util.ArrayList) -> h
    void applyHideShowLabel(java.util.ArrayList) -> i
    void applyCaptionStyle(java.util.ArrayList) -> j
    void applyTableTextFormat(java.util.ArrayList) -> k
    void applyVisualStyle(java.util.ArrayList) -> a
    geogebra.common.kernel.geos.GeoElement redefineGeo(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> a
    void setLabels() -> a
geogebra.euclidian.EuclidianStyleBar$1 -> geogebra.b.f:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$10 -> geogebra.b.g:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$11 -> geogebra.b.h:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBar$12 -> geogebra.b.i:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBar$13 -> geogebra.b.j:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$14 -> geogebra.b.k:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    java.awt.Dimension val$bgColorIconSize -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$15 -> geogebra.b.l:
    java.awt.Color geoColor -> a
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    java.awt.Dimension val$textColorIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBar$16 -> geogebra.b.m:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$17 -> geogebra.b.n:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$18 -> geogebra.b.o:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$19 -> geogebra.b.p:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$2 -> geogebra.b.q:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$20 -> geogebra.b.r:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$21 -> geogebra.b.s:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$22 -> geogebra.b.t:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$3 -> geogebra.b.u:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$4 -> geogebra.b.v:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$5 -> geogebra.b.w:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$6 -> geogebra.b.x:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianStyleBar$7 -> geogebra.b.y:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    java.awt.Dimension val$lineStyleIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBar$8 -> geogebra.b.z:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    java.awt.Dimension val$pointStyleIconSize -> a
    void update(java.lang.Object[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.euclidian.EuclidianStyleBar$9 -> geogebra.b.A:
    geogebra.euclidian.EuclidianStyleBar this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra.euclidian.EuclidianView -> geogebra.b.B:
    java.awt.RenderingHints defRenderingHints -> a
    java.awt.Image resetImage -> a
    java.awt.Image playImage -> b
    java.awt.Image pauseImage -> c
    java.awt.Cursor defaultCursor -> a
    void initView(boolean) -> l
    void setDragCursor() -> B
    void setMoveCursor() -> E
    void setResizeXAxisCursor() -> C
    void setResizeYAxisCursor() -> D
    void setHitCursor() -> A
    void setDefaultCursor() -> z
    void initCursor() -> n
    java.awt.Cursor getCursorForImage(java.awt.Image) -> a
    void setDefRenderingHints(geogebra.common.awt.Graphics2D) -> m
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void exportPaint(java.awt.Graphics2D,double) -> a
    void exportPaint(geogebra.common.awt.Graphics2D,double,boolean) -> a
    void exportPaintPre(geogebra.common.awt.Graphics2D,double) -> a
    void exportPaintPre(geogebra.common.awt.Graphics2D,double,boolean) -> b
    java.awt.image.BufferedImage getExportImage(double) -> a
    java.awt.image.BufferedImage getExportImage(double,boolean) -> a
    java.awt.image.BufferedImage createBufferedImage(int,int,boolean) -> a
    void drawResetIcon(geogebra.common.awt.Graphics2D) -> k
    java.awt.Image getResetImage() -> a
    java.awt.Image getPlayImage() -> b
    java.awt.Image getPauseImage() -> c
    void drawAnimationButtons(geogebra.common.awt.Graphics2D) -> o
    boolean hitAnimationButton(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean drawPlayButtonInThisView() -> p
    geogebra.euclidian.EuclidianController getEuclidianController() -> a
    geogebra.common.euclidian.AbstractEuclidianController getEuclidianController() -> a
geogebra.euclidian.EuclidianViewJPanel -> geogebra.b.C:
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    java.awt.Color bgColor -> a
    int temporaryWidth -> a
    int temporaryHeight -> b
    geogebra.awt.Graphics2D g2 -> a
    java.awt.Color getBackground() -> getBackground
    void setBackground(java.awt.Color) -> setBackground
    void paintChildren(java.awt.Graphics) -> paintChildren
    int getWidth() -> getWidth
    int getHeight() -> getHeight
    java.awt.Rectangle getBounds() -> getBounds
    void setToolTipText(java.lang.String) -> setToolTipText
    void paint(java.awt.Graphics) -> paint
geogebra.euclidian.EuclidianViewTransferHandler -> geogebra.b.D:
    geogebra.euclidianND.EuclidianViewND ev -> a
    geogebra.main.Application app -> a
    java.awt.datatransfer.DataFlavor textReaderFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    boolean debug -> a
    void setSupportedFlavours() -> a
    int getSourceActions(javax.swing.JComponent) -> getSourceActions
    boolean canImport(javax.swing.JComponent,java.awt.datatransfer.DataFlavor[]) -> canImport
    boolean importData(javax.swing.JComponent,java.awt.datatransfer.Transferable) -> importData
    void requestViewFocus() -> b
    java.awt.datatransfer.Transferable createTransferable(javax.swing.JComponent) -> createTransferable
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
geogebra.euclidian.HatchingHandler -> geogebra.b.E:
    java.awt.image.BufferedImage bufferedImage -> a
    void dosetHatching(geogebra.common.awt.Graphics2D,geogebra.common.awt.BasicStroke,geogebra.common.awt.Color,geogebra.common.awt.Color,float,double,double) -> a
    void doSetTexture(geogebra.common.awt.Graphics2D,geogebra.common.kernel.geos.GeoElement,float) -> a
geogebra.euclidian.Inertia -> geogebra.b.F:
    double mass -> a
    double sx -> b
    double sxx -> c
    double sy -> d
    double sxy -> e
    double syy -> f
geogebra.euclidian.LatexConvertor -> geogebra.b.G:
    geogebra.common.kernel.commands.AlgebraProcessor env -> a
    geogebra.common.kernel.Construction cons -> a
    java.lang.String getLaTeXString(java.lang.String) -> a
geogebra.euclidian.LatexConvertorFactory -> geogebra.b.H:
    geogebra.common.kernel.Kernel kernel -> a
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter getExternalConverter() -> a
    geogebra.common.kernel.commands.AlgebraProcessor getCurrentGeoGebraEnv() -> a
geogebra.euclidian.MyZoomer -> geogebra.b.I:
    javax.swing.Timer timer -> a
    void stopTimer() -> c
    boolean hasTimer() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void startTimer() -> d
geogebra.euclidian.PolyBezier -> geogebra.b.J:
    int n -> a
    int max_capacity -> b
    double[] x -> a
    double[] y -> b
    java.awt.geom.GeneralPath gp -> a
    void setNumberOfPoints(int) -> a
    void buildGeneralPath() -> a
    double[] tobezier(double[],double[],int) -> a
    double[] spline(double[],double[],int,double,double) -> a
geogebra.euclidian.RecoSegment -> geogebra.b.K:
    int startpt -> a
    int endpt -> b
    double xcenter -> a
    double ycenter -> b
    double angle -> c
    double radius -> d
    double x1 -> e
    double y1 -> f
    double x2 -> g
    double y2 -> h
    boolean reversed -> a
geogebra.euclidian.clipping.DoubleArrayFactory -> geogebra.b.a.a:
    java.util.Map map -> a
    java.util.Map createMap() -> a
    double[] getArray(int) -> a
    void putArray(double[]) -> a
geogebra.euclidian.event.FocusEvent -> geogebra.b.b.a:
    java.util.LinkedList pool -> a
    java.awt.event.FocusEvent event -> a
    geogebra.euclidian.event.FocusEvent wrapEvent(java.awt.event.FocusEvent) -> a
    void release() -> a
geogebra.euclidian.event.FocusListener -> geogebra.b.b.b:
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.euclidian.event.KeyEvent -> geogebra.b.b.c:
    java.util.LinkedList pool -> a
    java.awt.event.KeyEvent event -> a
    geogebra.euclidian.event.KeyEvent wrapEvent(java.awt.event.KeyEvent) -> a
    void release() -> a
    char getKeyChar() -> a
geogebra.euclidian.event.KeyListener -> geogebra.b.b.d:
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.euclidian.event.MouseEvent -> geogebra.b.b.e:
    java.util.LinkedList pool -> a
    java.awt.event.MouseEvent event -> a
    geogebra.common.euclidian.event.AbstractEvent wrapEvent(java.awt.event.MouseEvent) -> a
    geogebra.common.awt.Point getPoint() -> a
    boolean isAltDown() -> a
    boolean isShiftDown() -> b
    java.awt.event.MouseEvent getEvent(geogebra.common.euclidian.event.AbstractEvent) -> a
    void release() -> a
    int getX() -> a
    int getY() -> b
    boolean isRightClick() -> c
    boolean isControlDown() -> d
    int getClickCount() -> c
    boolean isMetaDown() -> e
    double getWheelRotation() -> a
    boolean isMiddleClick() -> f
    boolean isPopupTrigger() -> g
geogebra.euclidianND.EuclidianViewND -> geogebra.c.a:
    geogebra.euclidian.EuclidianViewJPanel evjpanel -> a
    java.awt.Graphics2D g2Dtemp -> a
    java.awt.Graphics2D getGraphicsForPen() -> a
    void setCursor(java.awt.Cursor) -> a
    boolean hasFocus() -> q
    void repaint() -> y
    void paintBackground(geogebra.common.awt.Graphics2D) -> e
    void add(geogebra.common.javax.swing.Box) -> a
    void remove(geogebra.common.javax.swing.Box) -> b
    javax.swing.JPanel getJPanel() -> a
    void requestFocus() -> F
    geogebra.common.awt.Font getFont() -> h
    java.awt.Point getMousePosition() -> a
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> a
    boolean isShowing() -> r
    boolean requestFocusInWindow() -> m
    void setPreferredSize(java.awt.Dimension) -> a
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    void revalidate() -> G
    void addMouseListener(java.awt.event.MouseListener) -> a
    void removeMouseListener(java.awt.event.MouseListener) -> b
    void addMouseMotionListener(java.awt.event.MouseMotionListener) -> a
    void removeMouseMotionListener(java.awt.event.MouseMotionListener) -> b
    void addMouseWheelListener(java.awt.event.MouseWheelListener) -> a
    void removeMouseWheelListener(java.awt.event.MouseWheelListener) -> b
    void dispatchEvent(java.awt.event.ComponentEvent) -> a
    void setBorder(javax.swing.border.Border) -> a
    void addComponentListener(java.awt.event.ComponentListener) -> a
    void setSize(java.awt.Dimension) -> b
    java.awt.Dimension getPreferredSize() -> a
    geogebra.main.Application getApplication() -> a
    void initPanel(boolean) -> n
    void setToolTipText(java.lang.String) -> a
    int getWidth() -> s
    int getHeight() -> t
    void updateSize() -> s
    void createImage(java.awt.GraphicsConfiguration) -> a
    void drawActionObjects(geogebra.common.awt.Graphics2D) -> l
    void clearView() -> b
    java.awt.Color getBackground() -> a
    geogebra.common.awt.Color getBackgroundCommon() -> c
    void setBackground(geogebra.common.awt.Color) -> b
    java.awt.Graphics2D getTempGraphics2D() -> b
    geogebra.common.awt.Graphics2D getTempGraphics2D(geogebra.common.awt.Font) -> a
    void setAntialiasing(java.awt.Graphics2D) -> a
    void setAntialiasing(geogebra.common.awt.Graphics2D) -> n
    void setHeight(int) -> j
    void setWidth(int) -> k
    void setStyleBarMode(int) -> l
    geogebra.euclidian.EuclidianStyleBar newEuclidianStyleBar() -> a
    geogebra.common.euclidian.EuclidianStyleBar getStyleBar() -> a
    boolean hasStyleBar() -> s
    geogebra.euclidian.MyZoomer newZoomer() -> a
    geogebra.euclidian.EuclidianController getEuclidianController() -> a
    geogebra.common.euclidian.AbstractZoomer newZoomer() -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.euclidian.AbstractEuclidianController getEuclidianController() -> a
geogebra.export.AnimationExportDialog -> geogebra.d.a:
    geogebra.main.Application app -> a
    javax.swing.JComboBox cbSliders -> a
    javax.swing.JCheckBox cbLoop -> a
    javax.swing.JTextField tfTimeBetweenFrames -> a
    javax.swing.JButton cancelButton -> a
    javax.swing.JButton exportButton -> b
    void initGUI() -> b
    void export() -> a
geogebra.export.AnimationExportDialog$1 -> geogebra.d.b:
    geogebra.export.AnimationExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.AnimationExportDialog$2 -> geogebra.d.c:
    geogebra.export.AnimationExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog -> geogebra.d.d:
    javax.swing.JCheckBox cbDrawingPadPicture -> a
    javax.swing.JCheckBox cbScreenshotPicture -> b
    javax.swing.JCheckBox cbColor -> c
    javax.swing.JCheckBox cbIcons -> d
    geogebra.export.GraphicSizePanel sizePanel -> a
    boolean kernelChanged -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView prot -> a
    geogebra.main.Application app -> a
    void initGUI() -> a
    void centerOnScreen() -> b
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void exportHTML(boolean,int,boolean,boolean,boolean) -> a
    java.awt.image.BufferedImage getCenterPanelImage() -> a
    void access$0(geogebra.export.ConstructionProtocolExportDialog,boolean) -> a
    javax.swing.JCheckBox access$1(geogebra.export.ConstructionProtocolExportDialog) -> a
    geogebra.export.GraphicSizePanel access$2(geogebra.export.ConstructionProtocolExportDialog) -> a
    javax.swing.JCheckBox access$3(geogebra.export.ConstructionProtocolExportDialog) -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$4(geogebra.export.ConstructionProtocolExportDialog) -> a
    javax.swing.JCheckBox access$5(geogebra.export.ConstructionProtocolExportDialog) -> c
    javax.swing.JCheckBox access$6(geogebra.export.ConstructionProtocolExportDialog) -> d
    boolean access$7(geogebra.export.ConstructionProtocolExportDialog) -> a
    geogebra.main.Application access$8(geogebra.export.ConstructionProtocolExportDialog) -> a
    void access$9(geogebra.export.ConstructionProtocolExportDialog,boolean,int,boolean,boolean,boolean) -> a
geogebra.export.ConstructionProtocolExportDialog$1 -> geogebra.d.e:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$2 -> geogebra.d.f:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$3 -> geogebra.d.g:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$4 -> geogebra.d.h:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$5 -> geogebra.d.i:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$6 -> geogebra.d.j:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.ConstructionProtocolExportDialog$7 -> geogebra.d.k:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.ConstructionProtocolExportDialog access$0(geogebra.export.ConstructionProtocolExportDialog$7) -> a
geogebra.export.ConstructionProtocolExportDialog$7$1 -> geogebra.d.l:
    geogebra.export.ConstructionProtocolExportDialog$7 this$1 -> a
    void run() -> run
geogebra.export.ConstructionProtocolExportDialog$8 -> geogebra.d.m:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.ConstructionProtocolExportDialog access$0(geogebra.export.ConstructionProtocolExportDialog$8) -> a
geogebra.export.ConstructionProtocolExportDialog$8$1 -> geogebra.d.n:
    geogebra.export.ConstructionProtocolExportDialog$8 this$1 -> a
    void run() -> run
geogebra.export.ConstructionProtocolExportDialog$9 -> geogebra.d.o:
    geogebra.export.ConstructionProtocolExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.GeoGebraTubeExportDesktop -> geogebra.d.p:
    javax.swing.JDialog progressDialog -> a
    javax.swing.JProgressBar progressBar -> a
    javax.swing.JLabel statusLabel -> a
    javax.swing.JButton abortButton -> a
    void setMaximum(int) -> a
    void setMinimum(int) -> b
    void setIndeterminate(boolean) -> a
    void setValue(int) -> c
    void setEnabled(boolean) -> b
    void uploadWorksheet(java.util.ArrayList) -> a
    void showDialog() -> a
    void pack() -> b
    void hideDialog() -> c
    void statusLabelSetText(java.lang.String) -> a
    java.lang.String encode(java.lang.String) -> a
    java.lang.String getBase64Tools(java.util.ArrayList) -> a
geogebra.export.GeoGebraTubeExportDesktop$1 -> geogebra.d.q:
    geogebra.export.GeoGebraTubeExportDesktop this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog -> geogebra.d.r:
    geogebra.main.Application app -> a
    javax.swing.JComboBox cbFormat -> a
    javax.swing.JComboBox cbDPI -> b
    javax.swing.JLabel sizeLabel -> a
    javax.swing.JButton cancelButton -> a
    double exportScale -> a
    int pixelWidth -> a
    int pixelHeight -> b
    java.text.NumberFormat sizeLabelFormat -> a
    boolean textAsShapes -> a
    boolean transparent -> b
    boolean EMFPlus -> c
    int FORMAT_PNG -> c
    int FORMAT_PDF -> d
    int FORMAT_EPS -> e
    int FORMAT_SVG -> f
    int FORMAT_EMF -> g
    geogebra.euclidian.EuclidianView specifiedEuclidianView -> a
    geogebra.euclidian.EuclidianView getEuclidianView() -> a
    void setVisible(boolean) -> setVisible
    void initGUI() -> a
    int getDPI() -> a
    void loadPreferences() -> b
    void savePreferences() -> c
    void updateSizeLabel() -> d
    void centerOnScreen() -> e
    boolean exportEPS(boolean) -> b
    boolean exportEMF(boolean,boolean) -> b
    boolean exportPDF(boolean) -> c
    boolean exportSVG(boolean) -> d
    boolean exportPNG(boolean) -> a
    boolean exportPNG(boolean,boolean) -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void sendToClipboard(java.io.File) -> a
    void exportSVG(geogebra.main.Application,geogebra.euclidian.EuclidianView,java.io.File,boolean,int,int,double) -> a
    void exportEMF(geogebra.main.Application,geogebra.euclidian.EuclidianView,java.io.File,boolean,int,int,double) -> b
    void exportPDF(geogebra.main.Application,geogebra.euclidian.EuclidianView,java.io.File,boolean,int,int,double) -> c
    void exportEPS(geogebra.main.Application,geogebra.euclidian.EuclidianView,java.io.File,boolean,int,int,double) -> d
    void exportPNG(geogebra.euclidian.EuclidianView,java.io.File,boolean,int,double) -> a
    void access$0(geogebra.export.GraphicExportDialog) -> a
    void access$1(geogebra.export.GraphicExportDialog,boolean) -> a
    void access$2(geogebra.export.GraphicExportDialog,boolean) -> b
    void access$3(geogebra.export.GraphicExportDialog,boolean) -> c
    javax.swing.JComboBox access$4(geogebra.export.GraphicExportDialog) -> a
    javax.swing.JComboBox access$5(geogebra.export.GraphicExportDialog) -> b
    boolean access$6(geogebra.export.GraphicExportDialog,boolean) -> a
    boolean access$7(geogebra.export.GraphicExportDialog) -> a
    boolean access$8(geogebra.export.GraphicExportDialog,boolean,boolean) -> a
    boolean access$9(geogebra.export.GraphicExportDialog,boolean) -> b
    boolean access$10(geogebra.export.GraphicExportDialog,boolean) -> c
geogebra.export.GraphicExportDialog$1 -> geogebra.d.s:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$2 -> geogebra.d.t:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$3 -> geogebra.d.u:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$cbTransparent -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$4 -> geogebra.d.v:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$cbEMFPlus -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$5 -> geogebra.d.w:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$textAsShapesCB -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$6 -> geogebra.d.x:
    geogebra.export.GraphicExportDialog this$0 -> a
    javax.swing.JCheckBox val$textAsShapesCB -> a
    javax.swing.JPanel val$dpiPanel -> a
    javax.swing.JLabel val$resolutionInDPILabel -> a
    javax.swing.JCheckBox val$cbEMFPlus -> b
    javax.swing.JCheckBox val$cbTransparent -> c
    javax.swing.JPanel val$p -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$7 -> geogebra.d.y:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.GraphicExportDialog$8 -> geogebra.d.z:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.GraphicExportDialog access$0(geogebra.export.GraphicExportDialog$8) -> a
geogebra.export.GraphicExportDialog$8$1 -> geogebra.d.A:
    geogebra.export.GraphicExportDialog$8 this$1 -> a
    void run() -> run
geogebra.export.GraphicExportDialog$9 -> geogebra.d.B:
    geogebra.export.GraphicExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.GraphicExportDialog access$0(geogebra.export.GraphicExportDialog$9) -> a
geogebra.export.GraphicExportDialog$9$1 -> geogebra.d.C:
    geogebra.export.GraphicExportDialog$9 this$1 -> a
    void run() -> run
geogebra.export.GraphicSizePanel -> geogebra.d.D:
    int width -> a
    int height -> b
    double ratio -> a
    javax.swing.JTextField tfWidth -> a
    javax.swing.JTextField tfHeight -> b
    boolean keepRatio -> a
    void setValues(int,int,boolean) -> a
    int getSelectedWidth() -> a
    int getSelectedHeight() -> b
    void setEnabled(boolean) -> setEnabled
    void updateValues(java.lang.Object) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.export.PrintGridable -> geogebra.d.E:
    geogebra.gui.view.Gridable gridable -> a
    int[] colWidths -> a
    int[] rowHeights -> b
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
geogebra.export.PrintPreview -> geogebra.d.F:
    int m_orientation -> a
    int m_scale -> b
    java.awt.print.Printable m_target -> a
    javax.swing.JComboBox m_cbScale -> a
    javax.swing.JComboBox m_cbOrientation -> b
    javax.swing.JComboBox m_cbView -> c
    javax.swing.JScrollPane ps -> a
    geogebra.export.PrintPreview$PreviewContainer m_preview -> a
    geogebra.main.Application app -> a
    javax.swing.JPanel tempPanel -> a
    javax.swing.JPanel panelForTitleAndScaling -> b
    java.awt.event.ActionListener lst -> a
    boolean kernelChanged -> a
    java.awt.Graphics tempGraphics -> a
    void initPrintPreview(java.awt.print.Printable,int) -> a
    javax.swing.JPanel createPanelForScaling() -> a
    void loadPreferences() -> a
    void savePreferences() -> b
    void setVisible(boolean) -> setVisible
    void centerOnScreen() -> c
    void initPages() -> d
    java.awt.print.PageFormat getDefaultPageFormat() -> a
    void updatePages() -> e
    boolean pageExists(int) -> a
    void setOrientation(int) -> a
    void setScale(int) -> b
    void access$0(geogebra.export.PrintPreview,int) -> a
    void access$1(geogebra.export.PrintPreview,int) -> b
    void access$2(geogebra.export.PrintPreview) -> a
    void access$3(geogebra.export.PrintPreview) -> b
geogebra.export.PrintPreview$1 -> geogebra.d.G:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$1) -> a
geogebra.export.PrintPreview$1$1 -> geogebra.d.H:
    geogebra.export.PrintPreview$1 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$2 -> geogebra.d.I:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.PrintPreview$3 -> geogebra.d.J:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$3) -> a
geogebra.export.PrintPreview$3$1 -> geogebra.d.K:
    geogebra.export.PrintPreview$3 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$4 -> geogebra.d.L:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$4) -> a
geogebra.export.PrintPreview$4$1 -> geogebra.d.M:
    geogebra.export.PrintPreview$4 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$5 -> geogebra.d.N:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$5) -> a
geogebra.export.PrintPreview$5$1 -> geogebra.d.O:
    geogebra.export.PrintPreview$5 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$6 -> geogebra.d.P:
    geogebra.export.PrintPreview this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.PrintPreview access$0(geogebra.export.PrintPreview$6) -> a
geogebra.export.PrintPreview$6$1 -> geogebra.d.Q:
    geogebra.export.PrintPreview$6 this$1 -> a
    void run() -> run
geogebra.export.PrintPreview$7 -> geogebra.d.R:
    geogebra.export.PrintPreview this$0 -> a
    javax.swing.JCheckBox val$cbEVscalePanel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.PrintPreview$PagePreview -> geogebra.d.F$a:
    int m_w -> a
    int m_h -> b
    java.awt.print.Printable target -> a
    java.awt.print.PageFormat format -> a
    int pageIndex -> c
    double scale -> a
    java.awt.image.BufferedImage img -> a
    geogebra.export.PrintPreview this$0 -> a
    void setPageFormat(java.awt.print.PageFormat) -> a
    java.awt.print.PageFormat getPageFormat() -> a
    void setScale(int) -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    java.awt.Dimension getMinimumSize() -> getMinimumSize
    void updateBufferedImage() -> b
    void update() -> a
    void paint(java.awt.Graphics) -> paint
geogebra.export.PrintPreview$PreviewContainer -> geogebra.d.F$b:
    int H_GAP -> a
    int V_GAP -> b
    geogebra.export.PrintPreview this$0 -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    java.awt.Dimension getMinimumSize() -> getMinimumSize
    void doLayout() -> doLayout
    int getNumberOfPages() -> getNumberOfPages
    java.awt.print.PageFormat getPageFormat(int) -> getPageFormat
    java.awt.print.Printable getPrintable(int) -> getPrintable
geogebra.export.PrintScalePanel -> geogebra.d.S:
    javax.swing.JTextField tfScale1 -> a
    javax.swing.JTextField tfScale2 -> b
    java.util.Vector listeners -> a
    geogebra.common.euclidian.AbstractEuclidianView ev -> a
    java.text.NumberFormat nf -> a
    java.awt.event.ActionListener al -> a
    void updateTextFields() -> a
    void fireTextFieldUpdate(javax.swing.JTextField) -> a
    void addActionListener(java.awt.event.ActionListener) -> a
    void notifyListeners() -> b
    void access$0(geogebra.export.PrintScalePanel,javax.swing.JTextField) -> a
geogebra.export.PrintScalePanel$1 -> geogebra.d.T:
    geogebra.export.PrintScalePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.PrintScalePanel$2 -> geogebra.d.U:
    geogebra.export.PrintScalePanel this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
geogebra.export.SVGExtensions -> geogebra.d.V:
    void startGroup(java.lang.String) -> a
    void endGroup(java.lang.String) -> b
geogebra.export.WorksheetExportDialog -> geogebra.d.W:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.algebra.InputPanel textAbove -> a
    geogebra.gui.view.algebra.InputPanel textBelow -> b
    geogebra.gui.view.algebra.InputPanel textAboveUpload -> c
    geogebra.gui.view.algebra.InputPanel textBelowUpload -> d
    javax.swing.JCheckBox cbEnableRightClick -> a
    javax.swing.JCheckBox cbEnableLabelDrags -> b
    javax.swing.JCheckBox cbShowResetIcon -> c
    javax.swing.JCheckBox cbShowMenuBar -> d
    javax.swing.JCheckBox cbSavePrint -> e
    javax.swing.JCheckBox cbShowToolBar -> f
    javax.swing.JCheckBox cbShowToolBarHelp -> g
    javax.swing.JCheckBox cbShowInputField -> h
    javax.swing.JCheckBox cbUseBrowserForJavaScript -> i
    javax.swing.JCheckBox cbAllowRescaling -> j
    javax.swing.JCheckBox cbRemoveLinebreaks -> k
    javax.swing.JCheckBox cbOfflineUse -> l
    javax.swing.JCheckBox cbIncludeHTML5 -> m
    javax.swing.JComboBox cbFileType -> a
    javax.swing.JComboBox cbAllWorksheets -> b
    javax.swing.JButton exportButton -> a
    javax.swing.JButton helpButton -> b
    geogebra.export.GraphicSizePanel sizePanel -> a
    boolean kernelChanged -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.main.GeoGebraPreferences ggbPref -> a
    geogebra.gui.GuiManager guiManager -> a
    boolean removeLineBreaks -> b
    geogebra.gui.inputfield.MyTextField titleField -> a
    geogebra.gui.TitlePanel titlePanel -> a
    javax.swing.JTabbedPane modeSwitch -> b
    javax.swing.JPanel modeUploadPanel -> a
    javax.swing.JPanel modeHtmlPanel -> b
    java.lang.String[] enableLabelDrags -> a
    java.lang.String[] showResetIcon -> b
    java.lang.String[] enableRightClick -> c
    java.lang.String[] errorDialogsActive -> d
    java.lang.String[] showMenuBar -> e
    java.lang.String[] showToolBar -> f
    java.lang.String[] showToolBarHelp -> g
    java.lang.String[] showAlgebraInput -> h
    java.lang.String[] useBrowserForJS -> i
    java.lang.String[] allowRescaling -> j
    java.lang.String[] java_arguments -> k
    java.lang.String[] cache_archive -> l
    java.lang.String[] cache_version -> m
    java.lang.StringBuilder sb2 -> a
    void checkEuclidianView() -> a
    void initGUI() -> b
    void loadPreferences() -> c
    void addHeight() -> d
    void savePreferences() -> e
    javax.swing.JPanel createUploadPanel() -> a
    javax.swing.JPanel createGeneralSettingsTab() -> b
    javax.swing.JPanel createAdvancedSettingsTab() -> c
    void setVisible(boolean) -> setVisible
    void centerOnScreen() -> f
    void exportToClipboard(int) -> a
    void exportHTMLtoFile() -> g
    void copyInputStream(java.io.InputStream,java.io.OutputStream) -> a
    void exportAllOpenFilesToHTMLasTabs() -> h
    void exportAllOpenFilesToHTML() -> i
    java.net.URL getAppletCodebase() -> a
    void copyJarsTo(java.net.URL,java.lang.String) -> a
    boolean appendBase64(geogebra.main.Application,java.lang.StringBuilder) -> a
    java.lang.String getMediaWiki() -> a
    void appendWithLineBreak(java.lang.StringBuilder,java.lang.String) -> a
    java.lang.String getGoogleGadget() -> b
    java.lang.String getHTML(geogebra.main.Application,java.io.File,java.lang.String,java.lang.String) -> a
    void appendText(java.lang.StringBuilder,java.lang.String) -> b
    void appendTitle(java.lang.StringBuilder,java.lang.String) -> c
    void appendJavaScript(java.lang.StringBuilder) -> a
    java.lang.String getFooter(geogebra.common.kernel.Construction,boolean) -> a
    java.lang.String getAppletTag(geogebra.main.Application,java.io.File,int,int,boolean,boolean,boolean,boolean) -> a
    void appletParam(java.lang.StringBuilder,java.lang.String[],boolean,int) -> a
    void appletParam(java.lang.StringBuilder,java.lang.String[],java.lang.String,int) -> a
    void appendGgbAppletParameters(java.lang.StringBuilder,int) -> a
    void appendAllAppletParameters(java.lang.StringBuilder,int) -> b
    void access$0(geogebra.export.WorksheetExportDialog,boolean) -> a
    boolean access$1(geogebra.export.WorksheetExportDialog) -> a
    geogebra.main.Application access$2(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JTabbedPane access$3(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JComboBox access$4(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JComboBox access$5(geogebra.export.WorksheetExportDialog) -> b
    void access$6(geogebra.export.WorksheetExportDialog) -> a
    void access$7(geogebra.export.WorksheetExportDialog,int) -> a
    void access$8(geogebra.export.WorksheetExportDialog) -> b
    void access$9(geogebra.export.WorksheetExportDialog) -> c
    javax.swing.JButton access$10(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.view.algebra.InputPanel access$11(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.view.algebra.InputPanel access$12(geogebra.export.WorksheetExportDialog) -> b
    geogebra.gui.view.algebra.InputPanel access$13(geogebra.export.WorksheetExportDialog) -> c
    geogebra.gui.view.algebra.InputPanel access$14(geogebra.export.WorksheetExportDialog) -> d
    geogebra.common.kernel.Kernel access$15(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.inputfield.MyTextField access$16(geogebra.export.WorksheetExportDialog) -> a
    geogebra.gui.TitlePanel access$17(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JCheckBox access$18(geogebra.export.WorksheetExportDialog) -> a
    void access$19(geogebra.export.WorksheetExportDialog,boolean) -> b
    javax.swing.JCheckBox access$20(geogebra.export.WorksheetExportDialog) -> b
    javax.swing.JCheckBox access$21(geogebra.export.WorksheetExportDialog) -> c
    geogebra.gui.GuiManager access$22(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JCheckBox access$23(geogebra.export.WorksheetExportDialog) -> d
    javax.swing.JCheckBox access$24(geogebra.export.WorksheetExportDialog) -> e
    geogebra.export.GraphicSizePanel access$25(geogebra.export.WorksheetExportDialog) -> a
    javax.swing.JCheckBox access$26(geogebra.export.WorksheetExportDialog) -> f
    java.net.URL access$27(geogebra.export.WorksheetExportDialog) -> a
geogebra.export.WorksheetExportDialog$1 -> geogebra.d.X:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$10 -> geogebra.d.Y:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$11 -> geogebra.d.Z:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$12 -> geogebra.d.aa:
    geogebra.export.WorksheetExportDialog this$0 -> a
    java.io.File val$HTMLfile -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$2 -> geogebra.d.ab:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$3 -> geogebra.d.ac:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.export.WorksheetExportDialog access$0(geogebra.export.WorksheetExportDialog$3) -> a
geogebra.export.WorksheetExportDialog$3$1 -> geogebra.d.ad:
    geogebra.export.WorksheetExportDialog$3 this$1 -> a
    void run() -> run
geogebra.export.WorksheetExportDialog$4 -> geogebra.d.ae:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.export.WorksheetExportDialog$5 -> geogebra.d.af:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$6 -> geogebra.d.ag:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
geogebra.export.WorksheetExportDialog$7 -> geogebra.d.ah:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$8 -> geogebra.d.ai:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.WorksheetExportDialog$9 -> geogebra.d.aj:
    geogebra.export.WorksheetExportDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.epsgraphics.ColorMode -> geogebra.d.a.a:
    geogebra.export.epsgraphics.ColorMode COLOR_CMYK -> a
    geogebra.export.epsgraphics.ColorMode COLOR_RGB -> b
    geogebra.export.epsgraphics.ColorMode GRAYSCALE -> c
    geogebra.export.epsgraphics.ColorMode BLACK_AND_WHITE -> d
    geogebra.export.epsgraphics.ColorMode[] ENUM$VALUES -> a
    geogebra.export.epsgraphics.ColorMode[] values() -> values
    geogebra.export.epsgraphics.ColorMode valueOf(java.lang.String) -> valueOf
geogebra.export.epsgraphics.EpsDocument -> geogebra.d.a.b:
    java.io.OutputStream stream -> a
    int minX -> a
    int minY -> b
    int maxX -> c
    int maxY -> d
    boolean _isClipSet -> a
    java.lang.String title -> a
    java.io.BufferedWriter bufferedWriter -> a
    geogebra.export.epsgraphics.EpsGraphics _lastG -> a
    void append(geogebra.export.epsgraphics.EpsGraphics,java.lang.String) -> a
    void write(java.io.Writer) -> a
    void writeFooter(java.io.Writer) -> b
    void flush() -> a
    void close() -> b
    boolean isClipSet() -> a
    void setClipSet(boolean) -> a
geogebra.export.epsgraphics.EpsGraphics -> geogebra.d.a.c:
    java.awt.Stroke currentStroke -> a
    java.awt.Color color -> a
    java.awt.geom.AffineTransform _clipTransform -> a
    java.awt.Color _backgroundColor -> b
    java.awt.Paint _paint -> a
    java.awt.Composite _composite -> a
    java.awt.BasicStroke _stroke -> a
    java.awt.Font _font -> a
    java.awt.Shape _clip -> a
    java.awt.geom.AffineTransform _transform -> b
    boolean _accurateTextMode -> a
    geogebra.export.epsgraphics.EpsDocument _document -> a
    java.awt.font.FontRenderContext _fontRenderContext -> a
    geogebra.export.epsgraphics.ColorMode colorMode -> a
    int[] $SWITCH_TABLE$geogebra$export$epsgraphics$ColorMode -> a
    void methodNotSupported() -> d
    boolean getAccurateTextMode() -> a
    void flush() -> a
    void close() -> b
    void append(java.lang.String) -> a
    java.awt.geom.Point2D transform(double,double) -> a
    void draw(java.awt.Shape,java.lang.String) -> a
    java.lang.String toHexString(int) -> a
    void draw3DRect(int,int,int,int,boolean) -> draw3DRect
    void fill3DRect(int,int,int,int,boolean) -> fill3DRect
    void draw(java.awt.Shape) -> draw
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    void drawString(java.lang.String,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void fill(java.awt.Shape) -> fill
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    void setComposite(java.awt.Composite) -> setComposite
    void setPaint(java.awt.Paint) -> setPaint
    void setStroke(java.awt.Stroke) -> setStroke
    void appendStroke() -> c
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    void setRenderingHints(java.util.Map) -> setRenderingHints
    void addRenderingHints(java.util.Map) -> addRenderingHints
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    void translate(int,int) -> translate
    void translate(double,double) -> translate
    void rotate(double) -> rotate
    void rotate(double,double,double) -> rotate
    void scale(double,double) -> scale
    void shear(double,double) -> shear
    void transform(java.awt.geom.AffineTransform) -> transform
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    java.awt.geom.AffineTransform getTransform() -> getTransform
    java.awt.Paint getPaint() -> getPaint
    java.awt.Composite getComposite() -> getComposite
    void setBackground(java.awt.Color) -> setBackground
    java.awt.Color getBackground() -> getBackground
    java.awt.Stroke getStroke() -> getStroke
    void clip(java.awt.Shape) -> clip
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.awt.Graphics create(int,int,int,int) -> create
    java.awt.Color getColor() -> getColor
    void setColor(java.awt.Color) -> setColor
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    java.awt.Font getFont() -> getFont
    void setFont(java.awt.Font) -> setFont
    java.awt.FontMetrics getFontMetrics() -> getFontMetrics
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    java.awt.Rectangle getClipBounds() -> getClipBounds
    void clipRect(int,int,int,int) -> clipRect
    void setClip(int,int,int,int) -> setClip
    java.awt.Shape getClip() -> getClip
    void setClip(java.awt.Shape) -> setClip
    void copyArea(int,int,int,int,int,int) -> copyArea
    void drawLine(int,int,int,int) -> drawLine
    void fillRect(int,int,int,int) -> fillRect
    void drawRect(int,int,int,int) -> drawRect
    void clearRect(int,int,int,int) -> clearRect
    void drawRoundRect(int,int,int,int,int,int) -> drawRoundRect
    void fillRoundRect(int,int,int,int,int,int) -> fillRoundRect
    void drawOval(int,int,int,int) -> drawOval
    void fillOval(int,int,int,int) -> fillOval
    void drawArc(int,int,int,int,int,int) -> drawArc
    void fillArc(int,int,int,int,int,int) -> fillArc
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawPolygon(java.awt.Polygon) -> drawPolygon
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillPolygon(java.awt.Polygon) -> fillPolygon
    void drawChars(char[],int,int,int,int) -> drawChars
    void drawBytes(byte[],int,int,int,int) -> drawBytes
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    void dispose() -> dispose
    void finalize() -> finalize
    java.lang.String toString() -> toString
    boolean hitClip(int,int,int,int) -> hitClip
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    java.awt.Graphics create() -> create
    int[] $SWITCH_TABLE$geogebra$export$epsgraphics$ColorMode() -> a
geogebra.export.pstricks.AsymptoteFrame -> geogebra.d.b.a:
    javax.swing.JComboBox comboFontSizeMore -> a
    java.lang.String[] format -> a
    java.lang.String[] fontsizelist -> b
    void initGui() -> a
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
    int getFontSize() -> a
geogebra.export.pstricks.ExportFrame -> geogebra.d.b.b:
    java.lang.String TEXT_XUNIT -> a
    java.lang.String TEXT_YUNIT -> b
    java.lang.String TEXT_WIDTH -> c
    java.lang.String TEXT_HEIGHT -> d
    java.lang.String TEXT_XMAX -> e
    java.lang.String TEXT_XMIN -> f
    java.lang.String TEXT_YMAX -> g
    java.lang.String TEXT_YMIN -> h
    geogebra.export.pstricks.TextValue textXUnit -> a
    geogebra.export.pstricks.TextValue textYUnit -> b
    geogebra.export.pstricks.TextValue textwidth -> c
    geogebra.export.pstricks.TextValue textheight -> d
    javax.swing.JLabel labelwidth -> a
    javax.swing.JLabel labelheight -> b
    javax.swing.JLabel labelXUnit -> c
    javax.swing.JLabel labelYUnit -> d
    javax.swing.JLabel labelFontSize -> e
    javax.swing.JLabel labelFormat -> f
    geogebra.export.pstricks.TextValue textXmin -> e
    geogebra.export.pstricks.TextValue textXmax -> f
    geogebra.export.pstricks.TextValue textYmin -> g
    geogebra.export.pstricks.TextValue textYmax -> h
    javax.swing.JLabel labelXmin -> g
    javax.swing.JLabel labelXmax -> h
    javax.swing.JLabel labelYmin -> i
    javax.swing.JLabel labelYmax -> j
    java.lang.String[] msg -> c
    javax.swing.JComboBox comboFontSize -> b
    javax.swing.JComboBox comboFormat -> c
    javax.swing.JComboBox comboFill -> d
    javax.swing.JLabel labelFill -> k
    javax.swing.JPanel panel -> a
    javax.swing.JButton button -> a
    javax.swing.JButton button_copy -> b
    javax.swing.JCheckBox jcbPointSymbol -> a
    javax.swing.JCheckBox jcbGrayscale -> b
    javax.swing.JCheckBox jcbShowAxes -> c
    javax.swing.JCheckBox jcbAsyCompact -> d
    javax.swing.JCheckBox jcbAsyCse5 -> e
    javax.swing.JCheckBox jcbDotColors -> f
    javax.swing.JCheckBox jcbPairName -> g
    javax.swing.JScrollPane js -> a
    javax.swing.JTextArea textarea -> a
    geogebra.main.Application app -> a
    double width -> a
    double height -> b
    javax.swing.JButton buttonSave -> c
    java.io.File currentFile -> a
    geogebra.export.pstricks.GeoGebraExport ggb -> a
    geogebra.export.pstricks.ExportFrame$ListenKey listenKey -> a
    void centerOnScreen() -> b
    boolean isGrayscale() -> d
    boolean getExportPointSymbol() -> e
    double getXUnit() -> a
    double getYUnit() -> b
    double getLatexHeight() -> c
    double getLatexWidth() -> d
    void write(java.lang.StringBuilder) -> a
    int getFontSize() -> a
    int getFormat() -> b
    boolean getShowAxes() -> f
    boolean getAsyCompact() -> g
    boolean getAsyCompactCse5() -> h
    boolean getKeepDotColors() -> i
    boolean getUsePairNames() -> j
    int getFillType() -> c
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
    boolean isBeamer() -> a
    geogebra.export.pstricks.GeoGebraExport access$0(geogebra.export.pstricks.ExportFrame) -> a
geogebra.export.pstricks.ExportFrame$1 -> geogebra.d.b.c:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$2 -> geogebra.d.b.d:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    geogebra.export.pstricks.GeoGebraExport val$ggb -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$3 -> geogebra.d.b.e:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$4 -> geogebra.d.b.f:
    geogebra.export.pstricks.ExportFrame this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.export.pstricks.ExportFrame$ListenKey -> geogebra.d.b.b$a:
    geogebra.export.pstricks.ExportFrame ef -> a
    geogebra.export.pstricks.ExportFrame this$0 -> b
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.export.pstricks.GeoGebraExport -> geogebra.d.b.g:
    int beamerSlideNumber -> a
    double PRECISION_XRANGE_FUNCTION -> a
    java.lang.StringBuilder code -> a
    java.lang.StringBuilder codePoint -> b
    java.lang.StringBuilder codePreamble -> c
    java.lang.StringBuilder codeFilledObject -> d
    java.lang.StringBuilder codeBeginDoc -> e
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction construction -> a
    geogebra.euclidianND.EuclidianViewND euclidianView -> a
    geogebra.export.pstricks.ExportFrame frame -> a
    java.util.HashMap CustomColor -> a
    double xunit -> b
    double yunit -> c
    double xmin -> d
    double xmax -> e
    double ymin -> f
    double ymax -> g
    int format -> b
    boolean isBeamer -> a
    geogebra.main.Application getApp() -> a
    java.lang.String format(double) -> a
    void refreshSelectionRectangle() -> a
    void setxmin(double) -> a
    void setxmax(double) -> b
    void setymin(double) -> c
    void setymax(double) -> d
    double getxmin() -> a
    double getxmax() -> b
    double getymin() -> c
    double getymax() -> d
    void initGui() -> e
    void setBeamer(boolean) -> a
    java.lang.String sci2dec(double) -> b
    java.lang.String createCustomColor(int,int,int) -> a
    void drawGeoElement(geogebra.common.kernel.geos.GeoElement,boolean,boolean) -> a
    boolean isSinglePointConic(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDoubleLineConic(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isEmpty(geogebra.common.kernel.geos.GeoElement) -> c
    int resizePt(int) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void createFrame() -> b
    void generateAllCode() -> c
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    double getXmin() -> e
    void setXmin(double) -> e
    double getXmax() -> f
    void setXmax(double) -> f
    double getYmin() -> g
    double getYmax() -> h
    double getXunit() -> i
    void setXunit(double) -> g
    double getYunit() -> j
    void setYunit(double) -> h
    void mark(double[],double[],int,geogebra.common.kernel.geos.GeoElement) -> a
    void markAngle(geogebra.common.kernel.geos.GeoAngle,double,double[],double,double) -> a
    void drawAllElements() -> d
    void startBeamer(java.lang.StringBuilder) -> a
    void endBeamer(java.lang.StringBuilder) -> b
    java.lang.String getImplicitExpr(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToAsymptote -> geogebra.d.b.h:
    boolean eurosym -> b
    boolean compact -> c
    boolean compactcse5 -> d
    boolean grayscale -> e
    boolean dotColors -> f
    boolean pairName -> g
    int parabolaCount -> c
    int hyperbolaCount -> d
    int arcCount -> e
    int functionCount -> f
    int implicitFuncCount -> g
    int fillType -> h
    int fontsize -> i
    java.lang.StringBuilder codeBeginPic -> f
    java.lang.StringBuilder codePointDecl -> g
    java.lang.StringBuilder codeColors -> h
    java.lang.StringBuilder codeEndDoc -> i
    java.util.ArrayList pointList -> a
    java.util.Map unicodeTable -> a
    java.util.Map pairNameTable -> b
    java.util.Map functionTable -> c
    java.util.Map implicitPolyTable -> d
    java.util.Set usepackage -> a
    java.util.Set importpackage -> b
    void createFrame() -> b
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    void drawSpecialPoint(geogebra.common.kernel.geos.GeoPoint2) -> b
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void initUnitAndVariable() -> g
    void initPointDeclarations() -> h
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    boolean ColorEquals(geogebra.common.awt.Color,geogebra.common.awt.Color) -> a
    void drawGrid() -> i
    void drawAxis() -> j
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint2,java.lang.StringBuilder,double) -> a
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint2,java.lang.StringBuilder) -> a
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.Color,java.lang.StringBuilder) -> a
    void ColorLightCode(geogebra.common.awt.Color,double,java.lang.StringBuilder) -> a
    void addText(java.lang.String,boolean,int,int,geogebra.common.awt.Color) -> a
    void packSpaceBetween(java.lang.String[]) -> a
    void packSpaceBetween(java.lang.StringBuilder,java.lang.String[]) -> a
    void packSpaceAfter(java.lang.String[]) -> b
    void packSpaceAfter(java.lang.StringBuilder,java.lang.String[]) -> b
    void packSpace(java.lang.String[]) -> c
    void packSpace(java.lang.StringBuilder,java.lang.String[]) -> c
    void startDraw() -> e
    void startDraw(java.lang.StringBuilder) -> c
    void endDraw(geogebra.common.kernel.geos.GeoElement) -> a
    void endDraw(geogebra.common.kernel.geos.GeoElement,java.lang.StringBuilder) -> a
    void startTransparentFill(java.lang.StringBuilder) -> d
    void endTransparentFill(geogebra.common.kernel.geos.GeoElement,java.lang.StringBuilder) -> b
    void endPoint(geogebra.common.awt.Color) -> a
    void addPoint(java.lang.String,java.lang.String,java.lang.StringBuilder) -> a
    void initUnicodeTextTable() -> f
    java.lang.StringBuilder convertUnicodeToText(java.lang.StringBuilder) -> a
    java.lang.String convertUnicodeToText(java.lang.String) -> a
    java.lang.String convertUnicodeToLatex(java.lang.String) -> b
    java.lang.String parseFunction(java.lang.String) -> c
    java.lang.String killSpace(java.lang.String) -> d
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToPgf -> geogebra.d.b.i:
    int functionIdentifier -> c
    boolean forceGnuplot -> b
    boolean gnuplotWarning -> c
    boolean hatchWarning -> d
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void addText(java.lang.String,boolean,int,int) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction,java.lang.StringBuilder) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian,java.lang.StringBuilder) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String replaceX(java.lang.String,java.lang.String) -> a
    java.lang.String killSpace(java.lang.String) -> a
    boolean warningFunc(java.lang.String,java.lang.String) -> a
    void addWarningGnuplot() -> e
    void addWarningHatch() -> f
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawGrid() -> g
    void drawAxis() -> h
    java.lang.String footnotesize(java.lang.String) -> b
    void writePoint(double,double,java.lang.StringBuilder) -> a
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.Color,java.lang.StringBuilder) -> a
    void createFrame() -> b
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    geogebra.common.kernel.StringTemplate getStringTemplate() -> a
geogebra.export.pstricks.GeoGebraToPstricks -> geogebra.d.b.j:
    boolean eurosym -> b
    java.lang.StringBuilder codeBeginPic -> f
    void createFrame() -> b
    void generateAllCode() -> c
    void drawLocus(geogebra.common.kernel.geos.GeoLocus) -> a
    void drawBoxPlot(geogebra.common.kernel.geos.GeoNumeric) -> g
    void drawHistogram(geogebra.common.kernel.geos.GeoNumeric) -> h
    void drawSumTrapezoidal(geogebra.common.kernel.geos.GeoNumeric) -> f
    void drawSumUpperLower(geogebra.common.kernel.geos.GeoNumeric) -> e
    void drawIntegralFunctions(geogebra.common.kernel.geos.GeoNumeric) -> d
    void drawIntegral(geogebra.common.kernel.geos.GeoNumeric) -> c
    void drawSlope(geogebra.common.kernel.geos.GeoNumeric) -> b
    void drawAngle(geogebra.common.kernel.geos.GeoAngle) -> a
    void drawArrowArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double,boolean) -> a
    void drawArc(geogebra.common.kernel.geos.GeoAngle,double[],double,double,double) -> a
    void drawTick(geogebra.common.kernel.geos.GeoAngle,double[],double) -> a
    void drawSlider(geogebra.common.kernel.geos.GeoNumeric) -> a
    void drawPolygon(geogebra.common.kernel.geos.GeoPolygon) -> a
    void drawText(geogebra.common.kernel.geos.GeoText) -> a
    void drawGeoConicPart(geogebra.common.kernel.geos.GeoConicPart) -> a
    void drawCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
    void drawFunction(geogebra.common.kernel.geos.GeoFunction) -> a
    java.lang.String killSpace(java.lang.String) -> a
    void renameFunc(java.lang.StringBuilder,java.lang.String,java.lang.String) -> a
    double maxDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    double firstDefinedValue(geogebra.common.kernel.geos.GeoFunction,double,double) -> b
    void drawGeoVector(geogebra.common.kernel.geos.GeoVector) -> a
    void drawCircle(geogebra.common.kernel.geos.GeoConic) -> b
    void drawGeoConic(geogebra.common.kernel.geos.GeoConic) -> a
    void drawGeoPoint(geogebra.common.kernel.geos.GeoPoint2) -> a
    void drawGeoLine(geogebra.common.kernel.geos.GeoLine) -> a
    void drawGeoSegment(geogebra.common.kernel.geos.GeoSegment) -> a
    void drawLine(double,double,double,double,geogebra.common.kernel.geos.GeoElement) -> a
    void drawGeoRay(geogebra.common.kernel.geos.GeoRay) -> a
    void initUnitAndVariable() -> e
    void drawLabel(geogebra.common.kernel.geos.GeoElement,geogebra.common.euclidian.DrawableND) -> a
    void drawGrid() -> f
    void drawAxis() -> g
    void PointOptionCode(geogebra.common.kernel.geos.GeoPoint2) -> b
    java.lang.String LineOptionCode(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void LinestyleCode(int,java.lang.StringBuilder) -> a
    void ColorCode(geogebra.common.awt.Color,java.lang.StringBuilder) -> a
    void addText(java.lang.String,boolean,int,int,geogebra.awt.Color) -> a
    void drawImplicitPoly(geogebra.common.kernel.implicit.GeoImplicitPoly) -> a
    void drawPolyLine(geogebra.common.kernel.geos.GeoPolyLine) -> a
    void drawGeoInequalities(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
geogebra.export.pstricks.PgfFrame -> geogebra.d.b.k:
    java.lang.String[] format -> a
    javax.swing.JCheckBox forceGnuplot -> h
    void initGui() -> a
    boolean getGnuplot() -> k
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
geogebra.export.pstricks.PstricksFrame -> geogebra.d.b.l:
    java.lang.String[] format -> a
    void initGui() -> a
    boolean isBeamer() -> a
    boolean isLaTeX() -> b
    boolean isConTeXt() -> c
geogebra.export.pstricks.TextValue -> geogebra.d.b.m:
    boolean ALLOW_NEGATIVE -> a
    javax.swing.JFrame jf -> a
    java.lang.String actionCommand -> a
    double getValue() -> a
    void setValue(double) -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    java.lang.String toString() -> toString
geogebra.factories.AwtFactory -> geogebra.e.a:
    geogebra.common.awt.Color newColor(int) -> a
    geogebra.common.awt.Color newColor(int,int,int) -> a
    geogebra.common.awt.Color newColor(int,int,int,int) -> a
    geogebra.common.awt.Color newColor(float,float,float,float) -> a
    geogebra.common.awt.Color newColor(float,float,float) -> a
    geogebra.common.awt.AffineTransform newAffineTransform() -> a
    geogebra.common.awt.Rectangle2D newRectangle2D() -> a
    geogebra.common.awt.Rectangle newRectangle(int,int,int,int) -> a
    geogebra.common.awt.BufferedImage newBufferedImage(int,int,int) -> a
    geogebra.common.awt.Dimension newDimension(int,int) -> a
    geogebra.common.awt.Point2D newPoint2D() -> a
    geogebra.common.awt.Point2D newPoint2D(double,double) -> a
    geogebra.common.awt.Rectangle newRectangle(int,int) -> a
    geogebra.common.awt.GeneralPath newGeneralPath() -> a
    geogebra.common.awt.BasicStroke newMyBasicStroke(float) -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float,int,int,float,float[],float) -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float) -> b
    geogebra.common.awt.BasicStroke newBasicStrokeJoinMitre(float) -> c
    geogebra.common.awt.Line2D newLine2D() -> a
    geogebra.common.awt.Rectangle newRectangle(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Rectangle newRectangle() -> a
    geogebra.awt.Ellipse2DDouble newEllipse2DDouble() -> a
    geogebra.common.awt.Ellipse2DFloat newEllipse2DFloat(int,int,int,int) -> a
    geogebra.common.awt.Arc2D newArc2D() -> a
    geogebra.common.awt.Area newArea() -> a
    geogebra.common.awt.Area newArea(geogebra.common.awt.Shape) -> a
    geogebra.common.awt.GeneralPath newGeneralPath(int) -> a
    geogebra.common.awt.CubicCurve2D newCubicCurve2D() -> a
    geogebra.common.awt.BasicStroke newBasicStroke(float,int,int) -> a
    geogebra.common.awt.font.TextLayout newTextLayout(java.lang.String,geogebra.common.awt.Font,geogebra.common.awt.FontRenderContext) -> a
    geogebra.common.awt.AlphaComposite newAlphaComposite(int,float) -> a
    geogebra.common.awt.GradientPaint newGradientPaint(int,int,geogebra.common.awt.Color,int,int,geogebra.common.awt.Color) -> a
    geogebra.common.euclidian.event.FocusListener newFocusListener(java.lang.Object) -> a
    geogebra.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
    geogebra.common.euclidian.event.KeyListener newKeyListener(java.lang.Object) -> a
    geogebra.common.awt.Ellipse2DDouble newEllipse2DDouble() -> a
geogebra.factories.CASFactory -> geogebra.e.b:
    geogebra.common.cas.mpreduce.AbstractCASmpreduce newMPReduce(geogebra.common.cas.CASparser,geogebra.common.cas.CasParserTools,geogebra.common.kernel.Kernel) -> a
geogebra.factories.FormatFactory -> geogebra.e.c:
    geogebra.common.util.ScientificFormatAdapter getScientificFormat(int,int,boolean) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(int) -> a
    geogebra.common.util.NumberFormatAdapter getNumberFormat(java.lang.String,int) -> a
geogebra.factories.LaTeXFactory -> geogebra.e.d:
    geogebra.common.util.LaTeXCache newLaTeXCache() -> a
geogebra.factories.SwingFactory -> geogebra.e.e:
    geogebra.common.gui.inputfield.AutoCompleteTextField newAutoCompleteTextField(int,geogebra.common.main.AbstractApplication,geogebra.common.euclidian.Drawable) -> a
    geogebra.common.javax.swing.JLabel newJLabel(java.lang.String) -> a
    geogebra.common.javax.swing.Box createHorizontalBox() -> a
geogebra.factories.UtilFactory -> geogebra.e.f:
    geogebra.common.util.HttpRequest newHttpRequest() -> a
    geogebra.common.util.URLEncoder newURLEncoder() -> a
geogebra.gui.AngleTextField -> geogebra.gui.a:
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.ContextMenuGeoElement -> geogebra.gui.b:
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    java.util.ArrayList geos -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.main.Application app -> a
    void addPointItems() -> a
    void addLineItems() -> b
    void addVectorItems() -> c
    void addConicItems() -> d
    void addUserInputItem() -> e
    void addNumberItems() -> f
    void addTextItems() -> g
    void addPlaneItems() -> h
    void addViewForValueStringItems() -> i
    void addForAllItems() -> j
    void addAction(javax.swing.Action) -> a
    void addItem(javax.swing.JMenuItem) -> a
    void setTitle(java.lang.String) -> a
    void setMenuShortCutAccelerator(javax.swing.JMenuItem,char) -> a
geogebra.gui.ContextMenuGeoElement$1 -> geogebra.gui.c:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$10 -> geogebra.gui.d:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$11 -> geogebra.gui.e:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    geogebra.common.kernel.geos.GeoUserInputElement val$inputElement -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$12 -> geogebra.gui.f:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    geogebra.common.kernel.geos.GeoUserInputElement val$inputElement -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$13 -> geogebra.gui.g:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$14 -> geogebra.gui.h:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    geogebra.common.kernel.kernelND.ViewCreator val$plane -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$15 -> geogebra.gui.i:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$16 -> geogebra.gui.j:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$17 -> geogebra.gui.k:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$18 -> geogebra.gui.l:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$19 -> geogebra.gui.m:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$2 -> geogebra.gui.n:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$20 -> geogebra.gui.o:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$21 -> geogebra.gui.p:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$22 -> geogebra.gui.q:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$23 -> geogebra.gui.r:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    geogebra.common.kernel.geos.GeoNumeric val$num -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$24 -> geogebra.gui.s:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$25 -> geogebra.gui.t:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$26 -> geogebra.gui.u:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$27 -> geogebra.gui.v:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$28 -> geogebra.gui.w:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$29 -> geogebra.gui.x:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.ContextMenuGeoElement$3 -> geogebra.gui.y:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$4 -> geogebra.gui.z:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$5 -> geogebra.gui.A:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$6 -> geogebra.gui.B:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$7 -> geogebra.gui.C:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$8 -> geogebra.gui.D:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGeoElement$9 -> geogebra.gui.E:
    geogebra.gui.ContextMenuGeoElement this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGraphicsWindow -> geogebra.gui.F:
    double px -> a
    double py -> b
    double[] zoomFactors -> a
    double[] axesRatios -> b
    javax.swing.ImageIcon iconZoom -> a
    void addMiProperties() -> a
    void addAxesAndGridCheckBoxes() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void showOptionsDialog() -> c
    void addZoomItems(javax.swing.JMenu) -> a
    void addAxesRatioItems(javax.swing.JMenu) -> b
    void zoom(double) -> a
    void zoomYaxis(double) -> b
    void access$0(geogebra.gui.ContextMenuGraphicsWindow,double) -> a
    void access$1(geogebra.gui.ContextMenuGraphicsWindow,double) -> b
geogebra.gui.ContextMenuGraphicsWindow$1 -> geogebra.gui.G:
    geogebra.gui.ContextMenuGraphicsWindow this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ContextMenuGraphicsWindow$2 -> geogebra.gui.H:
    geogebra.gui.ContextMenuGraphicsWindow this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane -> geogebra.gui.I:
    geogebra.main.Application app -> a
    geogebra.gui.DynamicTextInputPane thisPane -> a
    javax.swing.text.DefaultStyledDocument doc -> a
    java.lang.StringBuilder sb -> a
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String,geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String,int,geogebra.gui.dialog.TextInputDialog) -> a
    java.lang.String buildGeoGebraString(boolean) -> a
    void setText(geogebra.common.kernel.geos.GeoText,geogebra.gui.dialog.TextInputDialog) -> a
    void splitString(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.gui.dialog.TextInputDialog) -> a
    void insertString(int,java.lang.String,javax.swing.text.AttributeSet) -> a
    geogebra.gui.DynamicTextInputPane access$0(geogebra.gui.DynamicTextInputPane) -> a
    geogebra.main.Application access$1(geogebra.gui.DynamicTextInputPane) -> a
geogebra.gui.DynamicTextInputPane$DynamicTextField -> geogebra.gui.I$a:
    int mode -> a
    geogebra.gui.dialog.TextInputDialog id -> a
    javax.swing.JPopupMenu contextMenu -> a
    geogebra.gui.DynamicTextInputPane this$0 -> a
    java.awt.Dimension getMaximumSize() -> getMaximumSize
    int getMode() -> a
    void setMode(int) -> a
    void createContextMenu() -> b
    geogebra.gui.dialog.TextInputDialog access$0(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    void access$1(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    javax.swing.JPopupMenu access$2(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
    void access$3(geogebra.gui.DynamicTextInputPane$DynamicTextField,int) -> a
    geogebra.gui.DynamicTextInputPane access$4(geogebra.gui.DynamicTextInputPane$DynamicTextField) -> a
geogebra.gui.DynamicTextInputPane$DynamicTextField$1 -> geogebra.gui.J:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.gui.DynamicTextInputPane$DynamicTextField$2 -> geogebra.gui.K:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
geogebra.gui.DynamicTextInputPane$DynamicTextField$3 -> geogebra.gui.L:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane$DynamicTextField$4 -> geogebra.gui.M:
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.DynamicTextInputPane$DynamicTextField$MyKeyListener -> geogebra.gui.I$a$a:
    geogebra.gui.DynamicTextInputPane$DynamicTextField tf -> b
    geogebra.gui.DynamicTextInputPane$DynamicTextField this$1 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.FileDropTargetListener -> geogebra.gui.N:
    java.awt.datatransfer.DataFlavor urlFlavor -> a
    geogebra.main.Application app -> a
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    boolean handleFileDrop(java.awt.datatransfer.Transferable) -> a
    boolean isGGBFile(java.lang.String) -> a
    boolean isGGTFile(java.lang.String) -> b
    java.util.ArrayList getGGBfiles(java.awt.datatransfer.Transferable) -> a
geogebra.gui.GeoGebraKeys -> geogebra.gui.O:
    java.lang.StringBuilder altCodes -> a
    boolean altPressed -> a
    geogebra.main.Application app -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.GeoTreeCellRenderer -> geogebra.gui.P:
    geogebra.main.Application app -> a
    javax.swing.ImageIcon iconShown -> a
    javax.swing.ImageIcon iconHidden -> b
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
geogebra.gui.GuiManager -> geogebra.gui.Q:
    boolean USE_COMPRESSED_VIEW -> a
    int CV_UPDATES_PER_SECOND -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.DialogManagerDesktop dialogManager -> a
    geogebra.gui.dialog.DialogManagerDesktop$Factory dialogManagerFactory -> a
    geogebra.gui.inputbar.AlgebraInput algebraInput -> a
    geogebra.gui.view.algebra.AlgebraController algebraController -> a
    geogebra.gui.view.algebra.AlgebraView algebraView -> a
    geogebra.cas.view.CASView casView -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView spreadsheetView -> a
    geogebra.euclidian.EuclidianView euclidianView2 -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView constructionProtocolView -> a
    geogebra.gui.view.assignment.AssignmentView assignmentView -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation constProtocolNavigation -> a
    geogebra.gui.menubar.GeoGebraMenuBar menuBar -> a
    geogebra.gui.toolbar.ToolbarContainer toolbarPanel -> a
    java.lang.String strCustomToolbarDefinition -> a
    boolean htmlLoaded -> b
    geogebra.gui.layout.Layout layout -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalculator -> a
    java.awt.datatransfer.DataFlavor urlFlavor -> a
    java.awt.datatransfer.DataFlavor uriListFlavor -> b
    javax.swing.AbstractAction showAxesAction -> a
    javax.swing.AbstractAction showGridAction -> b
    javax.swing.AbstractAction undoAction -> c
    javax.swing.AbstractAction redoAction -> d
    geogebra.gui.view.properties.PropertiesView propertiesView -> a
    java.util.HashMap plotPanelIDMap -> a
    int lastUsedPlotPanelID -> b
    geogebra.gui.ContextMenuGraphicsWindow drawingPadpopupMenu -> a
    geogebra.gui.ContextMenuGeoElement popupMenu -> a
    geogebra.common.gui.VirtualKeyboardListener currentKeyboardListener -> a
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard kb -> a
    geogebra.gui.virtualkeyboard.VirtualKeyboard virtualKeyboard -> a
    java.util.ArrayList recentSymbolList -> a
    geogebra.gui.inputbar.InputBarHelpPanel inputHelpPanel -> a
    int[] $SWITCH_TABLE$geogebra$gui$GuiManager$Help -> a
    void initialize() -> i
    void updateLayout() -> j
    void initLayoutPanels() -> k
    geogebra.gui.layout.panels.EuclidianDockPanel newEuclidianDockPanel() -> a
    geogebra.gui.layout.panels.Euclidian2DockPanel newEuclidian2DockPanel() -> a
    boolean isPropertiesDialogSelectionListener() -> d
    boolean isInputFieldSelectionListener() -> c
    geogebra.cas.view.CASView getCasView() -> a
    geogebra.gui.view.algebra.AlgebraView getAlgebraView() -> a
    geogebra.gui.view.properties.PropertiesView getPropertiesView() -> a
    geogebra.gui.view.algebra.AlgebraView newAlgebraView(geogebra.gui.view.algebra.AlgebraController) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView getConstructionProtocolView() -> a
    geogebra.common.kernel.View getConstructionProtocolData() -> a
    geogebra.gui.view.assignment.AssignmentView getAssignmentView() -> a
    void startEditing(geogebra.common.kernel.geos.GeoElement) -> d
    void setScrollToShow(boolean) -> b
    void resetSpreadsheet() -> l
    boolean hasSpreadsheetView() -> e
    boolean hasAlgebraView() -> a
    boolean hasProbabilityCalculator() -> f
    geogebra.gui.view.probcalculator.ProbabilityCalculator getProbabilityCalculator() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView getSpreadsheetView() -> a
    void updateSpreadsheetColumnWidths() -> f
    void addSpreadsheetTrace(geogebra.common.kernel.geos.GeoElement) -> b
    void removeSpreadsheetTrace(geogebra.common.kernel.geos.GeoElement) -> a
    void resetTraceColumn(geogebra.common.kernel.geos.GeoElement) -> e
    void traceToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> f
    void getSpreadsheetViewXML(java.lang.StringBuilder,boolean) -> a
    void getConsProtocolXML(java.lang.StringBuilder) -> a
    void getProbabilityCalculatorXML(java.lang.StringBuilder) -> b
    java.util.HashMap getPlotPanelIDMap() -> a
    int assignPlotPanelID(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView) -> a
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView getPlotPanelView(int) -> a
    geogebra.euclidian.EuclidianView getEuclidianView2() -> a
    geogebra.euclidian.EuclidianView newEuclidianView(boolean[],boolean,int) -> a
    boolean hasEuclidianView2() -> g
    boolean hasEuclidianView2EitherShowingOrNot() -> h
    geogebra.euclidianND.EuclidianViewND getActiveEuclidianView() -> a
    void attachView(int) -> b
    void detachView(int) -> c
    void attachSpreadsheetView() -> d
    void detachSpreadsheetView() -> m
    void attachAlgebraView() -> n
    void detachAlgebraView() -> o
    void attachCasView() -> p
    void detachCasView() -> q
    void attachConstructionProtocolView() -> r
    void detachConstructionProtocolView() -> s
    void attachProbabilityCalculatorView() -> t
    void detachProbabilityCalculatorView() -> u
    void attachAssignmentView() -> v
    void detachAssignmentView() -> w
    void attachPropertiesView() -> x
    void setShowAuxiliaryObjects(boolean) -> a
    void initAlgebraController() -> N
    javax.swing.JComponent getAlgebraInput() -> a
    geogebra.common.javax.swing.JTextComponent getAlgebraInputTextField() -> a
    geogebra.gui.dialog.DialogManagerDesktop getDialogManager() -> a
    void doAfterRedefine(geogebra.common.kernel.geos.GeoElement) -> c
    void setLayout(geogebra.gui.layout.Layout) -> a
    geogebra.gui.layout.Layout getLayout() -> a
    java.awt.Container getToolbarPanelContainer() -> a
    geogebra.gui.toolbar.ToolbarContainer getToolbarPanel() -> a
    void updateToolbar() -> y
    void setShowView(boolean,int) -> a
    void setShowView(boolean,int,boolean) -> a
    boolean showView(int) -> a
    void setShowToolBarHelp(boolean) -> c
    javax.swing.JComponent getConstructionProtocolNavigation() -> b
    void setShowConstructionProtocolNavigation(boolean) -> d
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    boolean isConsProtNavigationPlayButtonVisible() -> i
    boolean isConsProtNavigationProtButtonVisible() -> j
    void updateConstructionProtocol() -> g
    boolean isUsingConstructionProtocol() -> b
    int getToolBarHeight() -> a
    java.lang.String getDefaultToolbarString() -> a
    void updateFonts() -> c
    void setLabels() -> z
    void initMenubar() -> A
    void updateMenubar() -> a
    void updateMenubarSelection() -> b
    void updateMenuWindow() -> B
    void updateMenuFile() -> C
    javax.swing.JMenuBar getMenuBar() -> a
    void showAboutDialog() -> D
    void showPrintPreview() -> E
    void showDrawingPadPopup(java.awt.Component,geogebra.common.awt.Point) -> a
    void toggleDrawingPadPopup(java.awt.Component,java.awt.Point) -> a
    void showPopupMenu(java.util.ArrayList,java.awt.Component,geogebra.common.awt.Point) -> a
    void togglePopupMenu(java.util.ArrayList,java.awt.Component,java.awt.Point) -> a
    boolean loadImage(geogebra.common.kernel.geos.GeoPoint2,java.awt.datatransfer.Transferable,boolean) -> a
    java.awt.Color showColorChooser(geogebra.common.awt.Color) -> a
    java.lang.String[] getImageFromTransferable(java.awt.datatransfer.Transferable) -> a
    java.lang.String getImageFromFile() -> b
    java.lang.String getImageFromFile(java.io.File) -> a
    java.io.File getDataFile() -> a
    boolean saveCurrentFile() -> k
    boolean save() -> l
    boolean saveAs() -> m
    java.io.File showSaveDialog(java.lang.String,java.io.File,java.lang.String,boolean,boolean) -> a
    java.io.File showSaveDialog(java.lang.String[],java.io.File,java.lang.String[],boolean,boolean) -> a
    java.io.File addExtension(java.io.File,java.lang.String) -> a
    java.io.File removeExtension(java.io.File) -> a
    void openURL() -> F
    void openFile() -> G
    void doOpenFiles(java.io.File[],boolean) -> a
    void doOpenFiles(java.io.File[],boolean,java.lang.String) -> a
    void allowGUIToRefresh() -> H
    boolean handleGGBFileDrop(java.awt.datatransfer.Transferable) -> a
    boolean loadFile(java.io.File,boolean) -> a
    boolean loadURL(java.lang.String) -> a
    boolean loadURL(java.lang.String,boolean) -> a
    java.net.URL getEscapedUrl(java.lang.String) -> a
    boolean loadFromHtml(java.net.URL) -> a
    java.lang.String getAttributeValue(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String getAttributeValue(java.lang.String,int,char[]) -> a
    boolean isMarker(char[],char) -> a
    java.lang.String fetchPage(java.net.URL) -> a
    boolean loadBase64File(java.io.File) -> a
    void updateGUIafterLoadFile(boolean,boolean) -> a
    boolean initActions() -> n
    void updateActions() -> e
    void redo() -> I
    void undo() -> J
    int getMenuBarHeight() -> b
    int getAlgebraInputHeight() -> c
    javax.swing.AbstractAction getShowAxesAction() -> a
    javax.swing.AbstractAction getShowGridAction() -> b
    geogebra.gui.toolbar.Toolbar getGeneralToolbar() -> a
    void setToolBarDefinition(java.lang.String) -> a
    java.lang.String getToolbarDefinition() -> c
    void removeFromToolbarDefinition(int) -> d
    void addToToolbarDefinition(int) -> e
    void showURLinBrowser(java.net.URL) -> a
    void openCommandHelp(java.lang.String) -> b
    void openHelp(java.lang.String) -> c
    void openToolHelp(java.lang.String) -> d
    void openHelp(java.lang.String,geogebra.gui.GuiManager$Help) -> a
    void showURLinBrowser(java.lang.String) -> e
    java.net.URL getHelpURL(geogebra.gui.GuiManager$Help,java.lang.String) -> a
    java.lang.String getCreatedWithHTML(boolean) -> a
    void setMode(int) -> a
    int setToolbarMode(int) -> a
    javax.swing.AbstractAction getRedoAction() -> c
    javax.swing.AbstractAction getUndoAction() -> d
    void updateFrameSize() -> K
    void updateFrameTitle() -> L
    javax.swing.JFrame createFrame() -> a
    void exitAll() -> M
    void setCurrentTextfield(geogebra.common.gui.VirtualKeyboardListener,boolean) -> a
    void insertStringIntoTextfield(java.lang.String,boolean,boolean,boolean) -> a
    void toggleKeyboard(boolean) -> e
    geogebra.gui.virtualkeyboard.VirtualKeyboard getVirtualKeyboard() -> a
    boolean showVirtualKeyboard() -> o
    boolean noMenusOpen() -> p
    java.util.ArrayList getRecentSymbolList() -> a
    void setFontRecursive(java.awt.Container,java.awt.Font) -> a
    void setLabelsRecursive(java.awt.Container) -> a
    boolean hasInputHelpPanel() -> q
    java.awt.Component getInputHelpPanel() -> a
    void setFocusedPanel(java.awt.event.MouseEvent) -> a
    void updateAlgebraInput() -> h
    void showPopupMenu(java.util.ArrayList,geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.Point) -> a
    void setFocusedPanel(geogebra.common.euclidian.event.AbstractEvent) -> a
    void loadImage(geogebra.common.kernel.geos.GeoPoint2,java.lang.Object,boolean) -> a
    void showDrawingPadPopup(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.Point) -> a
    geogebra.common.kernel.View getSpreadsheetView() -> c
    geogebra.common.kernel.View getPlotPanelView(int) -> a
    geogebra.common.kernel.View getProbabilityCalculator() -> d
    geogebra.common.kernel.View getCasView() -> b
    int[] $SWITCH_TABLE$geogebra$gui$GuiManager$Help() -> a
geogebra.gui.GuiManager$1 -> geogebra.gui.R:
    geogebra.gui.GuiManager this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManager$2 -> geogebra.gui.S:
    geogebra.gui.GuiManager this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManager$3 -> geogebra.gui.T:
    geogebra.gui.GuiManager this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManager$4 -> geogebra.gui.U:
    geogebra.gui.GuiManager this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.GuiManager$Help -> geogebra.gui.Q$a:
    geogebra.gui.GuiManager$Help COMMAND -> a
    geogebra.gui.GuiManager$Help TOOL -> b
    geogebra.gui.GuiManager$Help GENERIC -> c
    geogebra.gui.GuiManager$Help[] ENUM$VALUES -> a
    geogebra.gui.GuiManager$Help[] values() -> values
    geogebra.gui.GuiManager$Help valueOf(java.lang.String) -> valueOf
geogebra.gui.ImageResizer -> geogebra.gui.V:
    java.awt.image.BufferedImage resizeImage(java.awt.image.BufferedImage,int,int) -> a
geogebra.gui.InputHandler -> geogebra.gui.W:
    boolean processInput(java.lang.String) -> a
geogebra.gui.MySmallJButton -> geogebra.gui.X:
    void setSmallSize(int,int) -> a
geogebra.gui.NumberComboBox -> geogebra.gui.Y:
    geogebra.common.util.NumberFormatAdapter nf -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setValue(double) -> a
    double getValue() -> a
geogebra.gui.TitlePanel -> geogebra.gui.Z:
    javax.swing.JTextField titleField -> a
    javax.swing.JTextField authorField -> b
    javax.swing.JFormattedTextField dateField -> a
    java.util.ArrayList listeners -> a
    geogebra.common.kernel.Construction cons -> a
    void updateData() -> a
    java.lang.String configureDate(java.lang.String) -> a
    java.lang.String loadAuthor() -> a
    boolean saveAuthor(java.lang.String) -> a
    void fireTextFieldUpdate(javax.swing.JTextField) -> a
    void addActionListener(java.awt.event.ActionListener) -> a
    void notifyListeners() -> b
    void access$0(geogebra.gui.TitlePanel,javax.swing.JTextField) -> a
geogebra.gui.TitlePanel$1 -> geogebra.gui.aa:
    geogebra.gui.TitlePanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.TitlePanel$2 -> geogebra.gui.ab:
    geogebra.gui.TitlePanel this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.ToolNameIconPanel -> geogebra.gui.ac:
    javax.swing.JTextField tfCmdName -> a
    javax.swing.JTextField tfToolHelp -> b
    javax.swing.JTextField tfToolName -> c
    javax.swing.JCheckBox cbShowInToolBar -> a
    javax.swing.JLabel labelIcon -> a
    java.lang.String iconFileName -> a
    javax.swing.JButton btIconFile -> a
    geogebra.main.Application app -> a
    boolean editHappens -> a
    geogebra.gui.dialog.ToolManagerDialog managerDialog -> a
    geogebra.common.kernel.Macro macro -> a
    void updateMacro() -> a
    void setFromMacro(geogebra.common.kernel.Macro) -> a
    void init(geogebra.gui.dialog.ToolManagerDialog,geogebra.common.kernel.Macro) -> a
    void requestFocus() -> requestFocus
    java.lang.String getCommandName() -> a
    java.lang.String getToolName() -> b
    void setToolName(java.lang.String) -> a
    java.lang.String getToolHelp() -> c
    void setToolHelp(java.lang.String) -> b
    boolean showInToolBar() -> a
    void setIconFileName(java.lang.String) -> c
    java.lang.String getIconFileName() -> d
    void updateCmdName(java.lang.Object) -> a
    java.lang.String defaultToolName() -> e
    void access$0(geogebra.gui.ToolNameIconPanel,java.lang.Object) -> a
    javax.swing.JCheckBox access$1(geogebra.gui.ToolNameIconPanel) -> a
    javax.swing.JLabel access$2(geogebra.gui.ToolNameIconPanel) -> a
    javax.swing.JButton access$3(geogebra.gui.ToolNameIconPanel) -> a
    void access$4(geogebra.gui.ToolNameIconPanel) -> a
    boolean access$5(geogebra.gui.ToolNameIconPanel) -> a
geogebra.gui.ToolNameIconPanel$1 -> geogebra.gui.ad:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.gui.ToolNameIconPanel$2 -> geogebra.gui.ae:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.ToolNameIconPanel$3 -> geogebra.gui.af:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    geogebra.main.Application val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.ToolNameIconPanel$4 -> geogebra.gui.ag:
    geogebra.gui.ToolNameIconPanel this$0 -> a
    geogebra.main.Application val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.app.GeoGebraFrame -> geogebra.gui.a.a:
    java.util.ArrayList instances -> a
    geogebra.gui.app.GeoGebraFrame activeInstance -> a
    geogebra.gui.FileDropTargetListener dropTargetListener -> a
    geogebra.main.Application app -> a
    void dispose() -> dispose
    geogebra.main.Application getApplication() -> a
    void setApplication(geogebra.main.Application) -> a
    int getInstanceNumber() -> a
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    java.util.Locale getLocale() -> getLocale
    void setVisible(boolean) -> setVisible
    void updateSize() -> a
    void main(geogebra.CommandLineArguments) -> a
    void init(geogebra.CommandLineArguments,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.gui.app.GeoGebraFrame getActiveInstance() -> a
    void initMacSpecifics() -> b
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.main.Application createApplication(geogebra.CommandLineArguments,javax.swing.JFrame) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.common.kernel.Macro) -> a
    geogebra.gui.app.GeoGebraFrame createNewWindow(geogebra.CommandLineArguments,geogebra.common.kernel.Macro,geogebra.gui.app.GeoGebraFrame) -> a
    geogebra.gui.app.GeoGebraFrame$AppThread createAppThread(geogebra.main.Application) -> a
    java.lang.Long versionToLong(java.lang.String) -> a
    int getInstanceCount() -> b
    java.util.ArrayList getInstances() -> a
    geogebra.gui.app.GeoGebraFrame getInstance(int) -> a
    void updateAllTitles() -> c
    geogebra.gui.app.GeoGebraFrame getInstanceWithFile(java.io.File) -> a
    boolean isIconified() -> a
    geogebra.gui.FileDropTargetListener getDropTargetListener() -> a
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void checkCommandLineExport(geogebra.main.Application) -> b
geogebra.gui.app.GeoGebraFrame$1 -> geogebra.gui.a.b:
    geogebra.main.Application val$app -> a
    int val$dpi -> a
    java.lang.String val$filename -> a
    java.lang.String val$extension -> b
    void run() -> run
geogebra.gui.app.GeoGebraFrame$AppThread -> geogebra.gui.a.a$a:
    geogebra.main.Application app -> a
    geogebra.gui.app.GeoGebraFrame this$0 -> a
    void run() -> run
    void checkVersion() -> a
geogebra.gui.app.GeoGebraFrame3D -> geogebra.gui.a.c:
    void main(geogebra.CommandLineArguments) -> a
    geogebra.main.Application createApplication(geogebra.CommandLineArguments,javax.swing.JFrame) -> a
geogebra.gui.app.MacApplicationListener -> geogebra.gui.a.d:
    void initMacApplicationListener() -> a
    geogebra.gui.app.GeoGebraFrame getGGBInstance() -> a
    void handleQuit(com.apple.eawt.ApplicationEvent) -> handleQuit
    void handleAbout(com.apple.eawt.ApplicationEvent) -> handleAbout
    void handleOpenFile(com.apple.eawt.ApplicationEvent) -> handleOpenFile
    void handlePrintFile(com.apple.eawt.ApplicationEvent) -> handlePrintFile
    void handleOpenApplication(com.apple.eawt.ApplicationEvent) -> handleOpenApplication
    void handlePreferences(com.apple.eawt.ApplicationEvent) -> handlePreferences
    void handleReOpenApplication(com.apple.eawt.ApplicationEvent) -> handleReOpenApplication
geogebra.gui.app.MyFileFilter -> geogebra.gui.a.e:
    java.util.ArrayList filters -> a
    java.lang.String description -> a
    java.lang.String fullDescription -> b
    boolean useExtensionsInDescription -> a
    boolean accept(java.io.File) -> accept
    java.lang.String getExtension(java.io.File) -> a
    void addExtension(java.lang.String) -> a
    java.lang.String toString() -> toString
    java.lang.String getDescription() -> getDescription
    void setDescription(java.lang.String) -> b
    boolean isExtensionListInDescription() -> a
    java.lang.String getExtension() -> a
geogebra.gui.autocompletion.AutoCompletion -> geogebra.gui.b.a:
    geogebra.gui.autocompletion.FileChooserCompletionListCellRenderer FC_CELL_RENDERER -> a
    boolean caseInsensitivePaths -> a
    boolean initCaseInsenitvePaths() -> a
    void install(javax.swing.JFileChooser,boolean) -> a
    java.lang.String fileToString(java.io.File) -> b
    javax.swing.JTextField getInternalTextField(java.awt.Container) -> a
    void install(javax.swing.JTextField,geogebra.gui.autocompletion.CompletionProvider,javax.swing.ListCellRenderer,int) -> a
    java.lang.String access$0(java.io.File) -> a
geogebra.gui.autocompletion.AutoCompletion$1 -> geogebra.gui.b.b:
    javax.swing.JFileChooser val$fileChooser -> a
    boolean val$caseInsensitiveCompletion -> a
    java.util.List getCompletionOptions(java.lang.String) -> a
    java.lang.String toString(java.io.File) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.AutoCompletion$1$1 -> geogebra.gui.b.c:
    geogebra.gui.autocompletion.AutoCompletion$1 this$1 -> a
    javax.swing.filechooser.FileFilter val$fileChooserFileFilter -> a
    boolean accept(java.io.File) -> accept
geogebra.gui.autocompletion.AutoCompletion$1$2 -> geogebra.gui.b.d:
    geogebra.gui.autocompletion.AutoCompletion$1 this$1 -> a
    java.lang.String toString(java.io.File) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.CommandCompletionListCellRenderer -> geogebra.gui.b.e:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.autocompletion.CompletionProvider -> geogebra.gui.b.f:
    java.util.List getCompletionOptions(java.lang.String) -> a
    java.lang.String toString(java.lang.Object) -> a
geogebra.gui.autocompletion.CompletionsPopup -> geogebra.gui.b.g:
    geogebra.gui.inputfield.AutoCompleteTextField textField -> a
    int maxPopupRowCount -> a
    javax.swing.JPopupMenu popup -> a
    geogebra.gui.autocompletion.DelegatingListModel listModel -> a
    javax.swing.JList list -> a
    javax.swing.event.DocumentListener textFieldDocListener -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    int current_length -> b
    void setFont(java.awt.Font) -> a
    void registerListeners() -> c
    void placePopup() -> a
    void showCompletions() -> b
    void showPopup() -> d
    boolean isPopupVisible() -> a
    void hidePopup() -> e
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> a
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    geogebra.gui.inputfield.AutoCompleteTextField access$0(geogebra.gui.autocompletion.CompletionsPopup) -> a
    java.awt.event.KeyListener access$1(geogebra.gui.autocompletion.CompletionsPopup) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$3(geogebra.gui.autocompletion.CompletionsPopup,java.awt.event.KeyListener[]) -> a
    int access$4(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$5(geogebra.gui.autocompletion.CompletionsPopup) -> a
    void access$6(geogebra.gui.autocompletion.CompletionsPopup,int) -> a
    void access$7(geogebra.gui.autocompletion.CompletionsPopup,java.awt.event.MouseEvent) -> a
    boolean access$8(geogebra.gui.autocompletion.CompletionsPopup) -> a
geogebra.gui.autocompletion.CompletionsPopup$1 -> geogebra.gui.b.h:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
geogebra.gui.autocompletion.CompletionsPopup$2 -> geogebra.gui.b.i:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.autocompletion.CompletionsPopup$3 -> geogebra.gui.b.j:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.autocompletion.CompletionsPopup$4 -> geogebra.gui.b.k:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.autocompletion.CompletionsPopup$5 -> geogebra.gui.b.l:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void ancestorMoved(java.awt.event.HierarchyEvent) -> ancestorMoved
geogebra.gui.autocompletion.CompletionsPopup$PopupListener -> geogebra.gui.b.g$a:
    geogebra.gui.autocompletion.CompletionsPopup this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
geogebra.gui.autocompletion.DelegatingListModel -> geogebra.gui.b.m:
    java.util.List delegate -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    void setDataList(java.util.List) -> a
geogebra.gui.autocompletion.FileChooserCompletionListCellRenderer -> geogebra.gui.b.n:
    javax.swing.Icon DIRECTORY_ICON -> a
    javax.swing.Icon UNKNOWN_FILE_ICON -> b
    java.util.Map FILE_EXT_ICONS -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    javax.swing.Icon getIcon(java.io.File) -> a
    javax.swing.Icon loadIcon(java.lang.String) -> a
geogebra.gui.autocompletion.OptionsPopup -> geogebra.gui.b.o:
    javax.swing.JTextField textField -> a
    geogebra.gui.autocompletion.CompletionProvider completionProvider -> a
    int maxPopupRowCount -> a
    javax.swing.JPopupMenu popup -> a
    geogebra.gui.autocompletion.DelegatingListModel listModel -> a
    javax.swing.JList list -> a
    javax.swing.event.DocumentListener documentListener -> a
    java.lang.String userInput -> a
    int popupRowCount -> b
    void registerListeners() -> a
    void showCompletion() -> b
    void showOptionsPopup() -> c
    void adjustPopupSize(int) -> a
    boolean isOptionsPopupVisible() -> a
    void hideOptionsPopup() -> d
    void updateText() -> e
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> b
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void access$0(geogebra.gui.autocompletion.OptionsPopup) -> a
    void access$1(geogebra.gui.autocompletion.OptionsPopup,java.awt.event.KeyEvent) -> a
    void access$2(geogebra.gui.autocompletion.OptionsPopup) -> b
    void access$3(geogebra.gui.autocompletion.OptionsPopup,java.awt.event.MouseEvent) -> a
geogebra.gui.autocompletion.OptionsPopup$1 -> geogebra.gui.b.p:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
geogebra.gui.autocompletion.OptionsPopup$2 -> geogebra.gui.b.q:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.autocompletion.OptionsPopup$3 -> geogebra.gui.b.r:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.autocompletion.OptionsPopup$4 -> geogebra.gui.b.s:
    geogebra.gui.autocompletion.OptionsPopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.autocompletion.SortedArrayCompletionProvider -> geogebra.gui.b.t:
    java.lang.Comparable[] sortedCompletionOptions -> a
    boolean caseInsensitiveCompletion -> a
    java.util.List getCompletionOptions(java.lang.String) -> a
    boolean isValidCompletionOpiton(java.lang.String,java.lang.String) -> a
geogebra.gui.color.ColorPopupMenuButton -> geogebra.gui.c.a:
    geogebra.main.Application app -> a
    int colorSetType -> a
    geogebra.common.awt.Color[] colorSet -> a
    geogebra.common.awt.Color defaultColor -> a
    java.util.HashMap lookupMap -> a
    boolean hasSlider -> b
    java.awt.Dimension iconSize -> a
    void updateColorTable() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    javax.swing.ImageIcon getButtonIcon() -> a
    int getColorIndex(java.awt.Color) -> a
    geogebra.common.awt.Color getSelectedColor() -> a
    geogebra.common.awt.Color[] getColorArray(int) -> a
    void setDefaultColor(float,geogebra.common.awt.Color) -> a
    java.lang.String[] getToolTipArray() -> a
    javax.swing.ImageIcon[] getColorSwatchIcons(geogebra.common.awt.Color[],float,java.awt.Dimension,int) -> a
    javax.swing.ImageIcon[] createDummyIcons(java.awt.Dimension) -> a
geogebra.gui.color.DefaultRGBChooserPanel -> geogebra.gui.c.b:
    boolean internalChange -> a
    javax.swing.event.ChangeListener colorChanger -> a
    javax.swing.event.ChangeListener spinnerHandler -> b
    javax.swing.JSlider R -> a
    javax.swing.JSlider G -> b
    javax.swing.JSlider B -> c
    javax.swing.JLabel redLabel -> a
    javax.swing.JLabel greenLabel -> b
    javax.swing.JLabel blueLabel -> c
    javax.swing.JSpinner RSpinner -> a
    javax.swing.JSpinner GSpinner -> b
    javax.swing.JSpinner BSpinner -> c
    geogebra.gui.color.DefaultRGBChooserPanel$MyPreviewPanel previewPanel -> a
    geogebra.main.Application app -> a
    java.lang.String getDisplayName() -> getDisplayName
    void updateChooser() -> updateChooser
    void buildChooser() -> buildChooser
    void uninstallChooserPanel(javax.swing.JColorChooser) -> uninstallChooserPanel
    void uninstallListeners() -> b
    void installListeners() -> c
    javax.swing.Icon getSmallDisplayIcon() -> getSmallDisplayIcon
    javax.swing.Icon getLargeDisplayIcon() -> getLargeDisplayIcon
    void paint(java.awt.Graphics) -> paint
    void setLabels() -> a
    void updatePreviewPanel() -> d
    boolean access$0(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSlider access$1(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSlider access$2(geogebra.gui.color.DefaultRGBChooserPanel) -> b
    javax.swing.JSlider access$3(geogebra.gui.color.DefaultRGBChooserPanel) -> c
    void access$4(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSpinner access$5(geogebra.gui.color.DefaultRGBChooserPanel) -> a
    javax.swing.JSpinner access$6(geogebra.gui.color.DefaultRGBChooserPanel) -> b
    javax.swing.JSpinner access$7(geogebra.gui.color.DefaultRGBChooserPanel) -> c
geogebra.gui.color.DefaultRGBChooserPanel$MyPreviewPanel -> geogebra.gui.c.b$a:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.color.DefaultRGBChooserPanel$SliderHandler -> geogebra.gui.c.b$b:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.color.DefaultRGBChooserPanel$SpinnerHandler -> geogebra.gui.c.b$c:
    geogebra.gui.color.DefaultRGBChooserPanel this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.color.GeoGebraColorChooser -> geogebra.gui.c.c:
    geogebra.main.Application app -> a
    boolean isNullSelection -> a
    boolean isNullSelection() -> a
    void setLabels() -> a
    boolean access$0(geogebra.gui.color.GeoGebraColorChooser) -> a
    void access$1(geogebra.gui.color.GeoGebraColorChooser,boolean) -> a
geogebra.gui.color.GeoGebraColorChooser$MyColorSelectionModel -> geogebra.gui.c.c$a:
    geogebra.gui.color.GeoGebraColorChooser this$0 -> a
    void setSelectedColor(java.awt.Color) -> setSelectedColor
geogebra.gui.color.GeoGebraColorChooserPanel -> geogebra.gui.c.d:
    geogebra.main.Application app -> a
    geogebra.gui.color.GeoGebraColorChooser enclosingChooser -> a
    geogebra.gui.color.GeoGebraColorChooserPanel myChooser -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$MainSwatchPanel mainSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$RecentSwatchPanel recentSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$PrimarySwatchPanel primarySwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$CustomSwatchPanel customSwatchPanel -> a
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchListener swatchListener -> a
    java.util.ArrayList swatchPanelList -> a
    javax.swing.JButton btnCustomColor -> a
    javax.swing.JLabel lblRecent -> a
    javax.swing.JLabel lblCustom -> b
    javax.swing.JPanel recentPanel -> a
    javax.swing.JPanel customPanel -> b
    java.lang.String getDisplayName() -> getDisplayName
    int getMnemonic() -> getMnemonic
    int getDisplayedMnemonicIndex() -> getDisplayedMnemonicIndex
    javax.swing.Icon getSmallDisplayIcon() -> getSmallDisplayIcon
    javax.swing.Icon getLargeDisplayIcon() -> getLargeDisplayIcon
    void installChooserPanel(javax.swing.JColorChooser) -> installChooserPanel
    void buildChooser() -> buildChooser
    void createGUIElements() -> b
    void uninstallChooserPanel(javax.swing.JColorChooser) -> uninstallChooserPanel
    void updateChooser() -> updateChooser
    boolean setSwatchPanelSelection(java.awt.Color) -> a
    void setLabels() -> a
    java.awt.Color access$0(geogebra.gui.color.GeoGebraColorChooserPanel) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener -> geogebra.gui.c.d$a:
    javax.swing.JColorChooser chooser -> a
    java.awt.event.ActionListener okActionListener -> a
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.color.GeoGebraColorChooserPanel access$0(geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener$1 -> geogebra.gui.c.e:
    geogebra.gui.color.GeoGebraColorChooserPanel$CustomButtonActionListener this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.color.GeoGebraColorChooserPanel$CustomSwatchPanel -> geogebra.gui.c.d$b:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initSwatchCount() -> b
    void initColors() -> c
    void addCustomColor(java.awt.Color) -> a
    boolean setSelectionFromColor(java.awt.Color) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$MainSwatchPanel -> geogebra.gui.c.d$c:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
geogebra.gui.color.GeoGebraColorChooserPanel$PrimarySwatchPanel -> geogebra.gui.c.d$d:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
geogebra.gui.color.GeoGebraColorChooserPanel$RecentSwatchPanel -> geogebra.gui.c.d$e:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void initValues() -> a
    void initColors() -> c
    void initSwatchCount() -> b
    void setMostRecentColor(java.awt.Color) -> a
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchListener -> geogebra.gui.c.d$f:
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel -> geogebra.gui.c.d$g:
    geogebra.common.awt.Color[] colors -> a
    java.awt.Dimension swatchSize -> a
    java.awt.Dimension gap -> b
    java.awt.Dimension numSwatches -> c
    java.awt.Dimension selectedSwatch -> d
    java.awt.Dimension hoverSwatch -> e
    java.awt.Dimension prevHoverSwatch -> f
    int swatchCount -> a
    java.awt.Dimension cell -> g
    geogebra.gui.color.GeoGebraColorChooserPanel this$0 -> b
    boolean isFocusTraversable() -> isFocusTraversable
    void initValues() -> a
    void initColors() -> c
    void initSwatchCount() -> b
    void updateHoverSwatch(int,int) -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    java.lang.String getToolTipText(java.awt.event.MouseEvent) -> getToolTipText
    java.awt.Color getColorForLocation(int,int) -> a
    void setCellFromLocation(int,int,java.awt.Dimension) -> a
    java.awt.Color getColorForCell(int,int) -> b
    boolean getCellForColor(java.awt.Color,java.awt.Dimension) -> a
    boolean setSelectionFromColor(java.awt.Color) -> a
    void setSelectionFromLocation(int,int) -> b
    boolean isSwatchLocation(int,int) -> a
    boolean isSwatchCell(int,int) -> b
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel$SwatchMouseListener -> geogebra.gui.c.d$g$a:
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel this$1 -> a
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel$SwatchMouseMotionListener -> geogebra.gui.c.d$g$b:
    geogebra.gui.color.GeoGebraColorChooserPanel$SwatchPanel this$1 -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.dialog.AngleInputDialog -> geogebra.gui.d.a:
    javax.swing.JRadioButton rbCounterClockWise -> a
    javax.swing.JRadioButton rbClockWise -> b
    boolean success -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ButtonDialog -> geogebra.gui.d.b:
    javax.swing.text.JTextComponent tfCaption -> a
    javax.swing.text.JTextComponent tfScript -> b
    javax.swing.JPanel btPanel -> a
    javax.swing.DefaultComboBoxModel comboModel -> a
    geogebra.common.kernel.geos.GeoElement linkedGeo -> a
    boolean textField -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JPanel optionPane -> b
    geogebra.main.Application app -> a
    geogebra.common.kernel.geos.GeoElement geoResult -> b
    geogebra.common.kernel.geos.GeoButton button -> a
    int x -> a
    int y -> b
    void createGUI() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void access$0(geogebra.gui.dialog.ButtonDialog,geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.ButtonDialog$1 -> geogebra.gui.d.c:
    geogebra.gui.dialog.ButtonDialog this$0 -> a
    javax.swing.JComboBox val$cbAdd -> a
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.dialog.CheckboxCreationDialog -> geogebra.gui.d.d:
    javax.swing.text.JTextComponent tfCaption -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel btPanel -> b
    javax.swing.DefaultListModel listModel -> a
    javax.swing.DefaultComboBoxModel comboModel -> a
    java.awt.Point location -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.geos.GeoBoolean geoBoolean -> a
    void initLists() -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void createGUI(java.lang.String) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void apply() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void setVisible(boolean) -> setVisible
    javax.swing.DefaultComboBoxModel access$0(geogebra.gui.dialog.CheckboxCreationDialog) -> a
geogebra.gui.dialog.CheckboxCreationDialog$1 -> geogebra.gui.d.e:
    geogebra.gui.dialog.CheckboxCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ColorFunctionPanel -> geogebra.gui.d.f:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfRed -> a
    javax.swing.JTextField tfGreen -> b
    javax.swing.JTextField tfBlue -> c
    javax.swing.JTextField tfAlpha -> d
    javax.swing.JButton btRemove -> a
    javax.swing.JLabel nameLabelR -> a
    javax.swing.JLabel nameLabelG -> b
    javax.swing.JLabel nameLabelB -> c
    javax.swing.JLabel nameLabelA -> d
    javax.swing.JComboBox cbColorSpace -> a
    int colorSpace -> a
    boolean allowSetComboBoxLabels -> a
    java.lang.String defaultR -> a
    java.lang.String defaultG -> b
    java.lang.String defaultB -> c
    java.lang.String defaultA -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    boolean processed -> b
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    java.lang.Object[] access$0(geogebra.gui.dialog.ColorFunctionPanel) -> a
    javax.swing.JTextField access$1(geogebra.gui.dialog.ColorFunctionPanel) -> a
    javax.swing.JTextField access$2(geogebra.gui.dialog.ColorFunctionPanel) -> b
    javax.swing.JTextField access$3(geogebra.gui.dialog.ColorFunctionPanel) -> c
    javax.swing.JTextField access$4(geogebra.gui.dialog.ColorFunctionPanel) -> d
geogebra.gui.dialog.ColorFunctionPanel$1 -> geogebra.gui.d.g:
    geogebra.gui.dialog.ColorFunctionPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.DashListRenderer -> geogebra.gui.d.h:
    java.util.HashMap dashStrokeMap -> a
    java.awt.BasicStroke dashStroke -> a
    boolean nullValue -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DecorationAngleListRenderer -> geogebra.gui.d.i:
    java.awt.geom.Line2D$Double tick -> a
    java.awt.geom.Arc2D$Double arc -> a
    java.awt.geom.GeneralPath polygon -> a
    int id -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void drawTick(double) -> a
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DecorationListRenderer -> geogebra.gui.d.j:
    int id -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
geogebra.gui.dialog.DialogManagerDesktop -> geogebra.gui.d.k:
    geogebra.gui.dialog.options.OptionsDialog optionsDialog -> a
    geogebra.gui.dialog.options.OptionsDialog$Factory optionsDialogFactory -> a
    geogebra.gui.dialog.PropertiesDialog propDialog -> a
    geogebra.gui.view.functioninspector.FunctionInspector functionInspector -> a
    geogebra.gui.dialog.TextInputDialog textInputDialog -> a
    geogebra.gui.util.GeoGebraFileChooser fileChooser -> a
    java.util.ResourceBundle rbJavaUI -> a
    java.util.Locale currentLocale -> a
    java.util.ArrayList tempGeos -> a
    void initPropertiesDialog() -> d
    void reinitPropertiesDialog() -> e
    void updateFonts() -> f
    void setLabels() -> g
    void showOptionsDialog(int) -> a
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showPropertiesDialog() -> b
    void showToolbarConfigDialog() -> c
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showRedefineDialog(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void showTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    javax.swing.JDialog createTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.Point,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String) -> a
    void showNumberInputDialogRegularPolygon(java.lang.String,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.AbstractEuclidianView) -> a
    void showNumberInputDialogRotate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    void closeAll() -> a
    void closePropertiesDialog() -> h
    boolean showSliderCreationDialog(int,int) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    void closePropertiesDialogIfNotListener() -> i
    void initFileChooser() -> j
    void updateJavaUILanguage() -> k
    geogebra.gui.dialog.PropertiesDialog getPropDialog() -> a
    geogebra.gui.util.GeoGebraFileChooser getFileChooser() -> a
    void setFileChooser(geogebra.gui.util.GeoGebraFileChooser) -> a
    void setOptionsDialogFactory(geogebra.gui.dialog.options.OptionsDialog$Factory) -> a
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    boolean confirm(java.lang.String) -> a
geogebra.gui.dialog.DialogManagerDesktop$Factory -> geogebra.gui.d.k$a:
    geogebra.gui.dialog.DialogManagerDesktop create(geogebra.main.Application) -> a
geogebra.gui.dialog.DialogManagerDesktop$FileFilterChangedListener -> geogebra.gui.d.k$b:
    geogebra.gui.dialog.DialogManagerDesktop this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.dialog.GraphicsViewLocationPanel -> geogebra.gui.d.l:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox cbGraphicsView -> a
    javax.swing.JCheckBox cbGraphicsView2 -> b
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.Application app -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.InputDialog -> geogebra.gui.d.m:
    geogebra.main.Application app -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.common.main.GeoElementSelectionListener sl -> a
    java.lang.String inputText -> a
    geogebra.gui.view.algebra.InputPanel inputPanel -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JPanel buttonsPanel -> b
    javax.swing.JPanel btPanel -> c
    javax.swing.JPanel btPanel2 -> d
    javax.swing.JLabel msgLabel -> a
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JButton btProperties -> c
    javax.swing.JButton btOK -> d
    javax.swing.JButton btHelp -> e
    java.lang.String initString -> b
    geogebra.gui.InputHandler inputHandler -> a
    javax.swing.JCheckBox checkBox -> a
    java.util.ArrayList tempArrayList -> a
    void createGUI(java.lang.String,java.lang.String,boolean,int,int,boolean,boolean,boolean,boolean,geogebra.gui.view.algebra.InputPanel$DialogType) -> a
    void loadBtPanel(boolean) -> a
    void centerOnScreen() -> a
    void showSymbolTablePopup(boolean) -> b
    void addHelpButton(java.lang.String) -> b
    javax.swing.JPanel getButtonPanel() -> a
    void setLabels(java.lang.String) -> c
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void insertString(java.lang.String) -> a
    void insertString(java.lang.String,boolean) -> a
    java.lang.String getText() -> a
    void setRelativeCaretPosition(int) -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInputHandler() -> a
    void setVisible(boolean) -> setVisible
    void setVisibleForTools(boolean) -> c
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
geogebra.gui.dialog.InputDialog$1 -> geogebra.gui.d.n:
    geogebra.gui.dialog.InputDialog this$0 -> a
    void run() -> run
geogebra.gui.dialog.InputDialog$2 -> geogebra.gui.d.o:
    geogebra.gui.dialog.InputDialog this$0 -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
geogebra.gui.dialog.InputDialogAngleFixed -> geogebra.gui.d.p:
    java.lang.String defaultRotateAngle -> c
    geogebra.common.kernel.geos.GeoPoint2 geoPoint1 -> a
    geogebra.common.kernel.geos.GeoSegment[] segments -> a
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.dialog.InputDialogCirclePointRadius -> geogebra.gui.d.q:
    geogebra.common.kernel.geos.GeoPoint2 geoPoint1 -> a
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra.gui.dialog.InputDialogDilate -> geogebra.gui.d.r:
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogOpenURL -> geogebra.gui.d.s:
    void setLabels(java.lang.String) -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
geogebra.gui.dialog.InputDialogRadius -> geogebra.gui.d.t:
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogRegularPolygon -> geogebra.gui.d.u:
    geogebra.common.kernel.geos.GeoPoint2 geoPoint1 -> a
    geogebra.common.kernel.geos.GeoPoint2 geoPoint2 -> b
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.InputDialogRotate -> geogebra.gui.d.v:
    geogebra.common.kernel.geos.GeoPoint2 geoPoint1 -> a
    geogebra.common.kernel.geos.GeoPolygon[] polys -> a
    geogebra.common.kernel.geos.GeoPoint2[] points -> a
    geogebra.common.kernel.geos.GeoElement[] selGeos -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.String defaultRotateAngle -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.dialog.InputDialogSegmentFixed -> geogebra.gui.d.w:
    geogebra.common.kernel.geos.GeoPoint2 geoPoint1 -> a
    geogebra.common.kernel.Kernel kernel -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
geogebra.gui.dialog.MyCellRenderer -> geogebra.gui.d.x:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.NamePanel -> geogebra.gui.d.y:
    geogebra.gui.inputfield.AutoCompleteTextField tfName -> a
    geogebra.gui.inputfield.AutoCompleteTextField tfDefinition -> b
    geogebra.gui.inputfield.AutoCompleteTextField tfCaption -> c
    javax.swing.JLabel nameLabel -> a
    javax.swing.JLabel defLabel -> b
    javax.swing.JLabel captionLabel -> c
    geogebra.gui.view.algebra.InputPanel inputPanelName -> a
    geogebra.gui.view.algebra.InputPanel inputPanelDef -> b
    geogebra.gui.view.algebra.InputPanel inputPanelCap -> c
    geogebra.gui.dialog.handler.RenameInputHandler nameInputHandler -> a
    geogebra.gui.dialog.handler.RedefineInputHandler defInputHandler -> a
    geogebra.common.kernel.geos.GeoElement currentGeo -> a
    geogebra.main.Application app -> a
    boolean actionPerforming -> a
    void setLabels() -> a
    void updateGUI(boolean,boolean) -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    java.lang.String getDefText(geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.NumberChangeSignInputDialog -> geogebra.gui.d.z:
    boolean changingSign -> a
    boolean processInputHandler() -> a
    void loadBtPanel(boolean) -> a
geogebra.gui.dialog.PointStyleListRenderer -> geogebra.gui.d.A:
    int pointStyle -> a
    int pointSize -> b
    java.awt.geom.Ellipse2D$Double circle -> a
    java.awt.geom.Line2D$Double line1 -> a
    java.awt.geom.Line2D$Double line2 -> b
    java.awt.geom.Line2D$Double line3 -> c
    java.awt.geom.Line2D$Double line4 -> d
    java.awt.geom.GeneralPath gp -> a
    java.awt.BasicStroke borderStroke -> a
    java.awt.BasicStroke[] crossStrokes -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void paint(java.awt.Graphics) -> paint
    void getPath() -> a
geogebra.gui.dialog.PropertiesDialog -> geogebra.gui.d.B:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesDialog$JTreeGeoElements geoTree -> a
    javax.swing.JButton closeButton -> a
    javax.swing.JButton defaultsButton -> b
    javax.swing.JButton delButton -> c
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    geogebra.gui.color.GeoGebraColorChooser colChooser -> a
    boolean firstTime -> a
    boolean viewActive -> b
    java.util.ArrayList selectionList -> a
    java.util.ArrayList tempArrayList -> b
    void initGUI() -> b
    void showSliderTab() -> c
    void setLabels() -> a
    void cancel() -> d
    void closeDialog() -> e
    void applyDefaults() -> f
    void setVisibleWithGeos(java.util.ArrayList) -> a
    void setVisible(boolean) -> setVisible
    void setViewActive(boolean) -> a
    void selectionChanged() -> g
    java.util.ArrayList updateSelectedGeos(javax.swing.tree.TreePath[]) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void deleteSelectedGeos() -> h
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    geogebra.main.Application access$0(geogebra.gui.dialog.PropertiesDialog) -> a
    geogebra.common.kernel.Kernel access$1(geogebra.gui.dialog.PropertiesDialog) -> a
    void access$2(geogebra.gui.dialog.PropertiesDialog) -> a
    void access$3(geogebra.gui.dialog.PropertiesDialog) -> b
geogebra.gui.dialog.PropertiesDialog$1 -> geogebra.gui.d.C:
    geogebra.gui.dialog.PropertiesDialog this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra.gui.dialog.PropertiesDialog$2 -> geogebra.gui.d.D:
    geogebra.gui.dialog.PropertiesDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesDialog$3 -> geogebra.gui.d.E:
    geogebra.gui.dialog.PropertiesDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesDialog$4 -> geogebra.gui.d.F:
    geogebra.gui.dialog.PropertiesDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesDialog$JTreeGeoElements -> geogebra.gui.d.B$a:
    javax.swing.tree.DefaultTreeModel treeModel -> a
    javax.swing.tree.DefaultMutableTreeNode root -> a
    java.util.HashMap typeNodesMap -> a
    geogebra.gui.dialog.PropertiesDialog this$0 -> a
    void setLabels() -> a
    void setExpandedState(javax.swing.tree.TreePath,boolean) -> setExpandedState
    void expandAll() -> e
    void collapseAll() -> f
    void setSelected(java.util.ArrayList,boolean) -> a
    void selectFirstElement() -> h
    javax.swing.tree.TreePath getGeoPath(geogebra.common.kernel.geos.GeoElement) -> a
    void clearSelection() -> clearSelection
    void clear() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void remove(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    javax.swing.tree.TreePath getTreePath(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void setMode(int) -> a
    void reset() -> d
    void clearView() -> b
    void repaintView() -> c
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    int getViewID() -> b
    javax.swing.tree.DefaultMutableTreeNode access$0(geogebra.gui.dialog.PropertiesDialog$JTreeGeoElements) -> a
    javax.swing.tree.TreePath access$1(geogebra.gui.dialog.PropertiesDialog$JTreeGeoElements,geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.PropertiesPanel -> geogebra.gui.d.G:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.color.GeoGebraColorChooser colChooser -> a
    geogebra.gui.dialog.NamePanel namePanel -> a
    geogebra.gui.dialog.PropertiesPanel$ShowObjectPanel showObjectPanel -> a
    geogebra.gui.dialog.PropertiesPanel$SelectionAllowedPanel selectionAllowed -> a
    geogebra.gui.dialog.PropertiesPanel$ShowTrimmedIntersectionLines showTrimmedIntersectionLines -> a
    geogebra.gui.dialog.PropertiesPanel$ColorPanel colorPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LabelPanel labelPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TooltipPanel tooltipPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LayerPanel layerPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CoordPanel coordPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineEqnPanel lineEqnPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ConicEqnPanel conicEqnPanel -> a
    geogebra.gui.dialog.PropertiesPanel$PointSizePanel pointSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$PointStylePanel pointStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel textOptionsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ArcSizePanel arcSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineStylePanel lineStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$LineStyleHiddenPanel lineStylePanelHidden -> a
    geogebra.gui.dialog.PropertiesPanel$DecoSegmentPanel decoSegmentPanel -> a
    geogebra.gui.dialog.PropertiesPanel$DecoAnglePanel decoAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$RightAnglePanel rightAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$FillingPanel fillingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$FadingPanel fadingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$LodPanel lodPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CheckBoxInterpolateImage checkBoxInterpolateImage -> a
    geogebra.gui.dialog.PropertiesPanel$TracePanel tracePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AnimatingPanel animatingPanel -> a
    geogebra.gui.dialog.PropertiesPanel$FixPanel fixPanel -> a
    geogebra.gui.dialog.PropertiesPanel$IneqStylePanel ineqStylePanel -> a
    geogebra.gui.dialog.PropertiesPanel$CheckBoxFixPanel checkBoxFixPanel -> a
    geogebra.gui.dialog.PropertiesPanel$AllowReflexAnglePanel allowReflexAnglePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AllowOutlyingIntersectionsPanel allowOutlyingIntersectionsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$AuxiliaryObjectPanel auxPanel -> a
    geogebra.gui.properties.AnimationStepPanel animStepPanel -> a
    geogebra.gui.dialog.TextfieldSizePanel textFieldSizePanel -> a
    geogebra.gui.properties.AnimationSpeedPanel animSpeedPanel -> a
    geogebra.gui.properties.SliderPanel sliderPanel -> a
    geogebra.gui.dialog.PropertiesPanel$SlopeTriangleSizePanel slopeTriangleSizePanel -> a
    geogebra.gui.dialog.PropertiesPanel$StartPointPanel startPointPanel -> a
    geogebra.gui.dialog.PropertiesPanel$CornerPointsPanel cornerPointsPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel textEditPanel -> a
    geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel scriptEditPanel -> a
    geogebra.gui.dialog.PropertiesPanel$BackgroundImagePanel bgImagePanel -> a
    geogebra.gui.dialog.PropertiesPanel$AbsoluteScreenLocationPanel absScreenLocPanel -> a
    geogebra.gui.dialog.ShowConditionPanel showConditionPanel -> a
    geogebra.gui.dialog.ColorFunctionPanel colorFunctionPanel -> a
    geogebra.gui.dialog.GraphicsViewLocationPanel graphicsViewLocationPanel -> a
    geogebra.gui.dialog.PropertiesPanel$TabPanel basicTab -> a
    geogebra.gui.dialog.PropertiesPanel$TabPanel colorTab -> b
    geogebra.gui.dialog.PropertiesPanel$TabPanel styleTab -> c
    geogebra.gui.dialog.PropertiesPanel$TabPanel lineStyleTab -> d
    geogebra.gui.dialog.PropertiesPanel$TabPanel sliderTab -> e
    geogebra.gui.dialog.PropertiesPanel$TabPanel textTab -> f
    geogebra.gui.dialog.PropertiesPanel$TabPanel positionTab -> g
    geogebra.gui.dialog.PropertiesPanel$TabPanel algebraTab -> h
    geogebra.gui.dialog.PropertiesPanel$TabPanel scriptTab -> i
    geogebra.gui.dialog.PropertiesPanel$TabPanel advancedTab -> j
    boolean isDefaults -> a
    javax.swing.JTabbedPane tabs -> a
    java.util.ArrayList tabPanelList -> a
    void showSliderTab() -> b
    void setSliderMinValue() -> c
    void initTabs() -> d
    void setLabels() -> a
    void updateTabs(java.lang.Object[]) -> b
    boolean updateTabPanel(geogebra.gui.dialog.PropertiesPanel$TabPanel,java.util.ArrayList,java.lang.Object[]) -> b
    void updateSelection(java.lang.Object[]) -> a
    java.lang.String replaceEqualsSigns(java.lang.String) -> a
    boolean access$0(geogebra.gui.dialog.PropertiesPanel$TabPanel,java.util.ArrayList,java.lang.Object[]) -> a
    geogebra.main.Application access$1(geogebra.gui.dialog.PropertiesPanel) -> a
    geogebra.gui.color.GeoGebraColorChooser access$2(geogebra.gui.dialog.PropertiesPanel) -> a
    geogebra.common.kernel.Kernel access$3(geogebra.gui.dialog.PropertiesPanel) -> a
    geogebra.gui.dialog.PropertiesPanel$FillingPanel access$4(geogebra.gui.dialog.PropertiesPanel) -> a
    boolean access$5(geogebra.gui.dialog.PropertiesPanel) -> a
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel access$6(geogebra.gui.dialog.PropertiesPanel) -> a
geogebra.gui.dialog.PropertiesPanel$AbsoluteScreenLocationPanel -> geogebra.gui.d.G$a:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox cbAbsScreenLoc -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$AllowOutlyingIntersectionsPanel -> geogebra.gui.d.G$b:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox outlyingIntersectionsCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$AllowReflexAnglePanel -> geogebra.gui.d.G$c:
    java.lang.Object[] geos -> a
    javax.swing.JLabel intervalLabel -> a
    javax.swing.JComboBox intervalCombo -> a
    boolean hasOrientation -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    void setComboLabels() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    int getIndex() -> a
    void setSelectedIndex(int) -> a
geogebra.gui.dialog.PropertiesPanel$AnimatingPanel -> geogebra.gui.d.G$d:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showAnimatingCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$ArcSizePanel -> geogebra.gui.d.G$e:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    void setMinValue() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$AuxiliaryObjectPanel -> geogebra.gui.d.G$f:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox auxCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$BackgroundImagePanel -> geogebra.gui.d.G$g:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox isBGimage -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$CheckBoxFixPanel -> geogebra.gui.d.G$h:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox checkboxFixCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$CheckBoxInterpolateImage -> geogebra.gui.d.G$i:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox checkbox -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$ColorPanel -> geogebra.gui.d.G$j:
    java.lang.Object[] geos -> a
    javax.swing.JLabel previewLabel -> a
    javax.swing.JLabel currentColorLabel -> b
    geogebra.gui.dialog.PropertiesPanel$ColorPanel$PreviewPanel previewPanel -> a
    javax.swing.JPanel opacityPanel -> a
    javax.swing.JPanel colorChooserContainer -> b
    javax.swing.JRadioButton rbtnForegroundColor -> a
    javax.swing.JRadioButton rbtnBackgroundColor -> b
    javax.swing.JButton btnClearBackground -> a
    javax.swing.JSlider opacitySlider -> a
    javax.swing.JPanel previewMetaPanel -> c
    boolean allFillable -> a
    boolean hasBackground -> b
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    java.lang.String getToolTipText(java.awt.Color) -> a
    void updateColor(java.awt.Color,float,boolean) -> a
    void clearBackgroundColor() -> b
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.dialog.PropertiesPanel access$0(geogebra.gui.dialog.PropertiesPanel$ColorPanel) -> a
geogebra.gui.dialog.PropertiesPanel$ColorPanel$PreviewPanel -> geogebra.gui.d.G$j$a:
    java.awt.Color alphaFillColor -> a
    geogebra.gui.dialog.PropertiesPanel$ColorPanel this$1 -> a
    void setPreview(java.awt.Color,float) -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.dialog.PropertiesPanel$ConicEqnPanel -> geogebra.gui.d.G$k:
    java.lang.Object[] geos -> a
    javax.swing.DefaultComboBoxModel eqnCBmodel -> a
    javax.swing.JComboBox eqnCB -> a
    javax.swing.JLabel eqnLabel -> a
    int implicitIndex -> a
    int explicitIndex -> b
    int specificIndex -> c
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$CoordPanel -> geogebra.gui.d.G$l:
    java.lang.Object[] geos -> a
    javax.swing.JLabel coordLabel -> a
    javax.swing.JComboBox coordCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$CornerPointsPanel -> geogebra.gui.d.G$m:
    java.lang.Object[] geos -> a
    javax.swing.JLabel[] labelLocation -> a
    javax.swing.JComboBox[] cbLocation -> a
    javax.swing.DefaultComboBoxModel[] cbModel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.PropertiesPanel$DecoAnglePanel -> geogebra.gui.d.G$n:
    javax.swing.JComboBox decoCombo -> a
    javax.swing.JLabel decoLabel -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$DecoSegmentPanel -> geogebra.gui.d.G$o:
    javax.swing.JComboBox decoCombo -> a
    javax.swing.JLabel decoLabel -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$FadingPanel -> geogebra.gui.d.G$p:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$FillingPanel -> geogebra.gui.d.G$q:
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel$FillingPanel fillingPanel -> a
    javax.swing.JSlider fillingSlider -> a
    javax.swing.JSlider angleSlider -> b
    javax.swing.JSlider distanceSlider -> c
    javax.swing.JComboBox cbFillType -> a
    javax.swing.JCheckBox cbFillInverse -> a
    javax.swing.JPanel transparencyPanel -> a
    javax.swing.JPanel hatchFillPanel -> b
    javax.swing.JPanel imagePanel -> c
    javax.swing.JPanel anglePanel -> d
    javax.swing.JPanel distancePanel -> e
    javax.swing.JLabel lblFillType -> a
    javax.swing.JButton btnOpenFile -> a
    geogebra.gui.util.PopupMenuButton btnImage -> a
    javax.swing.JLabel lblFillInverse -> b
    boolean hasGeoButton -> a
    java.util.ArrayList imgFileNameList -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setAllEnabled(boolean) -> a
    void setLabels() -> a
    javax.swing.JPanel createImagePanel() -> a
    void updateFillTypePanel(int) -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$FixPanel -> geogebra.gui.d.G$r:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showFixCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$IneqStylePanel -> geogebra.gui.d.G$s:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showOnAxis -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$LabelPanel -> geogebra.gui.d.G$t:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showLabelCB -> a
    javax.swing.JComboBox labelModeCB -> a
    boolean showNameValueComboBox -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$LayerPanel -> geogebra.gui.d.G$u:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox layerModeCB -> a
    javax.swing.JLabel layerLabel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$LineEqnPanel -> geogebra.gui.d.G$v:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox eqnCB -> a
    javax.swing.JLabel eqnLabel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$LineStyleHiddenPanel -> geogebra.gui.d.G$w:
    java.lang.Object[] geos -> a
    javax.swing.JRadioButton[] buttons -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$LineStylePanel -> geogebra.gui.d.G$x:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    javax.swing.JPanel thicknessPanel -> a
    javax.swing.JLabel dashLabel -> a
    javax.swing.JComboBox dashCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    int maxMinimumThickness(java.lang.Object[]) -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$LodPanel -> geogebra.gui.d.G$y:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$PointSizePanel -> geogebra.gui.d.G$z:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$PointStylePanel -> geogebra.gui.d.G$A:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox cbStyle -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$RightAnglePanel -> geogebra.gui.d.G$B:
    javax.swing.JCheckBox emphasizeRightAngle -> a
    java.lang.Object[] geos -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$ScriptEditPanel -> geogebra.gui.d.G$C:
    geogebra.gui.dialog.ScriptInputDialog clickDialog -> a
    geogebra.gui.dialog.ScriptInputDialog updateDialog -> b
    geogebra.gui.dialog.ScriptInputDialog globalDialog -> c
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel clickScriptPanel -> a
    javax.swing.JPanel updateScriptPanel -> b
    javax.swing.JPanel globalScriptPanel -> c
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$SelectionAllowedPanel -> geogebra.gui.d.G$D:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox selectionAllowedCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$ShowObjectPanel -> geogebra.gui.d.G$E:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showObjectCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$ShowTrimmedIntersectionLines -> geogebra.gui.d.G$F:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showTrimmedLinesCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.PropertiesPanel$SlopeTriangleSizePanel -> geogebra.gui.d.G$G:
    java.lang.Object[] geos -> a
    javax.swing.JSlider slider -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.PropertiesPanel$StartPointPanel -> geogebra.gui.d.G$H:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    javax.swing.JComboBox cbLocation -> a
    javax.swing.DefaultComboBoxModel cbModel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.PropertiesPanel$TabPanel -> geogebra.gui.d.G$I:
    java.lang.String title -> a
    java.util.ArrayList panelList -> a
    boolean makeVisible -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setTitle(java.lang.String) -> a
    void update(java.lang.Object[]) -> a
    void addToTabbedPane(javax.swing.JTabbedPane) -> a
geogebra.gui.dialog.PropertiesPanel$TextEditPanel -> geogebra.gui.d.G$J:
    geogebra.gui.dialog.TextInputDialog td -> a
    javax.swing.JPanel editPanel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.dialog.TextInputDialog access$0(geogebra.gui.dialog.PropertiesPanel$TextEditPanel) -> a
geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel -> geogebra.gui.d.G$K:
    java.lang.Object[] geos -> a
    javax.swing.JLabel decimalLabel -> a
    javax.swing.JComboBox cbFont -> a
    javax.swing.JComboBox cbSize -> b
    javax.swing.JComboBox cbDecimalPlaces -> c
    javax.swing.JToggleButton btBold -> a
    javax.swing.JToggleButton btItalic -> b
    javax.swing.JPanel secondLine -> a
    boolean secondLineVisible -> a
    boolean justDisplayFontSize -> b
    geogebra.gui.dialog.PropertiesPanel$TextEditPanel editPanel -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setEditPanel(geogebra.gui.dialog.PropertiesPanel$TextEditPanel) -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel$ComboBoxRenderer -> geogebra.gui.d.G$K$a:
    javax.swing.JSeparator separator -> a
    geogebra.gui.dialog.PropertiesPanel$TextOptionsPanel this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.PropertiesPanel$TooltipPanel -> geogebra.gui.d.G$L:
    java.lang.Object[] geos -> a
    javax.swing.JComboBox tooltipModeCB -> a
    javax.swing.JLabel label -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.PropertiesPanel$TracePanel -> geogebra.gui.d.G$M:
    java.lang.Object[] geos -> a
    javax.swing.JCheckBox showTraceCB -> a
    geogebra.gui.dialog.PropertiesPanel this$0 -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
geogebra.gui.dialog.ScriptInputDialog -> geogebra.gui.d.H:
    geogebra.common.kernel.geos.GeoElement geo -> b
    boolean global -> a
    geogebra.common.kernel.geos.GeoElement$ScriptType scriptType -> a
    boolean updateScript -> b
    javax.swing.JComboBox languageSelector -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType -> a
    void setGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void setGlobal() -> b
    javax.swing.JPanel getInputPanel(int,int,boolean) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setScriptType(geogebra.common.kernel.geos.GeoElement$ScriptType) -> a
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    geogebra.common.kernel.geos.GeoElement getGeo() -> a
    boolean access$0(geogebra.gui.dialog.ScriptInputDialog) -> a
    boolean access$1(geogebra.gui.dialog.ScriptInputDialog) -> b
    geogebra.common.kernel.geos.GeoElement$ScriptType access$2(geogebra.gui.dialog.ScriptInputDialog) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$geos$GeoElement$ScriptType() -> a
geogebra.gui.dialog.ScriptInputDialog$TextInputHandler -> geogebra.gui.d.H$a:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.ScriptInputDialog this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.ShowConditionPanel -> geogebra.gui.d.I:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfCondition -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    boolean processed -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.SliderDialog -> geogebra.gui.d.J:
    javax.swing.JButton btApply -> a
    javax.swing.JButton btCancel -> b
    javax.swing.JRadioButton rbNumber -> a
    javax.swing.JRadioButton rbAngle -> b
    javax.swing.JRadioButton rbInteger -> c
    geogebra.gui.view.algebra.InputPanel tfLabel -> a
    javax.swing.JPanel optionPane -> a
    javax.swing.JCheckBox cbRandom -> a
    geogebra.main.Application app -> a
    geogebra.gui.properties.SliderPanel sliderPanel -> a
    geogebra.common.kernel.geos.GeoElement geoResult -> a
    geogebra.common.kernel.geos.GeoNumeric number -> a
    geogebra.common.kernel.geos.GeoAngle angle -> a
    void createGUI() -> a
    geogebra.common.kernel.geos.GeoElement getResult() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabelFieldFocus() -> b
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.dialog.TextInputDialog -> geogebra.gui.d.K:
    geogebra.gui.DynamicTextInputPane editor -> a
    geogebra.gui.dialog.TextPreviewPanel textPreviewer -> a
    geogebra.gui.dialog.TextInputDialog textInputDialog -> a
    javax.swing.JCheckBox cbLaTeX -> b
    javax.swing.JToolBar toolBar -> a
    javax.swing.JPanel previewPanel -> e
    javax.swing.JPanel editPanel -> f
    javax.swing.JPanel toolPanel -> g
    geogebra.gui.util.PopupMenuButton btInsertLaTeX -> a
    geogebra.gui.util.PopupMenuButton btInsertUnicode -> b
    geogebra.gui.util.PopupMenuButton btInsertGeo -> c
    javax.swing.JLabel previewHeader -> b
    javax.swing.JLabel editHeader -> c
    geogebra.common.kernel.geos.GeoText editGeo -> a
    boolean isLaTeX -> b
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    boolean isTextMode -> c
    geogebra.gui.util.SelectionTable recentSymbolTable -> a
    java.util.ArrayList recentSymbolList -> b
    javax.swing.JList geoList -> a
    boolean isIniting -> a
    javax.swing.undo.UndoManager undo -> a
    javax.swing.text.Document doc -> a
    java.util.HashMap laTexButtonTitleMap -> a
    void reInitEditor(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createAdditionalGUI() -> g
    void buildInsertUnicodeButton() -> h
    javax.swing.JMenu createMenuItem(java.lang.String[],int,int) -> a
    void buildInsertLaTeXButton() -> i
    void updateInsertLaTeXButtonLabels() -> b
    java.lang.String[] getGeoObjectList() -> a
    void buildInsertGeoButton() -> j
    javax.swing.JToolBar createRecentSymbolTable() -> a
    void addRecentSymbol(java.lang.String) -> d
    void updateRecentSymbolTable() -> c
    void setLabels() -> d
    void setLabels(java.lang.String) -> c
    void setGeoText(geogebra.common.kernel.geos.GeoText) -> a
    javax.swing.JPanel getToolBar() -> b
    javax.swing.JPanel getInputPanel() -> c
    javax.swing.JPanel getPreviewPanel() -> d
    boolean isLaTeX() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> setVisible
    void exitTextField(geogebra.gui.DynamicTextInputPane$DynamicTextField,boolean) -> a
    void updateFonts() -> e
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void handleDocumentEvent(javax.swing.event.DocumentEvent) -> a
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void insertEmptyDynamicText() -> f
    geogebra.gui.DynamicTextInputPane$DynamicTextField insertDynamicText(java.lang.String) -> a
    boolean access$0(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.DynamicTextInputPane access$1(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.common.kernel.geos.GeoText access$2(geogebra.gui.dialog.TextInputDialog) -> a
    javax.swing.JList access$3(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.util.PopupMenuButton access$4(geogebra.gui.dialog.TextInputDialog) -> a
    java.lang.String[] access$5(geogebra.gui.dialog.TextInputDialog) -> a
    java.util.ArrayList access$6(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.util.SelectionTable access$7(geogebra.gui.dialog.TextInputDialog) -> a
    geogebra.gui.dialog.TextInputDialog access$8(geogebra.gui.dialog.TextInputDialog) -> a
geogebra.gui.dialog.TextInputDialog$1 -> geogebra.gui.d.L:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void undoableEditHappened(javax.swing.event.UndoableEditEvent) -> undoableEditHappened
geogebra.gui.dialog.TextInputDialog$2 -> geogebra.gui.d.M:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$3 -> geogebra.gui.d.N:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$4 -> geogebra.gui.d.O:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.TextInputDialog$5 -> geogebra.gui.d.P:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.dialog.TextInputDialog$6 -> geogebra.gui.d.Q:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.dialog.TextInputDialog$7 -> geogebra.gui.d.R:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.dialog.TextInputDialog$MyKeyListener -> geogebra.gui.d.K$a:
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.dialog.TextInputDialog$TextInputHandler -> geogebra.gui.d.K$b:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.TextInputDialog this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.TextPreviewPanel -> geogebra.gui.d.S:
    geogebra.euclidian.EuclidianController ec -> a
    boolean[] showAxes -> a
    boolean showGrid -> f
    geogebra.common.kernel.geos.GeoText previewGeoIndependent -> a
    geogebra.common.kernel.geos.GeoText previewGeoDependent -> b
    geogebra.common.kernel.algos.AlgoDependentText textAlgo -> a
    geogebra.common.kernel.Construction cons -> a
    boolean isIndependent -> g
    java.awt.Dimension d -> a
    javax.swing.ImageIcon testIcon -> a
    javax.swing.JTextPane dummyText -> a
    int padding -> e
    void removePreviewGeoText() -> H
    void attachView() -> a
    void updatePreviewText(geogebra.common.kernel.geos.GeoText,java.lang.String,boolean) -> a
    void updateViewportSize(geogebra.common.kernel.geos.GeoText) -> a
    void updateVisualProperties(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.geos.GeoText,boolean,boolean) -> a
    void locateTextGeo(geogebra.common.kernel.geos.GeoText) -> b
    int getViewID() -> b
geogebra.gui.dialog.TextfieldSizePanel -> geogebra.gui.d.T:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    geogebra.gui.inputfield.MyTextField tfTextfieldSize -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.ToolCreationDialog -> geogebra.gui.d.U:
    geogebra.main.Application app -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.gui.ToolNameIconPanel namePanel -> a
    geogebra.gui.dialog.ToolCreationDialog$OutputListModel outputList -> a
    geogebra.gui.dialog.ToolCreationDialog$InputListModel inputList -> a
    javax.swing.DefaultComboBoxModel cbInputAddList -> a
    javax.swing.DefaultComboBoxModel cbOutputAddList -> b
    boolean allowMultiple -> a
    geogebra.common.kernel.Macro newTool -> a
    void setVisible(boolean) -> setVisible
    boolean createTool() -> a
    void finish() -> a
    void overwriteMacro(geogebra.common.kernel.Macro) -> b
    void updateInputList() -> b
    javax.swing.JComboBox removeListeningJComboBox(javax.swing.DefaultComboBoxModel) -> b
    geogebra.common.kernel.geos.GeoElement[] toGeoElements(javax.swing.DefaultListModel) -> a
    void initLists() -> c
    boolean possibleInput(geogebra.common.kernel.geos.GeoElement) -> b
    void initGUI() -> d
    void setFromMacro(geogebra.common.kernel.Macro) -> a
    javax.swing.JPanel createNavigationPanel() -> a
    javax.swing.JPanel createInputOutputPanel(geogebra.main.Application,javax.swing.DefaultListModel,javax.swing.DefaultComboBoxModel,boolean,boolean,java.awt.event.ActionListener) -> a
    javax.swing.JPanel createListUpDownRemovePanel(geogebra.main.Application,javax.swing.JList,javax.swing.JComboBox,boolean,boolean,boolean,java.awt.event.ActionListener) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    javax.swing.JComboBox access$0(javax.swing.DefaultComboBoxModel) -> a
    boolean access$1(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.gui.dialog.ToolCreationDialog$OutputListModel access$2(geogebra.gui.dialog.ToolCreationDialog) -> a
    javax.swing.JTabbedPane access$3(geogebra.gui.dialog.ToolCreationDialog) -> a
    void access$4(geogebra.gui.dialog.ToolCreationDialog) -> a
    void access$5(geogebra.gui.dialog.ToolCreationDialog) -> b
    geogebra.main.Application access$6(geogebra.gui.dialog.ToolCreationDialog) -> a
    boolean access$7(geogebra.gui.dialog.ToolCreationDialog) -> a
    geogebra.gui.dialog.ToolCreationDialog$InputListModel access$8(geogebra.gui.dialog.ToolCreationDialog) -> a
    geogebra.gui.ToolNameIconPanel access$9(geogebra.gui.dialog.ToolCreationDialog) -> a
geogebra.gui.dialog.ToolCreationDialog$1 -> geogebra.gui.d.V:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void removeElement(java.lang.Object) -> removeElement
geogebra.gui.dialog.ToolCreationDialog$2 -> geogebra.gui.d.W:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    javax.swing.JButton val$btNext -> a
    javax.swing.JButton val$btBack -> b
    javax.swing.JButton val$btCancel -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolCreationDialog$3 -> geogebra.gui.d.X:
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    javax.swing.JButton val$btBack -> a
    javax.swing.JButton val$btNext -> b
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.dialog.ToolCreationDialog$4 -> geogebra.gui.d.Y:
    javax.swing.JComboBox val$cbAdd -> a
    javax.swing.DefaultListModel val$listModel -> a
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.dialog.ToolCreationDialog$5 -> geogebra.gui.d.Z:
    javax.swing.JList val$list -> a
    javax.swing.JButton val$btUp -> a
    javax.swing.JButton val$btDown -> b
    javax.swing.JButton val$btRemove -> c
    javax.swing.JComboBox val$cbAdd -> a
    boolean val$allowMultiple -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolCreationDialog$InputListModel -> geogebra.gui.d.U$a:
    javax.swing.DefaultComboBoxModel cbInputAddList -> a
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ToolCreationDialog$OutputListModel -> geogebra.gui.d.U$b:
    javax.swing.DefaultComboBoxModel cbOutputAddList -> a
    geogebra.gui.dialog.ToolCreationDialog this$0 -> a
    void addElement(java.lang.Object) -> addElement
geogebra.gui.dialog.ToolManagerDialog -> geogebra.gui.d.aa:
    geogebra.main.Application app -> a
    javax.swing.DefaultListModel toolsModel -> a
    void setVisible(boolean) -> setVisible
    void updateToolBar(javax.swing.DefaultListModel) -> a
    void deleteTools(javax.swing.JList,javax.swing.DefaultListModel) -> a
    void initGUI() -> a
    void openTools(javax.swing.JList) -> a
    void insertTools(javax.swing.DefaultListModel) -> b
    void uploadToGeoGebraTube(javax.swing.JList) -> b
    void saveTools(javax.swing.JList) -> c
    geogebra.main.Application access$0(geogebra.gui.dialog.ToolManagerDialog) -> a
    javax.swing.DefaultListModel access$1(geogebra.gui.dialog.ToolManagerDialog) -> a
    void access$2(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList,javax.swing.DefaultListModel) -> a
    void access$3(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> a
    void access$4(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> b
    void access$5(geogebra.gui.dialog.ToolManagerDialog,javax.swing.JList) -> c
geogebra.gui.dialog.ToolManagerDialog$1 -> geogebra.gui.d.ab:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.JButton val$btClose -> a
    geogebra.gui.ToolNameIconPanel val$namePanel -> a
    javax.swing.JButton val$btDelete -> b
    javax.swing.JList val$toolList -> a
    javax.swing.JButton val$btOpen -> c
    javax.swing.JButton val$btSave -> d
    javax.swing.JButton val$btShare -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.ToolManagerDialog$2 -> geogebra.gui.d.ac:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.ListSelectionModel val$selModel -> a
    javax.swing.JList val$toolList -> a
    geogebra.gui.ToolNameIconPanel val$namePanel -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.dialog.ToolManagerDialog$3 -> geogebra.gui.d.ad:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    geogebra.common.kernel.Macro val$macro -> a
    void run() -> run
geogebra.gui.dialog.ToolManagerDialog$4 -> geogebra.gui.d.ae:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    javax.swing.JList val$toolList -> a
    void run() -> run
geogebra.gui.dialog.ToolManagerDialog$MacroCellRenderer -> geogebra.gui.d.aa$a:
    geogebra.gui.dialog.ToolManagerDialog this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.dialog.TurtleDriverPanel -> geogebra.gui.d.af:
    geogebra.common.kernel.geos.GeoTurtle t -> a
    javax.swing.JButton btnFD -> a
    javax.swing.JButton btnBK -> b
    javax.swing.JButton btnLT -> c
    javax.swing.JButton btnRT -> d
    javax.swing.JButton btnShape -> e
    javax.swing.JButton btnClear -> f
    double distance -> a
    double angle -> b
    void createGUI() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabels() -> a
geogebra.gui.dialog.handler.NumberChangeSignInputHandler -> geogebra.gui.d.a.a:
    boolean processInput(java.lang.String,boolean) -> a
geogebra.gui.dialog.handler.NumberInputHandler -> geogebra.gui.d.a.b:
    geogebra.common.kernel.commands.AlgebraProcessor algebraProcessor -> a
    geogebra.common.kernel.arithmetic.NumberValue num -> a
    boolean processInput(java.lang.String) -> a
    void setNum(geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.arithmetic.NumberValue getNum() -> a
geogebra.gui.dialog.handler.RedefineInputHandler -> geogebra.gui.d.a.c:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.main.Application app -> a
    java.lang.String oldString -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.handler.RenameInputHandler -> geogebra.gui.d.a.d:
    geogebra.common.kernel.geos.GeoElement geo -> a
    boolean storeUndo -> a
    geogebra.common.main.AbstractApplication app -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.dialog.options.AxisPanel -> geogebra.gui.d.b.a:
    int axis -> a
    javax.swing.JCheckBox cbShowAxis -> a
    javax.swing.JCheckBox cbAxisNumber -> b
    javax.swing.JCheckBox cbManualTicks -> c
    javax.swing.JCheckBox cbPositiveAxis -> d
    javax.swing.JCheckBox cbDrawAtBorder -> e
    geogebra.gui.NumberComboBox ncbTickDist -> a
    javax.swing.JComboBox cbTickStyle -> a
    javax.swing.JComboBox cbAxisLabel -> b
    javax.swing.JComboBox cbUnitLabel -> c
    javax.swing.JTextField tfCross -> a
    javax.swing.JLabel crossAt -> a
    javax.swing.JLabel axisTicks -> b
    javax.swing.JLabel axisLabel -> c
    javax.swing.JLabel axisUnitLabel -> d
    javax.swing.JLabel stickToEdge -> e
    geogebra.main.Application app -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    java.lang.String getString() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updatePanel() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setLabels() -> a
    double parseDouble(java.lang.String) -> a
geogebra.gui.dialog.options.OptionsAdvanced -> geogebra.gui.d.b.b:
    geogebra.main.Application app -> a
    geogebra.common.main.settings.Settings settings -> a
    javax.swing.JPanel virtualKeyboardPanel -> a
    javax.swing.JPanel guiFontsizePanel -> b
    javax.swing.JPanel tooltipPanel -> c
    javax.swing.JPanel languagePanel -> d
    javax.swing.JPanel perspectivesPanel -> e
    javax.swing.JPanel miscPanel -> f
    javax.swing.JPanel angleUnitPanel -> g
    javax.swing.JPanel continuityPanel -> h
    javax.swing.JPanel usePathAndRegionParametersPanel -> i
    javax.swing.JPanel checkboxSizePanel -> j
    javax.swing.JPanel rightAnglePanel -> k
    javax.swing.JPanel coordinatesPanel -> l
    javax.swing.JLabel keyboardLanguageLabel -> a
    javax.swing.JLabel guiFontSizeLabel -> b
    javax.swing.JLabel widthLabel -> c
    javax.swing.JLabel heightLabel -> d
    javax.swing.JLabel opacityLabel -> e
    javax.swing.JLabel tooltipLanguageLabel -> f
    javax.swing.JLabel tooltipTimeoutLabel -> g
    javax.swing.JComboBox cbKeyboardLanguage -> a
    javax.swing.JComboBox cbTooltipLanguage -> b
    javax.swing.JComboBox cbTooltipTimeout -> c
    javax.swing.JComboBox cbGUIFont -> d
    javax.swing.JCheckBox cbKeyboardShowAutomatic -> a
    javax.swing.JCheckBox cbUseLocalDigits -> b
    javax.swing.JCheckBox cbUseLocalLabels -> c
    javax.swing.JCheckBox cbReturnAngleInverseTrig -> d
    javax.swing.JCheckBox cbIgnoreDocumentLayout -> e
    javax.swing.JCheckBox cbShowTitleBar -> f
    javax.swing.JCheckBox cbAllowStyleBar -> g
    javax.swing.JCheckBox cbEnableScripting -> h
    javax.swing.JCheckBox cbUseJavaFonts -> i
    javax.swing.JCheckBox cbReverseMouseWheel -> j
    javax.swing.JRadioButton angleUnitRadioDegree -> a
    javax.swing.JRadioButton angleUnitRadioRadian -> b
    javax.swing.JRadioButton continuityRadioOn -> c
    javax.swing.JRadioButton continuityRadioOff -> d
    javax.swing.JRadioButton usePathAndRegionParametersRadioOn -> e
    javax.swing.JRadioButton usePathAndRegionParametersRadioOff -> f
    javax.swing.JRadioButton checkboxSizeRadioRegular -> g
    javax.swing.JRadioButton checkboxSizeRadioLarge -> h
    javax.swing.JRadioButton rightAngleRadio1 -> i
    javax.swing.JRadioButton rightAngleRadio2 -> j
    javax.swing.JRadioButton rightAngleRadio3 -> k
    javax.swing.JRadioButton rightAngleRadio4 -> l
    javax.swing.JRadioButton coordinatesRadio1 -> m
    javax.swing.JRadioButton coordinatesRadio2 -> n
    javax.swing.JRadioButton coordinatesRadio3 -> o
    javax.swing.ButtonGroup angleUnitButtonGroup -> a
    javax.swing.ButtonGroup continuityButtonGroup -> b
    javax.swing.ButtonGroup usePathAndRegionParametersButtonGroup -> c
    javax.swing.ButtonGroup checkboxSizeButtonGroup -> d
    javax.swing.ButtonGroup rightAngleButtonGroup -> e
    javax.swing.ButtonGroup coordinatesButtonGroup -> f
    javax.swing.JTextField tfKeyboardWidth -> a
    javax.swing.JTextField tfKeyboardHeight -> b
    javax.swing.JSlider slOpacity -> a
    java.lang.String[] tooltipTimeouts -> a
    void initGUI() -> f
    void initVirtualKeyboardPanel() -> g
    void initGUIFontSizePanel() -> h
    void initLanguagePanel() -> i
    void initTooltipPanel() -> j
    void initPerspectivesPanel() -> k
    void initScriptingPanel() -> l
    void initAngleUnitPanel() -> m
    void initContinuityPanel() -> n
    void initUsePathAndRegionParametersPanel() -> o
    void initCheckboxSizePanel() -> p
    void initRightAnglePanel() -> q
    void initCoordinatesPanel() -> r
    void updateGUI() -> b
    void updateAfterReset() -> c
    void updateGUIFont() -> d
    void updateTooltipLanguages() -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void handleEVOption(java.lang.Object,geogebra.euclidian.EuclidianView) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void changeWidthOrHeight(java.lang.Object) -> a
    void setLabels() -> a
    void setLabelsKeyboardLanguage() -> s
    void setLabelsGUIFontsize() -> t
    void setLabelsTooltipLanguages() -> u
    void setLabelsTooltipTimeouts() -> v
geogebra.gui.dialog.options.OptionsCAS -> geogebra.gui.d.b.c:
    geogebra.main.Application app -> a
    geogebra.common.main.settings.CASSettings casSettings -> a
    javax.swing.JLabel timeoutLabel -> a
    javax.swing.JComboBox cbTimeout -> a
    javax.swing.JCheckBox cbShowRoots -> a
    void initGUI() -> c
    void updateGUI() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabels() -> a
geogebra.gui.dialog.options.OptionsDefaults -> geogebra.gui.d.b.d:
    geogebra.main.Application app -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    javax.swing.JTree tree -> a
    javax.swing.tree.DefaultTreeModel treeModel -> a
    javax.swing.tree.DefaultMutableTreeNode rootNode -> a
    javax.swing.tree.DefaultMutableTreeNode pointsNode -> b
    javax.swing.tree.DefaultMutableTreeNode pointsFreeNode -> c
    javax.swing.tree.DefaultMutableTreeNode pointsDepNode -> d
    javax.swing.tree.DefaultMutableTreeNode pointsPathNode -> e
    javax.swing.tree.DefaultMutableTreeNode pointsInRegionNode -> f
    javax.swing.tree.DefaultMutableTreeNode pointsComplexNode -> g
    javax.swing.tree.DefaultMutableTreeNode lineNode -> h
    javax.swing.tree.DefaultMutableTreeNode segmentNode -> i
    javax.swing.tree.DefaultMutableTreeNode vectorNode -> j
    javax.swing.tree.DefaultMutableTreeNode conicNode -> k
    javax.swing.tree.DefaultMutableTreeNode conicSectorNode -> l
    javax.swing.tree.DefaultMutableTreeNode numberNode -> m
    javax.swing.tree.DefaultMutableTreeNode angleNode -> n
    javax.swing.tree.DefaultMutableTreeNode functionNode -> o
    javax.swing.tree.DefaultMutableTreeNode polygonNode -> p
    javax.swing.tree.DefaultMutableTreeNode locusNode -> q
    javax.swing.tree.DefaultMutableTreeNode textNode -> r
    javax.swing.tree.DefaultMutableTreeNode imageNode -> s
    javax.swing.tree.DefaultMutableTreeNode booleanNode -> t
    javax.swing.tree.DefaultMutableTreeNode listNode -> u
    javax.swing.tree.DefaultMutableTreeNode inequalitiesNode -> v
    geogebra.common.kernel.ConstructionDefaults defaults -> a
    java.util.Hashtable typeToNode -> a
    void initGUI() -> d
    void initNodes() -> e
    void createDefaultMap() -> f
    void restoreDefaults() -> b
    void updateGUI() -> c
    void setLabels() -> a
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
geogebra.gui.dialog.options.OptionsDialog -> geogebra.gui.d.b.e:
    geogebra.main.Application app -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.gui.dialog.options.OptionsDefaults defaultsPanel -> a
    geogebra.gui.dialog.options.OptionsEuclidian euclidianPanel -> a
    javax.swing.JScrollPane euclidianPanelScroll -> a
    geogebra.gui.dialog.options.OptionsSpreadsheet spreadsheetPanel -> a
    geogebra.gui.dialog.options.OptionsCAS casPanel -> a
    geogebra.gui.dialog.options.OptionsAdvanced advancedPanel -> a
    javax.swing.JButton saveButton -> a
    javax.swing.JButton closeButton -> b
    javax.swing.JButton restoreDefaultsButton -> c
    void updateGUI() -> b
    void restoreDefaults() -> c
    void showTab(int) -> a
    void initGUI() -> f
    void createTabs() -> d
    void addTabs() -> e
    void setLabels() -> a
    void closeDialog() -> g
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void access$0(geogebra.gui.dialog.options.OptionsDialog) -> a
geogebra.gui.dialog.options.OptionsDialog$1 -> geogebra.gui.d.b.f:
    geogebra.gui.dialog.options.OptionsDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsDialog$2 -> geogebra.gui.d.b.g:
    geogebra.gui.dialog.options.OptionsDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsDialog$3 -> geogebra.gui.d.b.h:
    geogebra.gui.dialog.options.OptionsDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsDialog$Factory -> geogebra.gui.d.b.e$a:
    geogebra.gui.dialog.options.OptionsDialog create(geogebra.main.Application) -> a
geogebra.gui.dialog.options.OptionsEuclidian -> geogebra.gui.d.b.i:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    geogebra.gui.dialog.options.AxisPanel xAxisPanel -> a
    geogebra.gui.dialog.options.AxisPanel yAxisPanel -> b
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel dimPanel -> a
    javax.swing.JPanel stylePanel -> b
    javax.swing.JPanel typePanel -> c
    javax.swing.JPanel axesOptionsPanel -> d
    javax.swing.JPanel miscPanel -> e
    javax.swing.JPanel selectViewPanel -> f
    javax.swing.JButton btBackgroundColor -> a
    javax.swing.JButton btAxesColor -> b
    javax.swing.JButton btGridColor -> c
    javax.swing.JCheckBox cbShowAxes -> a
    javax.swing.JCheckBox cbShowGrid -> b
    javax.swing.JCheckBox cbBoldGrid -> c
    javax.swing.JCheckBox cbGridManualTick -> d
    javax.swing.JCheckBox cbShowMouseCoords -> e
    javax.swing.JComboBox cbAxesStyle -> a
    javax.swing.JComboBox cbGridType -> b
    javax.swing.JComboBox cbGridStyle -> c
    javax.swing.JComboBox cbGridTickAngle -> d
    javax.swing.JComboBox cbView -> e
    javax.swing.JComboBox cbTooltips -> f
    javax.swing.JTextField tfAxesRatioX -> e
    javax.swing.JTextField tfAxesRatioY -> f
    java.text.NumberFormat nfAxesRatio -> a
    geogebra.gui.NumberComboBox ncbGridTickX -> a
    geogebra.gui.NumberComboBox ncbGridTickY -> b
    javax.swing.JTextField tfMinX -> a
    javax.swing.JTextField tfMaxX -> b
    javax.swing.JTextField tfMinY -> c
    javax.swing.JTextField tfMaxY -> d
    javax.swing.JLabel[] dimLabel -> a
    javax.swing.JLabel axesRatioLabel -> a
    javax.swing.JLabel gridLabel1 -> b
    javax.swing.JLabel gridLabel2 -> c
    javax.swing.JLabel gridLabel3 -> d
    javax.swing.JLabel lblColor -> e
    javax.swing.JLabel tooltips -> f
    javax.swing.JLabel backgroundColor -> g
    javax.swing.JLabel color -> h
    javax.swing.JLabel lineStyle -> i
    boolean isIniting -> a
    javax.swing.JToggleButton cbLockRatio -> a
    void setView(geogebra.euclidianND.EuclidianViewND) -> a
    void initGUI() -> l
    void createCbView() -> b
    void addCbView() -> c
    void showCbView(boolean) -> a
    void addTabs() -> d
    void initAxisPanels() -> e
    void initDimensionPanel() -> m
    void initAxesOptionsPanel() -> n
    void initMiscPanel() -> o
    javax.swing.JPanel buildBasicPanel() -> a
    void initGridTypePanel() -> p
    void initGridStylePanel() -> q
    javax.swing.JPanel buildGridPanel() -> b
    void updateMinMax() -> f
    void setCbViewSelectedIndex() -> g
    void updateGUIforCbView() -> h
    void updateGUI() -> i
    void setLabels() -> a
    void setTabLabels() -> j
    void setLabelsForCbView() -> k
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void setViewFromIndex(int) -> a
    double parseDouble(java.lang.String) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.options.OptionsEuclidian2 -> geogebra.gui.d.b.j:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.euclidianND.EuclidianViewND view -> a
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JLabel[] dimLabel -> a
    javax.swing.JLabel axesRatioLabel -> a
    javax.swing.JPanel dimPanel -> a
    javax.swing.JButton btBackgroundColor -> a
    javax.swing.JButton btAxesColor -> b
    javax.swing.JButton btGridColor -> c
    javax.swing.JCheckBox cbShowAxes -> a
    javax.swing.JCheckBox cbShowGrid -> b
    javax.swing.JCheckBox cbBoldGrid -> c
    javax.swing.JCheckBox cbGridManualTick -> d
    javax.swing.JCheckBox cbShowMouseCoords -> e
    javax.swing.JComboBox cbAxesStyle -> a
    javax.swing.JComboBox cbGridType -> b
    javax.swing.JComboBox cbGridStyle -> c
    javax.swing.JComboBox cbGridTickAngle -> d
    javax.swing.JComboBox cbView -> e
    javax.swing.JComboBox cbTooltips -> f
    javax.swing.JTextField tfAxesRatioX -> e
    javax.swing.JTextField tfAxesRatioY -> f
    java.text.NumberFormat nfAxesRatio -> a
    geogebra.gui.NumberComboBox ncbGridTickX -> a
    geogebra.gui.NumberComboBox ncbGridTickY -> b
    javax.swing.JTextField tfMinX -> a
    javax.swing.JTextField tfMaxX -> b
    javax.swing.JTextField tfMinY -> c
    javax.swing.JTextField tfMaxY -> d
    geogebra.gui.dialog.options.OptionsEuclidian2$AxisPanel xAxisPanel -> a
    geogebra.gui.dialog.options.OptionsEuclidian2$AxisPanel yAxisPanel -> b
    javax.swing.JLabel gridLabel1 -> b
    javax.swing.JLabel gridLabel2 -> c
    javax.swing.JLabel gridLabel3 -> d
    boolean isIniting -> a
    javax.swing.JPanel stylePanel -> b
    javax.swing.JLabel lblColor -> e
    javax.swing.JPanel typePanel -> c
    javax.swing.JLabel tooltips -> f
    javax.swing.JLabel backgroundColor -> g
    javax.swing.JLabel color -> h
    javax.swing.JLabel lineStyle -> i
    javax.swing.JPanel axesOptionsPanel -> d
    javax.swing.JPanel selectViewPanel -> e
    void setView(geogebra.euclidianND.EuclidianViewND) -> a
    void initAxisPanels() -> b
    void initGUI() -> m
    void createCbView() -> c
    void addCbView() -> d
    void addTabs() -> e
    void addAxisTabs() -> f
    javax.swing.JPanel buildBasicNorthPanel() -> a
    javax.swing.JPanel buildBasicPanel() -> b
    javax.swing.JPanel buildGridPanel() -> c
    void updateMinMax() -> g
    void setCbViewSelectedIndex() -> h
    void updateGUIforCbView() -> i
    void updateGUI() -> j
    void setLabels() -> a
    void setTabLabels() -> k
    void setLabelsForCbView() -> l
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void setViewFromIndex(int) -> a
    double parseDouble(java.lang.String) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    double access$0(geogebra.gui.dialog.options.OptionsEuclidian2,java.lang.String) -> a
geogebra.gui.dialog.options.OptionsEuclidian2$AxisPanel -> geogebra.gui.d.b.j$a:
    int axis -> a
    javax.swing.JCheckBox cbShowAxis -> a
    javax.swing.JCheckBox cbAxisNumber -> b
    javax.swing.JCheckBox cbManualTicks -> c
    javax.swing.JCheckBox cbPositiveAxis -> d
    javax.swing.JCheckBox cbDrawAtBorder -> e
    geogebra.gui.NumberComboBox ncbTickDist -> a
    javax.swing.JComboBox cbTickStyle -> a
    javax.swing.JComboBox cbAxisLabel -> b
    javax.swing.JComboBox cbUnitLabel -> c
    javax.swing.JTextField tfCross -> a
    javax.swing.JLabel crossAt -> a
    javax.swing.JLabel axisTicks -> b
    javax.swing.border.TitledBorder title -> a
    javax.swing.JLabel axisLabel -> c
    javax.swing.JLabel axisUnitLabel -> d
    javax.swing.JLabel stickToEdge -> e
    geogebra.gui.dialog.options.OptionsEuclidian2 this$0 -> a
    java.lang.String getString() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    void updatePanel() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setLabels() -> a
geogebra.gui.dialog.options.OptionsObject -> geogebra.gui.d.b.k:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.options.OptionsObject$JTreeGeoElements geoTree -> a
    javax.swing.JButton closeButton -> a
    javax.swing.JButton defaultsButton -> b
    javax.swing.JButton delButton -> c
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    geogebra.gui.color.GeoGebraColorChooser colChooser -> a
    boolean firstTime -> a
    boolean viewActive -> b
    java.util.ArrayList selectionList -> a
    java.util.ArrayList tempArrayList -> b
    void initGUI() -> b
    void setLabels() -> a
    void closeDialog() -> c
    void applyDefaults() -> e
    void setVisibleWithGeos(java.util.ArrayList) -> a
    void setVisible(boolean) -> setVisible
    void setViewActive(boolean) -> a
    void selectionChanged() -> d
    java.util.ArrayList updateSelectedGeos(javax.swing.tree.TreePath[]) -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void deleteSelectedGeos() -> f
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    geogebra.main.Application access$0(geogebra.gui.dialog.options.OptionsObject) -> a
    geogebra.common.kernel.Kernel access$1(geogebra.gui.dialog.options.OptionsObject) -> a
    void access$2(geogebra.gui.dialog.options.OptionsObject) -> a
    void access$3(geogebra.gui.dialog.options.OptionsObject) -> b
geogebra.gui.dialog.options.OptionsObject$1 -> geogebra.gui.d.b.l:
    geogebra.gui.dialog.options.OptionsObject this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra.gui.dialog.options.OptionsObject$2 -> geogebra.gui.d.b.m:
    geogebra.gui.dialog.options.OptionsObject this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsObject$3 -> geogebra.gui.d.b.n:
    geogebra.gui.dialog.options.OptionsObject this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsObject$4 -> geogebra.gui.d.b.o:
    geogebra.gui.dialog.options.OptionsObject this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.dialog.options.OptionsObject$JTreeGeoElements -> geogebra.gui.d.b.k$a:
    javax.swing.tree.DefaultTreeModel treeModel -> a
    javax.swing.tree.DefaultMutableTreeNode root -> a
    java.util.HashMap typeNodesMap -> a
    geogebra.gui.dialog.options.OptionsObject this$0 -> a
    void setLabels() -> a
    void setExpandedState(javax.swing.tree.TreePath,boolean) -> setExpandedState
    void expandAll() -> e
    void collapseAll() -> f
    void setSelected(java.util.ArrayList,boolean) -> a
    void selectFirstElement() -> h
    javax.swing.tree.TreePath getGeoPath(geogebra.common.kernel.geos.GeoElement) -> a
    void clearSelection() -> clearSelection
    void clear() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void remove(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    javax.swing.tree.TreePath getTreePath(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void setMode(int) -> a
    void reset() -> d
    void clearView() -> b
    void repaintView() -> c
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    int getViewID() -> b
    javax.swing.tree.DefaultMutableTreeNode access$0(geogebra.gui.dialog.options.OptionsObject$JTreeGeoElements) -> a
    javax.swing.tree.TreePath access$1(geogebra.gui.dialog.options.OptionsObject$JTreeGeoElements,geogebra.common.kernel.geos.GeoElement) -> a
geogebra.gui.dialog.options.OptionsSpreadsheet -> geogebra.gui.d.b.p:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.JCheckBox cbShowFormulaBar -> a
    javax.swing.JCheckBox cbShowGrid -> b
    javax.swing.JCheckBox cbShowRowHeader -> c
    javax.swing.JCheckBox cbShowColumnHeader -> d
    javax.swing.JCheckBox cbShowHScrollbar -> e
    javax.swing.JCheckBox cbShowVScrollbar -> f
    javax.swing.JCheckBox cbShowBrowser -> g
    javax.swing.JCheckBox cbAllowSpecialEditor -> h
    javax.swing.JCheckBox cbAllowToolTips -> i
    javax.swing.JCheckBox cbPrependCommands -> j
    javax.swing.JTextField dirField -> a
    javax.swing.JTextField urlField -> b
    javax.swing.JButton browseButton -> a
    javax.swing.JButton restoreButton -> b
    javax.swing.JButton setCurrentButton -> c
    javax.swing.JRadioButton dirRadioButton -> a
    javax.swing.JRadioButton urlRadioButton -> b
    javax.swing.JPanel locationPanel -> a
    javax.swing.JTabbedPane tabbedPane -> a
    geogebra.common.main.settings.SpreadsheetSettings settings() -> a
    void initGUI() -> c
    javax.swing.JPanel buildLayoutOptionsPanel() -> a
    javax.swing.JPanel buildBrowserOptionsPanel() -> b
    void setLabels() -> a
    void updateGUI() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.dialog.options.OptionsUtil -> geogebra.gui.d.b.q:
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
    javax.swing.border.Border titleBorder(java.lang.String) -> a
geogebra.gui.editor.GeoGebraContext -> geogebra.gui.e.a:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    geogebra.main.Application app -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.GeoGebraEditorKit -> geogebra.gui.e.b:
    geogebra.gui.editor.GeoGebraContext preferences -> a
    geogebra.main.Application app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.GeoGebraContext getStylePreferences() -> a
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.GeoGebraEditorPane -> geogebra.gui.e.c:
    javax.swing.Popup helpPopup -> a
    geogebra.main.Application app -> a
    int rows -> a
    int cols -> b
    int rowHeight -> c
    int columnWidth -> d
    geogebra.gui.editor.Lexer lexer -> a
    boolean matchingEnable -> a
    geogebra.gui.editor.MatchingBlockManager matchLR -> a
    geogebra.gui.editor.MatchingBlockManager matchRL -> b
    java.awt.Point mousePoint -> a
    java.util.List kwListeners -> a
    int type -> e
    void setEditorKit(java.lang.String) -> a
    void setFont(java.awt.Font) -> setFont
    java.awt.Dimension getPreferredSizeFromRowColumn(int,int) -> a
    void addKeywordListener(geogebra.gui.editor.KeywordListener) -> a
    void enableMatchingKeywords(boolean) -> a
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    geogebra.gui.editor.KeywordEvent getKeywordEvent(int) -> a
    void preventConcernedKeywordListener(int,java.util.EventObject,int) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
geogebra.gui.editor.GeoGebraLexer -> geogebra.gui.e.d:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    java.util.Set commands -> a
    java.util.Set variables -> b
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    java.lang.String yytext() -> a
    int yylength() -> c
    void zzScanError(int) -> b
    void yypushback(int) -> a
    int yylex() -> d
geogebra.gui.editor.GeoGebraView -> geogebra.gui.e.e:
    geogebra.gui.editor.ViewContext context -> a
    geogebra.gui.editor.Lexer lexer -> a
    boolean lexerValid -> a
    javax.swing.text.Document doc -> a
    javax.swing.text.Segment text -> a
    boolean isTabViewable -> b
    boolean isWhiteViewable -> c
    boolean enable -> d
    int tabType -> a
    java.lang.String tabCharacter -> a
    int numOfColumns -> b
    java.awt.Color lineColor -> a
    java.awt.Rectangle rect -> a
    java.util.Map desktopFontHints -> a
    boolean enableDesktopFontHints -> e
    int whiteHeight -> c
    int whiteWidth -> d
    boolean unselected -> f
    void paint(java.awt.Graphics,java.awt.Shape) -> paint
    java.awt.Shape modelToView(int,javax.swing.text.Position$Bias,int,javax.swing.text.Position$Bias,java.awt.Shape) -> modelToView
    int drawUnselectedText(java.awt.Graphics,int,int,int,int) -> drawUnselectedText
    int drawSelectedText(java.awt.Graphics,int,int,int,int) -> drawSelectedText
    void setTabRepresentation(int) -> a
    void paintTab(javax.swing.text.Segment,int,int,java.awt.Graphics,int) -> a
    void calculateHeight(java.awt.font.FontRenderContext,java.awt.Font) -> a
geogebra.gui.editor.HelpOnKeywordPanel -> geogebra.gui.e.f:
    geogebra.gui.editor.HelpOnKeywordPanel instance -> a
    javax.swing.JTextArea textarea -> a
    geogebra.gui.editor.HelpOnKeywordPanel getInstance(geogebra.main.Application,java.lang.String) -> a
geogebra.gui.editor.JavascriptContext -> geogebra.gui.e.g:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.JavascriptEditorKit -> geogebra.gui.e.h:
    geogebra.gui.editor.JavascriptContext preferences -> a
    geogebra.main.Application app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.JavascriptContext getStylePreferences() -> a
    javax.swing.text.Document createDefaultDocument() -> createDefaultDocument
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.JavascriptEditorKit$JavascriptDocument -> geogebra.gui.e.h$a:
    geogebra.gui.editor.GeoGebraEditorPane textcomponent -> a
    boolean isCommented(javax.swing.text.Element) -> a
    void setTextComponent(geogebra.gui.editor.GeoGebraEditorPane) -> a
    boolean isCommented(int) -> a
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void handleUpdate(javax.swing.event.DocumentEvent) -> a
    boolean handleElement(javax.swing.text.Element,boolean) -> a
geogebra.gui.editor.JavascriptLexer -> geogebra.gui.e.i:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    geogebra.gui.editor.JavascriptEditorKit$JavascriptDocument doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    void yybegin(int) -> a
    int yylength() -> c
    void zzScanError(int) -> c
    void yypushback(int) -> b
    int yylex() -> d
geogebra.gui.editor.KeywordAdapter -> geogebra.gui.e.j:
    int type -> a
    int getType() -> a
geogebra.gui.editor.KeywordAdapter$MouseOverAdapter -> geogebra.gui.e.j$a:
geogebra.gui.editor.KeywordEvent -> geogebra.gui.e.k:
    int start -> a
    int length -> b
    int type -> c
    java.util.EventObject event -> a
    int getStart() -> a
    int getLength() -> b
    int getType() -> c
geogebra.gui.editor.KeywordListener -> geogebra.gui.e.l:
    void caughtKeyword(geogebra.gui.editor.KeywordEvent) -> a
    int getType() -> a
geogebra.gui.editor.LaTeXContext -> geogebra.gui.e.m:
    java.util.Map TOKENS -> a
    javax.swing.text.View view -> a
    java.util.List typeToDefault -> a
    java.util.Map colorMap -> b
    java.util.Map attribMap -> c
    void genAttributes() -> a
    void genColors() -> b
    javax.swing.text.View create(javax.swing.text.Element) -> create
geogebra.gui.editor.LaTeXEditorKit -> geogebra.gui.e.n:
    geogebra.gui.editor.LaTeXContext preferences -> a
    geogebra.main.Application app -> a
    java.lang.String getContentType() -> getContentType
    geogebra.gui.editor.LaTeXContext getStylePreferences() -> a
    javax.swing.text.ViewFactory getViewFactory() -> getViewFactory
geogebra.gui.editor.LaTeXLexer -> geogebra.gui.e.o:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> c
    int zzLexicalState -> d
    char[] zzBuffer -> b
    int zzMarkedPos -> e
    int zzCurrentPos -> f
    int zzStartRead -> g
    int zzEndRead -> h
    int yyline -> i
    int yychar -> j
    int yycolumn -> k
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    int end -> a
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    void setDocument(javax.swing.text.Document) -> a
    void setRange(int,int) -> a
    int yychar() -> a
    int scan() -> b
    int getKeyword(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    int yylength() -> c
    void zzScanError(int) -> a
    int yylex() -> d
geogebra.gui.editor.Lexer -> geogebra.gui.e.p:
    int start -> b
    void setRange(int,int) -> a
    int yychar() -> a
    int yylength() -> c
    int scan() -> b
    int getKeyword(int,boolean) -> a
    void setDocument(javax.swing.text.Document) -> a
geogebra.gui.editor.MatchingBlockManager -> geogebra.gui.e.q:
    javax.swing.text.Document doc -> a
    geogebra.gui.editor.GeoGebraEditorPane pane -> a
    geogebra.gui.editor.MatchingBlockScanner scanner -> a
    javax.swing.text.Highlighter highlighter -> a
    geogebra.gui.editor.MatchingBlockScanner$MatchingPositions smpos -> a
    javax.swing.text.Highlighter$HighlightPainter kwPainter -> a
    javax.swing.text.Highlighter$HighlightPainter ocPainter -> b
    java.lang.Object first -> a
    java.lang.Object second -> b
    boolean insideOc -> a
    boolean insideKw -> b
    boolean ocIncluded -> c
    boolean kwIncluded -> d
    boolean lr -> e
    geogebra.gui.editor.MatchingBlockManager$MouseOverMatcher mouseover -> a
    void setPainterForOpenClose(boolean,boolean,java.awt.Color) -> a
    void setPainterForOpenClose(int,java.awt.Color) -> a
    void setPainterForOpenClose() -> a
    void setDefaults() -> b
    void activateMouseOver() -> c
    void update() -> d
    void searchMatchingBlock(int,int) -> a
    void createHighlights(geogebra.gui.editor.MatchingBlockScanner$MatchingPositions,boolean,boolean,javax.swing.text.Highlighter$HighlightPainter) -> a
    javax.swing.text.Document access$0(geogebra.gui.editor.MatchingBlockManager) -> a
    boolean access$1(geogebra.gui.editor.MatchingBlockManager) -> a
geogebra.gui.editor.MatchingBlockManager$GeoGebraKeywordsPainter -> geogebra.gui.e.q$a:
    java.awt.Color color -> a
    int type -> a
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    java.awt.Shape paintLayer(java.awt.Graphics,int,int,java.awt.Shape,javax.swing.text.JTextComponent,javax.swing.text.View) -> paintLayer
geogebra.gui.editor.MatchingBlockManager$InsideLinePainter -> geogebra.gui.e.q$b:
    boolean filled -> a
    boolean strict -> b
    java.awt.Color color -> a
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    void paint(java.awt.Graphics,int,int,java.awt.Shape,javax.swing.text.JTextComponent) -> paint
geogebra.gui.editor.MatchingBlockManager$MouseOverMatcher -> geogebra.gui.e.q$c:
    geogebra.gui.editor.MatchingBlockManager this$0 -> a
    void caughtKeyword(geogebra.gui.editor.KeywordEvent) -> a
geogebra.gui.editor.MatchingBlockManager$Parameters -> geogebra.gui.e.q$d:
    java.awt.Color color -> a
    boolean inside -> a
    boolean strict -> b
    boolean included -> c
    int type -> a
    boolean onmouseover -> d
geogebra.gui.editor.MatchingBlockScanner -> geogebra.gui.e.r:
    int[] ZZ_LEXSTATE -> a
    char[] ZZ_CMAP -> a
    int[] ZZ_ACTION -> b
    java.lang.String[] ZZ_ERROR_MSG -> a
    java.io.Reader zzReader -> a
    int zzState -> a
    int zzLexicalState -> b
    char[] zzBuffer -> b
    int zzMarkedPos -> c
    int zzCurrentPos -> d
    int zzStartRead -> e
    int zzEndRead -> f
    int yyline -> g
    int yychar -> h
    int yycolumn -> i
    boolean zzAtBOL -> a
    boolean zzAtEOF -> b
    boolean zzEOFDone -> c
    javax.swing.text.Document doc -> a
    javax.swing.text.Element elem -> a
    int start -> j
    int end -> k
    int[] zzUnpackAction() -> a
    int zzUnpackAction(java.lang.String,int,int[]) -> a
    geogebra.gui.editor.MatchingBlockScanner$MatchingPositions getMatchingBlock(int,boolean) -> a
    char[] zzUnpackCMap(java.lang.String) -> a
    boolean zzRefill() -> a
    void yyreset(java.io.Reader) -> a
    void yybegin(int) -> a
    int yylength() -> a
    void zzScanError(int) -> b
    int yylex() -> b
geogebra.gui.editor.MatchingBlockScanner$MatchingPositions -> geogebra.gui.e.r$a:
    int firstB -> a
    int firstE -> b
    int secondB -> c
    int secondE -> d
    geogebra.gui.editor.MatchingBlockScanner this$0 -> a
geogebra.gui.editor.ViewContext -> geogebra.gui.e.s:
    java.awt.Color[] tokenColors -> a
    java.awt.Font tokenFont -> a
    int[] tokenAttrib -> a
geogebra.gui.inputbar.AlgebraInput -> geogebra.gui.f.a:
    geogebra.main.Application app -> a
    geogebra.gui.inputfield.AutoCompleteTextField inputField -> a
    javax.swing.JLabel inputLabel -> a
    javax.swing.JToggleButton btnHelpToggle -> a
    geogebra.gui.view.algebra.InputPanel inputPanel -> a
    void initGUI() -> b
    boolean requestFocusInWindow() -> requestFocusInWindow
    void requestFocus() -> requestFocus
    boolean hasFocus() -> hasFocus
    void clear() -> c
    geogebra.gui.inputfield.AutoCompleteTextField getTextField() -> a
    void setLabels() -> a
    void updateFonts() -> d
    void insertCommand(java.lang.String) -> a
    void insertString(java.lang.String) -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.inputbar.InputBarHelpPanel -> geogebra.gui.f.b:
    geogebra.main.Application app -> a
    geogebra.gui.inputbar.InputBarHelpPanel thisPanel -> a
    java.awt.Color bgColor -> a
    java.awt.Color titleColor -> b
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree cmdTree -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree fcnTree -> b
    javax.swing.tree.DefaultMutableTreeNode functionTitleNode -> a
    javax.swing.tree.DefaultMutableTreeNode rootSubCommands -> b
    javax.swing.tree.DefaultMutableTreeNode rootAllCommands -> c
    javax.swing.tree.DefaultTreeModel cmdTreeModel -> a
    java.lang.String selectedCommand -> a
    java.lang.String rollOverCommand -> b
    java.lang.String selectedFunction -> c
    javax.swing.JPopupMenu contextMenu -> a
    javax.swing.JTextPane helpTextPane -> a
    javax.swing.JButton btnOnlineHelp -> a
    javax.swing.JButton btnRefresh -> b
    geogebra.gui.util.SelectionTable functionTable -> a
    javax.swing.JPanel tablePanel -> a
    javax.swing.JPanel syntaxHelpPanel -> b
    javax.swing.JSplitPane cmdSplitPane -> a
    javax.swing.JLabel titleLabel -> a
    javax.swing.JLabel syntaxLabel -> b
    javax.swing.JButton btnPaste -> c
    javax.swing.JScrollPane scroller -> a
    void createSyntaxPanel() -> d
    javax.swing.JPanel createButtonPanel() -> a
    void createFunctionPanel() -> e
    void setLabels() -> a
    void updateFonts() -> b
    void createCommandTree() -> f
    void setCommands() -> c
    void addNodeInSortedOrder(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultMutableTreeNode) -> a
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void showSelectedSyntax() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doPaste() -> h
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    geogebra.gui.util.SelectionTable access$0(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree access$1(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$2(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> a
    void access$3(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> b
    javax.swing.JTextPane access$4(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$5(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    javax.swing.JPopupMenu access$6(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    java.awt.Color access$7(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    void access$8(geogebra.gui.inputbar.InputBarHelpPanel,java.lang.String) -> c
    geogebra.main.Application access$9(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    java.lang.String access$10(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    geogebra.gui.inputbar.InputBarHelpPanel$MyJTree access$11(geogebra.gui.inputbar.InputBarHelpPanel) -> b
    geogebra.gui.inputbar.InputBarHelpPanel access$12(geogebra.gui.inputbar.InputBarHelpPanel) -> a
    javax.swing.JButton access$13(geogebra.gui.inputbar.InputBarHelpPanel) -> a
geogebra.gui.inputbar.InputBarHelpPanel$1 -> geogebra.gui.f.c:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.inputbar.InputBarHelpPanel$2 -> geogebra.gui.f.d:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.inputbar.InputBarHelpPanel$MyJTree -> geogebra.gui.f.b$a:
    int rollOverRow -> a
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
geogebra.gui.inputbar.InputBarHelpPanel$MyRenderer -> geogebra.gui.f.b$b:
    java.awt.Color selectionColor -> a
    java.awt.Color rollOverColor -> b
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener -> geogebra.gui.f.b$c:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void myPopupEvent(java.awt.event.MouseEvent) -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    geogebra.gui.inputbar.InputBarHelpPanel access$1(geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener) -> a
geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener$1 -> geogebra.gui.f.e:
    geogebra.gui.inputbar.InputBarHelpPanel$RollOverListener this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.inputbar.InputBarHelpPanel$TableSelectionListener -> geogebra.gui.f.b$d:
    geogebra.gui.inputbar.InputBarHelpPanel this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.AutoCompleteTextField -> geogebra.gui.g.a:
    geogebra.main.Application app -> a
    java.lang.StringBuilder curWord -> a
    int curWordStart -> a
    geogebra.common.util.AutoCompleteDictionary dict -> a
    boolean isCASInput -> a
    boolean autoComplete -> b
    int historyIndex -> b
    java.util.ArrayList history -> a
    boolean handleEscapeKey -> f
    java.util.List completions -> a
    java.lang.String cmdPrefix -> a
    geogebra.gui.autocompletion.CompletionsPopup completionsPopup -> a
    geogebra.gui.inputfield.HistoryPopup historyPopup -> a
    geogebra.common.euclidian.DrawTextField drawTextField -> a
    boolean isEqualsRequired -> g
    java.util.regex.Pattern syntaxArgPattern -> a
    boolean ctrlC -> c
    java.util.ArrayList getHistory() -> a
    void addHistoryPopup(boolean) -> d
    void showPopupSymbolButton(boolean) -> a
    void setCASInput(boolean) -> e
    void setDictionary(geogebra.common.util.AutoCompleteDictionary) -> a
    void setAutoComplete(boolean) -> b
    java.util.List getCompletions() -> a
    boolean getAutoComplete() -> a
    java.lang.String getCurrentWord() -> a
    int getCurrentWordStart() -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setEqualsRequired(boolean) -> f
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void mergeKoreanDoubles() -> b
    void clearSelection() -> e
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void updateCurrentWord(boolean) -> g
    java.lang.String getWordAtPos(java.lang.String,int) -> a
    boolean isLetterOrDigit(char) -> a
    boolean moveToNextArgument(boolean) -> a
    java.util.List resetCompletions() -> b
    java.util.List getSyntaxes(java.util.List) -> a
    void startAutoCompletion() -> c
    void cancelAutoCompletion() -> d
    boolean validateAutoCompletion(int,java.util.List) -> a
    void addToHistory(java.lang.String) -> b
    java.lang.String getPreviousInput() -> b
    java.lang.String getNextInput() -> c
    void showCommandHelp(java.lang.String) -> c
    void showError(java.lang.Exception) -> a
    void showError(geogebra.common.main.MyError) -> a
    void setFont(geogebra.common.awt.Font) -> a
    void setPopupsFont(java.awt.Font) -> a
    void setForeground(geogebra.common.awt.Color) -> a
    void setBackground(geogebra.common.awt.Color) -> b
    void setLabel(geogebra.common.javax.swing.JLabel) -> a
    void addFocusListener(geogebra.common.euclidian.event.FocusListener) -> a
    void addKeyListener(geogebra.common.euclidian.event.KeyListener) -> a
    void wrapSetText(java.lang.String) -> a_
    geogebra.gui.inputfield.HistoryPopup access$0(geogebra.gui.inputfield.AutoCompleteTextField) -> a
geogebra.gui.inputfield.AutoCompleteTextField$1 -> geogebra.gui.g.b:
    geogebra.gui.inputfield.AutoCompleteTextField this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.inputfield.AutoCompleteTextField$2 -> geogebra.gui.g.c:
    geogebra.gui.inputfield.AutoCompleteTextField this$0 -> a
    java.lang.String val$s -> a
    void run() -> run
geogebra.gui.inputfield.BorderButton -> geogebra.gui.g.d:
    java.awt.Component borderOwner -> a
    javax.swing.ImageIcon[] icon -> a
    boolean[] isVisibleIcon -> a
    boolean[] isMouseOverIcon -> b
    java.awt.Rectangle[] iconRect -> a
    java.awt.event.ActionListener[] al -> a
    java.awt.Cursor otherCursor -> a
    boolean isMouseOverIconRegion -> a
    int maxIconCount -> a
    void paintBorder(java.awt.Component,java.awt.Graphics,int,int,int,int) -> paintBorder
    void setBorderButton(int,javax.swing.ImageIcon,java.awt.event.ActionListener) -> a
    void setIconVisible(int,boolean) -> a
    boolean isIconVisible(int) -> a
    int getTotalInsetWidth() -> a
    java.awt.Insets getBorderInsets(java.awt.Component) -> getBorderInsets
    boolean isBorderOpaque() -> isBorderOpaque
    void swapCursor() -> a
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
geogebra.gui.inputfield.GeoGebraComboBoxEditor -> geogebra.gui.g.e:
    geogebra.gui.inputfield.MyTextField tf -> a
    void addActionListener(java.awt.event.ActionListener) -> addActionListener
    java.awt.Component getEditorComponent() -> getEditorComponent
    java.lang.Object getItem() -> getItem
    void removeActionListener(java.awt.event.ActionListener) -> removeActionListener
    void selectAll() -> selectAll
    void setItem(java.lang.Object) -> setItem
geogebra.gui.inputfield.HistoryPopup -> geogebra.gui.g.f:
    geogebra.gui.inputfield.AutoCompleteTextField textField -> a
    javax.swing.JPopupMenu popup -> a
    javax.swing.JList historyList -> a
    boolean isDownPopup -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    javax.swing.DefaultListModel model -> a
    void setFont(java.awt.Font) -> a
    void registerListeners() -> b
    void showPopup() -> a
    boolean isDownPopup() -> a
    void setDownPopup(boolean) -> a
    boolean isPopupVisible() -> b
    void hidePopup() -> c
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void undoPopupChange() -> d
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    void navigateRelative(int) -> a
    geogebra.gui.inputfield.AutoCompleteTextField access$0(geogebra.gui.inputfield.HistoryPopup) -> a
    java.awt.event.KeyListener access$1(geogebra.gui.inputfield.HistoryPopup) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.inputfield.HistoryPopup) -> a
    void access$3(geogebra.gui.inputfield.HistoryPopup,java.awt.event.KeyListener[]) -> a
    javax.swing.JList access$4(geogebra.gui.inputfield.HistoryPopup) -> a
geogebra.gui.inputfield.HistoryPopup$1 -> geogebra.gui.g.g:
    geogebra.gui.inputfield.HistoryPopup this$0 -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.inputfield.HistoryPopup$2 -> geogebra.gui.g.h:
    geogebra.gui.inputfield.HistoryPopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.inputfield.HistoryPopup$3 -> geogebra.gui.g.i:
    geogebra.gui.inputfield.HistoryPopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.HistoryPopup$HistoryListCellRenderer -> geogebra.gui.g.f$a:
    javax.swing.border.Border gridBorder -> a
    geogebra.gui.inputfield.HistoryPopup this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.inputfield.HistoryPopup$PopupListener -> geogebra.gui.g.f$b:
    java.awt.event.KeyListener[] listListeners -> a
    geogebra.gui.inputfield.HistoryPopup this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
geogebra.gui.inputfield.MathTextField -> geogebra.gui.g.j:
    geogebra.gui.GeoGebraKeys ggbKeys -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
geogebra.gui.inputfield.MyFormattedTextField -> geogebra.gui.g.k:
    geogebra.gui.GuiManager guiManager -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void insertString(java.lang.String) -> a
geogebra.gui.inputfield.MyTextField -> geogebra.gui.g.l:
    geogebra.main.Application app -> a
    geogebra.gui.inputfield.SymbolTablePopup tablePopup -> a
    geogebra.gui.inputfield.MyTextField thisField -> a
    javax.swing.ImageIcon icon -> a
    javax.swing.ImageIcon rollOverIcon -> b
    boolean showSymbolTableIcon -> a
    boolean caretUpdated -> d
    boolean caretShowing -> e
    geogebra.gui.inputfield.BorderButton borderBtn -> a
    javax.swing.border.Border defaultBorder -> a
    boolean enableColoring -> b
    float pos -> a
    int caret -> a
    int scrollOffset -> b
    int width -> c
    int height -> d
    int textBottom -> e
    int fontHeight -> f
    java.awt.font.FontRenderContext frc -> a
    java.awt.Font font -> a
    java.awt.Graphics2D g2 -> a
    java.awt.Insets insets -> a
    void initField() -> b
    void enableColoring(boolean) -> c
    void setDefaultBorder() -> c
    void setBorderButton(int,javax.swing.ImageIcon,java.awt.event.ActionListener) -> a
    void setBorderButtonVisible(int,boolean) -> a
    boolean isBorderButtonVisible(int) -> a
    void setBorder(javax.swing.border.Border) -> setBorder
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void insertString(java.lang.String) -> a
    void setShowSymbolTableIcon(boolean) -> h
    geogebra.gui.inputfield.SymbolTablePopup getTablePopup() -> a
    void processKeyEvent(java.awt.event.KeyEvent) -> processKeyEvent
    void setLabels() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    float getLength(java.lang.String) -> a
    void drawText(java.lang.String,boolean,java.awt.Color) -> a
geogebra.gui.inputfield.MyTextField$1 -> geogebra.gui.g.m:
    geogebra.gui.inputfield.MyTextField this$0 -> a
    int val$newPos -> a
    void run() -> run
geogebra.gui.inputfield.SymbolTablePopup -> geogebra.gui.g.n:
    geogebra.gui.inputfield.MyTextField textField -> a
    javax.swing.JPopupMenu popup -> a
    java.awt.event.KeyListener keyListener -> a
    java.awt.event.KeyListener[] textFieldKeyListeners -> a
    geogebra.gui.util.SelectionTable symbolTable -> a
    geogebra.main.Application app -> a
    java.util.Locale locale -> a
    void createSymbolTable() -> c
    void setLabels() -> a
    void registerListeners() -> d
    java.awt.Point getCaretPixelPosition() -> a
    void showPopup(boolean) -> a
    boolean isPopupVisible() -> a
    void hidePopup() -> e
    void handleMouseClick(java.awt.event.MouseEvent) -> a
    void handlePopupSelection() -> b
    void handleSpecialKeys(java.awt.event.KeyEvent) -> a
    geogebra.gui.inputfield.MyTextField access$0(geogebra.gui.inputfield.SymbolTablePopup) -> a
    void access$1(geogebra.gui.inputfield.SymbolTablePopup,java.awt.event.KeyListener[]) -> a
    java.awt.event.KeyListener[] access$2(geogebra.gui.inputfield.SymbolTablePopup) -> a
    java.awt.event.KeyListener access$3(geogebra.gui.inputfield.SymbolTablePopup) -> a
geogebra.gui.inputfield.SymbolTablePopup$1 -> geogebra.gui.g.o:
    geogebra.gui.inputfield.SymbolTablePopup this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.inputfield.SymbolTablePopup$2 -> geogebra.gui.g.p:
    geogebra.gui.inputfield.SymbolTablePopup this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.inputfield.SymbolTablePopup$PopupListener -> geogebra.gui.g.n$a:
    geogebra.gui.inputfield.SymbolTablePopup this$0 -> a
    void popupMenuCanceled(javax.swing.event.PopupMenuEvent) -> popupMenuCanceled
    void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeVisible
    void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent) -> popupMenuWillBecomeInvisible
geogebra.gui.layout.DnDState -> geogebra.gui.h.a:
    geogebra.gui.layout.DockPanel source -> a
    geogebra.gui.layout.DockPanel target -> b
    int region -> a
    geogebra.gui.layout.DockPanel getSource() -> a
    void setTarget(geogebra.gui.layout.DockPanel) -> a
    geogebra.gui.layout.DockPanel getTarget() -> b
    void setRegion(int) -> a
    int getRegion() -> a
    boolean isRegionOut() -> a
geogebra.gui.layout.DockBar -> geogebra.gui.h.b:
    geogebra.main.Application app -> a
    geogebra.gui.layout.Layout layout -> a
    javax.swing.JPanel mainPanel -> a
    javax.swing.JPanel minimumPanel -> b
    geogebra.gui.layout.ViewButtonBar viewButtonBar -> a
    javax.swing.JButton btnConfigure -> a
    javax.swing.JButton btnGeoGebra -> b
    javax.swing.JButton btnView -> c
    javax.swing.JButton btnOptions -> d
    javax.swing.JButton btnTurtle -> e
    boolean isMinimized -> a
    boolean fullScreen -> b
    javax.swing.JPopupMenu viewPopupMenu -> a
    javax.swing.JPopupMenu optionsPopupMenu -> b
    void updateLayout() -> a
    void update() -> b
    void initGUI() -> d
    void initButtons() -> e
    void toggleFullScreen() -> f
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    javax.swing.JPanel getMinimizedPanel() -> a
    void createTurtle(int) -> a
    void showViewPopup(javax.swing.JComponent) -> a
    void showOptionsPopup(javax.swing.JComponent) -> b
    void updateViewButtons() -> c
    geogebra.main.Application access$0(geogebra.gui.layout.DockBar) -> a
    javax.swing.JPanel access$1(geogebra.gui.layout.DockBar) -> a
geogebra.gui.layout.DockBar$1 -> geogebra.gui.h.c:
    geogebra.gui.layout.DockBar this$0 -> a
    javax.swing.border.Border val$border -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.layout.DockBar$MyDialog -> geogebra.gui.h.b$a:
    geogebra.gui.layout.DockBar this$0 -> a
geogebra.gui.layout.DockBar$MyMouseListener -> geogebra.gui.h.b$b:
    geogebra.gui.layout.DockBar this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.layout.DockGlassPane -> geogebra.gui.h.d:
    boolean dragInProgress -> a
    java.awt.BasicStroke stroke -> a
    geogebra.gui.layout.DockManager dockManager -> a
    geogebra.gui.layout.DockPanel[] dockPanels -> a
    java.awt.Rectangle[] dockPanelsBounds -> a
    geogebra.gui.layout.DnDState dndState -> a
    java.awt.Rectangle previewRect -> a
    void startDrag(geogebra.gui.layout.DnDState) -> a
    void stopDrag() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    void mouseDragged(java.awt.event.MouseEvent) -> a
    void eventDispatched(java.awt.AWTEvent) -> eventDispatched
geogebra.gui.layout.DockManager -> geogebra.gui.h.e:
    geogebra.main.Application app -> a
    geogebra.gui.layout.Layout layout -> a
    boolean hasFullFocusSystem -> a
    geogebra.gui.layout.DockGlassPane glassPane -> a
    geogebra.gui.layout.DockSplitPane rootPane -> a
    geogebra.gui.layout.DockPanel focusedDockPanel -> a
    geogebra.gui.layout.panels.EuclidianDockPanelAbstract focusedEuclidianDockPanel -> a
    java.util.ArrayList dockPanels -> a
    geogebra.common.io.layout.Perspective restorePerspective -> a
    boolean isMaximized -> b
    void registerPanel(geogebra.gui.layout.DockPanel) -> a
    void applyPerspective(geogebra.common.io.layout.DockSplitPaneData[],geogebra.common.io.layout.DockPanelData[]) -> a
    void drag(geogebra.gui.layout.DockPanel) -> b
    void drop(geogebra.gui.layout.DnDState) -> a
    void show(int) -> a
    void show(geogebra.gui.layout.DockPanel) -> c
    void hide(int,boolean) -> a
    void hide(geogebra.gui.layout.DockPanel) -> d
    void hide(geogebra.gui.layout.DockPanel,boolean) -> a
    void eventDispatched(java.awt.AWTEvent) -> eventDispatched
    void setFocusedPanel(geogebra.gui.layout.DockPanel) -> e
    boolean setFocusedPanel(int) -> a
    geogebra.gui.layout.DockPanel getFocusedPanel() -> a
    geogebra.gui.layout.panels.EuclidianDockPanelAbstract getFocusedEuclidianPanel() -> a
    void moveFocus(boolean) -> a
    void markAlonePanel() -> f
    void unmarkAlonePanels() -> g
    java.util.Iterator getForwardBackwardIterator(boolean) -> a
    void setLabels() -> a
    void updateGlassPane() -> b
    void updatePanels() -> c
    void updateToolbars() -> d
    void setToolbarMode(int) -> b
    void updateFonts() -> e
    void scale(float,float) -> a
    void scale(float,float,geogebra.gui.layout.DockSplitPane) -> a
    geogebra.gui.layout.Layout getLayout() -> a
    geogebra.gui.layout.DockGlassPane getGlassPane() -> a
    geogebra.gui.layout.DockPanel getPanel(int) -> a
    geogebra.gui.layout.DockPanel[] getPanels() -> a
    geogebra.gui.layout.DockSplitPane getRoot() -> a
    boolean hasFullFocusSystem() -> a
    boolean isMaximized() -> b
    void undoMaximize(boolean) -> b
    void maximize(geogebra.gui.layout.DockPanel) -> f
geogebra.gui.layout.DockManager$1 -> geogebra.gui.h.f:
    geogebra.gui.layout.DockManager this$0 -> a
    java.util.ListIterator val$original -> a
    void remove() -> remove
    geogebra.gui.layout.DockPanel next() -> a
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
geogebra.gui.layout.DockPanel -> geogebra.gui.h.g:
    geogebra.gui.layout.DockManager dockManager -> a
    geogebra.main.Application app -> a
    int id -> a
    java.lang.String title -> a
    boolean visible -> b
    boolean hasFocus -> a
    java.awt.Rectangle frameBounds -> a
    boolean openInFrame -> c
    boolean hasStyleBar -> d
    javax.swing.JComponent styleBar -> b
    javax.swing.JPanel styleBarButtonPanel -> c
    boolean showStyleBar -> e
    java.lang.String embeddedDef -> b
    int embeddedSize -> b
    javax.swing.JPanel titlePanel -> a
    javax.swing.JLabel titleLabel -> a
    javax.swing.JPanel buttonPanel -> b
    javax.swing.JButton closeButton -> a
    javax.swing.JButton windowButton -> b
    javax.swing.JButton unwindowButton -> c
    javax.swing.JButton toggleStyleBarButton -> d
    javax.swing.JButton toggleStyleBarButton2 -> e
    javax.swing.JButton maximizeButton -> f
    javax.swing.JPanel styleBarPanel -> d
    javax.swing.JPanel toolbarPanel -> e
    geogebra.gui.toolbar.ToolbarContainer toolbarContainer -> a
    geogebra.gui.toolbar.Toolbar toolbar -> a
    java.lang.String toolbarString -> c
    java.lang.String defaultToolbarString -> d
    javax.swing.JFrame frame -> a
    javax.swing.JComponent component -> a
    int menuOrder -> c
    char menuShortcut -> a
    boolean isAlone -> f
    boolean isHidden -> g
    javax.swing.ImageIcon getIcon() -> a
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent getComponent() -> c
    void focusGained() -> a
    void focusLost() -> b
    javax.swing.JComponent createFocusPanel() -> d
    void register(geogebra.gui.layout.DockManager) -> a
    void createButtons() -> r
    java.lang.String getPlainTitle() -> c
    void createFrame() -> c
    void createFrame(boolean) -> a
    void removeFrame() -> d
    void updateTitleBar() -> e
    void setAlone(boolean) -> b
    boolean isAlone() -> a
    boolean isHidden() -> b
    void setHidden(boolean) -> c
    void updatePanel() -> f
    void updateToolbar() -> g
    void setToolbarMode(int) -> a
    void buildToolbarGui() -> h
    void updateLabels() -> i
    void updateFonts() -> j
    void updateTitle() -> k
    void closePanel(boolean) -> d
    void windowPanel() -> l
    void unwindowPanel() -> m
    void toggleStyleBar() -> n
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    geogebra.gui.layout.DockSplitPane getParentSplitPane() -> a
    java.lang.String calculateEmbeddedDef() -> d
    geogebra.common.io.layout.DockPanelData createInfo() -> a
    boolean isInFrame() -> c
    void setOpenInFrame(boolean) -> e
    boolean isOpenInFrame() -> d
    void setShowStyleBar(boolean) -> f
    boolean isStyleBarVisible() -> h
    void setFrameBounds(java.awt.Rectangle) -> a
    java.awt.Rectangle getFrameBounds() -> a
    void setEmbeddedDef(java.lang.String) -> a
    java.lang.String getEmbeddedDef() -> e
    void setEmbeddedSize(int) -> b
    int getEmbeddedSize() -> b
    boolean isVisible() -> isVisible
    void setVisible(boolean) -> setVisible
    boolean hasFocus() -> hasFocus
    void setFocus(boolean) -> g
    void setActiveToolBar() -> o
    void setTitleLabelFocus() -> p
    int getViewId() -> a
    java.lang.String getViewTitle() -> f
    int getMenuOrder() -> c
    boolean hasMenuShortcut() -> e
    char getMenuShortcut() -> a
    geogebra.gui.toolbar.Toolbar getToolbar() -> a
    boolean hasToolbar() -> f
    java.lang.String getToolbarString() -> a
    void setToolbarString(java.lang.String) -> b
    java.lang.String getDefaultToolbarString() -> b
    java.lang.String toString() -> toString
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    boolean isMaximized() -> g
    void toggleMaximize() -> q
geogebra.gui.layout.DockPanel$1 -> geogebra.gui.h.h:
    geogebra.gui.layout.DockPanel this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
geogebra.gui.layout.DockPanel$MenuOrderComparator -> geogebra.gui.h.g$a:
    int compare(geogebra.gui.layout.DockPanel,geogebra.gui.layout.DockPanel) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.layout.DockSplitPane -> geogebra.gui.h.i:
    boolean dividerVisible -> a
    java.beans.PropertyChangeListener paneResizeListener -> a
    java.awt.Component getOpposite(java.awt.Component) -> a
    void setLeftComponent(java.awt.Component) -> setLeftComponent
    void setRightComponent(java.awt.Component) -> setRightComponent
    void replaceComponent(java.awt.Component,java.awt.Component) -> a
    void updateDivider() -> a
    void updateUI() -> updateUI
geogebra.gui.layout.DockSplitPane$1 -> geogebra.gui.h.j:
    geogebra.gui.layout.DockSplitPane this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.layout.DockSplitPane$TreeReader -> geogebra.gui.h.i$a:
    geogebra.main.Application app -> a
    java.util.ArrayList splitPaneInfo -> a
    int windowWidth -> a
    int windowHeight -> b
    geogebra.common.io.layout.DockSplitPaneData[] getInfo(geogebra.gui.layout.DockSplitPane) -> a
    void saveSplitPane(java.lang.String,geogebra.gui.layout.DockSplitPane) -> a
geogebra.gui.layout.Layout -> geogebra.gui.h.k:
    boolean isInitialized -> a
    geogebra.main.Application app -> a
    geogebra.gui.layout.DockManager dockManager -> a
    void initialize(geogebra.main.Application) -> a
    void registerPanel(geogebra.gui.layout.DockPanel) -> a
    void applyPerspective(geogebra.common.io.layout.Perspective) -> a
    void applyPerspective(java.lang.String) -> a
    geogebra.common.io.layout.Perspective createPerspective(java.lang.String) -> a
    geogebra.common.io.layout.Perspective[] getPerspectives() -> a
    geogebra.common.io.layout.Perspective getPerspective(int) -> a
    geogebra.common.io.layout.Perspective getPerspective(java.lang.String) -> b
    void addPerspective(geogebra.common.io.layout.Perspective) -> b
    void removePerspective(int) -> a
    void getXml(java.lang.StringBuilder,boolean) -> a
    boolean inExternalWindow(java.awt.Component) -> a
    boolean isOnlyVisible(int) -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    geogebra.main.Application getApplication() -> a
    geogebra.gui.layout.DockManager getDockManager() -> a
    javax.swing.JComponent getRootComponent() -> a
    void showSaveDialog() -> a
    void showManageDialog() -> b
    geogebra.main.Application access$0(geogebra.gui.layout.Layout) -> a
geogebra.gui.layout.Layout$1 -> geogebra.gui.h.l:
    geogebra.gui.layout.Layout this$0 -> a
    int compare(geogebra.common.io.layout.DockPanelData,geogebra.common.io.layout.DockPanelData) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.layout.Layout$ManagePerspectivesDialog -> geogebra.gui.h.k$a:
    geogebra.main.Application app -> a
    geogebra.gui.layout.Layout layout -> b
    javax.swing.JList list -> a
    javax.swing.DefaultListModel listModel -> a
    javax.swing.JButton cancelButton -> a
    javax.swing.JButton removeButton -> b
    geogebra.gui.layout.Layout this$0 -> a
    void buildGUI() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateRemoveButton() -> b
geogebra.gui.layout.Layout$SaveInputHandler -> geogebra.gui.h.k$b:
    geogebra.gui.layout.Layout layout -> b
    geogebra.gui.layout.Layout this$0 -> a
    boolean processInput(java.lang.String) -> a
geogebra.gui.layout.ViewButtonBar -> geogebra.gui.h.m:
    geogebra.main.Application app -> a
    geogebra.gui.layout.Layout layout -> a
    java.util.ArrayList viewButtons -> a
    void buildToolBar() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateViewButtons() -> a
    void updateViewButtonVisibility() -> b
geogebra.gui.layout.ViewButtonBar$ViewButton -> geogebra.gui.h.m$a:
    int viewID -> a
    geogebra.gui.layout.ViewButtonBar this$0 -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void setBorderPainted(boolean) -> setBorderPainted
    void setContentAreaFilled(boolean) -> setContentAreaFilled
    int getViewID() -> a
    void setViewID(int) -> a
geogebra.gui.layout.panels.AlgebraDockPanel -> geogebra.gui.h.a.a:
    geogebra.main.Application app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    void setActiveToolBar() -> o
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.AssignmentDockPanel -> geogebra.gui.h.a.b:
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
geogebra.gui.layout.panels.CasDockPanel -> geogebra.gui.h.a.c:
    geogebra.main.Application appCas -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    java.lang.String getDefaultToolbar() -> g
    void setActiveToolBar() -> o
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.ConstructionProtocolDockPanel -> geogebra.gui.h.a.d:
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.ErrorDockPanel -> geogebra.gui.h.a.e:
    javax.swing.JComponent loadComponent() -> b
    void updatePanel() -> f
    void setFocus(boolean) -> g
geogebra.gui.layout.panels.Euclidian2DockPanel -> geogebra.gui.h.a.f:
    geogebra.main.Application app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.EuclidianDockPanel -> geogebra.gui.h.a.g:
    geogebra.main.Application app -> b
    javax.swing.JPanel panel -> c
    javax.swing.JComponent consProtNav -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.layout.panels.EuclidianDockPanelAbstract -> geogebra.gui.h.a.h:
    boolean hasEuclidianFocus -> b
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
    void setEuclidianFocus(boolean) -> h
    javax.swing.JComponent createFocusPanel() -> d
geogebra.gui.layout.panels.ProbabilityCalculatorDockPanel -> geogebra.gui.h.a.i:
    geogebra.main.Application app -> b
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
geogebra.gui.layout.panels.PropertiesDockPanel -> geogebra.gui.h.a.j:
    geogebra.main.Application app -> b
    geogebra.gui.view.properties.PropertiesView view -> a
    javax.swing.JDialog dialog -> a
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    void windowPanel() -> l
    void unwindowPanel() -> m
    javax.swing.ImageIcon getIcon() -> a
    void createFrame() -> c
    void removeFrame() -> d
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
geogebra.gui.layout.panels.SpreadsheetDockPanel -> geogebra.gui.h.a.k:
    geogebra.main.Application app -> b
    javax.swing.JComponent loadStyleBar() -> a
    javax.swing.JComponent loadComponent() -> b
    void focusGained() -> a
    void focusLost() -> b
    java.lang.String getDefaultToolbar() -> g
    javax.swing.ImageIcon getIcon() -> a
geogebra.gui.menubar.BaseMenu -> geogebra.gui.i.a:
    geogebra.main.Application app -> a
    void update() -> a
    void setMenuShortCutAccelerator(javax.swing.JMenuItem,char) -> a
    void setMenuShortCutShiftAccelerator(javax.swing.JMenuItem,char) -> b
    void setMenuShortCutShiftAltAccelerator(javax.swing.JMenuItem,char) -> c
geogebra.gui.menubar.EditMenu -> geogebra.gui.i.b:
    javax.swing.AbstractAction deleteAction -> a
    javax.swing.AbstractAction invertAction -> b
    javax.swing.AbstractAction showhideAction -> c
    javax.swing.AbstractAction showhideLabelsAction -> d
    javax.swing.AbstractAction propertiesAction -> e
    javax.swing.AbstractAction selectAllAction -> f
    javax.swing.AbstractAction selectAllAncestorsAction -> g
    javax.swing.AbstractAction selectAllDescendantsAction -> h
    javax.swing.AbstractAction selectCurrentLayerAction -> i
    javax.swing.AbstractAction copyToClipboardAction -> j
    javax.swing.AbstractAction copyAction -> k
    javax.swing.AbstractAction pasteAction -> l
    javax.swing.JMenuItem deleteItem -> a
    javax.swing.JMenuItem invertItem -> b
    javax.swing.JMenuItem showhideItem -> c
    javax.swing.JMenuItem showhideLabelsItem -> d
    javax.swing.JMenuItem selectAllItem -> e
    javax.swing.JMenuItem selectAllAncestorsItem -> f
    javax.swing.JMenuItem selectAllDescendantsItem -> g
    javax.swing.JMenuItem selectCurrentLayerItem -> h
    javax.swing.JMenuItem copyToClipboardItem -> i
    javax.swing.JMenuItem copyItem -> j
    javax.swing.JMenuItem pasteItem -> k
    javax.swing.JSeparator selectionSeparator -> a
    javax.swing.JSeparator deleteSeparator -> b
    void initItems() -> c
    void initActions() -> d
    int getSelectedLayer() -> a
    void update() -> a
    void updateSelection() -> b
    int access$0(geogebra.gui.menubar.EditMenu) -> a
geogebra.gui.menubar.EditMenu$1 -> geogebra.gui.i.c:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$10 -> geogebra.gui.i.d:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$11 -> geogebra.gui.i.e:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$12 -> geogebra.gui.i.f:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$2 -> geogebra.gui.i.g:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$3 -> geogebra.gui.i.h:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$4 -> geogebra.gui.i.i:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$5 -> geogebra.gui.i.j:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$6 -> geogebra.gui.i.k:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$7 -> geogebra.gui.i.l:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$8 -> geogebra.gui.i.m:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.EditMenu$9 -> geogebra.gui.i.n:
    geogebra.gui.menubar.EditMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu -> geogebra.gui.i.o:
    javax.swing.AbstractAction newWindowAction -> a
    javax.swing.AbstractAction deleteAll -> b
    javax.swing.AbstractAction saveAction -> c
    javax.swing.AbstractAction saveAsAction -> d
    javax.swing.AbstractAction loadAction -> e
    javax.swing.AbstractAction loadURLAction -> f
    javax.swing.AbstractAction exportWorksheet -> g
    javax.swing.AbstractAction shareAction -> h
    javax.swing.AbstractAction exportGraphicAction -> i
    javax.swing.AbstractAction exportAnimationAction -> j
    javax.swing.AbstractAction exportPgfAction -> k
    javax.swing.AbstractAction exportPSTricksAction -> l
    javax.swing.AbstractAction exportAsymptoteAction -> m
    javax.swing.AbstractAction exportGeoGebraTubeAction -> n
    javax.swing.AbstractAction drawingPadToClipboardAction -> o
    javax.swing.AbstractAction printEuclidianViewAction -> p
    javax.swing.AbstractAction exitAction -> q
    javax.swing.AbstractAction exitAllAction -> r
    void updateItems() -> b
    void initActions() -> c
    void update() -> a
    javax.swing.AbstractAction access$0(geogebra.gui.menubar.FileMenu) -> a
geogebra.gui.menubar.FileMenu$1 -> geogebra.gui.i.p:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$10 -> geogebra.gui.i.q:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$11 -> geogebra.gui.i.r:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$11) -> a
geogebra.gui.menubar.FileMenu$11$1 -> geogebra.gui.i.s:
    geogebra.gui.menubar.FileMenu$11 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$12 -> geogebra.gui.i.t:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$12) -> a
geogebra.gui.menubar.FileMenu$12$1 -> geogebra.gui.i.u:
    geogebra.gui.menubar.FileMenu$12 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$13 -> geogebra.gui.i.v:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$14 -> geogebra.gui.i.w:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$15 -> geogebra.gui.i.x:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$16 -> geogebra.gui.i.y:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$17 -> geogebra.gui.i.z:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$17) -> a
geogebra.gui.menubar.FileMenu$17$1 -> geogebra.gui.i.A:
    geogebra.gui.menubar.FileMenu$17 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$18 -> geogebra.gui.i.B:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$18) -> a
geogebra.gui.menubar.FileMenu$18$1 -> geogebra.gui.i.C:
    geogebra.gui.menubar.FileMenu$18 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$2 -> geogebra.gui.i.D:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.FileMenu access$0(geogebra.gui.menubar.FileMenu$2) -> a
geogebra.gui.menubar.FileMenu$2$1 -> geogebra.gui.i.E:
    geogebra.gui.menubar.FileMenu$2 this$1 -> a
    void run() -> run
geogebra.gui.menubar.FileMenu$3 -> geogebra.gui.i.F:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$4 -> geogebra.gui.i.G:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$5 -> geogebra.gui.i.H:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$6 -> geogebra.gui.i.I:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$7 -> geogebra.gui.i.J:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$8 -> geogebra.gui.i.K:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.FileMenu$9 -> geogebra.gui.i.L:
    geogebra.gui.menubar.FileMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.GeoGebraMenuBar -> geogebra.gui.i.M:
    geogebra.gui.menubar.BaseMenu fileMenu -> a
    geogebra.gui.menubar.BaseMenu editMenu -> b
    geogebra.gui.menubar.BaseMenu viewMenu -> c
    geogebra.gui.menubar.BaseMenu perspectivesMenu -> d
    geogebra.gui.menubar.BaseMenu optionsMenu -> e
    geogebra.gui.menubar.BaseMenu toolsMenu -> f
    geogebra.gui.menubar.BaseMenu windowMenu -> g
    geogebra.gui.menubar.BaseMenu helpMenu -> h
    geogebra.main.Application app -> a
    geogebra.gui.layout.Layout layout -> a
    int[] $SWITCH_TABLE$geogebra$common$main$AbstractApplication$CasType -> a
    void initMenubar() -> a
    void updateMenubar() -> b
    void updateSelection() -> c
    void updateMenuFile() -> d
    void updateMenuWindow() -> e
    void updateFonts() -> f
    void setMenuFontRecursive(javax.swing.JMenuItem,java.awt.Font) -> a
    void showPrintPreview(geogebra.main.Application) -> a
    void showAboutDialog(geogebra.main.Application) -> b
    int[] $SWITCH_TABLE$geogebra$common$main$AbstractApplication$CasType() -> a
geogebra.gui.menubar.GeoGebraMenuBar$1 -> geogebra.gui.i.N:
    geogebra.main.Application val$app -> a
    void run() -> run
geogebra.gui.menubar.GeoGebraMenuBar$2 -> geogebra.gui.i.O:
    java.lang.StringBuilder val$vsb -> a
    geogebra.main.Application val$app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu -> geogebra.gui.i.P:
    javax.swing.AbstractAction helpAction -> a
    javax.swing.AbstractAction tutorialAction -> b
    javax.swing.AbstractAction websiteAction -> c
    javax.swing.AbstractAction forumAction -> d
    javax.swing.AbstractAction geogebratubeAction -> e
    javax.swing.AbstractAction infoAction -> f
    void initItems() -> b
    void initActions() -> c
    void update() -> a
geogebra.gui.menubar.HelpMenu$1 -> geogebra.gui.i.Q:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu$2 -> geogebra.gui.i.R:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu$3 -> geogebra.gui.i.S:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.HelpMenu$4 -> geogebra.gui.i.T:
    geogebra.gui.menubar.HelpMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.LoadFileListener -> geogebra.gui.i.U:
    geogebra.main.Application app -> a
    java.io.File file -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenu -> geogebra.gui.i.V:
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.AbstractAction showOptionsAction -> a
    javax.swing.JMenu menuPointCapturing -> a
    javax.swing.JMenu menuDecimalPlaces -> b
    javax.swing.JMenu menuLabeling -> c
    javax.swing.JMenu menuAlgebraStyle -> d
    void initItems() -> b
    void addRadioButtonMenuItems(javax.swing.JMenu,java.awt.event.ActionListener,java.lang.String[],java.lang.String[],int) -> a
    void addLanguageMenuItems(javax.swing.JMenu,java.awt.event.ActionListener) -> a
    void initActions() -> c
    void update() -> a
    void updateMenuViewDescription() -> d
    void updateMenuPointCapturing() -> e
    void updateMenuLabeling() -> f
    void updateMenuDecimalPlaces() -> g
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.common.kernel.Kernel access$0(geogebra.gui.menubar.OptionsMenu) -> a
geogebra.gui.menubar.OptionsMenu$1 -> geogebra.gui.i.W:
    geogebra.gui.menubar.OptionsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenu$2 -> geogebra.gui.i.X:
    geogebra.gui.menubar.OptionsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.OptionsMenu$LanguageActionListener -> geogebra.gui.i.V$a:
    geogebra.gui.menubar.OptionsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.PerspectivesMenu -> geogebra.gui.i.Y:
    geogebra.gui.layout.Layout layout -> a
    javax.swing.AbstractAction changePerspectiveAction -> a
    javax.swing.AbstractAction managePerspectivesAction -> b
    javax.swing.AbstractAction savePerspectiveAction -> c
    void initItems() -> b
    void initActions() -> c
    void update() -> a
    geogebra.gui.layout.Layout access$0(geogebra.gui.menubar.PerspectivesMenu) -> a
geogebra.gui.menubar.PerspectivesMenu$1 -> geogebra.gui.i.Z:
    geogebra.gui.menubar.PerspectivesMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.PerspectivesMenu$2 -> geogebra.gui.i.aa:
    geogebra.gui.menubar.PerspectivesMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.PerspectivesMenu$3 -> geogebra.gui.i.ab:
    geogebra.gui.menubar.PerspectivesMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.RequestFocusListener -> geogebra.gui.i.ac:
    javax.swing.JFrame frame -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu -> geogebra.gui.i.ad:
    javax.swing.AbstractAction toolbarConfigAction -> a
    javax.swing.AbstractAction showCreateToolsAction -> b
    javax.swing.AbstractAction showManageToolsAction -> c
    javax.swing.AbstractAction modeChangeAction -> d
    void updateItems() -> b
    void initActions() -> c
    void update() -> a
geogebra.gui.menubar.ToolsMenu$1 -> geogebra.gui.i.ae:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu$2 -> geogebra.gui.i.af:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu$3 -> geogebra.gui.i.ag:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ToolsMenu$4 -> geogebra.gui.i.ah:
    geogebra.gui.menubar.ToolsMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu -> geogebra.gui.i.ai:
    geogebra.gui.layout.Layout layout -> a
    javax.swing.AbstractAction showAlgebraInputAction -> a
    javax.swing.AbstractAction showKeyboardAction -> b
    javax.swing.AbstractAction showPythonAction -> c
    javax.swing.AbstractAction showKinectAction -> d
    javax.swing.AbstractAction showInputHelpToggleAction -> e
    javax.swing.AbstractAction showInputTopAction -> f
    javax.swing.AbstractAction showToolBarAction -> g
    javax.swing.AbstractAction showToolBarTopAction -> h
    javax.swing.AbstractAction showConsProtNavigationAction -> i
    javax.swing.AbstractAction showConsProtNavigationOpenProtAction -> j
    javax.swing.AbstractAction showConsProtNavigationPlayAction -> k
    javax.swing.AbstractAction refreshAction -> l
    javax.swing.AbstractAction recomputeAllViews -> m
    javax.swing.JCheckBoxMenuItem cbShowInputTop -> a
    javax.swing.JCheckBoxMenuItem cbShowToolBar -> b
    javax.swing.JCheckBoxMenuItem cbShowToolBarTop -> c
    javax.swing.JCheckBoxMenuItem cbShowConsProtNavigation -> d
    javax.swing.JCheckBoxMenuItem cbShowConsProtNavigationPlay -> e
    javax.swing.JCheckBoxMenuItem cbShowConsProtNavigationOpenProt -> f
    javax.swing.JCheckBoxMenuItem cbShowAlgebraInput -> g
    javax.swing.JCheckBoxMenuItem cbShowKeyboard -> h
    javax.swing.JCheckBoxMenuItem cbShowPython -> i
    javax.swing.JCheckBoxMenuItem cbShowKinect -> j
    javax.swing.JCheckBoxMenuItem cbShowInputHelpToggle -> k
    javax.swing.JCheckBoxMenuItem cbShowAxes -> l
    javax.swing.JCheckBoxMenuItem cbShowGrid -> m
    javax.swing.AbstractAction[] showViews -> a
    javax.swing.JCheckBoxMenuItem[] cbViews -> a
    javax.swing.JMenu menuConsProtNav -> a
    javax.swing.JMenu menuInput -> b
    javax.swing.JMenu menuToolBar -> c
    void updateItems() -> b
    void initItems() -> c
    void initActions() -> d
    void update() -> a
    void initViewActions() -> e
    void initViewItems(javax.swing.JMenu) -> a
    void updateViews() -> f
    void setPopupMenuVisible(boolean) -> setPopupMenuVisible
geogebra.gui.menubar.ViewMenu$1 -> geogebra.gui.i.aj:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$10 -> geogebra.gui.i.ak:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$11 -> geogebra.gui.i.al:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$12 -> geogebra.gui.i.am:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$13 -> geogebra.gui.i.an:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$14 -> geogebra.gui.i.ao:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$15 -> geogebra.gui.i.ap:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    int val$viewId -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$2 -> geogebra.gui.i.aq:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$3 -> geogebra.gui.i.ar:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$3$1 -> geogebra.gui.i.as:
    geogebra.gui.menubar.ViewMenu$3 this$1 -> a
    geogebra.plugin.kinect.KinectTestApplication val$app2 -> a
    void run() -> run
geogebra.gui.menubar.ViewMenu$4 -> geogebra.gui.i.at:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$5 -> geogebra.gui.i.au:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$6 -> geogebra.gui.i.av:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$7 -> geogebra.gui.i.aw:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$8 -> geogebra.gui.i.ax:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.ViewMenu$9 -> geogebra.gui.i.ay:
    geogebra.gui.menubar.ViewMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.menubar.WindowMenu -> geogebra.gui.i.az:
    javax.swing.AbstractAction newWindowAction -> a
    void updateItems() -> b
    void initActions() -> c
    void update() -> a
geogebra.gui.menubar.WindowMenu$1 -> geogebra.gui.i.aA:
    geogebra.gui.menubar.WindowMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.menubar.WindowMenu access$0(geogebra.gui.menubar.WindowMenu$1) -> a
geogebra.gui.menubar.WindowMenu$1$1 -> geogebra.gui.i.aB:
    geogebra.gui.menubar.WindowMenu$1 this$1 -> a
    void run() -> run
geogebra.gui.properties.AnimationSpeedPanel -> geogebra.gui.j.a:
    java.lang.Object[] geos -> a
    javax.swing.JTextField tfAnimSpeed -> a
    boolean partOfSliderPanel -> a
    javax.swing.JComboBox animationModeCB -> a
    javax.swing.JLabel modeLabel -> a
    javax.swing.JLabel speedLabel -> b
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    void setPartOfSliderPanel() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> c
    void setType(int) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.properties.AnimationStepPanel -> geogebra.gui.j.b:
    java.lang.Object[] geos -> a
    javax.swing.JLabel label -> a
    geogebra.gui.AngleTextField tfAnimStep -> a
    boolean partOfSliderPanel -> a
    geogebra.common.kernel.Kernel kernel -> a
    void setLabels() -> a
    void setPartOfSliderPanel() -> b
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed() -> c
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.properties.SliderPanel -> geogebra.gui.j.c:
    java.lang.Object[] geos -> a
    geogebra.gui.AngleTextField tfMin -> a
    geogebra.gui.AngleTextField tfMax -> b
    javax.swing.JTextField tfWidth -> a
    javax.swing.JTextField[] tfields -> a
    javax.swing.JLabel[] tLabels -> a
    javax.swing.JCheckBox cbSliderFixed -> a
    javax.swing.JCheckBox cbRandom -> b
    javax.swing.JComboBox coSliderHorizontal -> a
    geogebra.main.Application app -> a
    geogebra.gui.properties.AnimationStepPanel stepPanel -> a
    geogebra.gui.properties.AnimationSpeedPanel speedPanel -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.dialog.PropertiesPanel propPanel -> a
    javax.swing.JPanel intervalPanel -> a
    javax.swing.JPanel sliderPanel -> b
    javax.swing.JPanel animationPanel -> c
    boolean useTabbedPane -> a
    boolean includeRandom -> b
    boolean actionPerforming -> c
    void initPanels() -> b
    void setLabels() -> a
    javax.swing.JPanel update(java.lang.Object[]) -> a
    boolean checkGeos(java.lang.Object[]) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doCheckBoxActionPerformed(javax.swing.JCheckBox) -> a
    void doRandomActionPerformed(javax.swing.JCheckBox) -> b
    void doComboBoxActionPerformed(javax.swing.JComboBox) -> a
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.properties.UpdateablePropertiesPanel -> geogebra.gui.j.d:
    javax.swing.JPanel update(java.lang.Object[]) -> a
    void setVisible(boolean) -> setVisible
geogebra.gui.toolbar.ModeCellRenderer -> geogebra.gui.k.a:
    geogebra.main.Application app -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
    void handleRootNode(javax.swing.tree.DefaultMutableTreeNode) -> a
    void handleModeNode(int) -> a
    void handleSelection(boolean) -> a
geogebra.gui.toolbar.ModeToggleButtonGroup -> geogebra.gui.k.b:
    geogebra.common.javax.swing.JPopupMenu activePopMenu -> a
    void setActivePopupMenu(geogebra.common.javax.swing.JPopupMenu) -> a
    geogebra.common.javax.swing.JPopupMenu getActivePopupMenu() -> a
geogebra.gui.toolbar.ModeToggleMenu -> geogebra.gui.k.c:
    geogebra.gui.toolbar.ModeToggleButtonGroup bg -> a
    geogebra.gui.toolbar.MyJToggleButton tbutton -> a
    geogebra.gui.toolbar.MyJToggleButton mouseOverButton -> b
    javax.swing.JPopupMenu popMenu -> a
    java.util.ArrayList menuItemList -> a
    java.awt.event.ActionListener popupMenuItemListener -> a
    geogebra.main.Application app -> a
    int size -> a
    java.awt.Color bgColor -> a
    int getToolsCount() -> a
    javax.swing.JToggleButton getJToggleButton() -> a
    boolean selectMode(int) -> a
    int getFirstMode() -> b
    void selectItem(javax.swing.JMenuItem) -> a
    void addMode(int) -> a
    void addSeparator() -> a
    void setMouseOverButton(geogebra.gui.toolbar.MyJToggleButton) -> a
    javax.swing.JToggleButton getMouseOverButton() -> b
    void mouseOver() -> b
    void setPopupVisible(boolean) -> a
    boolean isPopupShowing() -> a
    void setMode(int) -> b
    void access$0(geogebra.gui.toolbar.ModeToggleMenu,javax.swing.JMenuItem) -> a
    geogebra.gui.toolbar.MyJToggleButton access$1(geogebra.gui.toolbar.ModeToggleMenu) -> a
geogebra.gui.toolbar.ModeToggleMenu$MenuItemListener -> geogebra.gui.k.c$a:
    geogebra.gui.toolbar.ModeToggleMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.MyJToggleButton -> geogebra.gui.k.d:
    int BORDER -> a
    int iconWidth -> b
    int iconHeight -> c
    java.awt.geom.GeneralPath gp -> a
    boolean showToolTipText -> c
    boolean popupTriangleHighlighting -> a
    boolean popupTriangleClicked -> b
    geogebra.gui.toolbar.ModeToggleMenu menu -> a
    java.awt.Color arrowColor -> a
    java.awt.Color selColor -> b
    java.awt.BasicStroke selStroke -> a
    javax.swing.Timer showMenuTimer -> a
    java.lang.String getToolTipText() -> getToolTipText
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setIcon(javax.swing.Icon) -> setIcon
    void paint(java.awt.Graphics) -> paint
    void initPath() -> a
    boolean popupTriangleClicked(int,int) -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void doClick() -> doClick
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    geogebra.gui.toolbar.ModeToggleMenu access$0(geogebra.gui.toolbar.MyJToggleButton) -> a
geogebra.gui.toolbar.MyJToggleButton$1 -> geogebra.gui.k.e:
    geogebra.gui.toolbar.MyJToggleButton this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.Toolbar -> geogebra.gui.k.f:
    geogebra.main.Application app -> a
    geogebra.common.gui.layout.DockPanel dockPanel -> a
    int mode -> a
    java.util.ArrayList modeToggleMenus -> a
    void buildGui() -> a
    int setMode(int) -> a
    int getSelectedMode() -> a
    int getFirstMode() -> b
    void addCustomModesToToolbar(geogebra.gui.toolbar.ModeToggleButtonGroup) -> a
    boolean containsMode(int) -> a
    geogebra.common.gui.layout.DockPanel getDockPanel() -> a
    java.lang.String getDefaultToolbarString() -> a
    java.lang.String getAllTools(geogebra.main.Application) -> a
geogebra.gui.toolbar.ToolbarConfigDialog -> geogebra.gui.k.g:
    geogebra.main.Application app -> a
    geogebra.gui.toolbar.ToolbarConfigPanel confPanel -> a
    void apply() -> a
    javax.swing.JPanel createButtonPanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarConfigDialog$1 -> geogebra.gui.k.h:
    geogebra.gui.toolbar.ToolbarConfigDialog this$0 -> a
    javax.swing.JButton val$btApply -> a
    javax.swing.JButton val$btCancel -> b
    javax.swing.JButton val$btDefaultToolbar -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.toolbar.ToolbarConfigDialog$KeyValue -> geogebra.gui.k.g$a:
    int key -> a
    java.lang.String value -> a
    geogebra.gui.toolbar.ToolbarConfigDialog this$0 -> a
    int getKey() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
geogebra.gui.toolbar.ToolbarConfigPanel -> geogebra.gui.k.i:
    geogebra.gui.layout.DockPanel dockPanel -> a
    javax.swing.JButton insertButton -> a
    javax.swing.JButton moveUpButton -> b
    javax.swing.JButton moveDownButton -> c
    javax.swing.JButton deleteButton -> d
    javax.swing.JTree tree -> a
    javax.swing.JScrollPane configScrollPane -> a
    javax.swing.JScrollPane modeScrollPane -> b
    javax.swing.JPanel selectionPanel -> a
    javax.swing.JList toolList -> a
    javax.swing.DefaultListModel toolListModel -> a
    geogebra.main.Application app -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean containsTool(javax.swing.tree.DefaultMutableTreeNode,java.lang.Integer) -> a
    void setToolbar(geogebra.gui.layout.DockPanel,java.lang.String) -> a
    void apply() -> a
    void resetDefaultToolbar() -> b
    java.lang.String getToolBarString() -> a
    void collapseAllRows() -> c
    java.util.Vector generateToolsVector(java.lang.String) -> a
    javax.swing.JTree generateTree() -> a
    javax.swing.tree.DefaultMutableTreeNode generateRootNode(java.util.Vector) -> a
    void sortToolList() -> d
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
geogebra.gui.toolbar.ToolbarConfigPanel$1 -> geogebra.gui.k.j:
    geogebra.gui.toolbar.ToolbarConfigPanel this$0 -> a
    void setExpandedState(javax.swing.tree.TreePath,boolean) -> setExpandedState
geogebra.gui.toolbar.ToolbarContainer -> geogebra.gui.k.k:
    boolean showHelp -> a
    geogebra.main.Application app -> a
    boolean isMain -> b
    javax.swing.JPanel toolbarHelpPanel -> a
    javax.swing.JLabel modeNameLabel -> a
    geogebra.gui.toolbar.ToolbarContainer$ToolbarPanel toolbarPanel -> a
    java.util.ArrayList toolbars -> a
    int activeToolbar -> a
    geogebra.gui.layout.ViewButtonBar viewButtonBar -> a
    int oldWidth -> b
    java.awt.event.MouseAdapter helpMouseAdapter -> a
    void buildGui() -> a
    int setMode(int) -> a
    void setActiveToolbar(geogebra.gui.toolbar.Toolbar) -> a
    void setActiveToolbar(int) -> a
    void updateToolbarPanel() -> b
    void addToolbar(geogebra.gui.toolbar.Toolbar) -> b
    void removeToolbar(geogebra.gui.toolbar.Toolbar) -> c
    geogebra.gui.toolbar.Toolbar getToolbar(int) -> a
    int getViewId(geogebra.gui.toolbar.Toolbar) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void updateHelpText() -> c
    void resolveMouseListener(int) -> b
    java.lang.String wrappedModeText(java.lang.String,java.lang.String,javax.swing.JPanel) -> a
    geogebra.gui.toolbar.Toolbar getFirstToolbar() -> a
    void setShowHelp(boolean) -> a
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
geogebra.gui.toolbar.ToolbarContainer$1 -> geogebra.gui.k.l:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    java.lang.String val$modeName -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.toolbar.ToolbarContainer$ToolbarPanel -> geogebra.gui.k.k$a:
    geogebra.gui.toolbar.ToolbarContainer this$0 -> a
    void show(java.lang.String) -> a
    void add(java.awt.Component,java.lang.String) -> a
geogebra.gui.util.AnimatedGifEncoder -> geogebra.gui.l.a:
    int width -> a
    int height -> b
    java.awt.Color transparent -> a
    int transIndex -> c
    int repeat -> d
    int delay -> e
    boolean started -> a
    java.io.OutputStream out -> a
    java.awt.image.BufferedImage image -> a
    byte[] pixels -> a
    byte[] indexedPixels -> b
    int colorDepth -> f
    byte[] colorTab -> c
    boolean[] usedEntry -> a
    int palSize -> g
    int dispose -> h
    boolean closeStream -> b
    boolean firstFrame -> c
    boolean sizeSet -> d
    int sample -> i
    void setDelay(int) -> a
    void setRepeat(int) -> b
    boolean addFrame(java.awt.image.BufferedImage) -> a
    boolean finish() -> a
    void setSize(int,int) -> a
    boolean start(java.io.OutputStream) -> a
    boolean start(java.io.File) -> a
    void analyzePixels() -> a
    int findClosest(java.awt.Color) -> a
    void getImagePixels() -> b
    void writeGraphicCtrlExt() -> c
    void writeImageDesc() -> d
    void writeLSD() -> e
    void writeNetscapeExt() -> f
    void writePalette() -> g
    void writePixels() -> h
    void writeShort(int) -> c
    void writeString(java.lang.String) -> a
geogebra.gui.util.BrowserLauncher -> geogebra.gui.l.b:
    void openURL(java.lang.String) -> a
geogebra.gui.util.FileTransferable -> geogebra.gui.l.c:
    java.awt.datatransfer.DataFlavor[] dataFlavors -> a
    java.util.List files -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.util.FullWidthLayout -> geogebra.gui.l.d:
    int vgap -> a
    int minWidth -> b
    int minHeight -> c
    int preferredWidth -> d
    int preferredHeight -> e
    boolean sizeUnknown -> a
    void calculateSizes(java.awt.Container) -> a
    java.awt.Dimension preferredLayoutSize(java.awt.Container) -> preferredLayoutSize
    java.awt.Dimension minimumLayoutSize(java.awt.Container) -> minimumLayoutSize
    void layoutContainer(java.awt.Container) -> layoutContainer
    void addLayoutComponent(java.lang.String,java.awt.Component) -> addLayoutComponent
    void removeLayoutComponent(java.awt.Component) -> removeLayoutComponent
    java.lang.String toString() -> toString
geogebra.gui.util.GeoGebraFileChooser -> geogebra.gui.l.e:
    geogebra.main.Application app -> a
    int currentMode -> a
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel previewPanel -> a
    boolean showAccessory -> a
    int getMode() -> a
    void setMode(int) -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    geogebra.main.Application access$0(geogebra.gui.util.GeoGebraFileChooser) -> a
geogebra.gui.util.GeoGebraFileChooser$PreviewPanel -> geogebra.gui.l.e$a:
    geogebra.gui.util.GeoGebraFileChooser fileChooser -> b
    java.awt.image.BufferedImage img -> a
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel$ImagePanel imagePanel -> a
    javax.swing.JTextArea dataPreviewPanel -> a
    javax.swing.JPanel cards -> a
    java.awt.Label fileLabel -> a
    geogebra.gui.util.GeoGebraFileChooser this$0 -> a
    void setPreviewPanelType(int) -> a
    javax.swing.JScrollPane buildDataPanel() -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    void updateDataPreview(java.io.File) -> a
    void updateImage(java.io.File) -> b
    java.awt.image.BufferedImage access$0(geogebra.gui.util.GeoGebraFileChooser$PreviewPanel) -> a
    geogebra.gui.util.GeoGebraFileChooser access$1(geogebra.gui.util.GeoGebraFileChooser$PreviewPanel) -> a
geogebra.gui.util.GeoGebraFileChooser$PreviewPanel$ImagePanel -> geogebra.gui.l.e$a$a:
    geogebra.gui.util.GeoGebraFileChooser$PreviewPanel this$1 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.util.GeoGebraIcon -> geogebra.gui.l.f:
    javax.swing.ImageIcon createEmptyIcon(int,int) -> a
    javax.swing.ImageIcon createNullSymbolIcon(int,int) -> b
    javax.swing.ImageIcon createFileImageIcon(geogebra.main.Application,java.lang.String,float,java.awt.Dimension) -> a
    javax.swing.ImageIcon createHGridIcon(java.awt.Dimension) -> a
    javax.swing.ImageIcon createVGridIcon(java.awt.Dimension) -> b
    javax.swing.ImageIcon createDownTriangleIcon(int) -> a
    javax.swing.ImageIcon createSymbolTableIcon(java.awt.Font,boolean) -> a
    void drawCenteredText(java.awt.Graphics2D,java.lang.String,int,int) -> a
    javax.swing.ImageIcon createUpDownTriangleIcon(boolean,boolean) -> a
    javax.swing.ImageIcon createColorSwatchIcon(float,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createLineStyleIcon(int,int,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createTextSymbolIcon(java.lang.String,java.awt.Font,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createCellGridIcon(java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createStringIcon(java.lang.String,java.awt.Font,boolean,boolean,boolean,java.awt.Dimension,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createLatexIcon(geogebra.main.Application,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon createPointStyleIcon(int,int,java.awt.Dimension,java.awt.Color,java.awt.Color) -> b
    javax.swing.ImageIcon ensureIconSize(javax.swing.ImageIcon,java.awt.Dimension) -> a
    void drawLatexImageIcon(geogebra.main.Application,javax.swing.ImageIcon,java.lang.String,java.awt.Font,boolean,java.awt.Color,java.awt.Color) -> a
    javax.swing.ImageIcon joinIcons(javax.swing.ImageIcon,javax.swing.ImageIcon) -> a
geogebra.gui.util.GeoGebraIcon$PointStyleImage -> geogebra.gui.l.f$a:
    int pointStyle -> a
    int pointSize -> b
    java.awt.geom.Ellipse2D$Double circle -> a
    java.awt.geom.Line2D$Double line1 -> a
    java.awt.geom.Line2D$Double line2 -> b
    java.awt.geom.Line2D$Double line3 -> c
    java.awt.geom.Line2D$Double line4 -> d
    java.awt.geom.GeneralPath gp -> a
    java.awt.BasicStroke borderStroke -> a
    java.awt.BasicStroke[] crossStrokes -> a
    int h -> c
    int w -> d
    geogebra.gui.util.GeoGebraIcon this$0 -> a
    void drawPointStyle(java.awt.Color,java.awt.Color) -> a
    void getPath() -> a
geogebra.gui.util.HelpAction -> geogebra.gui.l.g:
    geogebra.main.Application app -> a
    java.lang.String articleName -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.main.Application access$0(geogebra.gui.util.HelpAction) -> a
    java.lang.String access$1(geogebra.gui.util.HelpAction) -> a
geogebra.gui.util.HelpAction$1 -> geogebra.gui.l.h:
    geogebra.gui.util.HelpAction this$0 -> a
    void run() -> run
geogebra.gui.util.IconTabbedPane -> geogebra.gui.l.i:
    void setUI(javax.swing.plaf.TabbedPaneUI) -> setUI
    void updateUI() -> updateUI
geogebra.gui.util.IconTabbedPane$IconTabbedPaneUI -> geogebra.gui.l.i$a:
    java.awt.Color bgColor -> a
    java.awt.Color bgActiveColor -> b
    java.awt.Color bgHoverColor -> c
    geogebra.gui.util.IconTabbedPane this$0 -> a
    void installDefaults() -> installDefaults
    void uninstallDefaults() -> uninstallDefaults
    void updateFont() -> a
    void paintTabBorder(java.awt.Graphics,int,int,int,int,int,int,boolean) -> paintTabBorder
    void paintTabBackground(java.awt.Graphics,int,int,int,int,int,int,boolean) -> paintTabBackground
    void setRolloverTab(int) -> setRolloverTab
    void paintTabArea(java.awt.Graphics,int,int) -> paintTabArea
    void layoutLabel(int,java.awt.FontMetrics,int,java.lang.String,javax.swing.Icon,java.awt.Rectangle,java.awt.Rectangle,java.awt.Rectangle,boolean) -> layoutLabel
    int calculateTabHeight(int,int,int) -> calculateTabHeight
    int calculateTabWidth(int,int,java.awt.FontMetrics) -> calculateTabWidth
    int getTabLabelShiftY(int,int,boolean) -> getTabLabelShiftY
    void paintContentBorderTopEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderTopEdge
    void paintFocusIndicator(java.awt.Graphics,int,java.awt.Rectangle[],int,java.awt.Rectangle,java.awt.Rectangle,boolean) -> paintFocusIndicator
    void paintContentBorderRightEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderRightEdge
    void paintContentBorderLeftEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderLeftEdge
    void paintContentBorderBottomEdge(java.awt.Graphics,int,int,int,int,int,int) -> paintContentBorderBottomEdge
geogebra.gui.util.ImageSelection -> geogebra.gui.l.j:
    java.awt.Image image -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.util.LZWEncoder -> geogebra.gui.l.k:
    int imgW -> m
    int imgH -> n
    byte[] pixAry -> b
    int initCodeSize -> o
    int remaining -> p
    int curPixel -> q
    int n_bits -> a
    int maxbits -> b
    int maxcode -> c
    int maxmaxcode -> d
    int[] htab -> a
    int[] codetab -> b
    int hsize -> e
    int free_ent -> f
    boolean clear_flg -> a
    int g_init_bits -> g
    int ClearCode -> h
    int EOFCode -> i
    int cur_accum -> j
    int cur_bits -> k
    int[] masks -> c
    int a_count -> l
    byte[] accum -> a
    void char_out(byte,java.io.OutputStream) -> a
    void cl_block(java.io.OutputStream) -> a
    void cl_hash(int) -> a
    void compress(int,java.io.OutputStream) -> a
    void encode(java.io.OutputStream) -> b
    void flush_char(java.io.OutputStream) -> c
    int MAXCODE(int) -> a
    int nextPixel() -> a
    void output(int,java.io.OutputStream) -> b
geogebra.gui.util.LatexTable -> geogebra.gui.l.l:
    geogebra.gui.dialog.TextInputDialog inputDialog -> a
    java.lang.String[] latexArray -> a
    geogebra.gui.util.PopupMenuButton popupButton -> a
    int caretPosition -> a
    int mode -> b
    java.awt.Component getComponent() -> getComponent
    javax.swing.MenuElement[] getSubElements() -> getSubElements
    void menuSelectionChanged(boolean) -> menuSelectionChanged
    void processKeyEvent(java.awt.event.KeyEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager) -> processKeyEvent
    void processMouseEvent(java.awt.event.MouseEvent,javax.swing.MenuElement[],javax.swing.MenuSelectionManager) -> processMouseEvent
geogebra.gui.util.MyToggleButton -> geogebra.gui.l.m:
    void update(java.lang.Object[]) -> a
    void toggle() -> a
    void access$0(geogebra.gui.util.MyToggleButton) -> a
geogebra.gui.util.MyToggleButton$1 -> geogebra.gui.l.n:
    geogebra.gui.util.MyToggleButton this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.util.NeuQuant -> geogebra.gui.l.o:
    int alphadec -> a
    byte[] thepicture -> a
    int lengthcount -> b
    int samplefac -> c
    int[][] network -> a
    int[] netindex -> a
    int[] bias -> b
    int[] freq -> c
    int[] radpower -> d
    byte[] colorMap() -> a
    void inxbuild() -> a
    void learn() -> b
    int map(int,int,int) -> a
    byte[] process() -> b
    void unbiasnet() -> c
    void alterneigh(int,int,int,int,int) -> a
    void altersingle(int,int,int,int,int) -> b
    int contest(int,int,int) -> b
geogebra.gui.util.PopupMenuButton -> geogebra.gui.l.p:
    int mode -> a
    java.lang.Object[] data -> a
    geogebra.main.Application app -> a
    geogebra.gui.util.PopupMenuButton thisButton -> a
    javax.swing.JPopupMenu myPopup -> a
    javax.swing.JSlider mySlider -> a
    java.awt.Color fgColor -> a
    int fontStyle -> b
    geogebra.gui.util.SelectionTable myTable -> a
    java.awt.Dimension iconSize -> a
    boolean hasTable -> b
    boolean keepVisible -> c
    boolean isDownwardPopup -> d
    boolean isStandardButton -> e
    boolean isFixedIcon -> f
    boolean isIniting -> g
    boolean popupIsVisible -> a
    void setFontStyle(int) -> a
    void setFgColor(java.awt.Color) -> a
    geogebra.gui.util.SelectionTable getMyTable() -> a
    void setIconSize(java.awt.Dimension) -> a
    void setDownwardPopup(boolean) -> a
    void setStandardButton(boolean) -> b
    boolean prepareToShowPopup() -> a
    void addPopupMenuItem(javax.swing.JComponent) -> a
    void removeAllMenuItems() -> b
    void setPopupMenu(javax.swing.JPopupMenu) -> a
    void processMouseEvent(java.awt.event.MouseEvent) -> processMouseEvent
    void update(java.lang.Object[]) -> a
    void updateGUI() -> a
    void initSlider() -> d
    void handlePopupActionEvent() -> c
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    int getSelectedIndex() -> a
    java.lang.Object getSelectedValue() -> a
    void setSelectedIndex(java.lang.Integer) -> a
    int getSliderValue() -> b
    void setSliderValue(int) -> b
    javax.swing.JSlider getMySlider() -> a
    void setKeepVisible(boolean) -> c
    void setToolTipArray(java.lang.String[]) -> a
    javax.swing.ImageIcon getButtonIcon() -> a
    void setIcon(javax.swing.Icon) -> setIcon
    void setFixedIcon(javax.swing.Icon) -> a
    javax.swing.JPopupMenu access$0(geogebra.gui.util.PopupMenuButton) -> a
    geogebra.gui.util.PopupMenuButton access$1(geogebra.gui.util.PopupMenuButton) -> a
    boolean access$2(geogebra.gui.util.PopupMenuButton) -> a
    geogebra.gui.util.SelectionTable access$3(geogebra.gui.util.PopupMenuButton) -> a
    boolean access$4(geogebra.gui.util.PopupMenuButton) -> b
geogebra.gui.util.PopupMenuButton$1 -> geogebra.gui.l.q:
    geogebra.gui.util.PopupMenuButton this$0 -> a
    boolean val$hasTable -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.util.PopupMenuButton$2 -> geogebra.gui.l.r:
    geogebra.gui.util.PopupMenuButton this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.util.RestrictedFileSystemView -> geogebra.gui.l.s:
    java.lang.String newFolderString -> a
    java.io.File _defaultDirectory -> a
    boolean isRoot(java.io.File) -> isRoot
    java.lang.Boolean isTraversable(java.io.File) -> isTraversable
    java.lang.String getSystemDisplayName(java.io.File) -> getSystemDisplayName
    java.lang.String getSystemTypeDescription(java.io.File) -> getSystemTypeDescription
    javax.swing.Icon getSystemIcon(java.io.File) -> getSystemIcon
    boolean isParent(java.io.File,java.io.File) -> isParent
    java.io.File getChild(java.io.File,java.lang.String) -> getChild
    boolean isFileSystem(java.io.File) -> isFileSystem
    boolean isHiddenFile(java.io.File) -> isHiddenFile
    boolean isFileSystemRoot(java.io.File) -> isFileSystemRoot
    boolean isDrive(java.io.File) -> isDrive
    boolean isFloppyDrive(java.io.File) -> isFloppyDrive
    boolean isComputerNode(java.io.File) -> isComputerNode
    java.io.File[] getRoots() -> getRoots
    java.io.File getHomeDirectory() -> getHomeDirectory
    java.io.File getDefaultDirectory() -> getDefaultDirectory
    java.io.File createFileObject(java.io.File,java.lang.String) -> createFileObject
    java.io.File createFileObject(java.lang.String) -> createFileObject
    java.io.File[] getFiles(java.io.File,boolean) -> getFiles
    java.io.File getParentDirectory(java.io.File) -> getParentDirectory
    java.io.File createFileSystemRoot(java.io.File) -> createFileSystemRoot
    java.io.File createNewFolder(java.io.File) -> createNewFolder
geogebra.gui.util.RestrictedFileSystemView$FileSystemRoot -> geogebra.gui.l.s$a:
    boolean isDirectory() -> isDirectory
    java.lang.String getName() -> getName
geogebra.gui.util.SelectionTable -> geogebra.gui.l.t:
    geogebra.main.Application app -> a
    geogebra.gui.util.SelectionTable$MyCellRenderer renderer -> a
    javax.swing.table.DefaultTableModel model -> a
    int rollOverRow -> a
    int rollOverColumn -> b
    int sliderValue -> c
    int horizontalAlignment -> d
    boolean showSelection -> b
    java.lang.Object[] data -> a
    int numRows -> e
    int numColumns -> f
    int rowHeight -> g
    int columnWidth -> h
    java.awt.Dimension iconSize -> a
    int mode -> i
    java.awt.Color fgColor -> a
    float alpha -> a
    boolean useColorSwatchBorder -> a
    java.lang.String[] toolTipArray -> a
    void setShowSelection(boolean) -> a
    void setHorizontalAlignment(int) -> a
    int getColumnWidth() -> a
    void setFgColor(java.awt.Color) -> a
    void setUseColorSwatchBorder(boolean) -> b
    void setToolTipArray(java.lang.String[]) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void populateModel(java.lang.Object[]) -> a
    javax.swing.ImageIcon[] createLatexIconArray(java.lang.String[]) -> a
    void setCellDimensions() -> b
    void updateFonts() -> a
    int getSelectedIndex() -> b
    void setSelectedIndex(int) -> b
    java.lang.Object getSelectedValue() -> a
    void setSliderValue(int) -> c
    javax.swing.ImageIcon getDataIcon(java.lang.Object) -> a
    int getMaxColumnWidth(javax.swing.JTable,int) -> a
    int getMaxRowHeight(javax.swing.JTable) -> a
    void access$0(geogebra.gui.util.SelectionTable,int) -> a
    void access$1(geogebra.gui.util.SelectionTable,int) -> b
    int access$2(geogebra.gui.util.SelectionTable) -> a
    int access$3(geogebra.gui.util.SelectionTable) -> b
    java.lang.String[] access$4(geogebra.gui.util.SelectionTable) -> a
    java.lang.Object[] access$5(geogebra.gui.util.SelectionTable) -> a
    int access$6(geogebra.gui.util.SelectionTable) -> c
    int access$7(geogebra.gui.util.SelectionTable) -> d
    geogebra.main.Application access$8(geogebra.gui.util.SelectionTable) -> a
    boolean access$9(geogebra.gui.util.SelectionTable) -> a
geogebra.gui.util.SelectionTable$MyCellRenderer -> geogebra.gui.l.t$a:
    javax.swing.border.Border normalBorder -> a
    javax.swing.border.Border selectedBorder -> b
    javax.swing.border.Border rollOverBorder -> c
    javax.swing.border.Border paddingBorder -> d
    java.awt.Color selectionColor -> a
    java.awt.Color rollOverColor -> b
    geogebra.gui.util.SelectionTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.util.SelectionTable$RollOverListener -> geogebra.gui.l.t$b:
    geogebra.gui.util.SelectionTable this$0 -> a
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.util.SpecialNumberFormat -> geogebra.gui.l.u:
    geogebra.main.Application app -> a
    geogebra.gui.util.SpecialNumberFormatInterface invoker -> a
    javax.swing.JMenu menuDecimalPlaces -> a
    int printFigures -> a
    int printDecimals -> b
    int getPrintFigures() -> a
    int getPrintDecimals() -> b
    java.lang.String format(double) -> a
    javax.swing.JMenu createMenuDecimalPlaces() -> a
    void updateMenuDecimalPlaces() -> a
    void addRadioButtonMenuItems(javax.swing.JMenu,java.awt.event.ActionListener,java.lang.String[],java.lang.String[],int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.util.SpecialNumberFormatInterface -> geogebra.gui.l.v:
    void changedNumberFormat() -> c_
geogebra.gui.util.SpringUtilities -> geogebra.gui.l.w:
    javax.swing.SpringLayout$Constraints getConstraintsForCell(int,int,java.awt.Container,int) -> a
    void makeCompactGrid(java.awt.Container,int,int,int,int,int,int) -> a
geogebra.gui.util.TableSymbolsLaTeX -> geogebra.gui.l.x:
    java.lang.String[] miscSymbols -> a
    java.lang.String[] roots_fractions -> b
    java.lang.String[] sums -> c
    java.lang.String[] accents -> d
    java.lang.String[] accentsExtended -> e
    java.lang.String[] brackets -> f
    java.lang.String[] matrices -> g
    java.lang.String[] operators -> h
    java.lang.String[] relations -> i
    java.lang.String[] negations -> j
    java.lang.String[] arrows -> k
    java.lang.String[] mathfrak() -> a
    java.lang.String[] mathcal() -> b
    java.lang.String[] mathbb() -> c
    java.lang.String[] mathscr() -> d
geogebra.gui.util.TextLineNumber -> geogebra.gui.l.y:
    javax.swing.border.Border OUTER -> a
    javax.swing.text.JTextComponent component -> a
    boolean updateFont -> a
    int borderGap -> a
    java.awt.Color currentLineForeground -> a
    float digitAlignment -> a
    int minimumDisplayDigits -> b
    int lastDigits -> c
    int lastHeight -> d
    int lastLine -> e
    java.util.HashMap fonts -> a
    void setBorderGap(int) -> a
    java.awt.Color getCurrentLineForeground() -> a
    void setCurrentLineForeground(java.awt.Color) -> a
    void setDigitAlignment(float) -> a
    void setMinimumDisplayDigits(int) -> b
    void setPreferredWidth() -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
    boolean isCurrentLine(int) -> a
    java.lang.String getTextLineNumber(int) -> a
    int getOffsetX(int,int) -> a
    int getOffsetY(int,java.awt.FontMetrics) -> a
    void caretUpdate(javax.swing.event.CaretEvent) -> caretUpdate
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void documentChanged() -> b
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    javax.swing.text.JTextComponent access$0(geogebra.gui.util.TextLineNumber) -> a
    int access$1(geogebra.gui.util.TextLineNumber) -> a
    void access$2(geogebra.gui.util.TextLineNumber) -> a
    void access$3(geogebra.gui.util.TextLineNumber,int) -> a
geogebra.gui.util.TextLineNumber$1 -> geogebra.gui.l.z:
    geogebra.gui.util.TextLineNumber this$0 -> a
    void run() -> run
geogebra.gui.view.CompressedAlgebraView -> geogebra.gui.m.a:
    int ups -> a
    javax.swing.Timer updateTimer -> a
    java.util.Set updateSet -> a
    java.awt.event.ActionListener updateListener -> a
    java.util.concurrent.locks.ReentrantLock lock -> a
    int rps -> b
    javax.swing.Timer repaintTimer -> b
    java.awt.event.ActionListener repaintListener -> b
    boolean needRepaint -> b
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateNow(geogebra.common.kernel.geos.GeoElement) -> g
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void repaintView() -> c
    void repaintNow() -> e
    void repaint() -> repaint
geogebra.gui.view.CompressedRepaintListener -> geogebra.gui.m.b:
    geogebra.gui.view.CompressedView view -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.CompressedUpdateListener -> geogebra.gui.m.c:
    javax.swing.Timer updateTimer -> a
    java.util.Set updateSet -> a
    geogebra.gui.view.CompressedView view -> a
    java.util.concurrent.locks.ReentrantLock lock -> a
    boolean isWorking -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.CompressedView -> geogebra.gui.m.d:
    void updateNow(geogebra.common.kernel.geos.GeoElement) -> g
    void repaintNow() -> e
geogebra.gui.view.Gridable -> geogebra.gui.m.e:
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    geogebra.main.Application getApplication() -> b
    java.awt.Component[][] getPrintComponents() -> a
geogebra.gui.view.algebra.AlgebraContextMenu -> geogebra.gui.m.a.a:
    geogebra.main.Application app -> a
    void initItems() -> a
    geogebra.main.Application access$0(geogebra.gui.view.algebra.AlgebraContextMenu) -> a
geogebra.gui.view.algebra.AlgebraContextMenu$1 -> geogebra.gui.m.a.b:
    geogebra.gui.view.algebra.AlgebraContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraContextMenu$2 -> geogebra.gui.m.a.c:
    geogebra.gui.view.algebra.AlgebraContextMenu this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.algebra.AlgebraController -> geogebra.gui.m.a.d:
    java.awt.dnd.DragSource ds -> a
    java.util.ArrayList geoLabelList -> a
    void enableDnD() -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
geogebra.gui.view.algebra.AlgebraController$TransferableAlgebraView -> geogebra.gui.m.a.d$a:
    java.awt.datatransfer.DataFlavor algebraViewFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.util.ArrayList geoLabelList -> a
    geogebra.gui.view.algebra.AlgebraController this$0 -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.view.algebra.AlgebraHelperBar -> geogebra.gui.m.a.e:
    geogebra.gui.view.algebra.AlgebraView algebraView -> a
    geogebra.main.Application app -> a
    javax.swing.JButton toggleAuxiliary -> a
    geogebra.gui.util.PopupMenuButton toggleTypeTreeMode -> a
    javax.swing.JPopupMenu menu -> a
    void addButtons() -> a
    void updateStates() -> b
    void updateLabels() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void buildMenu() -> d
    void access$0(geogebra.gui.view.algebra.AlgebraHelperBar) -> a
geogebra.gui.view.algebra.AlgebraHelperBar$1 -> geogebra.gui.m.a.f:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$2 -> geogebra.gui.m.a.g:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$3 -> geogebra.gui.m.a.h:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraHelperBar$4 -> geogebra.gui.m.a.i:
    geogebra.gui.view.algebra.AlgebraHelperBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.algebra.AlgebraInputDropTargetListener -> geogebra.gui.m.a.j:
    geogebra.main.Application app -> a
    javax.swing.text.JTextComponent textComp -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    boolean debug -> a
    java.lang.String textImport -> a
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
geogebra.gui.view.algebra.AlgebraView -> geogebra.gui.m.a.k:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.algebra.MyRenderer renderer -> a
    geogebra.gui.view.algebra.AlgebraView$MyDefaultTreeCellEditor editor -> a
    geogebra.gui.inputfield.MathTextField editTF -> a
    java.util.HashMap nodeTable -> a
    javax.swing.tree.DefaultTreeModel model -> a
    javax.swing.tree.DefaultMutableTreeNode rootDependency -> a
    javax.swing.tree.DefaultMutableTreeNode depNode -> c
    javax.swing.tree.DefaultMutableTreeNode indNode -> d
    javax.swing.tree.DefaultMutableTreeNode auxiliaryNode -> b
    javax.swing.tree.DefaultMutableTreeNode rootType -> e
    java.util.HashMap typeNodesMap -> b
    javax.swing.tree.DefaultMutableTreeNode rootOrder -> f
    javax.swing.tree.DefaultMutableTreeNode rootLayer -> g
    java.util.HashMap layerNodesMap -> c
    geogebra.gui.view.algebra.AlgebraView$SortMode treeMode -> a
    geogebra.common.kernel.geos.GeoElement selectedGeoElement -> a
    javax.swing.tree.DefaultMutableTreeNode selectedNode -> h
    geogebra.gui.view.algebra.AlgebraHelperBar helperBar -> a
    geogebra.gui.view.algebra.AlgebraController algebraController -> a
    boolean attached -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$algebra$AlgebraView$SortMode -> a
    void initModel() -> f
    void removeAuxiliaryNode() -> g
    void attachView() -> h
    void detachView() -> i
    void updateFonts() -> j
    void initTreeCellRendererEditor() -> e
    geogebra.gui.view.algebra.MyRenderer newMyRenderer(geogebra.main.Application) -> a
    void clearSelection() -> clearSelection
    boolean showAuxiliaryObjects() -> a
    void setShowAuxiliaryObjects(boolean) -> a
    geogebra.gui.view.algebra.AlgebraView$SortMode getTreeMode() -> a
    void setTreeMode(geogebra.gui.view.algebra.AlgebraView$SortMode) -> a
    geogebra.gui.view.algebra.AlgebraHelperBar getHelperBar() -> a
    geogebra.gui.view.algebra.AlgebraHelperBar newAlgebraHelperBar() -> b
    geogebra.common.kernel.geos.GeoElement getGeoElementForLocation(javax.swing.JTree,int,int) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElementForPath(javax.swing.tree.TreePath) -> a
    void setToolTipText(java.lang.String) -> setToolTipText
    void startEditing(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setLabels() -> a
    void setTreeLabels() -> k
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void add(geogebra.common.kernel.geos.GeoElement,int) -> a
    javax.swing.tree.DefaultMutableTreeNode getParentNode(geogebra.common.kernel.geos.GeoElement,int) -> a
    boolean compare(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.algebra.AlgebraView$SortMode) -> a
    int getInsertPosition(javax.swing.tree.DefaultMutableTreeNode,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.algebra.AlgebraView$SortMode) -> a
    int binarySearchGeo(javax.swing.tree.DefaultMutableTreeNode,java.lang.String) -> a
    int linearSearchGeo(javax.swing.tree.DefaultMutableTreeNode,java.lang.String) -> b
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void clearView() -> b
    void clearTree() -> l
    void repaintView() -> c
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void setMode(int) -> a
    void reset() -> d
    void removeFromModel(javax.swing.tree.DefaultMutableTreeNode,javax.swing.tree.DefaultTreeModel) -> a
    void removeFromLayer(javax.swing.tree.DefaultTreeModel,int) -> a
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    boolean isRenderLaTeX() -> b
    int getViewID() -> b
    geogebra.main.Application getApplication() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    void changeLayer(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElementForLocation(java.lang.Object,int,int) -> a
    java.lang.Object getPathBounds(java.lang.Object) -> a
    java.lang.Object getPathForLocation(int,int) -> a
    javax.swing.tree.DefaultMutableTreeNode access$1(geogebra.gui.view.algebra.AlgebraView) -> a
    geogebra.common.kernel.geos.GeoElement access$2(geogebra.gui.view.algebra.AlgebraView) -> a
    geogebra.common.kernel.Kernel access$3(geogebra.gui.view.algebra.AlgebraView) -> a
    void access$4(geogebra.gui.view.algebra.AlgebraView,geogebra.common.kernel.geos.GeoElement) -> a
    void access$5(geogebra.gui.view.algebra.AlgebraView,javax.swing.tree.DefaultMutableTreeNode) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$algebra$AlgebraView$SortMode() -> c
    geogebra.gui.inputfield.MathTextField access$7(geogebra.gui.view.algebra.AlgebraView) -> a
geogebra.gui.view.algebra.AlgebraView$1 -> geogebra.gui.m.a.l:
    geogebra.gui.view.algebra.AlgebraView this$0 -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.view.algebra.AlgebraView$MyDefaultTreeCellEditor -> geogebra.gui.m.a.k$a:
    geogebra.gui.view.algebra.AlgebraView this$0 -> a
    void editingCanceled(javax.swing.event.ChangeEvent) -> editingCanceled
    void editingStopped(javax.swing.event.ChangeEvent) -> editingStopped
    boolean isCellEditable(java.util.EventObject) -> isCellEditable
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void storeSelection(javax.swing.tree.TreePath) -> a
    java.awt.Component getTreeCellEditorComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int) -> getTreeCellEditorComponent
geogebra.gui.view.algebra.AlgebraView$MyDefaultTreeCellEditor$WideEditorContainer -> geogebra.gui.m.a.k$a$a:
    javax.swing.JTree tree -> a
    javax.swing.tree.TreePath lastPath -> a
    int offset -> a
    java.awt.Component editingComponent -> a
    geogebra.gui.view.algebra.AlgebraView$MyDefaultTreeCellEditor this$1 -> a
    void doLayout() -> doLayout
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void updateContainer(javax.swing.JTree,javax.swing.tree.TreePath,int,java.awt.Component) -> a
geogebra.gui.view.algebra.AlgebraView$SortMode -> geogebra.gui.m.a.k$b:
    geogebra.gui.view.algebra.AlgebraView$SortMode DEPENDENCY -> a
    geogebra.gui.view.algebra.AlgebraView$SortMode TYPE -> b
    geogebra.gui.view.algebra.AlgebraView$SortMode VIEW -> c
    geogebra.gui.view.algebra.AlgebraView$SortMode ORDER -> d
    geogebra.gui.view.algebra.AlgebraView$SortMode LAYER -> e
    geogebra.gui.view.algebra.AlgebraView$SortMode[] ENUM$VALUES -> a
    geogebra.gui.view.algebra.AlgebraView$SortMode[] values() -> values
    geogebra.gui.view.algebra.AlgebraView$SortMode valueOf(java.lang.String) -> valueOf
geogebra.gui.view.algebra.InputPanel -> geogebra.gui.m.a.m:
    geogebra.main.Application app -> a
    javax.swing.text.JTextComponent textComponent -> a
    javax.swing.JPanel tfPanel -> a
    boolean showSymbolPopup -> a
    javax.swing.JScrollPane scrollPane -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$algebra$InputPanel$DialogType -> a
    void setShowLineNumbering(boolean) -> a
    javax.swing.text.JTextComponent getTextComponent() -> a
    java.lang.String getText() -> a
    java.lang.String getSelectedText() -> b
    void selectText() -> a
    void setText(java.lang.String) -> b
    void insertString(java.lang.String) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void showSpecialChars(boolean) -> b
    int[] $SWITCH_TABLE$geogebra$gui$view$algebra$InputPanel$DialogType() -> a
geogebra.gui.view.algebra.InputPanel$DialogType -> geogebra.gui.m.a.m$a:
    geogebra.gui.view.algebra.InputPanel$DialogType TextArea -> a
    geogebra.gui.view.algebra.InputPanel$DialogType DynamicText -> b
    geogebra.gui.view.algebra.InputPanel$DialogType GeoGebraEditor -> c
    geogebra.gui.view.algebra.InputPanel$DialogType[] ENUM$VALUES -> a
    geogebra.gui.view.algebra.InputPanel$DialogType[] values() -> values
    geogebra.gui.view.algebra.InputPanel$DialogType valueOf(java.lang.String) -> valueOf
geogebra.gui.view.algebra.MyCellEditor -> geogebra.gui.m.a.n:
    geogebra.main.Application app -> a
    java.awt.Component getTreeCellEditorComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int) -> getTreeCellEditorComponent
geogebra.gui.view.algebra.MyComboBoxListener -> geogebra.gui.m.a.o:
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
geogebra.gui.view.algebra.MyRenderer -> geogebra.gui.m.a.p:
    geogebra.main.Application app -> a
    geogebra.gui.view.algebra.AlgebraView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.ImageIcon iconShown -> a
    javax.swing.ImageIcon iconHidden -> b
    javax.swing.ImageIcon latexIcon -> c
    java.lang.String latexStr -> a
    java.awt.Font latexFont -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
    java.lang.String getAlgebraDescriptionTextOrHTML(geogebra.common.kernel.geos.GeoElement) -> a
    javax.swing.ImageIcon joinIcons(javax.swing.ImageIcon,javax.swing.ImageIcon) -> a
    void setFont(java.awt.Font) -> setFont
geogebra.gui.view.assignment.AssignmentView -> geogebra.gui.m.b.a:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    void attachView() -> a
    void detachView() -> e
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void clearView() -> b
    void setMode(int) -> a
    int getViewID() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    geogebra.main.Application getApplication() -> b
    java.awt.Component[][] getPrintComponents() -> a
    javax.swing.JComponent getStyleBar() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu -> geogebra.gui.m.c.a:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView constprotView -> a
    void initItems() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$1 -> geogebra.gui.m.c.b:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$2 -> geogebra.gui.m.c.c:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu$3 -> geogebra.gui.m.c.d:
    geogebra.gui.view.consprotocol.ConstructionProtocolContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation -> geogebra.gui.m.c.e:
    javax.swing.JButton btFirst -> b
    javax.swing.JButton btPrev -> c
    javax.swing.JButton btNext -> d
    javax.swing.JButton btLast -> e
    javax.swing.JButton btOpenWindow -> f
    javax.swing.JButton btPlay -> a
    javax.swing.JLabel lbSteps -> a
    javax.swing.JSpinner spDelay -> a
    double playDelay -> a
    javax.swing.JPanel playPanel -> a
    geogebra.main.Application app -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView prot -> a
    boolean showPlayButton -> b
    boolean showConsProtButton -> c
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$AutomaticPlayer player -> a
    boolean isPlaying -> a
    boolean isPlayButtonVisible() -> a
    void setPlayButtonVisible(boolean) -> a
    boolean isConsProtButtonVisible() -> b
    void setConsProtButtonVisible(boolean) -> b
    double getPlayDelay() -> a
    void setPlayDelay(double) -> a
    void initGUI() -> b
    void setLabels() -> a
    void update() -> c
    void register() -> d
    void unregister() -> e
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setComponentsEnabled(boolean) -> c
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$1 -> geogebra.gui.m.c.f:
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$2 -> geogebra.gui.m.c.g:
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolNavigation$AutomaticPlayer -> geogebra.gui.m.c.e$a:
    javax.swing.Timer timer -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation this$0 -> a
    void startAnimation() -> a
    void stopAnimation() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar -> geogebra.gui.m.c.h:
    geogebra.gui.view.consprotocol.ConstructionProtocolView cpView -> a
    geogebra.main.Application app -> a
    geogebra.gui.util.PopupMenuButton btnColumns -> a
    geogebra.gui.util.PopupMenuButton btnOptions -> b
    javax.swing.JButton btnExport -> a
    javax.swing.JButton btnPrint -> b
    javax.swing.JButton btnHelp -> c
    javax.swing.JCheckBoxMenuItem miShowOnlyBreakpoints -> a
    javax.swing.JCheckBoxMenuItem miColorfulConstructionProtocol -> b
    void addButtons() -> a
    void setLabels() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$1 -> geogebra.gui.m.c.i:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$2 -> geogebra.gui.m.c.j:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    boolean prepareToShowPopup() -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$3 -> geogebra.gui.m.c.k:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$4 -> geogebra.gui.m.c.l:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5 -> geogebra.gui.m.c.m:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar access$0(geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5$1 -> geogebra.gui.m.c.n:
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar$5 this$1 -> a
    void run() -> run
geogebra.gui.view.consprotocol.ConstructionProtocolView -> geogebra.gui.m.c.o:
    java.awt.Color COLOR_STEP_HIGHLIGHT -> a
    java.awt.Color COLOR_DRAG_HIGHLIGHT -> b
    java.awt.Color COLOR_DROP_HIGHLIGHT -> c
    javax.swing.JTable table -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData data -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    javax.swing.table.TableColumn[] tableColumns -> a
    boolean useColors -> a
    boolean addIcons -> b
    boolean dragging -> c
    int dragIndex -> a
    int dropIndex -> b
    int maxNumPage -> c
    boolean isViewAttached -> d
    java.util.ArrayList navigationBars -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolNavigation protNavBar -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView view -> a
    javax.swing.JScrollPane scrollPane -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar helperBar -> a
    javax.swing.AbstractAction exportHtmlAction -> a
    javax.swing.AbstractAction printPreviewAction -> b
    geogebra.main.Application getApplication() -> a
    void registerNavigationBar(geogebra.gui.view.consprotocol.ConstructionProtocolNavigation) -> a
    void unregisterNavigationBar(geogebra.gui.view.consprotocol.ConstructionProtocolNavigation) -> b
    void updateNavigationBars() -> h
    int getLastStepNumber() -> a
    int getCurrentStepNumber() -> b
    void setConstructionStep(int) -> a
    void nextStep() -> a
    void previousStep() -> b
    void firstStep() -> c
    void lastStep() -> d
    void initGUI() -> e
    void setUseColors(boolean) -> a
    void setAddIcons(boolean) -> b
    boolean getAddIcons() -> a
    void update() -> f
    javax.swing.table.TableColumn[] getTableColumns() -> a
    boolean getUseColors() -> b
    boolean isColumnInModel(javax.swing.table.TableColumn) -> a
    void setVisible(boolean) -> setVisible
    void scrollToConstructionStep() -> g
    javax.swing.JTable getTable() -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData getData() -> a
    javax.swing.AbstractAction getExportHtmlAction() -> a
    javax.swing.AbstractAction getPrintPreviewAction() -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar getStyleBar() -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolStyleBar newConstructionProtocolHelperBar() -> b
    void initActions() -> i
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    java.lang.String getHTML(java.io.File,java.lang.String) -> a
    java.lang.String getConsProtocolXML() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    void setColsVisibility(boolean[]) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$1(geogebra.gui.view.consprotocol.ConstructionProtocolView,int) -> a
    boolean access$2(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$3(geogebra.gui.view.consprotocol.ConstructionProtocolView,int) -> b
    int access$4(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    int access$5(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> b
    void access$6(geogebra.gui.view.consprotocol.ConstructionProtocolView,boolean) -> a
    boolean access$7(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> b
    java.awt.Color access$8() -> a
    java.awt.Color access$9() -> b
    java.awt.Color access$10() -> c
    javax.swing.table.TableColumn[] access$11(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    boolean access$12(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> c
    void access$13(geogebra.gui.view.consprotocol.ConstructionProtocolView,boolean) -> b
    java.util.ArrayList access$14(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
    void access$15(geogebra.gui.view.consprotocol.ConstructionProtocolView) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$1 -> geogebra.gui.m.c.p:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$1) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$1$1 -> geogebra.gui.m.c.q:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$1 this$1 -> a
    void run() -> run
geogebra.gui.view.consprotocol.ConstructionProtocolView$2 -> geogebra.gui.m.c.r:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.consprotocol.ConstructionProtocolView access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$2) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$2$1 -> geogebra.gui.m.c.s:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$2 this$1 -> a
    void run() -> run
    java.lang.String tableHeader(geogebra.common.kernel.Construction) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData -> geogebra.gui.m.c.o$a:
    java.lang.String title -> a
    boolean isVisible -> a
    int prefWidth -> a
    int minWidth -> b
    int alignment -> c
    boolean initShow -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.lang.String getTitle() -> a
    java.lang.String getTranslatedTitle() -> b
    int getPreferredWidth() -> a
    int getMinWidth() -> b
    int getAlignment() -> c
    boolean getInitShow() -> a
    void setVisible(boolean) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnKeeper -> geogebra.gui.m.c.o$b:
    javax.swing.table.TableColumn column -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData colData -> a
    boolean isBreakPointColumn -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionKeyListener -> geogebra.gui.m.c.o$c:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionMouseListener -> geogebra.gui.m.c.o$d:
    int minIndex -> a
    int maxIndex -> b
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableCellEditor -> geogebra.gui.m.c.o$e:
    geogebra.gui.view.algebra.InputPanel inputPanel -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    boolean stopCellEditing() -> stopCellEditing
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableCellRenderer -> geogebra.gui.m.c.o$f:
    javax.swing.JCheckBox cbTemp -> a
    javax.swing.JLabel iTemp -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData -> geogebra.gui.m.c.o$g:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData[] columns -> a
    java.util.ArrayList rowList -> a
    java.util.HashMap geoMap -> a
    int columnsCount -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    int getLastStepNumber() -> a
    int getCurrentStepNumber() -> c
    void setConstructionStepForRow(int) -> b
    boolean moveInConstructionList(int,int) -> a
    geogebra.common.kernel.geos.GeoElement getGeoElement(int) -> a
    int getConstructionIndex(int) -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView$RowData getRow(int) -> a
    void initView() -> a
    void attachView() -> e
    void detachView() -> f
    void setMode(int) -> a
    int getRowCount() -> getRowCount
    int getColumnCount() -> getColumnCount
    int getColumnNumber(geogebra.gui.view.consprotocol.ConstructionProtocolView$ColumnData) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    java.awt.Color getColorAt(int,int) -> a
    java.lang.Object getValueAt(int,int) -> getValueAt
    java.lang.String getPlainHTMLAt(int,int,java.lang.String) -> a
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void clearView() -> b
    void repaintView() -> c
    void updateRowNumbers(int) -> c
    void updateIndices() -> h
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void repaint() -> g
    void updateAll() -> i
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void reset() -> d
    void setValueAt(java.lang.Object,int,int) -> setValueAt
    int getViewID() -> b
    int access$0(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData) -> a
    void access$1(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData,int) -> a
    void access$2(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData) -> a
    java.awt.Color access$3(geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData,int,int) -> a
geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData$ColumnMovementListener -> geogebra.gui.m.c.o$g$a:
    geogebra.gui.view.consprotocol.ConstructionProtocolView$ConstructionTableData this$1 -> a
    void columnAdded(javax.swing.event.TableColumnModelEvent) -> columnAdded
    void columnRemoved(javax.swing.event.TableColumnModelEvent) -> columnRemoved
    void columnMarginChanged(javax.swing.event.ChangeEvent) -> columnMarginChanged
    void columnMoved(javax.swing.event.TableColumnModelEvent) -> columnMoved
    void columnSelectionChanged(javax.swing.event.ListSelectionEvent) -> columnSelectionChanged
geogebra.gui.view.consprotocol.ConstructionProtocolView$HeaderRenderer -> geogebra.gui.m.c.o$h:
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.consprotocol.ConstructionProtocolView$RowData -> geogebra.gui.m.c.o$i:
    int rowNumber -> a
    int index -> b
    geogebra.common.kernel.geos.GeoElement geo -> a
    javax.swing.ImageIcon toolbarIcon -> a
    java.lang.String name -> a
    java.lang.String algebra -> b
    java.lang.String definition -> c
    java.lang.String command -> d
    java.lang.String caption -> e
    boolean includesIndex -> a
    java.lang.Boolean consProtocolVisible -> a
    geogebra.gui.view.consprotocol.ConstructionProtocolView this$0 -> a
    void updateAlgebraAndName() -> a
    void updateCaption() -> b
    void updateAll() -> c
geogebra.gui.view.functioninspector.FunctionInspector -> geogebra.gui.m.d.a:
    java.awt.Color DISPLAY_GEO_COLOR -> a
    java.awt.Color DISPLAY_GEO2_COLOR -> b
    java.awt.Color EVEN_ROW_COLOR -> c
    java.awt.Color TABLE_GRID_COLOR -> d
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.euclidian.AbstractEuclidianView activeEV -> a
    geogebra.gui.view.functioninspector.InspectorTable tableXY -> a
    geogebra.gui.view.functioninspector.InspectorTable tableInterval -> b
    javax.swing.table.DefaultTableModel modelXY -> a
    javax.swing.table.DefaultTableModel modelInterval -> b
    java.lang.String[] columnNames -> a
    java.util.ArrayList extraColumnList -> b
    javax.swing.JLabel lblGeoName -> b
    javax.swing.JLabel lblStep -> c
    javax.swing.JLabel lblInterval -> d
    geogebra.gui.inputfield.MyTextField fldStep -> a
    geogebra.gui.inputfield.MyTextField fldLow -> b
    geogebra.gui.inputfield.MyTextField fldHigh -> c
    javax.swing.JButton btnRemoveColumn -> f
    javax.swing.JToggleButton btnOscCircle -> a
    javax.swing.JToggleButton btnTangent -> b
    javax.swing.JToggleButton btnXYSegments -> c
    javax.swing.JToggleButton btnTable -> d
    geogebra.gui.util.PopupMenuButton btnAddColumn -> a
    geogebra.gui.util.PopupMenuButton btnOptions -> b
    javax.swing.JTabbedPane tabPanel -> a
    javax.swing.JPanel intervalTabPanel -> e
    javax.swing.JPanel pointTabPanel -> f
    javax.swing.JPanel headerPanel -> g
    javax.swing.JPanel helpPanel -> h
    geogebra.common.kernel.geos.GeoElement tangentLine -> b
    geogebra.common.kernel.geos.GeoElement oscCircle -> c
    geogebra.common.kernel.geos.GeoElement xSegment -> d
    geogebra.common.kernel.geos.GeoElement ySegment -> e
    geogebra.common.kernel.geos.GeoElement functionInterval -> f
    geogebra.common.kernel.geos.GeoElement integralGeo -> g
    geogebra.common.kernel.geos.GeoElement lengthGeo -> h
    geogebra.common.kernel.geos.GeoElement areaGeo -> i
    geogebra.common.kernel.geos.GeoFunction derivative -> a
    geogebra.common.kernel.geos.GeoFunction derivative2 -> b
    geogebra.common.kernel.geos.GeoFunction selectedGeo -> c
    geogebra.common.kernel.geos.GeoPoint2 testPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 lowPoint -> b
    geogebra.common.kernel.geos.GeoPoint2 highPoint -> c
    geogebra.common.kernel.geos.GeoPoint2 minPoint -> d
    geogebra.common.kernel.geos.GeoPoint2 maxPoint -> e
    geogebra.common.kernel.geos.GeoList pts -> a
    java.util.ArrayList intervalTabGeoList -> c
    java.util.ArrayList pointTabGeoList -> d
    java.util.ArrayList hiddenGeoList -> e
    geogebra.common.kernel.geos.GeoElement[] rootGeos -> a
    java.util.ArrayList xyTableCopyList -> f
    boolean isIniting -> a
    double xMin -> a
    double xMax -> b
    double start -> c
    double step -> d
    double initialX -> e
    boolean isChangingValue -> b
    int pointCount -> a
    geogebra.gui.util.SpecialNumberFormat nf -> a
    javax.swing.JButton btnHelp -> g
    java.util.ArrayList property -> g
    java.util.ArrayList value -> h
    java.util.ArrayList value2 -> i
    void createTabPanel() -> g
    void createHeaderPanel() -> h
    void createHelpPanel() -> i
    void createTabIntervalPanel() -> j
    void createTabPointPanel() -> k
    void createGUIElements() -> l
    void createBtnAddColumn() -> m
    void setLabels() -> e
    java.lang.String getTitleString() -> b
    void updateGUI() -> n
    void handleTabChange() -> o
    void updateIntervalFields() -> p
    void updateIntervalTable() -> q
    void updateXYTable() -> r
    void updateExtraColumns() -> s
    void addColumn(int) -> c
    void removeColumn() -> t
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void setVisible(boolean) -> setVisible
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void clearView() -> b
    void setMode(int) -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void insertGeoElement(geogebra.common.kernel.geos.GeoElement) -> g
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void defineDisplayGeos() -> u
    void updateTestPoint() -> v
    void clearGeoList() -> w
    void updateFonts() -> f
    void windowGainedFocus(java.awt.event.WindowEvent) -> windowGainedFocus
    void changeStart(double) -> a
    void updateIntervalGeoVisiblity() -> x
    geogebra.gui.util.SpecialNumberFormat getMyNumberFormat() -> a
    void changedNumberFormat() -> c_
    void createOptionsButton() -> y
    void doCopyToSpreadsheet() -> z
    void processCellGeo(geogebra.common.kernel.geos.GeoElement,int,int) -> a
    int getViewID() -> b
    void access$0(geogebra.gui.view.functioninspector.FunctionInspector) -> a
    void access$1(geogebra.gui.view.functioninspector.FunctionInspector) -> b
    geogebra.main.Application access$2(geogebra.gui.view.functioninspector.FunctionInspector) -> a
    void access$3(geogebra.gui.view.functioninspector.FunctionInspector) -> c
geogebra.gui.view.functioninspector.FunctionInspector$1 -> geogebra.gui.m.d.b:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.functioninspector.FunctionInspector$2 -> geogebra.gui.m.d.c:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
geogebra.gui.view.functioninspector.FunctionInspector$3 -> geogebra.gui.m.d.d:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.functioninspector.FunctionInspector access$0(geogebra.gui.view.functioninspector.FunctionInspector$3) -> a
geogebra.gui.view.functioninspector.FunctionInspector$3$1 -> geogebra.gui.m.d.e:
    geogebra.gui.view.functioninspector.FunctionInspector$3 this$1 -> a
    void run() -> run
geogebra.gui.view.functioninspector.FunctionInspector$4 -> geogebra.gui.m.d.f:
    geogebra.gui.view.functioninspector.FunctionInspector this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.functioninspector.InspectorTable -> geogebra.gui.m.d.g:
    geogebra.main.Application app -> a
    geogebra.gui.view.functioninspector.FunctionInspector inspector -> a
    boolean doRedNegative -> a
    java.util.HashSet editableCell -> a
    int tableType -> a
    boolean isDoRedNegative() -> a
    void setCellEditable(int,int) -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    void setMyCellEditor(int) -> a
geogebra.gui.view.functioninspector.InspectorTable$MyCellRenderer -> geogebra.gui.m.d.g$a:
    javax.swing.JTextField tf -> a
    javax.swing.border.Border editCellBorder -> a
    javax.swing.JTable table -> a
    javax.swing.border.Border paddingBorder -> b
    boolean doRedNegative -> a
    geogebra.gui.view.functioninspector.InspectorTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
    java.awt.Color rowColor(int) -> a
geogebra.gui.view.functioninspector.InspectorTable$MyEditor -> geogebra.gui.m.d.g$b:
    geogebra.gui.view.functioninspector.InspectorTable this$0 -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    boolean stopCellEditing() -> stopCellEditing
geogebra.gui.view.probcalculator.ProbabilityCalculator -> geogebra.gui.m.e.a:
    boolean hasIntegral -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.probcalculator.ProbabilityManager probManager -> a
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar styleBar -> a
    int selectedDist -> a
    java.lang.String[][] parameterLabels -> a
    double[] parameters -> a
    boolean isCumulative -> b
    boolean isLineGraph -> c
    java.util.HashMap distributionMap -> a
    java.util.HashMap reverseDistributionMap -> b
    java.util.ArrayList plotGeoList -> a
    geogebra.common.kernel.geos.GeoPoint2 lowPoint -> a
    geogebra.common.kernel.geos.GeoPoint2 highPoint -> b
    geogebra.common.kernel.geos.GeoPoint2 curvePoint -> c
    geogebra.common.kernel.geos.GeoElement densityCurve -> a
    geogebra.common.kernel.geos.GeoElement integral -> b
    geogebra.common.kernel.geos.GeoElement ySegment -> c
    geogebra.common.kernel.geos.GeoElement xSegment -> d
    geogebra.common.kernel.geos.GeoElement discreteGraph -> e
    geogebra.common.kernel.geos.GeoElement discreteIntervalGraph -> f
    geogebra.common.kernel.geos.GeoList discreteValueList -> a
    geogebra.common.kernel.geos.GeoList discreteProbList -> b
    geogebra.common.kernel.geos.GeoList intervalProbList -> c
    geogebra.common.kernel.geos.GeoList intervalValueList -> d
    java.util.ArrayList pointList -> b
    javax.swing.JComboBox comboDistribution -> a
    javax.swing.JComboBox comboProbType -> b
    javax.swing.JTextField[] fldParameterArray -> a
    javax.swing.JTextField fldLow -> a
    javax.swing.JTextField fldHigh -> b
    javax.swing.JTextField fldResult -> c
    javax.swing.JLabel[] lblParameterArray -> a
    javax.swing.JLabel lblBetween -> a
    javax.swing.JLabel lblProbOf -> b
    javax.swing.JLabel lblEndProbOf -> c
    javax.swing.JLabel lblProb -> d
    javax.swing.JLabel lblDist -> e
    javax.swing.JSlider[] sliderArray -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator$ListSeparatorRenderer comboRenderer -> a
    javax.swing.JPanel controlPanel -> a
    javax.swing.JPanel distPanel -> b
    javax.swing.JPanel probPanel -> c
    javax.swing.JPanel tablePanel -> d
    javax.swing.JSplitPane mainSplitPane -> a
    javax.swing.JSplitPane plotSplitPane -> b
    int defaultDividerSize -> b
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView plotPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.PlotSettings plotSettings -> a
    geogebra.gui.view.probcalculator.ProbabilityTable table -> a
    boolean isIniting -> d
    boolean isSettingAxisPoints -> e
    int probMode -> c
    double low -> a
    double high -> b
    double probability -> c
    int printDecimals -> d
    int printFigures -> e
    java.awt.Color COLOR_PDF -> a
    java.awt.Color COLOR_PDF_FILL -> b
    java.awt.Color COLOR_POINT -> c
    boolean removeFromConstruction -> f
    java.util.TreeSet tempSet -> a
    javax.swing.AbstractAction exportToEVAction -> a
    void setProbabilityCalculator(int,double[],boolean) -> a
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar getStyleBar() -> a
    geogebra.gui.view.probcalculator.ProbabilityManager getProbManager() -> a
    int getSelectedDist() -> a
    int getProbMode() -> c
    boolean isCumulative() -> a
    void setCumulative(boolean) -> a
    boolean isLineGraph() -> b
    void setLineGraph(boolean) -> b
    int getPrintDecimals() -> d
    int getPrintFigures() -> e
    geogebra.gui.view.spreadsheet.statdialog.PlotSettings getPlotSettings() -> a
    void setPlotSettings(geogebra.gui.view.spreadsheet.statdialog.PlotSettings) -> a
    void createLayoutPanels() -> m
    void buildLayout() -> n
    void addRemoveTable(boolean) -> c
    geogebra.gui.view.probcalculator.ProbabilityCalculator$ListSeparatorRenderer getComboRenderer() -> a
    javax.swing.JPanel createDistributionPanel() -> a
    javax.swing.JPanel createProbabilityPanel() -> b
    void createGeoElements() -> o
    void updatePlotSettings() -> a
    void setXAxisPoints() -> e
    java.util.TreeSet getTempSet() -> a
    double intervalProbability() -> a
    double inverseProbability(double) -> a
    boolean isValidInterval(double,double) -> a
    boolean isValidParameter(double,double) -> b
    void updateFonts() -> f
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void setInterval(double,double) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateAll() -> g
    void updateGUI() -> p
    void updateIntervalProbability() -> q
    void updateProbabilityType() -> r
    void updateDistribution() -> h
    void updateDiscreteTable() -> s
    void updatePrintFormat(int,int) -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void clearView() -> b
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void repaintView() -> c
    void reset() -> d
    void setMode(int) -> a
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void attachView() -> i
    void detachView() -> j
    void setLabels() -> k
    void setLabelArrays() -> t
    void setProbabilityComboBoxMenu() -> u
    void setDistributionComboBoxMenu() -> v
    geogebra.common.kernel.geos.GeoElement createGeoFromString(java.lang.String,java.lang.String,boolean) -> a
    void removeGeos() -> l
    void clearPlotGeoList() -> w
    void hideAllGeosFromViews() -> x
    void hideGeoFromViews(geogebra.common.kernel.geos.GeoElement) -> g
    void hideToolTips() -> y
    java.lang.String buildDensityCurveExpression(int) -> a
    void createDiscreteLists() -> z
    double[] getPlotDimensions() -> a
    int getDiscreteXMax() -> f
    int getDiscreteXMin() -> g
    java.lang.String format(double) -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
    void getXML(java.lang.StringBuilder) -> a
    void removeFromAlgorithmList(geogebra.common.kernel.algos.AlgoElement) -> a
    void exportGeosToEV(int) -> b
    int getViewID() -> b
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    geogebra.main.Application access$0(geogebra.gui.view.probcalculator.ProbabilityCalculator) -> a
geogebra.gui.view.probcalculator.ProbabilityCalculator$1 -> geogebra.gui.m.e.b:
    geogebra.gui.view.probcalculator.ProbabilityCalculator this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabilityCalculator$ListSeparatorRenderer -> geogebra.gui.m.e.a$a:
    javax.swing.JSeparator separator -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.probcalculator.ProbabilityManager -> geogebra.gui.m.e.c:
    geogebra.main.Application app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    boolean isDiscrete(int) -> a
    java.util.HashMap getDistributionMap() -> a
    java.util.HashMap getReverseDistributionMap() -> b
    java.lang.String[][] getParameterLabelArray(geogebra.main.Application) -> a
    java.lang.String[] getCommand() -> a
    java.lang.String[] getInverseCommand() -> b
    int[] getParmCount() -> a
    java.util.HashMap getDefaultParameterMap() -> c
    double[] getPlotDimensions(int,double[],geogebra.common.kernel.geos.GeoElement,boolean) -> a
    double getDiscreteYMax(int,double[],int,int) -> a
    double probability(double,double[],int,boolean) -> a
    double intervalProbability(double,double,int,double[],int) -> a
    double inverseProbability(int,double,double[]) -> a
    double evaluateExpression(java.lang.String) -> a
geogebra.gui.view.probcalculator.ProbabilityTable -> geogebra.gui.m.e.d:
    geogebra.main.Application app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    geogebra.gui.view.probcalculator.ProbabilityManager probManager -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable statTable -> a
    java.lang.String[] columnNames -> a
    int distType -> a
    int xMin -> b
    int xMax -> c
    boolean isIniting -> a
    double[] parms -> a
    void setTable(int,double[],int,int) -> a
    boolean isCumulative() -> a
    void updateFonts(java.awt.Font) -> a
    void setColumnNames() -> a
    void setLabels() -> b
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void setSelectionByRowValue(int,int) -> a
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar -> geogebra.gui.m.e.e:
    geogebra.main.Application app -> a
    geogebra.gui.view.probcalculator.ProbabilityCalculator probCalc -> a
    int iconHeight -> a
    javax.swing.JButton btnRounding -> a
    javax.swing.JToggleButton btnCumulative -> a
    javax.swing.JToggleButton btnLineGraph -> b
    javax.swing.JToggleButton btnGrid -> c
    javax.swing.JPopupMenu roundingPopup -> a
    void createGUI() -> c
    void updateGUI() -> a
    void setLabels() -> b
    void buildOptionsButton() -> d
    void updateMenuDecimalPlaces(javax.swing.JPopupMenu) -> a
    javax.swing.JPopupMenu createRoundingPopup() -> a
    void addRadioButtonMenuItems(javax.swing.JPopupMenu,java.awt.event.ActionListener,java.lang.String[],java.lang.String[],int) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.probcalculator.ProbabilityCalculator access$0(geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar) -> a
    javax.swing.JPopupMenu access$1(geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar) -> a
    javax.swing.JButton access$2(geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar) -> a
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$1 -> geogebra.gui.m.e.f:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$2 -> geogebra.gui.m.e.g:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$3 -> geogebra.gui.m.e.h:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar$4 -> geogebra.gui.m.e.i:
    geogebra.gui.view.probcalculator.ProbabiltyCalculatorStyleBar this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.properties.PropertiesStyleBar -> geogebra.gui.m.f.a:
    geogebra.gui.view.properties.PropertiesView propertiesView -> a
    geogebra.main.Application app -> a
    geogebra.gui.util.PopupMenuButton btnOption -> a
    javax.swing.JPopupMenu menu -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$properties$PropertiesView$OptionType -> a
    void updateGUI() -> a
    void buildMenu() -> b
    java.lang.String getTypeLabel(geogebra.gui.view.properties.PropertiesView$OptionType) -> a
    javax.swing.ImageIcon getTypeIcon(geogebra.gui.view.properties.PropertiesView$OptionType) -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$properties$PropertiesView$OptionType() -> a
geogebra.gui.view.properties.PropertiesStyleBar$1 -> geogebra.gui.m.f.b:
    geogebra.gui.view.properties.PropertiesStyleBar this$0 -> a
    geogebra.gui.view.properties.PropertiesView$OptionType val$type -> a
    javax.swing.JCheckBoxMenuItem val$mi -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.properties.PropertiesView -> geogebra.gui.m.f.c:
    geogebra.main.Application app -> a
    boolean attached -> a
    geogebra.gui.view.properties.PropertiesStyleBar styleBar -> a
    geogebra.gui.dialog.options.OptionsDefaults defaultsPanel -> a
    geogebra.gui.dialog.options.OptionsEuclidian euclidianPanel -> a
    geogebra.gui.dialog.options.OptionsSpreadsheet spreadsheetPanel -> a
    geogebra.gui.dialog.options.OptionsCAS casPanel -> a
    geogebra.gui.dialog.options.OptionsAdvanced advancedPanel -> a
    geogebra.gui.dialog.options.OptionsObject objectPanel -> a
    geogebra.gui.view.properties.PropertiesView$OptionType selectedOptionType -> a
    int[] $SWITCH_TABLE$geogebra$gui$view$properties$PropertiesView$OptionType -> a
    geogebra.gui.view.properties.PropertiesView$OptionType getSelectedOptionType() -> a
    void setOptionPanel(geogebra.gui.view.properties.PropertiesView$OptionType) -> a
    void updateGUI() -> e
    javax.swing.JComponent getOptionPanel(geogebra.gui.view.properties.PropertiesView$OptionType) -> a
    geogebra.gui.view.properties.PropertiesStyleBar getStyleBar() -> a
    geogebra.gui.view.properties.PropertiesStyleBar newPropertiesStyleBar() -> b
    void setLabels() -> f
    void attachView() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void clearView() -> b
    void setMode(int) -> a
    int getViewID() -> b
    void updateSelection() -> a
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void windowPanel() -> h
    void unwindowPanel() -> i
    int[] $SWITCH_TABLE$geogebra$gui$view$properties$PropertiesView$OptionType() -> a
geogebra.gui.view.properties.PropertiesView$OptionType -> geogebra.gui.m.f.c$a:
    geogebra.gui.view.properties.PropertiesView$OptionType OBJECTS -> a
    geogebra.gui.view.properties.PropertiesView$OptionType EUCLIDIAN -> b
    geogebra.gui.view.properties.PropertiesView$OptionType EUCLIDIAN2 -> c
    geogebra.gui.view.properties.PropertiesView$OptionType CAS -> d
    geogebra.gui.view.properties.PropertiesView$OptionType SPREADSHEET -> e
    geogebra.gui.view.properties.PropertiesView$OptionType DEFAULTS -> f
    geogebra.gui.view.properties.PropertiesView$OptionType ADVANCED -> g
    geogebra.gui.view.properties.PropertiesView$OptionType[] ENUM$VALUES -> a
    geogebra.gui.view.properties.PropertiesView$OptionType[] values() -> values
    geogebra.gui.view.properties.PropertiesView$OptionType valueOf(java.lang.String) -> valueOf
geogebra.gui.view.spreadsheet.CellFormat -> geogebra.gui.m.g.a:
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.view.spreadsheet.CellFormat$MyHashMap[] formatMapArray -> a
    int formatCount -> a
    java.util.HashMap formatTokenMap -> a
    void clearAll() -> a
    java.util.HashMap getFormatMap(int) -> a
    java.lang.Object getCellFormat(geogebra.common.awt.Point,int) -> a
    java.lang.Object getCellFormat(geogebra.common.gui.view.spreadsheet.CellRange,int) -> a
    void setFormat(geogebra.common.awt.Point,int,java.lang.Object) -> a
    void setFormat(geogebra.common.gui.view.spreadsheet.CellRange,int,java.lang.Object) -> a
    void setFormat(java.util.ArrayList,int,java.lang.Object) -> a
    void setCellFormatString() -> b
    void setBorderStyle(java.util.ArrayList,int) -> a
    void setBorderStyle(geogebra.common.gui.view.spreadsheet.CellRange,int) -> a
    void getXML(java.lang.StringBuilder) -> a
    java.lang.StringBuilder encodeFormats() -> a
    void processXMLString(java.lang.String) -> a
    void processCellFormatString(java.lang.String) -> b
geogebra.gui.view.spreadsheet.CellFormat$MyHashMap -> geogebra.gui.m.g.a$a:
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
geogebra.gui.view.spreadsheet.CellRangeProcessor -> geogebra.gui.m.g.b:
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel tableModel -> a
    boolean isCreatePointListPossible(java.util.ArrayList) -> a
    boolean isCreateOperationTablePossible(java.util.ArrayList) -> b
    boolean isCreateMatrixPossible(java.util.ArrayList) -> c
    boolean isOneVarStatsPossible(java.util.ArrayList) -> d
    boolean isMultiVarStatsPossible(java.util.ArrayList) -> e
    boolean containsMinimumGeoNumeric(geogebra.common.gui.view.spreadsheet.CellRange,int) -> a
    geogebra.common.kernel.geos.GeoList createCollectionList(java.util.ArrayList,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createPolyLine(java.util.ArrayList,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createPolyLine(java.util.ArrayList,boolean,boolean,boolean,boolean) -> a
    void getPointListDimensions(java.util.ArrayList,geogebra.gui.view.spreadsheet.CellRangeProcessor$PointDimension) -> a
    geogebra.common.kernel.geos.GeoList createPointGeoList(java.util.ArrayList,boolean,boolean,boolean,boolean,boolean) -> a
    java.lang.String[] getPointListTitles(java.util.ArrayList,boolean) -> a
    java.lang.String[] getColumnTitles(java.util.ArrayList) -> a
    geogebra.common.kernel.geos.GeoElement createList(java.util.ArrayList,boolean,boolean) -> b
    geogebra.common.kernel.geos.GeoElement createList(java.util.ArrayList,boolean,boolean,boolean,boolean,geogebra.common.plugin.GeoClass,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createListFromColumn(int,boolean,boolean,boolean,geogebra.common.plugin.GeoClass,boolean) -> a
    java.lang.String createMatrixExpression(int,int,int,int,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createMatrix(int,int,int,int,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createMatrix(int,int,int,int,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createTableText(int,int,int,int,boolean,boolean) -> b
    void InsertLeft(int,int) -> a
    void InsertRight(int,int) -> b
    void InsertAbove(int,int) -> c
    void InsertBelow(int,int) -> d
    void createOperationTable(geogebra.common.gui.view.spreadsheet.CellRange,geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    java.lang.String getCellRangeString(geogebra.common.gui.view.spreadsheet.CellRange) -> a
geogebra.gui.view.spreadsheet.CellRangeProcessor$PointDimension -> geogebra.gui.m.g.b$a:
    boolean doHorizontalPairs -> a
    int c1 -> a
    int c2 -> b
    int r1 -> c
    int r2 -> d
    geogebra.gui.view.spreadsheet.CellRangeProcessor this$0 -> a
geogebra.gui.view.spreadsheet.CopyPasteCut -> geogebra.gui.m.g.c:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel tableModel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    java.lang.String cellBufferStr -> a
    geogebra.common.kernel.geos.GeoElement[][] cellBufferGeo -> a
    int sourceColumn1 -> a
    int sourceRow1 -> b
    java.lang.Object[] constructionIndexes -> a
    java.util.Comparator comparator -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView getView() -> a
    geogebra.gui.view.spreadsheet.MyTable getTable() -> a
    void copy(int,int,int,int,boolean) -> a
    boolean cut(int,int,int,int) -> a
    boolean paste(int,int,int,int) -> b
    boolean paste(int,int,int,int,java.awt.datatransfer.Transferable) -> a
    boolean pasteInternalMultiple(int,int,int,int) -> c
    boolean pasteInternal(int,int,int,int) -> d
    boolean pasteExternalMultiple(java.lang.String[][],geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean pasteExternalMultiple(java.lang.String[][],int,int,int,int) -> b
    boolean pasteExternal(java.lang.String[][],int,int,int,int) -> a
    boolean delete(int,int,int,int) -> e
    void deleteAll() -> a
    boolean delete(geogebra.common.main.AbstractApplication,int,int,int,int,int) -> a
    java.util.Comparator getComparator() -> a
    boolean pasteFromURL(java.net.URL) -> a
    boolean pasteFromURL(java.net.URL,geogebra.common.gui.view.spreadsheet.CellRange,boolean) -> a
    java.lang.String getExtension(java.lang.String) -> a
geogebra.gui.view.spreadsheet.CopyPasteCut$1 -> geogebra.gui.m.g.d:
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.view.spreadsheet.CopyPasteCut$Record -> geogebra.gui.m.g.c$a:
    int id -> a
    int x1 -> b
    int y1 -> c
    int x2 -> d
    int y2 -> e
    int getx1() -> a
    int getx2() -> b
    int gety1() -> c
    int gety2() -> d
geogebra.gui.view.spreadsheet.CreateObjectDialog -> geogebra.gui.m.g.e:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.CellRangeProcessor cp -> a
    java.util.ArrayList selectedCellRanges -> b
    int selectionType -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    int objectType -> b
    javax.swing.JList typeList -> a
    javax.swing.DefaultListModel model -> a
    javax.swing.JLabel lblObject -> b
    javax.swing.JLabel lblName -> c
    javax.swing.JLabel lblTake -> d
    javax.swing.JLabel lblOrder -> e
    javax.swing.JLabel lblXYOrder -> f
    javax.swing.JCheckBox ckSort -> b
    javax.swing.JCheckBox ckTranspose -> c
    javax.swing.JRadioButton btnValue -> a
    javax.swing.JRadioButton btnObject -> b
    javax.swing.JComboBox cbScanOrder -> a
    javax.swing.JComboBox cbTake -> b
    boolean isIniting -> a
    javax.swing.JPanel optionsPanel -> e
    javax.swing.JPanel typePanel -> f
    geogebra.gui.inputfield.MyTextField fldName -> a
    geogebra.common.kernel.geos.GeoElement newGeo -> b
    javax.swing.JScrollPane previewPanel -> a
    java.lang.String title -> c
    boolean keepNewGeo -> b
    javax.swing.JComboBox cbLeftRightOrder -> c
    javax.swing.JPanel cards -> g
    javax.swing.JLabel lblPreview -> g
    javax.swing.JPanel namePanel -> h
    void createAdditionalGUI() -> b
    void buildOptionsPanel() -> c
    void setLabels(java.lang.String) -> c
    void updateGUI() -> d
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void setVisible(boolean) -> setVisible
    void addNewGeoToConstruction() -> e
    void createNewGeo() -> f
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void windowLostFocus(java.awt.event.WindowEvent) -> windowLostFocus
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
geogebra.gui.view.spreadsheet.DataImport -> geogebra.gui.m.g.f:
    au.com.bytecode.opencsv.CSVParser commaParser -> a
    au.com.bytecode.opencsv.CSVParser tabParser -> b
    java.awt.datatransfer.DataFlavor HTMLflavor -> a
    boolean hasHTMLFlavor(java.awt.datatransfer.Transferable) -> a
    java.lang.String convertTransferableToString(java.awt.datatransfer.Transferable) -> a
    java.lang.String convertHTMLTableToCSV(java.lang.String) -> a
    java.lang.String[][] parseExternalData(geogebra.common.main.AbstractApplication,java.lang.String,java.lang.String[],boolean) -> a
    au.com.bytecode.opencsv.CSVParser getCommaParser() -> a
    au.com.bytecode.opencsv.CSVParser getTabParser() -> b
    java.lang.String[][] parseCSVdata(java.lang.String) -> b
    java.lang.String[][] parseTabData(java.lang.String) -> a
    java.lang.String adjustNumberString(geogebra.common.main.AbstractApplication,java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String[] getDefaultSeparators(geogebra.common.main.AbstractApplication) -> a
geogebra.gui.view.spreadsheet.DataImport$1 -> geogebra.gui.m.g.g:
    boolean foundTable -> a
    boolean firstInRow -> b
    boolean firstColumn -> c
    boolean finished -> d
    java.lang.StringBuilder val$sbHTML -> a
    void handleText(char[],int) -> handleText
    void handleStartTag(javax.swing.text.html.HTML$Tag,javax.swing.text.MutableAttributeSet,int) -> handleStartTag
geogebra.gui.view.spreadsheet.DialogCopyToSpreadsheet -> geogebra.gui.m.g.h:
    geogebra.gui.view.spreadsheet.SpreadsheetViewDnD dndHandler -> a
    geogebra.main.Application app -> a
    javax.swing.JButton btnCancel -> a
    javax.swing.JButton btnCopy -> b
    javax.swing.JRadioButton rbFree -> a
    javax.swing.JRadioButton rbDependent -> b
    javax.swing.JCheckBox ckTranspose -> a
    void createGUI() -> b
    void createGUIElements() -> c
    void setLabels() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setVisible(boolean) -> setVisible
geogebra.gui.view.spreadsheet.FileBrowserPanel -> geogebra.gui.m.g.i:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel browserPanel -> a
    javax.swing.JTree tree -> a
    javax.swing.tree.DefaultTreeModel treeModel -> a
    geogebra.common.io.QDParser xmlParser -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel$MyFileTreeHandler handler -> a
    java.lang.Object root -> a
    java.io.File rootFile -> a
    java.net.URL rootURL -> a
    javax.swing.JButton minimizeButton -> a
    javax.swing.JButton menuButton -> b
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    int mode -> a
    java.lang.Object getRoot() -> a
    java.lang.String getRootString() -> a
    boolean setRoot(java.lang.String,int) -> a
    void setRoot(java.lang.Object,int) -> a
    boolean loadRootDirectory() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void valueChanged(javax.swing.event.TreeSelectionEvent) -> valueChanged
    void treeExpanded(javax.swing.event.TreeExpansionEvent) -> treeExpanded
    void treeCollapsed(javax.swing.event.TreeExpansionEvent) -> treeCollapsed
    void updateFonts() -> a
    void addFileTree(javax.swing.tree.DefaultMutableTreeNode,java.io.File) -> a
    void sortFileList(java.io.File[]) -> a
    java.io.File getFileFromPath(javax.swing.tree.TreePath) -> a
    java.net.URL getURLFromPath(javax.swing.tree.TreePath) -> a
    void saveXMLTree(java.io.File) -> a
    java.lang.StringBuilder buildXMLFileTree(java.io.File) -> a
    void traverseDirectory(java.io.File,java.lang.StringBuilder) -> a
    javax.swing.ImageIcon dropDownIcon(javax.swing.ImageIcon,java.awt.Color) -> a
    geogebra.main.Application access$0(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    java.io.File access$1(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    void access$2(geogebra.gui.view.spreadsheet.FileBrowserPanel,java.io.File) -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel access$3(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView access$4(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
    int access$5(geogebra.gui.view.spreadsheet.FileBrowserPanel) -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$1 -> geogebra.gui.m.g.j:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra.gui.view.spreadsheet.FileBrowserPanel$2 -> geogebra.gui.m.g.k:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.view.spreadsheet.FileBrowserPanel$3 -> geogebra.gui.m.g.l:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.gui.view.spreadsheet.FileBrowserPanel$DataFileFilter -> geogebra.gui.m.g.i$a:
    boolean accept(java.io.File,java.lang.String) -> accept
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu -> geogebra.gui.m.g.i$b:
    javax.swing.JMenuItem menuItem -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel access$0(geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu) -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$1 -> geogebra.gui.m.g.m:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$2 -> geogebra.gui.m.g.n:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu$3 -> geogebra.gui.m.g.o:
    geogebra.gui.view.spreadsheet.FileBrowserPanel$FileBrowserMenu this$1 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.FileBrowserPanel$MyFileTreeHandler -> geogebra.gui.m.g.i$c:
    javax.swing.tree.DefaultMutableTreeNode previousNode -> a
    javax.swing.tree.DefaultMutableTreeNode currentNode -> b
    void startElement(java.lang.String,java.util.LinkedHashMap) -> a
    void endElement(java.lang.String) -> a
    javax.swing.tree.DefaultMutableTreeNode getFileTree() -> a
    void startDocument() -> a
    void endDocument() -> b
    void text(java.lang.String) -> b
    int getConsStep() -> a
geogebra.gui.view.spreadsheet.FileBrowserPanel$MyRenderer -> geogebra.gui.m.g.i$d:
    geogebra.gui.view.spreadsheet.FileBrowserPanel this$0 -> a
    java.awt.Component getTreeCellRendererComponent(javax.swing.JTree,java.lang.Object,boolean,boolean,boolean,int,boolean) -> getTreeCellRendererComponent
geogebra.gui.view.spreadsheet.FormulaBar -> geogebra.gui.m.g.p:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    javax.swing.JButton btnCancelFormula -> a
    javax.swing.JButton btnAcceptFormula -> b
    geogebra.gui.inputfield.AutoCompleteTextField fldFormula -> a
    geogebra.gui.inputfield.AutoCompleteTextField fldCellName -> b
    boolean isIniting -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    int row -> a
    int column -> b
    javax.swing.event.DocumentListener documentListener -> a
    void setEditorText(java.lang.String) -> a
    void update() -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
    boolean editorHasFocus() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView access$0(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    geogebra.gui.inputfield.AutoCompleteTextField access$1(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    javax.swing.JButton access$2(geogebra.gui.view.spreadsheet.FormulaBar) -> a
    javax.swing.JButton access$3(geogebra.gui.view.spreadsheet.FormulaBar) -> b
    geogebra.gui.view.spreadsheet.MyCellEditor access$4(geogebra.gui.view.spreadsheet.FormulaBar) -> a
geogebra.gui.view.spreadsheet.FormulaBar$1 -> geogebra.gui.m.g.q:
    geogebra.gui.view.spreadsheet.FormulaBar this$0 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void updateCellEditor(javax.swing.event.DocumentEvent) -> a
geogebra.gui.view.spreadsheet.FormulaBar$BarButtonListener -> geogebra.gui.m.g.p$a:
    geogebra.gui.view.spreadsheet.FormulaBar this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.spreadsheet.InputDialogOpenDataFolderURL -> geogebra.gui.m.g.r:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    void setLabels(java.lang.String) -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean processInput() -> b
geogebra.gui.view.spreadsheet.MyCellEditor -> geogebra.gui.m.g.s:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.geos.GeoElement value -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.inputfield.AutoCompleteTextField textField -> a
    int column -> a
    int row -> b
    boolean editing -> a
    boolean errorOnStopEditing -> b
    boolean allowProcessGeo -> c
    int tabReturnCol -> c
    void setAllowProcessGeo(boolean) -> a
    void setText(java.lang.String) -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    void setEqualsRequired(boolean) -> b
    void setLabels() -> a
    java.lang.String getEditorInitString(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isEditing() -> a
    int getCaretPosition() -> a
    void addLabel(java.lang.String) -> b
    void setLabel(java.lang.String) -> c
    java.lang.String getEditingValue() -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    void cancelCellEditing() -> cancelCellEditing
    boolean stopCellEditing() -> stopCellEditing
    boolean stopCellEditing(int,int) -> a
    void moveSelectedCell(int,int) -> a
    boolean processGeo() -> b
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    javax.swing.DefaultCellEditor$EditorDelegate access$0(geogebra.gui.view.spreadsheet.MyCellEditor) -> a
    void access$1(geogebra.gui.view.spreadsheet.MyCellEditor,boolean) -> a
    geogebra.gui.inputfield.AutoCompleteTextField access$2(geogebra.gui.view.spreadsheet.MyCellEditor) -> a
geogebra.gui.view.spreadsheet.MyCellEditor$1 -> geogebra.gui.m.g.t:
    geogebra.gui.view.spreadsheet.MyCellEditor this$0 -> a
    void changedUpdate(javax.swing.event.DocumentEvent) -> changedUpdate
    void insertUpdate(javax.swing.event.DocumentEvent) -> insertUpdate
    void removeUpdate(javax.swing.event.DocumentEvent) -> removeUpdate
    void updateFormulaBar(javax.swing.event.DocumentEvent) -> a
geogebra.gui.view.spreadsheet.MyCellEditor$SpreadsheetCellEditorKeyListener -> geogebra.gui.m.g.s$a:
    boolean isFormulaBarListener -> a
    geogebra.gui.view.spreadsheet.MyCellEditor this$0 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void checkCursorKeys(java.awt.event.KeyEvent) -> a
geogebra.gui.view.spreadsheet.MyCellEditorBoolean -> geogebra.gui.m.g.u:
    geogebra.main.Application app -> a
    geogebra.common.kernel.geos.GeoBoolean editGeo -> a
    javax.swing.JCheckBox checkBox -> a
    boolean editing -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    boolean stopCellEditing() -> stopCellEditing
geogebra.gui.view.spreadsheet.MyCellEditorButton -> geogebra.gui.m.g.v:
    javax.swing.JButton delegate -> a
    geogebra.common.kernel.geos.GeoButton editGeo -> a
    java.lang.Object getCellEditorValue() -> getCellEditorValue
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    geogebra.common.kernel.geos.GeoButton access$0(geogebra.gui.view.spreadsheet.MyCellEditorButton) -> a
geogebra.gui.view.spreadsheet.MyCellEditorButton$1 -> geogebra.gui.m.g.w:
    geogebra.gui.view.spreadsheet.MyCellEditorButton this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.spreadsheet.MyCellEditorButton access$0(geogebra.gui.view.spreadsheet.MyCellEditorButton$1) -> a
geogebra.gui.view.spreadsheet.MyCellEditorButton$1$1 -> geogebra.gui.m.g.x:
    geogebra.gui.view.spreadsheet.MyCellEditorButton$1 this$1 -> a
    void run() -> run
geogebra.gui.view.spreadsheet.MyCellEditorList -> geogebra.gui.m.g.y:
    geogebra.common.kernel.geos.GeoList editGeo -> a
    javax.swing.JComboBox comboBox -> a
    javax.swing.DefaultComboBoxModel model -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    java.lang.Object getCellEditorValue() -> getCellEditorValue
geogebra.gui.view.spreadsheet.MyCellEditorList$MyListCellRenderer -> geogebra.gui.m.g.y$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.MyCellRenderer -> geogebra.gui.m.g.z:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.ImageIcon latexIcon -> a
    javax.swing.ImageIcon emptyIcon -> b
    java.lang.String latexStr -> a
    geogebra.gui.view.spreadsheet.CellFormat formatHandler -> a
    geogebra.common.awt.Point cellPoint -> a
    java.lang.Integer alignment -> a
    java.lang.Integer traceBorder -> b
    java.lang.Integer fontStyle -> c
    boolean isCustomBGColor -> a
    javax.swing.border.Border cellPadding -> a
    javax.swing.border.Border bTop -> b
    javax.swing.border.Border bLeft -> c
    javax.swing.border.Border bBottom -> d
    javax.swing.border.Border bRight -> e
    javax.swing.border.Border bAll -> f
    javax.swing.JCheckBox checkBox -> a
    javax.swing.JButton button -> a
    javax.swing.JComboBox comboBox -> a
    javax.swing.DefaultComboBoxModel cbModel -> a
    java.awt.Color bgColor -> a
    geogebra.common.kernel.geos.GeoElement geo -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.MyCellRenderer$MyListCellRenderer -> geogebra.gui.m.g.z$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.MyTable -> geogebra.gui.m.g.A:
    int tableMode -> l
    java.awt.Color SELECTED_BACKGROUND_COLOR -> a
    java.awt.Color SELECTED_BACKGROUND_COLOR_HEADER -> b
    java.awt.Color BACKGROUND_COLOR_HEADER -> c
    java.awt.Color TABLE_GRID_COLOR -> d
    java.awt.Color HEADER_GRID_COLOR -> e
    java.awt.Color SELECTED_RECTANGLE_COLOR -> f
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    geogebra.gui.view.spreadsheet.MyCellEditorBoolean editorBoolean -> a
    geogebra.gui.view.spreadsheet.MyCellEditorButton editorButton -> a
    geogebra.gui.view.spreadsheet.MyCellEditorList editorList -> a
    geogebra.common.gui.view.spreadsheet.RelativeCopy relativeCopy -> a
    geogebra.gui.view.spreadsheet.CopyPasteCut copyPasteCut -> a
    geogebra.gui.view.spreadsheet.SpreadsheetColumnController$ColumnHeaderRenderer headerRenderer -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    javax.swing.table.DefaultTableModel tableModel -> a
    geogebra.gui.view.spreadsheet.CellRangeProcessor crProcessor -> a
    geogebra.gui.view.spreadsheet.MyTable$MyTableColumnModelListener columnModelListener -> a
    geogebra.gui.view.spreadsheet.CellFormat formatHandler -> a
    geogebra.common.kernel.geos.GeoElement targetCell -> a
    java.util.ArrayList selectedCellRanges -> a
    int minSelectionRow -> a
    int maxSelectionRow -> b
    int minSelectionColumn -> c
    int maxSelectionColumn -> d
    java.util.HashSet selectedColumnSet -> a
    java.util.HashSet selectedRowSet -> b
    int selectionType -> m
    boolean doShowDragHandle -> f
    java.awt.Color selectionRectangleColor -> g
    boolean isDragingDot -> a
    int dragingToRow -> e
    int dragingToColumn -> f
    boolean isOverDot -> b
    boolean isDragging2 -> c
    int minColumn2 -> g
    int maxColumn2 -> h
    int minRow2 -> i
    int maxRow2 -> j
    boolean isOverDnDRegion -> d
    boolean metaDown -> e
    java.util.HashSet cellResizeHeightSet -> c
    java.util.HashSet cellResizeWidthSet -> d
    java.util.ArrayList adjustedRowHeights -> b
    boolean doRecordRowHeights -> g
    int preferredColumnWidth -> k
    java.util.HashMap oneClickEditMap -> a
    java.awt.Cursor defaultCursor -> a
    java.awt.Cursor crossHairCursor -> b
    java.awt.Cursor handCursor -> c
    java.awt.Cursor grabbingCursor -> d
    java.awt.Cursor grabCursor -> e
    boolean isSelectAll -> h
    boolean isSelectNone -> i
    java.awt.Rectangle targetcellFrame -> a
    float[] dash1 -> a
    java.awt.BasicStroke dashed -> a
    boolean allowEditing -> j
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    java.util.ArrayList getSelectedCellRanges() -> a
    java.util.HashMap getOneClickEditMap() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView getView() -> a
    geogebra.gui.view.spreadsheet.CellRangeProcessor getCellRangeProcessor() -> a
    geogebra.gui.view.spreadsheet.CellFormat getCellFormatHandler() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorBoolean getEditorBoolean() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorButton getEditorButton() -> a
    geogebra.gui.view.spreadsheet.MyCellEditorList getEditorList() -> a
    void updateColumnCount() -> a
    javax.swing.table.TableCellEditor getCellEditor(int,int) -> getCellEditor
    void setEqualsRequired(boolean) -> a
    void setLabels() -> b
    int preferredColumnWidth() -> a
    void setPreferredColumnWidth(int) -> a
    void changeSelection(int,int,boolean,boolean) -> changeSelection
    void selectAll() -> selectAll
    void selectionChanged() -> c
    void setInitialCellSelection(int,int) -> a
    boolean setSelection(java.lang.String) -> a
    boolean setSelection(int,int) -> a
    boolean setSelection(int,int,int,int) -> a
    boolean setSelection(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void setSelectionType(int) -> b
    int getSelectionType() -> b
    void setRowSelectionInterval(int,int) -> setRowSelectionInterval
    void setColumnSelectionInterval(int,int) -> setColumnSelectionInterval
    boolean isSelectNone() -> a
    void setSelectNone(boolean) -> b
    boolean isSelectAll() -> b
    void setSelectAll(boolean) -> c
    java.util.ArrayList getSelectedColumnsList() -> b
    int[] getSelectedColumns() -> getSelectedColumns
    void setSelectionRectangleColor(java.awt.Color) -> a
    geogebra.common.awt.Point getPixel(int,int,boolean) -> a
    geogebra.common.awt.Point getMinSelectionPixel() -> a
    geogebra.common.awt.Point getMaxSelectionPixel() -> b
    geogebra.common.awt.Point getIndexFromPixel(int,int) -> a
    java.awt.Rectangle getCellBlockRect(int,int,int,int,boolean) -> a
    java.awt.Rectangle getSelectionRect(boolean) -> a
    void setTargetcellFrame(java.awt.Rectangle) -> a
    void paint(java.awt.Graphics) -> paint
    boolean editCellAt(int,int) -> editCellAt
    void handleControlDragSelect(java.awt.event.MouseEvent) -> a
    int convertColumnIndexToModel(int) -> convertColumnIndexToModel
    void setAllowEditing(boolean) -> d
    boolean isCellEditable(int,int) -> isCellEditable
    void updateEditor(java.lang.String) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setRowHeight(int,int) -> setRowHeight
    void setRowHeight(int) -> setRowHeight
    void resetRowHeights() -> d
    void resizeMarkedCells() -> e
    void setPreferredCellSize(int,int,boolean,boolean) -> a
    void fitColumn(int) -> c
    void fitRow(int) -> d
    void fitAll(boolean,boolean) -> a
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    int getTableMode() -> c
    void setTableMode(int) -> e
    boolean initAutoFunction() -> c
    void performAutoFunctionCreation(geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void stopAutoFunction() -> f
    boolean createAutoFunctionCell(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void updateAutoFunction() -> g
    void copy(boolean) -> e
    boolean paste() -> d
    boolean cut() -> e
    boolean delete() -> f
    java.awt.Cursor createCursor(java.awt.Image,boolean) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.gui.view.spreadsheet.MyTable$MyTableColumnModelListener -> geogebra.gui.m.g.A$a:
    geogebra.gui.view.spreadsheet.MyTable this$0 -> a
    void columnMarginChanged(javax.swing.event.ChangeEvent) -> columnMarginChanged
    void columnAdded(javax.swing.event.TableColumnModelEvent) -> columnAdded
    void columnMoved(javax.swing.event.TableColumnModelEvent) -> columnMoved
    void columnRemoved(javax.swing.event.TableColumnModelEvent) -> columnRemoved
    void columnSelectionChanged(javax.swing.event.ListSelectionEvent) -> columnSelectionChanged
geogebra.gui.view.spreadsheet.MyTable$MyTableModelListener -> geogebra.gui.m.g.A$b:
    geogebra.gui.view.spreadsheet.MyTable this$0 -> a
    void tableChanged(javax.swing.event.TableModelEvent) -> tableChanged
geogebra.gui.view.spreadsheet.SpreadsheetBorders -> geogebra.gui.m.g.B:
    void drawFormatBorders(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTable) -> a
    void handleRowOrColumnGridFormat(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTable,int,int,byte) -> a
    void drawPartialBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTable,int,int,int,int,byte) -> a
    void drawRowBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTable,int) -> a
    void drawColumnBorder(java.awt.Graphics2D,geogebra.gui.view.spreadsheet.MyTable,int) -> b
    boolean isZeroBit(int,int) -> a
geogebra.gui.view.spreadsheet.SpreadsheetColumnController -> geogebra.gui.m.g.C:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    javax.swing.table.DefaultTableModel model -> a
    int column0 -> a
    boolean isResizing -> a
    int overTraceButtonColumn -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    geogebra.main.Application access$0(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
    int access$1(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
    geogebra.gui.view.spreadsheet.MyTable access$2(geogebra.gui.view.spreadsheet.SpreadsheetColumnController) -> a
geogebra.gui.view.spreadsheet.SpreadsheetColumnController$ColumnHeaderRenderer -> geogebra.gui.m.g.C$a:
    java.awt.Color defaultBackground -> a
    javax.swing.JLabel lblHeader -> a
    javax.swing.JButton btnTrace -> a
    java.awt.BorderLayout layout -> a
    javax.swing.ImageIcon traceIcon -> a
    javax.swing.ImageIcon traceRollOverIcon -> b
    java.awt.Rectangle rect -> a
    geogebra.gui.view.spreadsheet.SpreadsheetColumnController this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
    boolean isOverTraceButton(int,java.awt.Point,java.lang.Object) -> a
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu -> geogebra.gui.m.g.D:
    java.awt.Color bgColor -> a
    java.awt.Color fgColor -> b
    geogebra.gui.view.spreadsheet.MyTable table -> a
    int row1 -> a
    int row2 -> b
    int column1 -> c
    int column2 -> d
    java.util.ArrayList selectedCellRanges -> a
    int selectionType -> e
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    java.util.ArrayList geos -> b
    geogebra.gui.view.spreadsheet.CellRangeProcessor cp -> a
    boolean isShiftDown -> a
    void initMenu() -> a
    java.lang.String getTitleString() -> a
    void setTitle(java.lang.String) -> a
    void addItem(java.awt.Component) -> a
    void addSubItem(javax.swing.JMenu,java.awt.Component) -> a
    boolean allFixed() -> a
    boolean isEmptySelection() -> b
    geogebra.gui.view.spreadsheet.CellRangeProcessor access$0(geogebra.gui.view.spreadsheet.SpreadsheetContextMenu) -> a
    java.util.ArrayList access$1(geogebra.gui.view.spreadsheet.SpreadsheetContextMenu) -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView access$2(geogebra.gui.view.spreadsheet.SpreadsheetContextMenu) -> a
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$1 -> geogebra.gui.m.g.E:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$10 -> geogebra.gui.m.g.F:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$11 -> geogebra.gui.m.g.G:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$12 -> geogebra.gui.m.g.H:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$13 -> geogebra.gui.m.g.I:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$14 -> geogebra.gui.m.g.J:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$15 -> geogebra.gui.m.g.K:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$16 -> geogebra.gui.m.g.L:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$17 -> geogebra.gui.m.g.M:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$18 -> geogebra.gui.m.g.N:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$19 -> geogebra.gui.m.g.O:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$2 -> geogebra.gui.m.g.P:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$20 -> geogebra.gui.m.g.Q:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$21 -> geogebra.gui.m.g.R:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$22 -> geogebra.gui.m.g.S:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$3 -> geogebra.gui.m.g.T:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$4 -> geogebra.gui.m.g.U:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$5 -> geogebra.gui.m.g.V:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$6 -> geogebra.gui.m.g.W:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$7 -> geogebra.gui.m.g.X:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$8 -> geogebra.gui.m.g.Y:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetContextMenu$9 -> geogebra.gui.m.g.Z:
    geogebra.gui.view.spreadsheet.SpreadsheetContextMenu this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.SpreadsheetKeyListener -> geogebra.gui.m.g.aa:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    javax.swing.table.DefaultTableModel model -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void letterOrDigitTyped() -> a
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
geogebra.gui.view.spreadsheet.SpreadsheetKeyListener$1 -> geogebra.gui.m.g.ab:
    geogebra.gui.view.spreadsheet.SpreadsheetKeyListener this$0 -> a
    javax.swing.text.JTextComponent val$f -> a
    void run() -> run
geogebra.gui.view.spreadsheet.SpreadsheetMouseListener -> geogebra.gui.m.g.ac:
    java.lang.String selectedCellName -> a
    java.lang.String prefix0 -> b
    java.lang.String postfix0 -> c
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    javax.swing.table.DefaultTableModel model -> a
    geogebra.gui.view.spreadsheet.MyCellEditor editor -> a
    geogebra.common.gui.view.spreadsheet.RelativeCopy relativeCopy -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void handleAutoFillDown() -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void setTableCursor() -> b
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader -> geogebra.gui.m.g.ad:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$MyListModel listModel -> a
    int minSelectionRow -> b
    int maxSelectionRow -> c
    java.awt.Cursor resizeCursor -> a
    java.awt.Cursor otherCursor -> b
    int mouseYOffset -> d
    int resizingRow -> e
    boolean doRowResize -> a
    int row0 -> a
    void updateRowHeader() -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    int getResizingRow(java.awt.Point) -> a
    void swapCursor() -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    geogebra.main.Application access$0(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    geogebra.gui.view.spreadsheet.MyTable access$1(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    int access$2(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> a
    int access$3(geogebra.gui.view.spreadsheet.SpreadsheetRowHeader) -> b
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$MyListModel -> geogebra.gui.m.g.ad$a:
    javax.swing.table.DefaultTableModel model -> a
    int getSize() -> getSize
    java.lang.Object getElementAt(int) -> getElementAt
    java.lang.Void changed() -> a
geogebra.gui.view.spreadsheet.SpreadsheetRowHeader$RowHeaderRenderer -> geogebra.gui.m.g.ad$b:
    javax.swing.JList rowHeader -> a
    java.awt.Color defaultBackground -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader this$0 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.SpreadsheetStyleBar -> geogebra.gui.m.g.ae:
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.view.spreadsheet.CellFormat formatHandler -> a
    java.util.ArrayList selectedCells -> a
    geogebra.gui.util.MyToggleButton btnFormulaBar -> a
    geogebra.gui.util.MyToggleButton btnLeftAlign -> b
    geogebra.gui.util.MyToggleButton btnCenterAlign -> c
    geogebra.gui.util.MyToggleButton btnRightAlign -> d
    geogebra.gui.color.ColorPopupMenuButton btnBgColor -> a
    geogebra.gui.util.MyToggleButton btnBold -> e
    geogebra.gui.util.MyToggleButton btnItalic -> f
    boolean allowActionPerformed -> a
    geogebra.gui.util.PopupMenuButton btnBorderStyle -> a
    int iconHeight -> a
    java.awt.Dimension iconDimension -> a
    void createButtons() -> c
    void setLabels() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void updateStyleBar() -> b
geogebra.gui.view.spreadsheet.SpreadsheetStyleBar$1 -> geogebra.gui.m.g.af:
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar this$0 -> a
    java.awt.Dimension val$bgColorIconSize -> a
    javax.swing.ImageIcon getButtonIcon() -> a
geogebra.gui.view.spreadsheet.SpreadsheetTableModel -> geogebra.gui.m.g.ag:
    javax.swing.table.DefaultTableModel defaultTableModel -> a
    javax.swing.table.DefaultTableModel getDefaultTableModel() -> a
    int getRowCount() -> a
    int getColumnCount() -> c
    void setRowCount(int) -> b
    void setColumnCount(int) -> c
    java.lang.Object getValueAt(int,int) -> a
    void setValueAt(java.lang.Object,int,int) -> a
geogebra.gui.view.spreadsheet.SpreadsheetToolbarManager -> geogebra.gui.m.g.ah:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.view.spreadsheet.CreateObjectDialog id -> a
    void handleModeChange(int) -> a
geogebra.gui.view.spreadsheet.SpreadsheetTraceManager -> geogebra.gui.m.g.ai:
    geogebra.common.main.AbstractApplication app -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.util.HashMap traceGeoCollection -> a
    java.util.HashSet storedTraces -> a
    boolean collectingTraces -> a
    boolean doShiftCellsUp -> b
    double[] coords -> a
    java.util.ArrayList currentTrace -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void addSpreadsheetTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void updateTraceSettings(geogebra.common.kernel.geos.GeoElement) -> b
    void removeSpreadsheetTraceGeo(geogebra.common.kernel.geos.GeoElement) -> c
    void loadTraceGeoCollection() -> a
    int getNextTraceColumn() -> a
    int getHighestTraceColumn() -> b
    boolean isTraceGeo(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isTraceColumn(int) -> a
    java.util.ArrayList getTraceGeoList() -> a
    geogebra.common.kernel.geos.GeoElement getTraceGeo(int) -> a
    void clearGeoTraceColumns(geogebra.common.kernel.geos.GeoElement) -> d
    void handleColumnDelete(int,int) -> a
    void setNeedsColumnReset(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    java.lang.String getTraceXML(geogebra.common.kernel.geos.GeoElement) -> a
    void traceToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> e
    boolean setGeoTraceRow(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction,java.util.ArrayList,int) -> a
    void setTraceCellAsGeoCopy(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement,int,int) -> a
    void setTraceCell(geogebra.common.kernel.Construction,int,int,java.lang.Object,geogebra.common.plugin.GeoClass) -> a
    void createTraceListCell(geogebra.common.kernel.Construction,int,int) -> a
    void updateTraceListCell(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement,int,int,java.lang.Object) -> a
    void getCurrentTrace(geogebra.common.kernel.geos.GeoElement) -> f
    boolean addElementTrace(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction,java.util.ArrayList) -> a
    void setHeader(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.Construction) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra.gui.view.spreadsheet.SpreadsheetView -> geogebra.gui.m.g.aj:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    geogebra.gui.view.spreadsheet.SpreadsheetTableModel tableModel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetRowHeader rowHeader -> a
    javax.swing.table.JTableHeader tableHeader -> a
    int DEFAULT_COLUMN_WIDTH -> a
    geogebra.gui.view.spreadsheet.TraceDialog traceDialog -> a
    javax.swing.JScrollPane spreadsheet -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel fileBrowser -> a
    int defaultDividerLocation -> b
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar styleBar -> a
    javax.swing.JPanel restorePanel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetToolbarManager toolbarManager -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog oneVarStatDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog twoVarStatDialog -> b
    geogebra.gui.view.spreadsheet.statdialog.StatDialog multiVarStatDialog -> c
    int mode -> c
    javax.swing.JSplitPane splitPane -> a
    geogebra.gui.view.spreadsheet.FormulaBar formulaBar -> a
    javax.swing.JPanel spreadsheetPanel -> b
    geogebra.gui.view.spreadsheet.SpreadsheetViewDnD dndHandler -> a
    boolean scrollToShow -> b
    boolean allowSettingUpate -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void buildSpreadsheet() -> v
    void setDefaultLayout() -> a
    void setDefaultSelection() -> e
    geogebra.main.Application getApplication() -> b
    geogebra.gui.view.spreadsheet.MyTable getTable() -> a
    javax.swing.JViewport getRowHeader() -> a
    javax.swing.JViewport getColumnHeader() -> b
    javax.swing.table.JTableHeader getTableHeader() -> a
    int getMode() -> a
    geogebra.gui.view.spreadsheet.SpreadsheetStyleBar getSpreadsheetStyleBar() -> a
    void attachView() -> f
    void detachView() -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void clearView() -> b
    void setMode(int) -> a
    void restart() -> h
    void reset() -> d
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void setScrollToShow(boolean) -> a
    geogebra.gui.view.spreadsheet.FormulaBar getFormulaBar() -> a
    void updateFormulaBar() -> i
    void showStatDialog(int) -> b
    boolean isStatDialogVisible() -> a
    void notifySpreadsheetSelectionChange() -> j
    void showTraceDialog(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    boolean isTraceDialogVisible() -> b
    geogebra.common.gui.view.spreadsheet.CellRange getTraceSelectionRange(int,int) -> a
    void setTraceDialogMode(boolean) -> b
    void getXML(java.lang.StringBuilder,boolean) -> a
    void setLabels() -> k
    void updateFonts() -> l
    void updateColumnWidths() -> m
    void setColumnWidthsFromSettings() -> n
    void setRowHeightsFromSettings() -> o
    void updateRowHeader() -> p
    void setSpreadsheetScrollPosition(int,int) -> a
    void expandSpreadsheetToViewport() -> q
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    boolean loadSpreadsheetFromURL(java.io.File) -> a
    boolean loadSpreadsheetFromURL(java.net.URL) -> a
    geogebra.gui.view.spreadsheet.FileBrowserPanel getFileBrowser() -> a
    void setShowFileBrowser(boolean) -> c
    boolean getShowBrowserPanel() -> c
    void minimizeBrowserPanel() -> r
    void restoreBrowserPanel() -> s
    javax.swing.JPanel getRestorePanel() -> a
    void initFileBrowser() -> t
    boolean setFileBrowserDirectory(java.lang.String,int) -> a
    void setShowRowHeader(boolean) -> d
    void setShowColumnHeader(boolean) -> e
    void setShowVScrollBar(boolean) -> f
    void setShowHScrollBar(boolean) -> g
    void setShowGrid(boolean) -> h
    boolean getAllowToolTips() -> d
    void setAllowToolTips(boolean) -> i
    void setShowFormulaBar(boolean) -> j
    boolean getShowFormulaBar() -> e
    boolean isVisibleStyleBar() -> f
    void setColumnSelect(boolean) -> k
    boolean isColumnSelect() -> g
    void setAllowSpecialEditor(boolean) -> l
    boolean allowSpecialEditor() -> h
    void setEqualsRequired(boolean) -> m
    void updateCellFormat(java.lang.String) -> a
    void updateRowHeightSetting(int,int) -> b
    void updatePreferredRowHeight(int) -> c
    void updateAllColumnWidthSettings() -> u
    geogebra.common.main.settings.SpreadsheetSettings settings() -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    boolean hasViewFocus() -> i
    void requestFocus() -> requestFocus
    boolean hasFocus() -> hasFocus
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    int getViewID() -> b
    int[] getGridColwidths() -> a
    int[] getGridRowHeights() -> b
    java.awt.Component[][] getPrintComponents() -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> c
    javax.swing.JPanel access$1(geogebra.gui.view.spreadsheet.SpreadsheetView) -> a
geogebra.gui.view.spreadsheet.SpreadsheetView$1 -> geogebra.gui.m.g.ak:
    geogebra.gui.view.spreadsheet.SpreadsheetView this$0 -> a
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
geogebra.gui.view.spreadsheet.SpreadsheetView$2 -> geogebra.gui.m.g.al:
    geogebra.gui.view.spreadsheet.SpreadsheetView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.spreadsheet.SpreadsheetView$Corner -> geogebra.gui.m.g.aj$a:
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.spreadsheet.SpreadsheetViewDnD -> geogebra.gui.m.g.am:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.MyTable table -> a
    java.awt.dnd.DragSource ds -> a
    java.awt.dnd.DropTarget dt -> a
    geogebra.common.awt.Point currentCell -> a
    boolean isTranspose -> b
    boolean isCopyByValue -> c
    boolean allowDrop -> a
    java.awt.datatransfer.DataFlavor HTMLflavor -> a
    void setAllowDrop(boolean) -> a
    boolean isTranspose() -> a
    void setTranspose(boolean) -> b
    boolean isCopyByValue() -> b
    void setCopyByValue(boolean) -> c
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragEnter(java.awt.dnd.DropTargetDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DropTargetEvent) -> dragExit
    void dragOver(java.awt.dnd.DropTargetDragEvent) -> dragOver
    void drop(java.awt.dnd.DropTargetDropEvent) -> drop
    boolean handleHtmlFlavorDrop(java.awt.dnd.DropTargetDropEvent) -> a
    void handleDropComplete(java.awt.dnd.DropTargetDropEvent,boolean) -> a
    void dropActionChanged(java.awt.dnd.DropTargetDragEvent) -> dropActionChanged
geogebra.gui.view.spreadsheet.TraceDialog -> geogebra.gui.m.g.an:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView view -> a
    geogebra.gui.view.spreadsheet.SpreadsheetTraceManager traceManager -> a
    javax.swing.JList traceGeoList -> a
    javax.swing.DefaultListModel traceGeoListModel -> a
    javax.swing.JSplitPane splitPane -> a
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JPanel optionsPanel -> a
    javax.swing.JPanel listPanel -> b
    javax.swing.JPanel promptPanel -> c
    javax.swing.JPanel buttonPanel -> d
    javax.swing.JPanel locationPanel -> e
    javax.swing.JPanel leftButtonPanel -> f
    javax.swing.JTextField firstRowField -> a
    javax.swing.JTextField numRowsField -> b
    javax.swing.JCheckBox cbResetColumns -> a
    javax.swing.JCheckBox cbRowLimit -> b
    javax.swing.JCheckBox cbShowLabel -> c
    javax.swing.JCheckBox cbTraceList -> d
    javax.swing.JCheckBox cbTraceGeoCopy -> e
    javax.swing.JButton btRemove -> a
    javax.swing.JButton btAdd -> b
    javax.swing.JButton btClose -> c
    javax.swing.JButton btCancel -> d
    javax.swing.JButton btErase -> e
    javax.swing.JLabel prompt -> a
    int mode -> a
    geogebra.common.gui.view.spreadsheet.CellRange newTraceLocation -> a
    boolean isIniting -> a
    javax.swing.JLabel lblStartRow -> b
    void setTraceDialogSelection(geogebra.common.kernel.geos.GeoElement,geogebra.common.gui.view.spreadsheet.CellRange) -> a
    void setVisible(boolean) -> setVisible
    void initGUI() -> d
    javax.swing.JPanel buildListPanel() -> a
    javax.swing.JPanel buildLocationPanel() -> b
    javax.swing.JPanel buildOptionsPanel() -> c
    javax.swing.JPanel buildButtonPanel() -> d
    void setLabels() -> a
    void updateGUI() -> e
    void updateTraceGeoList() -> f
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doActionPerformed(java.lang.Object) -> a
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void valueChanged(javax.swing.event.ListSelectionEvent) -> valueChanged
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void addTrace(geogebra.common.kernel.geos.GeoElement) -> a
    void removeTrace() -> g
    geogebra.common.kernel.geos.GeoElement getSelectedGeo() -> a
    geogebra.common.util.SpreadsheetTraceSettings getSettings() -> a
    void updateSelectedTraceGeo() -> h
    geogebra.common.gui.view.spreadsheet.CellRange getTraceSelectionRange(int,int) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setMode(int) -> b
    void toolbarModeChanged(int) -> a
    void updateTraceDialog() -> b
    void closeDialog() -> c
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.view.spreadsheet.TraceDialog$MyCellRenderer -> geogebra.gui.m.g.an$a:
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.ANOVATable -> geogebra.gui.m.g.a.a:
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.util.ArrayList getCategoryData(geogebra.common.kernel.geos.GeoList) -> a
    geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats anovaStats(java.util.Collection) -> a
geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats -> geogebra.gui.m.g.a.a$a:
    int dfbg -> a
    int dfwg -> b
    double F -> a
    double ssbg -> b
    double sswg -> c
    double sst -> d
    double msbg -> e
    double mswg -> f
    double P -> g
    int access$0(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> a
    int access$1(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> b
    double access$2(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> a
    double access$3(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> b
    double access$4(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> c
    double access$5(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> d
    double access$6(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> e
    double access$7(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> f
    double access$8(geogebra.gui.view.spreadsheet.statdialog.ANOVATable$AnovaStats) -> g
geogebra.gui.view.spreadsheet.statdialog.BasicStatTable -> geogebra.gui.m.g.a.b:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    int mode -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable statTable -> a
    java.lang.String[][] statMap -> a
    void initStatTable() -> c
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    java.lang.String[][] getStatMap() -> a
    java.lang.String[][] createOneVarStatMap() -> b
    java.lang.String[][] createTwoVarStatMap() -> c
    void updatePanel() -> a
    geogebra.common.kernel.algos.AlgoElement getStatMapAlgo(java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> a
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
geogebra.gui.view.spreadsheet.statdialog.DataPanel -> geogebra.gui.m.g.a.c:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialogController statController -> a
    javax.swing.JTable dataTable -> a
    javax.swing.JButton btnEnableAll -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyRowHeader rowHeader -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyColumnHeaderRenderer columnHeader -> a
    javax.swing.JScrollPane scrollPane -> a
    java.lang.Boolean[] selectionList -> a
    javax.swing.JLabel lblHeader -> a
    int preferredColumnWidth -> a
    java.awt.Color DISABLED_BACKGROUND_COLOR -> a
    java.awt.Color SELECTED_BACKGROUND_COLOR_HEADER -> b
    java.awt.Color TABLE_GRID_COLOR -> c
    java.awt.Color TABLE_HEADER_COLOR -> d
    void buildDataTable() -> a
    void createGUI() -> c
    java.lang.Boolean[] updateSelectionList(java.util.ArrayList) -> a
    void populateDataTable(java.util.ArrayList) -> b
    void loadDataTable(java.util.ArrayList) -> a
    void updateFonts(java.awt.Font) -> a
    void setFont(java.awt.Font) -> setFont
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setLabels() -> b
    java.awt.Color access$0() -> a
    java.awt.Color access$1() -> b
    geogebra.main.Application access$2(geogebra.gui.view.spreadsheet.statdialog.DataPanel) -> a
    java.lang.Boolean[] access$3(geogebra.gui.view.spreadsheet.statdialog.DataPanel) -> a
    java.awt.Color access$4() -> c
    geogebra.gui.view.spreadsheet.statdialog.StatDialogController access$5(geogebra.gui.view.spreadsheet.statdialog.DataPanel) -> a
    javax.swing.JButton access$6(geogebra.gui.view.spreadsheet.statdialog.DataPanel) -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyRowHeader access$7(geogebra.gui.view.spreadsheet.statdialog.DataPanel) -> a
geogebra.gui.view.spreadsheet.statdialog.DataPanel$1 -> geogebra.gui.m.g.a.d:
    geogebra.gui.view.spreadsheet.statdialog.DataPanel this$0 -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
geogebra.gui.view.spreadsheet.statdialog.DataPanel$CheckBoxIcon -> geogebra.gui.m.g.a.c$a:
    java.awt.Color highlightBackground -> a
    int csize -> a
    void paintIcon(boolean,boolean,java.awt.Graphics,int,int) -> a
    javax.swing.ImageIcon createCheckBoxImageIcon(boolean,boolean) -> a
geogebra.gui.view.spreadsheet.statdialog.DataPanel$Corner -> geogebra.gui.m.g.a.c$b:
    geogebra.gui.view.spreadsheet.statdialog.DataPanel this$0 -> a
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyCellRenderer -> geogebra.gui.m.g.a.c$c:
    geogebra.gui.view.spreadsheet.statdialog.DataPanel this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyColumnHeaderRenderer -> geogebra.gui.m.g.a.c$d:
    geogebra.gui.view.spreadsheet.statdialog.DataPanel this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyRowHeader -> geogebra.gui.m.g.a.c$e:
    javax.swing.JTable table -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel dataPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel this$0 -> b
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void enableAll() -> a
    boolean isAllEnabled() -> a
geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyRowHeader$RowHeaderRenderer -> geogebra.gui.m.g.a.c$e$a:
    javax.swing.ImageIcon iconChecked -> a
    javax.swing.ImageIcon iconUnChecked -> b
    geogebra.gui.view.spreadsheet.statdialog.DataPanel$MyRowHeader this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.FrequencyTable -> geogebra.gui.m.g.a.e:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable statTable -> a
    void setTable(double[],double[],geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    java.lang.String[] getColumnNames(geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
geogebra.gui.view.spreadsheet.statdialog.MinimalMultiVarStatPanel -> geogebra.gui.m.g.a.f:
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.lang.String[][] getCmdMap() -> a
geogebra.gui.view.spreadsheet.statdialog.MultiVarStatPanel -> geogebra.gui.m.g.a.g:
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    void updatePanel() -> a
    java.lang.String[][] getCmdMap() -> a
geogebra.gui.view.spreadsheet.statdialog.OneVarInferencePanel -> geogebra.gui.m.g.a.h:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable resultTable -> a
    javax.swing.JLabel lblHypParameter -> a
    javax.swing.JLabel lblTailType -> b
    javax.swing.JLabel lblNull -> c
    javax.swing.JLabel lblConfLevel -> d
    javax.swing.JLabel lblSigma -> e
    javax.swing.JLabel lblResultHeader -> f
    javax.swing.JButton btnCalculate -> a
    geogebra.gui.inputfield.MyTextField fldNullHyp -> a
    geogebra.gui.inputfield.MyTextField fldConfLevel -> b
    geogebra.gui.inputfield.MyTextField fldSigma -> c
    javax.swing.JRadioButton btnLeft -> a
    javax.swing.JRadioButton btnRight -> b
    javax.swing.JRadioButton btnTwo -> c
    javax.swing.JComboBox cbAltHyp -> a
    javax.swing.JPanel testPanel -> a
    javax.swing.JPanel intPanel -> b
    javax.swing.JPanel mainPanel -> c
    javax.swing.JPanel resultPanel -> d
    javax.swing.Box sigmaPanel -> a
    int fieldWidth -> a
    java.lang.String tail -> a
    double confLevel -> j
    double hypMean -> k
    double sigma -> l
    double testStat -> a
    double P -> b
    double df -> c
    double lower -> d
    double upper -> e
    double mean -> f
    double se -> g
    double me -> h
    double N -> i
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    org.apache.commons.math.distribution.NormalDistributionImpl normalDist -> a
    boolean isIniting -> a
    boolean isTest -> b
    boolean isZProcedure -> c
    int selectedPlot -> b
    void createGUIElements() -> c
    void updateMainPanel() -> d
    void setResultTable() -> e
    void updateResultTable() -> f
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
    void updateNumberField(javax.swing.JTextField,double) -> a
    void updateGUI() -> g
    void updateCBAlternativeHyp() -> h
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setSelectedPlot(int) -> a
    void updatePanel() -> a
    void evaluate() -> i
    double adjustedPValue(double,double,java.lang.String) -> a
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
    javax.swing.Box hBox(java.awt.Component[]) -> a
geogebra.gui.view.spreadsheet.statdialog.OptionsPanel -> geogebra.gui.m.g.a.i:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings settings -> a
    javax.swing.JCheckBox ckCumulative -> a
    javax.swing.JCheckBox ckManual -> b
    javax.swing.JCheckBox ckOverlayNormal -> c
    javax.swing.JCheckBox ckOverlayPolygon -> d
    javax.swing.JCheckBox ckShowFrequencyTable -> e
    javax.swing.JCheckBox ckShowHistogram -> f
    javax.swing.JRadioButton rbRelative -> a
    javax.swing.JRadioButton rbNormalized -> b
    javax.swing.JRadioButton rbFreq -> c
    javax.swing.JLabel lblFreqType -> a
    javax.swing.JCheckBox ckAutoWindow -> g
    javax.swing.JCheckBox ckShowGrid -> h
    javax.swing.JLabel lblXMin -> b
    javax.swing.JLabel lblXMax -> c
    javax.swing.JLabel lblYMin -> d
    javax.swing.JLabel lblYMax -> e
    javax.swing.JLabel lblXInterval -> f
    javax.swing.JLabel lblYInterval -> g
    geogebra.gui.inputfield.MyTextField fldXMin -> a
    geogebra.gui.inputfield.MyTextField fldXMax -> b
    geogebra.gui.inputfield.MyTextField fldYMin -> c
    geogebra.gui.inputfield.MyTextField fldYMax -> d
    geogebra.gui.inputfield.MyTextField fldXInterval -> e
    geogebra.gui.inputfield.MyTextField fldYInterval -> f
    javax.swing.JPanel histogramPanel -> a
    javax.swing.JPanel graphPanel -> b
    javax.swing.JPanel classesPanel -> c
    javax.swing.JPanel scatterplotPanel -> d
    javax.swing.JPanel mainPanel -> e
    boolean showYSettings -> a
    javax.swing.JTabbedPane tabbedPane -> a
    javax.swing.JCheckBox ckShowLines -> i
    javax.swing.JLabel lblOverlay -> h
    boolean isUpdating -> b
    int plotType -> a
    javax.swing.JPanel freqPanel -> f
    javax.swing.JPanel showPanel -> g
    javax.swing.JRadioButton rbLeftRule -> d
    javax.swing.JRadioButton rbRightRule -> e
    javax.swing.JPanel dimPanel -> h
    javax.swing.JLabel lblClassRule -> i
    void setPanel(int) -> a
    void createHistogramPanel() -> a
    void createScatterplotPanel() -> c
    void createGraphPanel() -> d
    javax.swing.JComponent insetPanel(int,javax.swing.JComponent[]) -> a
    void setLabels() -> b
    void updateGUI() -> e
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void updateFonts(java.awt.Font) -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianController -> geogebra.gui.m.g.a.j:
    void showDrawingPadPopup(geogebra.common.awt.Point) -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView -> geogebra.gui.m.g.a.k:
    geogebra.euclidian.EuclidianController ec -> a
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView plotPanelEV -> a
    boolean[] showAxes -> a
    boolean showGrid -> f
    int viewID -> e
    geogebra.gui.view.spreadsheet.statdialog.PlotSettings plotSettings -> a
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$MyMouseListener myMouseListener -> a
    boolean overDragRegion -> g
    java.awt.dnd.DragSource ds -> a
    java.awt.Cursor grabbingCursor -> b
    java.awt.Cursor grabCursor -> c
    java.util.ArrayList actionList -> a
    javax.swing.AbstractAction exportToEVAction -> c
    java.awt.datatransfer.DataFlavor plotPanelFlavor -> a
    javax.swing.AbstractAction exportGraphicAction -> a
    javax.swing.AbstractAction drawingPadToClipboardAction -> b
    void setMode(int) -> a
    int getViewID() -> b
    void updateSize() -> s
    void updateSettings(geogebra.gui.view.spreadsheet.statdialog.PlotSettings) -> a
    void setEVParams() -> H
    void componentHidden(java.awt.event.ComponentEvent) -> componentHidden
    void componentMoved(java.awt.event.ComponentEvent) -> componentMoved
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
    void componentShown(java.awt.event.ComponentEvent) -> componentShown
    void setMouseEnabled(boolean,boolean) -> b
    void setMouseMotionEnabled(boolean) -> o
    void setMouseWheelEnabled(boolean) -> p
    void setDefaultCursor() -> z
    java.util.ArrayList getActionList() -> b
    void enableDnD() -> I
    void dragDropEnd(java.awt.dnd.DragSourceDropEvent) -> dragDropEnd
    void dragEnter(java.awt.dnd.DragSourceDragEvent) -> dragEnter
    void dragExit(java.awt.dnd.DragSourceEvent) -> dragExit
    void dragOver(java.awt.dnd.DragSourceDragEvent) -> dragOver
    void dropActionChanged(java.awt.dnd.DragSourceDragEvent) -> dropActionChanged
    void dragGestureRecognized(java.awt.dnd.DragGestureEvent) -> dragGestureRecognized
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView access$0(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView) -> a
    void access$1(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView,boolean) -> a
    javax.swing.AbstractAction access$2(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView) -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$1 -> geogebra.gui.m.g.a.l:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView access$0(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$1) -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$1$1 -> geogebra.gui.m.g.a.m:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$1 this$1 -> a
    void run() -> run
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$2 -> geogebra.gui.m.g.a.n:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView access$0(geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$2) -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$2$1 -> geogebra.gui.m.g.a.o:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$2 this$1 -> a
    void run() -> run
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$ContextMenu -> geogebra.gui.m.g.a.k$a:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$MyMouseListener -> geogebra.gui.m.g.a.k$b:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$MyMouseMotionListener -> geogebra.gui.m.g.a.k$c:
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView$TransferablePlotPanel -> geogebra.gui.m.g.a.k$d:
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.lang.String plotPanelIdentifier -> a
    java.awt.Image image -> a
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView this$0 -> a
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
geogebra.gui.view.spreadsheet.statdialog.PlotSettings -> geogebra.gui.m.g.a.p:
    double xMin -> a
    double xMax -> b
    double xAxesInterval -> c
    boolean xAxesIntervalAuto -> a
    double yMin -> d
    double yMax -> e
    double yAxesInterval -> f
    boolean yAxesIntervalAuto -> b
    double[] gridInterval -> a
    boolean gridIntervalAuto -> c
    int pointCaptureStyle -> a
    boolean showYAxis -> d
    boolean showArrows -> e
    boolean forceXAxisBuffer -> f
    boolean forceYAxisBuffer -> g
    boolean[] isEdgeAxis -> a
    boolean[] isPositiveOnly -> b
    boolean showGrid -> h
geogebra.gui.view.spreadsheet.statdialog.RegressionPanel -> geogebra.gui.m.g.a.q:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    javax.swing.JLabel lblRegEquation -> a
    javax.swing.JLabel lblEqn -> b
    javax.swing.JLabel lblTitleX -> c
    javax.swing.JLabel lblTitleY -> d
    geogebra.gui.inputfield.MyTextField fldTitleX -> a
    geogebra.gui.inputfield.MyTextField fldTitleY -> b
    javax.swing.JComboBox cbRegression -> a
    javax.swing.JComboBox cbPolyOrder -> b
    javax.swing.JButton btnSwapXY -> a
    javax.swing.JLabel lblEvaluate -> e
    geogebra.gui.inputfield.MyTextField fldInputX -> c
    javax.swing.JLabel lblOutputY -> f
    java.lang.String[] regressionLabels -> a
    geogebra.gui.inputfield.MyTextField fldOutputY -> d
    boolean isIniting -> a
    javax.swing.JPanel predictionPanel -> a
    javax.swing.JPanel regressionPanel -> b
    javax.swing.JPanel createRegressionPanel() -> a
    void createPredictionPanel() -> d
    void updateRegressionPanel() -> a
    void setRegressionLabels() -> e
    void setLabels() -> b
    void setRegressionEquationLabel() -> c
    void updateGUI() -> f
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void updateFonts(java.awt.Font) -> a
geogebra.gui.view.spreadsheet.statdialog.StatComboPanel -> geogebra.gui.m.g.a.r:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatGeo statGeo -> a
    int mode -> a
    int selectedPlot -> b
    java.util.HashMap plotMap -> a
    java.util.HashMap plotMapReverse -> b
    geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings settings -> a
    java.util.ArrayList plotGeoList -> a
    geogebra.common.kernel.geos.GeoElement[] boxPlotTitles -> a
    geogebra.common.kernel.geos.GeoElement histogram -> a
    geogebra.common.kernel.geos.GeoElement dotPlot -> b
    geogebra.common.kernel.geos.GeoElement frequencyPolygon -> c
    geogebra.common.kernel.geos.GeoElement normalCurve -> d
    geogebra.common.kernel.geos.GeoElement scatterPlot -> e
    geogebra.common.kernel.geos.GeoElement scatterPlotLine -> f
    geogebra.common.kernel.geos.GeoElement residualPlot -> g
    geogebra.common.kernel.geos.GeoElement nqPlot -> h
    geogebra.common.kernel.geos.GeoElement boxPlot -> i
    javax.swing.JPanel displayCardPanel -> a
    javax.swing.JPanel metaPlotPanel -> b
    javax.swing.JPanel plotPanelNorth -> c
    javax.swing.JPanel plotPanelSouth -> d
    geogebra.gui.view.spreadsheet.statdialog.PlotPanelEuclidianView plotPanel -> a
    javax.swing.JLabel imageContainer -> a
    javax.swing.JPanel controlPanel -> e
    javax.swing.JPanel controlCards -> f
    boolean hasControlPanel -> a
    javax.swing.JComboBox cbDisplayType -> a
    geogebra.gui.view.spreadsheet.statdialog.OptionsPanel optionsPanel -> a
    javax.swing.JToggleButton optionsButton -> a
    int numClasses -> c
    javax.swing.JPanel numClassesPanel -> g
    javax.swing.JSlider sliderNumClasses -> a
    javax.swing.JToolBar manualClassesPanel -> a
    javax.swing.JLabel lblStart -> b
    javax.swing.JLabel lblWidth -> c
    geogebra.gui.inputfield.AutoCompleteTextField fldStart -> a
    geogebra.gui.inputfield.AutoCompleteTextField fldWidth -> b
    javax.swing.JLabel lblNumClasses -> d
    javax.swing.JToolBar stemAdjustPanel -> b
    javax.swing.JLabel lblAdjust -> e
    javax.swing.JButton minus -> a
    javax.swing.JButton none -> b
    javax.swing.JButton plus -> c
    int stemPlotAdjustment -> d
    javax.swing.JPanel imagePanel -> h
    javax.swing.JLabel lblTitleX -> f
    javax.swing.JLabel lblTitleY -> g
    geogebra.gui.inputfield.MyTextField fldTitleX -> a
    geogebra.gui.inputfield.MyTextField fldTitleY -> b
    geogebra.gui.view.spreadsheet.statdialog.FrequencyTable frequencyTable -> a
    javax.swing.AbstractAction exportToEVAction -> a
    void createGUI() -> f
    void setLabels() -> b
    void createDisplayTypeComboBox() -> g
    void updatePlotPanelLayout() -> h
    void createImagePanel() -> i
    void createNumClassesPanel() -> j
    void createStemPlotAdjustmentPanel() -> k
    void createManualClassesPanel() -> l
    void createPlotMap() -> m
    void updatePlot(boolean) -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(java.lang.Object) -> a
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void clearPlotGeoList() -> a
    void removeGeos() -> c
    void detachView() -> d
    void attachView() -> e
    javax.swing.JPanel flowPanel(javax.swing.JComponent[]) -> a
    javax.swing.JPanel flowPanelRight(javax.swing.JComponent[]) -> b
    void updateFonts(java.awt.Font) -> a
    void exportGeosToEV(int) -> a
    void prepareGeoForEV(geogebra.common.kernel.geos.GeoElement,int) -> a
    geogebra.main.Application access$0(geogebra.gui.view.spreadsheet.statdialog.StatComboPanel) -> a
    void access$1(geogebra.gui.view.spreadsheet.statdialog.StatComboPanel,int) -> a
    int access$2(geogebra.gui.view.spreadsheet.statdialog.StatComboPanel) -> a
geogebra.gui.view.spreadsheet.statdialog.StatComboPanel$1 -> geogebra.gui.m.g.a.s:
    geogebra.gui.view.spreadsheet.statdialog.StatComboPanel this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatComboPanel$2 -> geogebra.gui.m.g.a.t:
    geogebra.gui.view.spreadsheet.statdialog.StatComboPanel this$0 -> a
    void propertyChange(java.beans.PropertyChangeEvent) -> propertyChange
geogebra.gui.view.spreadsheet.statdialog.StatComboPanel$3 -> geogebra.gui.m.g.a.u:
    geogebra.gui.view.spreadsheet.statdialog.StatComboPanel this$0 -> a
    javax.swing.JTextField val$fldNumClasses -> a
    void stateChanged(javax.swing.event.ChangeEvent) -> stateChanged
geogebra.gui.view.spreadsheet.statdialog.StatComboPanel$MyRenderer -> geogebra.gui.m.g.a.r$a:
    javax.swing.JSeparator separator -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.StatDialog -> geogebra.gui.m.g.a.v:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView spView -> a
    geogebra.gui.view.spreadsheet.statdialog.StatGeo statGeo -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialogController sdc -> a
    int mode -> a
    boolean showDataPanel -> c
    boolean showStatPanel -> d
    boolean showComboPanel2 -> e
    boolean isIniting -> a
    boolean leftToRight -> b
    java.awt.Color TABLE_GRID_COLOR -> a
    java.awt.Color TABLE_HEADER_COLOR -> b
    java.awt.Color HISTOGRAM_COLOR -> c
    java.awt.Color BOXPLOT_COLOR -> d
    java.awt.Color DOTPLOT_COLOR -> e
    java.awt.Color NQPLOT_COLOR -> f
    java.awt.Color REGRESSION_COLOR -> g
    java.awt.Color OVERLAY_COLOR -> h
    int regressionMode -> b
    int regressionOrder -> c
    javax.swing.JLabel lblOneVarTitle -> a
    geogebra.gui.inputfield.MyTextField fldOneVarTitle -> a
    javax.swing.JButton btnClose -> a
    geogebra.gui.util.PopupMenuButton btnOptions -> a
    geogebra.gui.view.spreadsheet.statdialog.DataPanel dataPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatisticsPanel statisticsPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.RegressionPanel regressionPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatComboPanel comboStatPanel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatComboPanel comboStatPanel2 -> b
    javax.swing.JSplitPane statDataPanel -> a
    javax.swing.JSplitPane displayPanel -> b
    javax.swing.JSplitPane comboPanelSplit -> c
    javax.swing.JPanel buttonPanel -> a
    int defaultDividerSize -> d
    java.awt.Dimension defaultDialogDimension -> a
    geogebra.gui.util.SpecialNumberFormat nf -> a
    void createGUI() -> j
    geogebra.gui.view.spreadsheet.statdialog.DataPanel getDataPanel() -> a
    void initGUI() -> k
    javax.swing.JPanel createOneVarTitlePanel() -> a
    void createOptionsButton() -> l
    java.lang.String format(double) -> a
    int getPrintDecimals() -> a
    int getPrintFigures() -> c
    geogebra.gui.view.spreadsheet.statdialog.StatDialogController getStatDialogController() -> a
    geogebra.common.kernel.geos.GeoElement getRegressionModel() -> a
    geogebra.gui.view.spreadsheet.statdialog.StatGeo getStatGeo() -> a
    int getRegressionOrder() -> d
    void setRegressionMode(int) -> b
    int getRegressionMode() -> e
    void setRegressionOrder(int) -> c
    geogebra.main.Application getApp() -> a
    void setLeftToRight(boolean) -> a
    int getMode() -> f
    void setShowComboPanel2(boolean) -> c
    void updateStatDataPanelVisibility() -> e
    void doPrint() -> m
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void changedNumberFormat() -> c_
    void setVisible(boolean) -> setVisible
    void updateGUI() -> n
    void updateFonts() -> f
    void setFontRecursive(java.awt.Container,java.awt.Font) -> a
    void setLabels() -> g
    void setLabelsRecursive(java.awt.Container) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void clearView() -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void repaintView() -> c
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void reset() -> d
    void setMode(int) -> a
    void attachView() -> h
    void detachView() -> i
    void updateDialog(boolean) -> b
    java.lang.String[] getDataTitles() -> a
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void paint(java.awt.Graphics,double) -> a
    int getViewID() -> b
    boolean access$0(geogebra.gui.view.spreadsheet.statdialog.StatDialog) -> a
    void access$1(geogebra.gui.view.spreadsheet.statdialog.StatDialog,boolean) -> a
    boolean access$2(geogebra.gui.view.spreadsheet.statdialog.StatDialog) -> b
    void access$3(geogebra.gui.view.spreadsheet.statdialog.StatDialog,boolean) -> b
    boolean access$4(geogebra.gui.view.spreadsheet.statdialog.StatDialog) -> c
    void access$5(geogebra.gui.view.spreadsheet.statdialog.StatDialog,boolean) -> c
    void access$6(geogebra.gui.view.spreadsheet.statdialog.StatDialog) -> a
geogebra.gui.view.spreadsheet.statdialog.StatDialog$1 -> geogebra.gui.m.g.a.w:
    geogebra.gui.view.spreadsheet.statdialog.StatDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatDialog$2 -> geogebra.gui.m.g.a.x:
    geogebra.gui.view.spreadsheet.statdialog.StatDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatDialog$3 -> geogebra.gui.m.g.a.y:
    geogebra.gui.view.spreadsheet.statdialog.StatDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatDialog$4 -> geogebra.gui.m.g.a.z:
    geogebra.gui.view.spreadsheet.statdialog.StatDialog this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatDialogController -> geogebra.gui.m.g.a.A:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra.gui.view.spreadsheet.MyTable spreadsheetTable -> a
    geogebra.gui.view.spreadsheet.SpreadsheetView spView -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog sd -> a
    geogebra.gui.view.spreadsheet.statdialog.StatGeo statGeo -> a
    java.lang.Object dataSource -> a
    java.util.ArrayList dataArray -> a
    geogebra.common.kernel.geos.GeoList dataSelected -> a
    int mode -> a
    boolean leftToRight -> a
    geogebra.common.kernel.geos.GeoElement geoRegression -> a
    java.util.ArrayList getDataArray() -> a
    geogebra.common.kernel.geos.GeoList getDataSelected() -> a
    void setLeftToRight(boolean) -> a
    geogebra.common.kernel.geos.GeoElement getRegressionModel() -> a
    boolean setDataSource() -> a
    boolean isInDataSource(geogebra.common.kernel.geos.GeoElement) -> a
    void loadDataLists() -> a
    void updateSelectedDataList(int,boolean) -> a
    java.lang.String[] getDataTitles() -> a
    void swapXY() -> b
    void updateDialog(boolean) -> b
    void updateAllStatPanels(boolean) -> c
    void handleRemovedDataGeo(geogebra.common.kernel.geos.GeoElement) -> a
    void setRegressionGeo() -> c
    void removeRegressionGeo() -> d
    void removeDataListSelected() -> e
    void removeStatGeos() -> f
    void removeStatGeo(geogebra.common.kernel.geos.GeoElement) -> b
    double[] getValueArray(geogebra.common.kernel.geos.GeoList) -> a
geogebra.gui.view.spreadsheet.statdialog.StatGeo -> geogebra.gui.m.g.a.B:
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    double xMinData -> a
    double xMaxData -> b
    double yMinData -> c
    double yMaxData -> d
    double[] dataBounds -> a
    boolean histogramRight -> a
    boolean removeFromConstruction -> b
    void getDataBounds(geogebra.common.kernel.geos.GeoList) -> a
    void getDataBounds(geogebra.common.kernel.geos.GeoList,boolean) -> a
    void getDataBounds(geogebra.common.kernel.geos.GeoList,boolean,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createHistogram(geogebra.common.kernel.geos.GeoList,int,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings,boolean) -> a
    geogebra.common.kernel.algos.AlgoPolyLine createFrequencyPolygon(geogebra.common.kernel.algos.AlgoHistogram,boolean) -> a
    geogebra.common.kernel.geos.GeoElement createNormalCurveOverlay(geogebra.common.kernel.geos.GeoList) -> a
    void getHistogramSettings(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement createBoxPlot(geogebra.common.kernel.geos.GeoList) -> b
    void getBoxPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement[] createMultipleBoxPlot(geogebra.common.kernel.geos.GeoList) -> a
    void getMultipleBoxPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> b
    geogebra.common.kernel.geos.GeoElement[] createBoxPlotTitles(geogebra.gui.view.spreadsheet.statdialog.StatDialog,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    geogebra.common.kernel.geos.GeoElement createDotPlot(geogebra.common.kernel.geos.GeoList) -> c
    void updateDotPlot(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> b
    geogebra.common.kernel.geos.GeoElement createNormalQuantilePlot(geogebra.common.kernel.geos.GeoList) -> d
    void updateNormalQuantilePlot(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> c
    geogebra.common.kernel.geos.GeoElement createScatterPlotLine(geogebra.common.kernel.geos.GeoList) -> e
    geogebra.common.kernel.geos.GeoElement createScatterPlot(geogebra.common.kernel.geos.GeoList) -> f
    void getScatterPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> d
    geogebra.common.kernel.geos.GeoElement createRegressionPlot(geogebra.common.kernel.geos.GeoList,int,int,boolean) -> a
    void getResidualPlotSettings(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement,geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> c
    void setXYBounds(geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings) -> a
    void setXYBounds(geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings,double,double) -> a
    java.lang.String getStemPlotLatex(geogebra.common.kernel.geos.GeoList,int) -> a
    boolean removeFromConstruction() -> a
    void setRemoveFromConstruction(boolean) -> a
    void removeFromConstructionList(geogebra.common.kernel.algos.ConstructionElement) -> a
geogebra.gui.view.spreadsheet.statdialog.StatPanelInterface -> geogebra.gui.m.g.a.C:
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
geogebra.gui.view.spreadsheet.statdialog.StatPanelSettings -> geogebra.gui.m.g.a.D:
    int frequencyType -> b
    boolean isCumulative -> i
    boolean useManualClasses -> j
    boolean hasOverlayNormal -> k
    boolean hasOverlayPolygon -> l
    boolean showFrequencyTable -> m
    boolean showHistogram -> n
    boolean showScatterplotLine -> o
    double classStart -> g
    double classWidth -> h
    boolean isLeftRule -> p
    boolean isAutomaticWindow -> q
    int stemAdjust -> c
geogebra.gui.view.spreadsheet.statdialog.StatTable -> geogebra.gui.m.g.a.E:
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyTable myTable -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyRowHeader rowHeader -> a
    boolean isRowHeaderPainted -> a
    java.awt.Color TABLE_GRID_COLOR -> a
    java.awt.Color TABLE_HEADER_COLOR -> b
    java.awt.Color SELECTED_BACKGROUND_COLOR -> c
    javax.swing.table.DefaultTableModel tableModel -> a
    java.util.HashMap comboBoxEditorMap -> a
    java.util.HashMap comboBoxRendererMap -> b
    java.awt.event.ActionListener al -> a
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyTable getTable() -> a
    void initTable() -> c
    void setStatTable(int,java.lang.String[],int,java.lang.String[]) -> a
    void clear() -> a
    void setComboBoxCells(java.util.HashMap,java.awt.event.ActionListener) -> a
    java.lang.Integer getComboCellEditorSelectedIndex(int,int) -> a
    boolean setComboCellSelectedIndex(int,int,int) -> a
    void setLabels(java.lang.String[],java.lang.String[]) -> a
    javax.swing.table.DefaultTableModel getModel() -> a
    void updateFonts(java.awt.Font) -> a
    void autoFitColumnWidth(int,int) -> a
    void autoFitRowHeight() -> b
    java.awt.Color access$0() -> a
    java.awt.Color access$1() -> b
    java.awt.Color access$2() -> c
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyTable access$3(geogebra.gui.view.spreadsheet.statdialog.StatTable) -> a
    java.awt.event.ActionListener access$4(geogebra.gui.view.spreadsheet.statdialog.StatTable) -> a
    java.util.HashMap access$5(geogebra.gui.view.spreadsheet.statdialog.StatTable) -> a
    java.util.HashMap access$6(geogebra.gui.view.spreadsheet.statdialog.StatTable) -> b
geogebra.gui.view.spreadsheet.statdialog.StatTable$Corner -> geogebra.gui.m.g.a.E$a:
    void paintComponent(java.awt.Graphics) -> paintComponent
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyCellRenderer -> geogebra.gui.m.g.a.E$b:
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyComboBoxEditor -> geogebra.gui.m.g.a.E$c:
    javax.swing.JComboBox comboBox -> a
    int row -> a
    int column -> b
    geogebra.gui.view.spreadsheet.statdialog.StatTable this$0 -> a
    java.awt.Component getTableCellEditorComponent(javax.swing.JTable,java.lang.Object,boolean,int,int) -> getTableCellEditorComponent
    void itemStateChanged(java.awt.event.ItemEvent) -> itemStateChanged
    int getSelectedIndex() -> a
    void setSelectedIndex(int) -> a
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyComboBoxRenderer -> geogebra.gui.m.g.a.E$d:
    javax.swing.JComboBox comboBox -> a
    javax.swing.JLabel label -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable this$0 -> a
    java.awt.Component getTableCellRendererComponent(javax.swing.JTable,java.lang.Object,boolean,boolean,int,int) -> getTableCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyRowHeader -> geogebra.gui.m.g.a.E$e:
    javax.swing.JTable table -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable this$0 -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable access$0(geogebra.gui.view.spreadsheet.statdialog.StatTable$MyRowHeader) -> a
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyRowHeader$RowHeaderRenderer -> geogebra.gui.m.g.a.E$e$a:
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyRowHeader this$1 -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.StatTable$MyTable -> geogebra.gui.m.g.a.E$f:
    geogebra.gui.view.spreadsheet.statdialog.StatTable this$0 -> a
    boolean isCellEditable(int,int) -> isCellEditable
    void configureEnclosingScrollPane() -> configureEnclosingScrollPane
    javax.swing.table.TableCellEditor getCellEditor(int,int) -> getCellEditor
    javax.swing.table.TableCellRenderer getCellRenderer(int,int) -> getCellRenderer
geogebra.gui.view.spreadsheet.statdialog.StatisticsPanel -> geogebra.gui.m.g.a.F:
    javax.swing.JComboBox cbInferenceMode -> a
    java.util.HashMap labelMap -> a
    java.util.HashMap labelMapReverse -> b
    int selectedMode -> a
    geogebra.gui.view.spreadsheet.statdialog.BasicStatTable statTable -> a
    geogebra.gui.view.spreadsheet.statdialog.OneVarInferencePanel oneVarInferencePanel -> a
    geogebra.gui.view.spreadsheet.statdialog.TwoVarInferencePanel twoVarInferencePanel -> a
    geogebra.gui.view.spreadsheet.statdialog.ANOVATable anovaTable -> a
    geogebra.gui.view.spreadsheet.statdialog.MinimalMultiVarStatPanel minMVStatPanel -> a
    javax.swing.JPanel selectionPanel -> a
    javax.swing.JPanel inferencePanel -> b
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.main.Application app -> a
    void createStatTable() -> c
    void setInferencePanel() -> d
    void createSelectionPanel() -> e
    geogebra.gui.view.spreadsheet.statdialog.ANOVATable getAnovaTable() -> a
    geogebra.gui.view.spreadsheet.statdialog.OneVarInferencePanel getOneVarInferencePanel() -> a
    geogebra.gui.view.spreadsheet.statdialog.TwoVarInferencePanel getTwoVarInferencePanel() -> a
    geogebra.gui.view.spreadsheet.statdialog.MinimalMultiVarStatPanel getMinMVStatPanel() -> a
    void createInferenceTypeComboBox() -> f
    void createLabelMap() -> g
    void updateFonts(java.awt.Font) -> a
    void setLabels() -> b
    void updatePanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.view.spreadsheet.statdialog.StatisticsPanel$MyRenderer -> geogebra.gui.m.g.a.F$a:
    javax.swing.JSeparator separator -> a
    java.awt.Component getListCellRendererComponent(javax.swing.JList,java.lang.Object,int,boolean,boolean) -> getListCellRendererComponent
geogebra.gui.view.spreadsheet.statdialog.TwoVarInferencePanel -> geogebra.gui.m.g.a.G:
    geogebra.main.Application app -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable resultTable -> a
    javax.swing.JComboBox cbTitle1 -> a
    javax.swing.JComboBox cbTitle2 -> b
    javax.swing.JComboBox cbAltHyp -> c
    javax.swing.JLabel lblTitle1 -> a
    javax.swing.JLabel lblTitle2 -> b
    javax.swing.JLabel lblHypParameter -> c
    javax.swing.JLabel lblTailType -> d
    javax.swing.JLabel lblNull -> e
    javax.swing.JLabel lblConfLevel -> f
    javax.swing.JLabel lblResultHeader -> g
    geogebra.gui.inputfield.MyTextField fldNullHyp -> a
    javax.swing.JPanel resultPanel -> a
    javax.swing.JCheckBox ckEqualVariances -> a
    geogebra.gui.inputfield.MyTextField fldConfLevel -> b
    int selectedInference -> a
    java.lang.String tail -> a
    double confLevel -> m
    double hypMean -> n
    double t -> a
    double P -> b
    double df -> c
    double lower -> d
    double upper -> e
    double se -> f
    double me -> g
    double n1 -> h
    double n2 -> i
    double diffMeans -> j
    double mean1 -> k
    double mean2 -> l
    org.apache.commons.math.stat.inference.TTestImpl tTestImpl -> a
    org.apache.commons.math.distribution.TDistributionImpl tDist -> a
    boolean pooled -> a
    boolean isIniting -> b
    javax.swing.JPanel testPanel -> b
    javax.swing.JPanel intPanel -> c
    javax.swing.JPanel mainPanel -> d
    boolean isTest -> c
    javax.swing.JPanel samplePanel -> e
    geogebra.gui.view.spreadsheet.statdialog.TwoVarStatPanel twoStatPanel -> a
    double meanDifference -> o
    void createGUIElements() -> c
    void updateMainPanel() -> d
    boolean isPairedData() -> a
    void updateGUI() -> e
    void updateNumberField(javax.swing.JTextField,double) -> a
    void updateCBAlternativeHyp() -> f
    void setSelectedInference(int) -> a
    void updateFonts(java.awt.Font) -> a
    java.lang.String getNullHypName() -> a
    void setLabels() -> b
    void updatePanel() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void doTextFieldActionPerformed(javax.swing.JTextField) -> a
    void focusGained(java.awt.event.FocusEvent) -> focusGained
    void focusLost(java.awt.event.FocusEvent) -> focusLost
    void setResultTable() -> g
    void updateResultTable() -> h
    java.lang.Integer[] selectedDataIndex() -> a
    boolean evaluate() -> b
    double adjustedPValue(double,double,java.lang.String) -> a
    double getDegreeOfFreedom(double,double,double,double,boolean) -> a
    javax.swing.JPanel flowPanel(java.awt.Component[]) -> a
geogebra.gui.view.spreadsheet.statdialog.TwoVarStatPanel -> geogebra.gui.m.g.a.H:
    geogebra.main.Application app -> b
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.gui.view.spreadsheet.statdialog.StatDialog statDialog -> a
    geogebra.gui.view.spreadsheet.statdialog.StatTable$MyTable statTable -> a
    java.lang.Integer[] selectedDataIndex -> a
    java.awt.event.ActionListener parentActionListener -> a
    boolean isPairedData -> b
    boolean isIniting -> c
    double mean1 -> a
    double mean2 -> b
    double sd1 -> c
    double sd2 -> d
    double sdDifference -> e
    double meanDifference -> f
    long n1 -> a
    long n2 -> b
    void setTable(boolean) -> a
    java.lang.String[] getRowNames() -> a
    java.lang.String[] getColumnNames() -> b
    int getRowCount() -> a
    int getColumnCount() -> b
    java.lang.Integer[] getSelectedDataIndex() -> a
    void updatePanel() -> c
    boolean evaluatePairedDifferences() -> a
    boolean evaluateSampleData() -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.Keyboard -> geogebra.gui.virtualkeyboard.a:
    java.awt.Robot robot -> a
    void type(boolean,boolean,boolean,java.lang.CharSequence) -> a
    void type(char) -> a
    void doType(boolean,boolean,boolean,java.lang.String) -> a
    void doType(boolean,boolean,boolean,int[]) -> a
    void doType(int[]) -> a
    void doType(int[],int,int) -> a
geogebra.gui.virtualkeyboard.VirtualKeyboard -> geogebra.gui.virtualkeyboard.VirtualKeyboard:
    javax.swing.JButton SpaceButton -> a
    javax.swing.JButton DummyButton -> b
    javax.swing.JToggleButton CapsLockButton -> a
    javax.swing.JToggleButton AltButton -> b
    javax.swing.JToggleButton AltGrButton -> c
    javax.swing.JToggleButton CtrlButton -> d
    javax.swing.JToggleButton MathButton -> e
    javax.swing.JToggleButton GreekButton -> f
    javax.swing.JToggleButton EnglishButton -> g
    java.lang.String ctrlText -> a
    java.lang.String altText -> b
    java.lang.String altGrText -> c
    java.lang.String escText -> d
    geogebra.main.Application app -> a
    char wideChar -> r
    int buttonRows -> a
    int buttonCols -> b
    double buttonSizeX -> a
    double buttonSizeY -> b
    double horizontalMultiplier -> c
    double verticalMultiplier -> d
    javax.swing.JButton[][] Buttons -> a
    int windowWidth -> c
    int windowHeight -> d
    float opacity -> a
    java.awt.Font currentFont -> a
    java.awt.Font[] fonts -> a
    java.lang.String fontName -> e
    char KEYBOARD_NORMAL -> a
    char KEYBOARD_MATH -> b
    char KEYBOARD_ACUTE -> c
    char KEYBOARD_GRAVE -> d
    char KEYBOARD_UMLAUT -> e
    char KEYBOARD_CEDILLA -> f
    char KEYBOARD_CARON -> g
    char KEYBOARD_CIRCUMFLEX -> h
    char KEYBOARD_BREVE -> i
    char KEYBOARD_TILDE -> j
    char KEYBOARD_OGONEK -> k
    char KEYBOARD_DOT_ABOVE -> l
    char KEYBOARD_RING_ABOVE -> m
    char KEYBOARD_DIALYTIKA_TONOS -> n
    char KEYBOARD_DOUBLE_ACUTE -> o
    char KEYBOARD_SOLIDUS -> p
    char KEYBOARD_MODE -> q
    java.lang.StringBuilder sbAlt -> a
    java.lang.StringBuilder sb -> b
    java.util.HashMap characterIsTooWide -> a
    java.util.HashMap fontsHash -> b
    java.util.Hashtable myKeys -> a
    java.util.Locale kbLocale -> a
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard kb -> a
    javax.swing.Timer timer -> a
    java.lang.String timerInsertStr -> f
    void setFonts() -> c
    void updateOpacity() -> d
    void windowResized() -> e
    void initialize() -> f
    void updateButtons() -> b
    javax.swing.JButton getSpaceButton() -> a
    javax.swing.JButton getDummyButton() -> b
    void updateSpaceButton() -> g
    void updateCapsLockButton() -> h
    void updateCtrlButton() -> i
    void updateAltButton() -> j
    void updateAltGrButton() -> k
    void updateMathButton() -> l
    void setColor(javax.swing.JToggleButton) -> a
    void updateGreekButton() -> m
    void updateEnglishButton() -> n
    double minButtonSize() -> a
    javax.swing.JToggleButton getCapsLockButton() -> a
    javax.swing.JToggleButton getAltButton() -> b
    javax.swing.JToggleButton getAltGrButton() -> c
    javax.swing.JToggleButton getCtrlButton() -> d
    javax.swing.JToggleButton getMathButton() -> e
    boolean greek() -> a
    javax.swing.JToggleButton getGreekButton() -> f
    boolean english() -> b
    javax.swing.JToggleButton getEnglishButton() -> g
    void populateContentPane() -> o
    void insertText(java.lang.String) -> a
    java.lang.StringBuilder getAltStringBuilder() -> a
    void setMode(char,java.util.Locale) -> a
    boolean Upper() -> c
    void insertKeyText(geogebra.gui.virtualkeyboard.keys) -> a
    geogebra.gui.virtualkeyboard.keys getKey(int,int) -> a
    javax.swing.JButton getButton(int,int) -> a
    void buttonPressed(int,int) -> a
    java.lang.String processSpecialKeys(java.lang.String) -> a
    java.lang.String unicodeString(char,java.lang.String) -> a
    void updateButton(int,int) -> b
    java.awt.Font getCurrentFont() -> a
    java.awt.Font getFont(int,boolean) -> a
    void setKbLocale(java.util.Locale) -> a
    void readConf(geogebra.main.Application,java.util.Locale,boolean) -> a
    void setLabels() -> a
    void doSetLabels() -> p
    geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard getKeyboard() -> a
    void startAutoRepeat(java.lang.String) -> b
    void insertAutoRepeatString() -> q
    void stopAutoRepeat() -> r
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void setWindowWidth(int) -> a
    void setWindowHeight(int) -> b
    void setOpacity(float) -> a
    void settingsChanged(geogebra.common.main.settings.AbstractSettings) -> a
    void access$0(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> a
    void access$1(geogebra.gui.virtualkeyboard.VirtualKeyboard,java.lang.String) -> a
    void access$2(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> b
    void access$3(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> c
    void access$4(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> d
    javax.swing.JToggleButton access$5(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> a
    javax.swing.JToggleButton access$6(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> b
    void access$7(geogebra.gui.virtualkeyboard.VirtualKeyboard,char,java.util.Locale) -> a
    boolean access$8(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> a
    geogebra.main.Application access$9(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> a
    void access$10(geogebra.gui.virtualkeyboard.VirtualKeyboard,geogebra.main.Application,java.util.Locale,boolean) -> a
    boolean access$11(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> b
    javax.swing.JButton[][] access$12(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> a
    void access$13(geogebra.gui.virtualkeyboard.VirtualKeyboard,java.lang.String) -> b
    void access$14(geogebra.gui.virtualkeyboard.VirtualKeyboard) -> e
    void access$15(geogebra.gui.virtualkeyboard.VirtualKeyboard,int,int) -> a
geogebra.gui.virtualkeyboard.VirtualKeyboard$1 -> geogebra.gui.virtualkeyboard.b:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    geogebra.main.Application val$app -> a
    void windowClosed(java.awt.event.WindowEvent) -> windowClosed
    void windowActivated(java.awt.event.WindowEvent) -> windowActivated
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
    void windowDeactivated(java.awt.event.WindowEvent) -> windowDeactivated
    void windowDeiconified(java.awt.event.WindowEvent) -> windowDeiconified
    void windowIconified(java.awt.event.WindowEvent) -> windowIconified
    void windowOpened(java.awt.event.WindowEvent) -> windowOpened
geogebra.gui.virtualkeyboard.VirtualKeyboard$10 -> geogebra.gui.virtualkeyboard.c:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$11 -> geogebra.gui.virtualkeyboard.d:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$12 -> geogebra.gui.virtualkeyboard.e:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    int val$i -> a
    int val$j -> b
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
geogebra.gui.virtualkeyboard.VirtualKeyboard$13 -> geogebra.gui.virtualkeyboard.f:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    int val$i -> a
    int val$j -> b
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$2 -> geogebra.gui.virtualkeyboard.g:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.gui.virtualkeyboard.VirtualKeyboard$3 -> geogebra.gui.virtualkeyboard.h:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void run() -> run
geogebra.gui.virtualkeyboard.VirtualKeyboard$4 -> geogebra.gui.virtualkeyboard.i:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$5 -> geogebra.gui.virtualkeyboard.j:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$6 -> geogebra.gui.virtualkeyboard.k:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$7 -> geogebra.gui.virtualkeyboard.l:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$8 -> geogebra.gui.virtualkeyboard.m:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.VirtualKeyboard$9 -> geogebra.gui.virtualkeyboard.n:
    geogebra.gui.virtualkeyboard.VirtualKeyboard this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.gui.virtualkeyboard.WindowsUnicodeKeyboard -> geogebra.gui.virtualkeyboard.o:
    java.awt.Robot robot -> b
    void type(char) -> a
    void typeNumPad(int) -> a
geogebra.gui.virtualkeyboard.keys -> geogebra.gui.virtualkeyboard.p:
    java.lang.String UpperCase -> a
    java.lang.String LowerCase -> b
    java.lang.String getUpperCase() -> a
    void setUpperCase(java.lang.String) -> a
    java.lang.String getLowerCase() -> b
    void setLowerCase(java.lang.String) -> b
geogebra.io.MyImageIO -> geogebra.f.a:
    void write(java.awt.image.BufferedImage,java.lang.String,float,java.io.File) -> a
    void writeImage(javax.imageio.ImageWriter,java.awt.image.BufferedImage,double) -> a
geogebra.io.MyXMLio -> geogebra.f.b:
    geogebra.common.io.DocHandler handler -> a
    geogebra.common.io.DocHandler ggbDocHandler -> b
    geogebra.common.io.QDParser xmlParser -> a
    geogebra.common.io.DocHandler getGGBHandler() -> a
    void readZipFromInputStream(java.io.InputStream,boolean) -> a
    void readZipFromString(byte[]) -> a
    void readZip(java.util.zip.ZipInputStream,boolean) -> a
    java.awt.image.BufferedImage getPreviewImage(java.io.File) -> a
    void processXMLBuffer(byte[],boolean,boolean) -> a
    void doParseXML(java.io.Reader,boolean,boolean,boolean,boolean) -> a
    void readZipFromMemory(java.io.InputStream) -> a
    void processXMLString(java.lang.String,boolean,boolean,boolean) -> a
    void writeGeoGebraFile(java.io.File) -> a
    void writeGeoGebraFile(java.io.OutputStream,boolean) -> a
    void writeMacroFile(java.io.File,java.util.ArrayList) -> a
    void writeMacroStream(java.io.OutputStream,java.util.ArrayList) -> a
    void writeConstructionImages(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream) -> a
    void writeConstructionImages(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream,java.lang.String) -> a
    void writeThumbnail(geogebra.common.kernel.Construction,java.util.zip.ZipOutputStream,java.lang.String) -> b
    void writeMacroImages(java.util.ArrayList,java.util.zip.ZipOutputStream) -> a
    void writeMacroImages(java.util.ArrayList,java.util.zip.ZipOutputStream,java.lang.String) -> a
    void writeImageToZip(java.util.zip.ZipOutputStream,java.lang.String,java.awt.image.BufferedImage) -> a
    void writeImageToStream(java.io.OutputStream,java.lang.String,java.awt.image.BufferedImage) -> a
    void writeZipped(java.io.OutputStream,java.lang.StringBuilder) -> a
    java.lang.StringBuilder getUndoXML(geogebra.common.kernel.Construction) -> a
geogebra.javax.swing.Box -> geogebra.g.a.a:
    javax.swing.Box impl -> a
    javax.swing.Box getImpl() -> a
    void add(geogebra.common.javax.swing.JLabel) -> a
    void add(geogebra.common.gui.inputfield.AutoCompleteTextField) -> a
    void setVisible(boolean) -> a
    void setBounds(geogebra.common.awt.Rectangle) -> a
    geogebra.common.awt.Dimension getPreferredSize() -> a
    geogebra.common.awt.Rectangle getBounds() -> a
geogebra.javax.swing.JLabel -> geogebra.g.a.b:
    javax.swing.JLabel impl -> a
    javax.swing.JLabel getImpl() -> a
    void setVisible(boolean) -> a
    void setText(java.lang.String) -> a
    void setOpaque(boolean) -> b
    void setFont(geogebra.common.awt.Font) -> a
    void setForeground(geogebra.common.awt.Color) -> a
    void setBackground(geogebra.common.awt.Color) -> b
geogebra.javax.swing.JPopupMenu -> geogebra.g.a.c:
    javax.swing.JPopupMenu impl -> a
    javax.swing.JPopupMenu getImpl(geogebra.common.javax.swing.JPopupMenu) -> a
geogebra.javax.swing.JTextComponent -> geogebra.g.a.d:
    javax.swing.text.JTextComponent impl -> a
    void replaceSelection(java.lang.String) -> a
    geogebra.javax.swing.JTextComponent wrap(javax.swing.text.JTextComponent) -> a
    javax.swing.text.JTextComponent getImpl() -> a
geogebra.kernel.AnimationManager -> geogebra.h.a:
    javax.swing.Timer timer -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    boolean isRunning() -> c
    void setTimerDelay(int) -> a
    void stopTimer() -> f
    void startTimer() -> g
geogebra.kernel.UndoManager -> geogebra.h.b:
    geogebra.io.MyXMLio xmlio -> a
    void storeUndoInfoAfterPasteOrAdd() -> g
    void storeUndoInfo(boolean) -> a
    void doStoreUndoInfo(java.lang.StringBuilder) -> a
    java.io.File createTempFile(java.lang.StringBuilder) -> a
    void loadUndoInfo(geogebra.common.kernel.AbstractUndoManager$AppState) -> a
    void processXML(java.lang.String) -> a
geogebra.kernel.UndoManager$1 -> geogebra.h.c:
    geogebra.kernel.UndoManager this$0 -> a
    java.lang.StringBuilder val$currentUndoXML -> a
    void run() -> run
geogebra.kernel.UndoManager$2 -> geogebra.h.d:
    geogebra.kernel.UndoManager this$0 -> a
    java.lang.StringBuilder val$currentUndoXML -> a
    boolean val$refresh -> a
    void run() -> run
geogebra.kernel.UndoManager$3 -> geogebra.h.e:
    geogebra.kernel.UndoManager this$0 -> a
    java.lang.StringBuilder val$undoXML -> a
    java.lang.Object run() -> run
geogebra.kernel.UndoManager$AppStateDesktop -> geogebra.h.b$a:
    java.io.File f -> a
    geogebra.kernel.UndoManager this$0 -> a
    java.io.File getFile() -> a
    void delete() -> a
geogebra.kernel.commands.CmdBarCode -> geogebra.h.a.a:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] decode(java.awt.image.BufferedImage,geogebra.common.kernel.arithmetic.Command) -> a
geogebra.kernel.geos.GeoElementGraphicsAdapterDesktop -> geogebra.h.b.a:
    geogebra.main.Application app -> a
    geogebra.common.awt.BufferedImage getFillImage() -> b
    void setImageFileName(java.lang.String) -> b
geogebra.main.AppletImplementation -> geogebra.i.a:
    javax.swing.JApplet applet -> a
    geogebra.main.Application app -> a
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.euclidian.EuclidianView ev -> a
    boolean undoActive -> a
    boolean showToolBar -> b
    boolean showToolBarHelp -> c
    boolean showAlgebraInput -> d
    boolean allowStyleBar -> e
    boolean enableRightClick -> f
    boolean useBrowserForJavaScript -> g
    boolean enableChooserPopups -> h
    boolean errorDialogsActive -> i
    boolean enableLabelDrags -> j
    boolean enableShiftDragZoom -> k
    boolean allowRescaling -> l
    boolean showMenuBar -> m
    boolean showResetIcon -> n
    java.awt.Color bgColor -> a
    java.awt.Color borderColor -> b
    java.lang.String fileStr -> b
    java.lang.String customToolBar -> c
    int maxIconSize -> c
    javax.swing.JFrame wnd -> a
    netscape.javascript.JSObject browserWindow -> a
    int width -> a
    int height -> b
    geogebra.plugin.GgbAPI ggbApi -> a
    java.lang.String ggbOnInitParam -> a
    int originalWidth -> d
    int originalHeight -> e
    void dispose() -> a
    void initInBackground() -> b
    void init() -> f
    geogebra.main.Application buildApplication(geogebra.CommandLineArguments,boolean) -> a
    boolean needsGui() -> a
    void initGUI() -> c
    void setInitialScaling() -> g
    javax.swing.JPanel createGeoGebraAppletPanel() -> a
    void showApplet() -> d
    void reinitGUI() -> h
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getXML() -> getXML
    java.lang.String getBase64(boolean) -> getBase64
    java.lang.String getXML(java.lang.String) -> getXML
    java.lang.String getAlgorithmXML(java.lang.String) -> getAlgorithmXML
    void setXML(java.lang.String) -> setXML
    void setBase64(java.lang.String) -> setBase64
    void evalXML(java.lang.String) -> evalXML
    boolean evalCommand(java.lang.String) -> evalCommand
    void debug(java.lang.String) -> debug
    void setOnTheFlyPointCreationActive(boolean) -> setOnTheFlyPointCreationActive
    void setUndoPoint() -> setUndoPoint
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void reset() -> reset
    void refreshViews() -> refreshViews
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
    void openFile(java.lang.String) -> openFile
    void setVisible(java.lang.String,boolean) -> setVisible
    boolean getVisible(java.lang.String) -> getVisible
    void setLayer(java.lang.String,int) -> setLayer
    int getLayer(java.lang.String) -> getLayer
    void setLayerVisible(int,boolean) -> setLayerVisible
    void setFixed(java.lang.String,boolean) -> setFixed
    void setTrace(java.lang.String,boolean) -> setTrace
    void setLabelVisible(java.lang.String,boolean) -> setLabelVisible
    void setLabelStyle(java.lang.String,int) -> setLabelStyle
    void setLabelMode(java.lang.String,boolean) -> setLabelMode
    void setColor(java.lang.String,int,int,int) -> setColor
    void setLineStyle(java.lang.String,int) -> setLineStyle
    void setLineThickness(java.lang.String,int) -> setLineThickness
    void setPointStyle(java.lang.String,int) -> setPointStyle
    void setPointSize(java.lang.String,int) -> setPointSize
    void setFilling(java.lang.String,double) -> setFilling
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    java.lang.String getColor(java.lang.String) -> getColor
    double getFilling(java.lang.String) -> getFilling
    int getLineStyle(java.lang.String) -> getLineStyle
    int getLineThickness(java.lang.String) -> getLineThickness
    int getPointStyle(java.lang.String) -> getPointStyle
    int getPointSize(java.lang.String) -> getPointSize
    void deleteObject(java.lang.String) -> deleteObject
    void setAnimating(java.lang.String,boolean) -> setAnimating
    void setAnimationSpeed(java.lang.String,double) -> setAnimationSpeed
    void startAnimation() -> startAnimation
    void stopAnimation() -> stopAnimation
    void hideCursorWhenDragging(boolean) -> hideCursorWhenDragging
    boolean isAnimationRunning() -> isAnimationRunning
    boolean renameObject(java.lang.String,java.lang.String) -> renameObject
    boolean exists(java.lang.String) -> exists
    boolean isDefined(java.lang.String) -> isDefined
    boolean isIndependent(java.lang.String) -> isIndependent
    java.lang.String getValueString(java.lang.String) -> getValueString
    java.lang.String getDefinitionString(java.lang.String) -> getDefinitionString
    java.lang.String getCommandString(java.lang.String) -> getCommandString
    double getXcoord(java.lang.String) -> getXcoord
    double getYcoord(java.lang.String) -> getYcoord
    void setCoords(java.lang.String,double,double) -> setCoords
    double getValue(java.lang.String) -> getValue
    void setValue(java.lang.String,double) -> setValue
    void setRepaintingActive(boolean) -> setRepaintingActive
    void setCoordSystem(double,double,double,double) -> setCoordSystem
    void setAxesVisible(boolean,boolean) -> setAxesVisible
    void setGridVisible(boolean) -> setGridVisible
    java.lang.String[] getAllObjectNames() -> getAllObjectNames
    int getObjectNumber() -> getObjectNumber
    java.lang.String getObjectName(int) -> getObjectName
    java.lang.String getObjectType(java.lang.String) -> getObjectType
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    void setMode(int) -> setMode
    void initJavaScript() -> e
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
    javax.swing.JApplet getJApplet() -> a
    void registerAddListener(java.lang.String) -> registerAddListener
    void unregisterAddListener(java.lang.String) -> unregisterAddListener
    void registerRemoveListener(java.lang.String) -> registerRemoveListener
    void unregisterRemoveListener(java.lang.String) -> unregisterRemoveListener
    void registerClearListener(java.lang.String) -> registerClearListener
    void unregisterClearListener(java.lang.String) -> unregisterClearListener
    void registerRenameListener(java.lang.String) -> registerRenameListener
    void unregisterRenameListener(java.lang.String) -> unregisterRenameListener
    void registerUpdateListener(java.lang.String) -> registerUpdateListener
    void unregisterUpdateListener(java.lang.String) -> unregisterUpdateListener
    void registerObjectUpdateListener(java.lang.String,java.lang.String) -> registerObjectUpdateListener
    void unregisterObjectUpdateListener(java.lang.String) -> unregisterObjectUpdateListener
    boolean isMoveable(java.lang.String) -> isMoveable
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void unregisterPenListener(java.lang.String) -> unregisterPenListener
    void clearImage(java.lang.String) -> clearImage
    void uploadToGeoGebraTube() -> uploadToGeoGebraTube
    void setPenColor(int,int,int) -> setPenColor
    void setPenSize(int) -> setPenSize
    int getPenSize() -> getPenSize
    java.lang.String getPenColor() -> getPenColor
    javax.swing.JFrame access$2(geogebra.main.AppletImplementation) -> a
    void access$3(geogebra.main.AppletImplementation) -> a
    geogebra.plugin.GgbAPI access$4(geogebra.main.AppletImplementation) -> a
    java.lang.String access$5(geogebra.main.AppletImplementation) -> a
geogebra.main.AppletImplementation$1 -> geogebra.i.b:
    geogebra.main.AppletImplementation this$0 -> a
    void componentResized(java.awt.event.ComponentEvent) -> componentResized
geogebra.main.AppletImplementation$10 -> geogebra.i.c:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$algorithm -> a
    java.lang.String val$format -> b
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$11 -> geogebra.i.d:
    geogebra.main.AppletImplementation this$0 -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.lang.String run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$12 -> geogebra.i.e:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$filename -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.lang.Boolean run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$2 -> geogebra.i.f:
    geogebra.main.AppletImplementation this$0 -> a
    void run() -> run
geogebra.main.AppletImplementation$4 -> geogebra.i.g:
    geogebra.main.AppletImplementation this$0 -> a
    void run() -> run
geogebra.main.AppletImplementation$5 -> geogebra.i.h:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$base64 -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$6 -> geogebra.i.i:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$cmdString -> a
    geogebra.common.kernel.arithmetic.MyBoolean run() -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$8 -> geogebra.i.j:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.Object run() -> run
geogebra.main.AppletImplementation$9 -> geogebra.i.k:
    geogebra.main.AppletImplementation this$0 -> a
    java.lang.String val$strURL -> a
    java.lang.Object run() -> run
geogebra.main.Application -> geogebra.i.l:
    java.lang.String[] JAR_FILES -> c
    java.util.ArrayList supportedLocales -> c
    java.awt.Color COLOR_SELECTION -> a
    java.io.File currentPath -> a
    java.io.File currentImagePath -> b
    java.io.File currentFile -> c
    java.awt.Dimension preferredSize -> a
    javax.swing.JFrame frame -> a
    geogebra.main.AppletImplementation appletImpl -> a
    geogebra.main.FontManager fontManager -> a
    geogebra.gui.GuiManager guiManager -> a
    java.awt.Component mainComp -> a
    boolean isApplet -> G
    geogebra.main.GlobalKeyDispatcher globalKeyDispatcher -> a
    java.util.Locale currentLocale -> a
    java.util.Locale tooltipLocale -> b
    java.util.ResourceBundle rbmenu -> a
    java.util.ResourceBundle rbmenuTT -> b
    java.util.ResourceBundle rbcommand -> c
    java.util.ResourceBundle rbcommandTT -> d
    java.util.ResourceBundle rbcommandEnglish -> e
    java.util.ResourceBundle rbcommandOld -> f
    java.util.ResourceBundle rbcommandScripting -> g
    java.util.ResourceBundle rberror -> h
    java.util.ResourceBundle rbcolors -> i
    java.util.ResourceBundle rbplain -> j
    java.util.ResourceBundle rbplainTT -> k
    java.util.ResourceBundle rbmenuEnglish -> l
    java.util.ResourceBundle rbsymbol -> m
    java.util.ResourceBundle rbsettings -> n
    geogebra.util.ImageManager imageManager -> a
    int maxIconSize -> l
    boolean showAlgebraView -> y
    boolean showToolBarTop -> H
    boolean showConsProtNavigation -> z
    boolean printScaleString -> I
    boolean allowToolTips -> J
    boolean rightClickEnabled -> K
    boolean chooserPopupsEnabled -> L
    boolean isErrorDialogsActive -> M
    boolean isErrorDialogShowing -> A
    java.util.LinkedList fileList -> a
    javax.swing.JPanel centerPanel -> a
    javax.swing.JPanel topPanel -> b
    javax.swing.JPanel bottomPanel -> c
    javax.swing.JPanel backPanel -> d
    javax.swing.JPanel mainCardPanel -> e
    geogebra.plugin.GgbAPI ggbapi -> a
    geogebra.plugin.PluginManager pluginmanager -> a
    geogebra.plugin.jython.PythonBridge pythonBridge -> a
    javax.swing.JSplitPane applicationSplitPane -> a
    geogebra.gui.layout.DockBar dockBar -> a
    geogebra.gui.view.spreadsheet.SpreadsheetTableModel tableModel -> a
    geogebra.CommandLineArguments args -> a
    boolean isMainPanelShowing -> N
    java.lang.String regressionFileName -> d
    java.lang.String versionCheckAllow -> e
    boolean versionCheckAllowed -> O
    java.lang.StringBuilder testCharacters -> b
    boolean showConstProtNavigationNeedsUpdate -> P
    java.net.URL codebase -> a
    boolean runningFromJar -> Q
    geogebra.main.GlassPaneListener glassPaneListener -> a
    boolean controlDown -> R
    boolean shiftDown -> S
    boolean fakeRightClick -> T
    java.lang.Runtime runtime -> a
    java.awt.Rectangle screenSize -> a
    java.awt.Cursor transparentCursor -> a
    java.awt.Cursor eraserCursor -> b
    boolean virtualKeyboardActive -> U
    java.util.logging.LogManager logManager -> a
    java.lang.StringBuilder logFile -> c
    geogebra.sound.SoundManager soundManager -> a
    geogebra.euclidian.DrawEquation drawEquation -> a
    boolean exporting -> B
    java.lang.String uniqueId -> f
    geogebra.gui.view.spreadsheet.SpreadsheetTraceManager traceManager -> a
    geogebra.common.gui.dialog.DialogManager dialogManager -> a
    java.lang.String OS -> g
    boolean MAC_OS -> C
    boolean WINDOWS -> D
    boolean LINUX -> E
    boolean WINDOWS_VISTA_OR_LATER -> F
    void initFactories() -> ai
    void handleHelpVersionArgs(geogebra.CommandLineArguments) -> a
    geogebra.euclidian.EuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.euclidian.AbstractEuclidianView newEuclidianView(boolean[],boolean) -> a
    void initImageManager(java.awt.Component) -> a
    boolean isUsingFullGui() -> e
    void initGuiManager() -> t
    geogebra.gui.GuiManager newGuiManager() -> a
    geogebra.gui.GuiManager getGuiManager() -> b
    javax.swing.JApplet getJApplet() -> a
    java.awt.Font getBoldFont() -> a
    java.awt.Font getItalicFont() -> b
    java.awt.Font getPlainFont() -> c
    geogebra.common.awt.Font getPlainFontCommon() -> a
    java.awt.Font getSmallFont() -> d
    java.awt.Font getFont(boolean,int,int) -> a
    geogebra.main.FontManager getFontManager() -> a
    void setSaved() -> Q
    void setUnsaved() -> w
    void fileNew() -> R
    boolean getAllowToolTips() -> O
    void updateContentPane() -> S
    void updateContentPane(boolean) -> F
    javax.swing.JPanel buildApplicationPanel() -> a
    void showMainPanel() -> T
    void setShowInputHelpPanel(boolean) -> t
    void updateDockBar() -> U
    void updateTopBottomPanels() -> P
    void createRegressionFile() -> V
    boolean addMacroXML(java.lang.String) -> c
    void updateCenterPanel(boolean) -> u
    javax.swing.JPanel getCenterPanel() -> b
    void validateComponent() -> W
    void handleOptionArgs(geogebra.CommandLineArguments) -> b
    void setVersionCheckAllowed() -> aj
    void setProverOption(java.lang.String) -> s
    boolean getVersionCheckAllowed() -> P
    void handleOptionArgsEarly(geogebra.CommandLineArguments) -> c
    boolean isLoadingTool(geogebra.CommandLineArguments) -> a
    boolean handleFileArg(geogebra.CommandLineArguments) -> b
    void setApplet(geogebra.main.AppletImplementation) -> a
    geogebra.main.AppletImplementation getApplet() -> a
    void reset() -> N
    void setFrame(javax.swing.JFrame) -> a
    boolean isApplet() -> d
    javax.swing.JFrame getFrame() -> a
    java.awt.Component getMainComponent() -> a
    java.awt.Dimension getPreferredSize() -> a
    void setPreferredSize(geogebra.common.awt.Dimension) -> a
    boolean isJustEuclidianVisible() -> ak
    geogebra.euclidian.EuclidianView getEuclidianView1() -> a
    geogebra.gui.view.algebra.AlgebraView getAlgebraView() -> a
    geogebra.euclidian.EuclidianView getEuclidianView2() -> b
    boolean hasEuclidianView2() -> x
    boolean hasEuclidianView2EitherShowingOrNot() -> s
    boolean isShowingEuclidianView2() -> t
    geogebra.euclidianND.EuclidianViewND getActiveEuclidianView() -> a
    java.awt.image.BufferedImage getExportImage(double,double) -> a
    void setShowAxesSelected(javax.swing.JCheckBoxMenuItem) -> a
    void setShowGridSelected(javax.swing.JCheckBoxMenuItem) -> b
    void setMaxIconSize(int) -> i
    int getMaxIconSize() -> m
    javax.swing.ImageIcon getImageIcon(java.lang.String) -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String,java.awt.Color) -> a
    javax.swing.ImageIcon getToolBarImage(java.lang.String,java.awt.Color) -> b
    javax.swing.ImageIcon getToolIcon(java.awt.Color) -> a
    javax.swing.ImageIcon getEmptyIcon() -> a
    java.awt.Image getInternalImage(java.lang.String) -> a
    java.awt.Image getRefreshViewImage() -> a
    java.awt.Image getPlayImage() -> b
    java.awt.Image getPauseImage() -> c
    java.awt.image.BufferedImage getExternalImage(java.lang.String) -> a
    geogebra.common.awt.BufferedImage getExternalImageAdapter(java.lang.String) -> a
    geogebra.common.awt.Image getInternalImageAdapter(java.lang.String) -> a
    void addExternalImage(java.lang.String,java.awt.image.BufferedImage) -> a
    void zoom(double,double,double) -> a
    void zoomAxesRatio(double) -> a
    void setStandardView() -> X
    void setViewShowAllObjects() -> Y
    java.util.Locale getLocale(java.lang.String) -> a
    void setTooltipFlag() -> i
    void setTooltipLanguage(java.lang.String) -> n
    java.util.Locale getTooltipLanguage() -> a
    java.lang.String getTooltipLanguageString() -> i
    int getTooltipTimeout() -> e
    void setLanguage(java.util.Locale) -> a
    void setLocale(java.util.Locale) -> b
    java.util.Locale getClosestSupportedLocale(java.util.Locale) -> a
    void updateResourceBundles() -> ak
    java.util.Locale getLocale() -> b
    java.lang.String getColor(java.lang.String) -> j
    java.lang.String reverseGetColor(java.lang.String) -> i
    java.lang.String getPlain(java.lang.String) -> d
    java.lang.String getPlainTooltip(java.lang.String) -> l
    java.lang.String getSymbol(int) -> a
    java.lang.String getSymbolTooltip(int) -> b
    void initPlainResourceBundle() -> al
    void initPlainTTResourceBundle() -> am
    void initSymbolResourceBundle() -> an
    void initColorsResourceBundle() -> ao
    java.lang.String getMenu(java.lang.String) -> e
    java.lang.String getMenuTooltip(java.lang.String) -> m
    java.lang.String getError(java.lang.String) -> f
    void initCommand() -> c
    java.lang.String getInternalCommand(java.lang.String) -> h
    java.lang.String getReverseCommand(java.lang.String) -> n
    java.lang.String getCommand(java.lang.String) -> c
    java.lang.String getCommandTooltip(java.lang.String) -> o
    java.lang.String getEnglishCommand(java.lang.String) -> p
    java.lang.String getEnglishMenu(java.lang.String) -> q
    java.lang.String getSyntaxString() -> d
    java.lang.String getCommandSyntaxCAS(java.lang.String) -> r
    java.lang.String getSetting(java.lang.String) -> s
    boolean propertiesFilesPresent() -> Q
    void showRelation(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void showHelp(java.lang.String) -> p
    void showError(java.lang.String) -> b
    void showError(java.lang.String,java.lang.String) -> a
    void showError(geogebra.common.main.MyError) -> a
    void showErrorDialog(java.lang.String) -> q
    boolean isErrorDialogShowing() -> R
    void showMessage(java.lang.String) -> r
    void setWaitCursor() -> C
    void setDefaultCursor() -> B
    java.io.File getCurrentFile() -> a
    java.io.File getCurrentPath() -> b
    void setCurrentPath(java.io.File) -> a
    void setCurrentFile(java.io.File) -> b
    void addToFileList(java.io.File) -> c
    java.io.File getFromFileList(int) -> a
    int getFileListSize() -> n
    void updateTitle() -> Z
    void updateUI() -> J
    void resetFonts() -> L
    void setLabels() -> ap
    java.lang.String getToolTooltipHTML(int) -> g
    javax.swing.ImageIcon getModeIcon(int) -> a
    boolean onlyGraphicsViewShowing() -> S
    boolean showAlgebraInput() -> D
    void setShowAlgebraInput(boolean,boolean) -> b
    boolean showToolBarTop() -> T
    void setShowToolBarTop(boolean) -> v
    boolean getShowCPNavNeedsUpdate() -> U
    void setShowConstructionProtocolNavigation(boolean) -> l
    boolean showConsProtNavigation() -> V
    void setShowAuxiliaryObjects(boolean) -> h
    void setShowMenuBar(boolean) -> w
    void setShowToolBar(boolean) -> x
    void setShowToolBar(boolean,boolean) -> c
    boolean showToolBar() -> W
    boolean showMenuBar() -> X
    void setRightClickEnabled(boolean) -> y
    void setChooserPopupsEnabled(boolean) -> z
    boolean isRightClickEnabled() -> F
    boolean letShowPopupMenu() -> Y
    boolean letShowPropertiesDialog() -> Z
    void updateToolBar() -> aa
    void updateMenubar() -> I
    void updateStyleBars() -> D
    void updateMenuWindow() -> ab
    void clearConstruction() -> ac
    void exit() -> ad
    void exitAll() -> ae
    boolean saveCurrentFile() -> aa
    geogebra.common.euclidian.AbstractEuclidianView createEuclidianView() -> b
    boolean loadFile(java.io.File,boolean) -> a
    boolean loadXML(java.io.File,boolean) -> b
    boolean loadXML(java.net.URL,boolean) -> a
    boolean loadXML(byte[]) -> a
    boolean loadXML(java.lang.String) -> d
    boolean loadXML(java.io.InputStream,boolean) -> a
    void setActiveView(int) -> c
    boolean saveGeoGebraFile(java.io.File) -> a
    boolean saveMacroFile(java.io.File,java.util.ArrayList) -> a
    void setXML(java.lang.String,boolean) -> a
    java.lang.String getPreferencesXML() -> k
    byte[] getMacroFileAsByteArray() -> a
    void loadMacroFileFromByteArray(byte[],boolean) -> a
    geogebra.io.MyXMLio getXMLio() -> a
    boolean isSaved() -> ab
    void storeUndoInfo() -> j
    void getWindowLayoutXML(java.lang.StringBuilder,boolean) -> b
    java.net.URL getCodeBase() -> a
    void initCodeBase() -> aq
    boolean isWebstart() -> ac
    boolean isWebstartDebug() -> ad
    boolean hasFullPermissions() -> ae
    void startDispatchingEventsTo(javax.swing.JComponent) -> a
    void stopDispatchingEvents() -> af
    java.awt.Component getGlassPane() -> b
    void setGlassPane(java.awt.Component) -> b
    java.awt.Container getContentPane() -> a
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
    void handleShiftEvent(boolean) -> A
    geogebra.main.GlobalKeyDispatcher getGlobalKeyDispatcher() -> a
    geogebra.main.GlobalKeyDispatcher newGlobalKeyDispatcher() -> b
    boolean isPrintScaleString() -> af
    void setPrintScaleString(boolean) -> B
    java.io.File getCurrentImagePath() -> c
    void setCurrentImagePath(java.io.File) -> d
    java.lang.String loadTextFile(java.lang.String) -> t
    void setErrorDialogsActive(boolean) -> C
    geogebra.plugin.GgbAPI getGgbApi() -> a
    geogebra.plugin.jython.PythonBridge getPythonBridge() -> a
    java.lang.String getCurrentPythonScript() -> l
    boolean isPythonWindowVisible() -> ag
    geogebra.plugin.ScriptManager getScriptManager() -> a
    geogebra.plugin.PluginManager getPluginManager() -> a
    void printStacktrace(java.lang.String) -> d
    void setEmptyIcon(javax.swing.JCheckBoxMenuItem) -> c
    boolean isAltDown(java.awt.event.InputEvent) -> a
    boolean getControlDown() -> ah
    boolean getShiftDown() -> ai
    boolean isControlDown(java.awt.event.InputEvent) -> b
    boolean isMiddleClick(java.awt.event.MouseEvent) -> a
    boolean isRightClick(java.awt.event.MouseEvent) -> b
    java.lang.String createImage(java.awt.image.BufferedImage,java.lang.String) -> a
    java.lang.String getExtension(java.io.File) -> a
    java.lang.String getExtension(java.lang.String) -> u
    java.io.File addExtension(java.io.File,java.lang.String) -> a
    java.io.File removeExtension(java.io.File) -> a
    java.lang.String removeExtension(java.lang.String) -> v
    boolean freeMemoryIsCritical() -> m
    long freeMemory() -> a
    long getHeapSize() -> b
    void copyGraphicsViewToClipboard() -> ag
    void copyGraphicsViewToClipboard(geogebra.euclidian.EuclidianView) -> a
    void simpleExportToClipboard(geogebra.euclidian.EuclidianView) -> b
    java.awt.Rectangle getScreenSize() -> a
    java.awt.Cursor getTransparentCursor() -> a
    java.awt.Cursor getEraserCursor() -> b
    boolean isVirtualKeyboardActive() -> aj
    void setVirtualKeyboardActive(boolean) -> D
    void removeTraversableKeys(javax.swing.JPanel) -> a
    void setUpLogging() -> ar
    java.lang.String getCodeBaseFolder() -> m
    void exportToLMS(boolean) -> E
    java.lang.String getStringFromClipboard() -> n
    geogebra.util.ImageManager getImageManager() -> a
    geogebra.sound.SoundManager getSoundManager() -> a
    void setScrollToShow(boolean) -> g
    geogebra.euclidian.DrawEquation getDrawEquation() -> a
    java.lang.String getUniqueId() -> g
    void setUniqueId(java.lang.String) -> m
    void resetUniqueId() -> ah
    void callAppletJavaScript(java.lang.String,java.lang.Object[]) -> a
    boolean showView(int) -> b
    void traceToSpreadsheet(geogebra.common.kernel.geos.GeoElement) -> a
    void resetTraceColumn(geogebra.common.kernel.geos.GeoElement) -> b
    java.lang.String getTraceXML(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getLanguage() -> b
    void evalJavaScript(geogebra.common.main.AbstractApplication,java.lang.String,java.lang.String) -> a
    int getMD5folderLength(java.lang.String) -> a
    void setShowConstructionProtocolNavigation(boolean,boolean,double,boolean) -> a
    void setTooltipTimeout(int) -> e
    double getWidth() -> a
    double getHeight() -> b
    geogebra.common.awt.Font getFontCommon(boolean,int,int) -> a
    geogebra.common.awt.Font getBoldFontCommon() -> b
    geogebra.gui.view.spreadsheet.SpreadsheetTraceManager getTraceManager() -> a
    void repaintSpreadsheet() -> A
    geogebra.kernel.UndoManager getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoElementGraphicsAdapter newGeoElementGraphicsAdapter() -> a
    geogebra.common.kernel.AbstractAnimationManager newAnimationManager(geogebra.common.kernel.Kernel) -> a
    geogebra.common.kernel.algos.AlgoElement newAlgoShortestDistance(geogebra.common.kernel.Construction,java.lang.String,geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.geos.GeoBoolean) -> a
    geogebra.common.gui.view.spreadsheet.AbstractSpreadsheetTableModel getSpreadsheetTableModel() -> a
    geogebra.common.kernel.commands.CommandProcessor newCmdBarCode() -> a
    void initScriptingBundle() -> h
    java.lang.String getScriptingCommand(java.lang.String) -> b
    boolean isCommandChanged() -> b
    void setCommandChanged(boolean) -> a
    boolean isCommandNull() -> c
    boolean isRightClick(geogebra.common.euclidian.event.AbstractEvent) -> a
    boolean isControlDown(geogebra.common.euclidian.event.AbstractEvent) -> b
    boolean isMiddleClick(geogebra.common.euclidian.event.AbstractEvent) -> c
    java.awt.Font getFontCanDisplayAwt(java.lang.String,boolean,int,int) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String,int) -> a
    boolean isMacOS() -> u
    boolean isWindows() -> v
    boolean isHTML5Applet() -> J
    geogebra.common.kernel.arithmetic.ExpressionNodeConstants$StringType getFormulaRenderingType() -> a
    geogebra.common.gui.dialog.DialogManager getDialogManager() -> a
    java.lang.String getLocaleStr() -> j
    void showURLinBrowser(java.lang.String) -> o
    void uploadToGeoGebraTube() -> O
    geogebra.common.util.LowerCaseDictionary newLowerCaseDictionary() -> a
    geogebra.CommandLineArguments getCommandLineArgs() -> a
    geogebra.common.sound.SoundManager getSoundManager() -> a
    geogebra.common.gui.GuiManager getGuiManager() -> a
    geogebra.common.euclidian.AbstractEuclidianView getEuclidianView2() -> c
    geogebra.common.kernel.AbstractUndoManager getUndoManager(geogebra.common.kernel.Construction) -> a
    geogebra.common.gui.view.spreadsheet.SpreadsheetTraceManager getTraceManager() -> a
    geogebra.common.util.AbstractImageManager getImageManager() -> a
    geogebra.common.euclidian.DrawEquationInterface getDrawEquation() -> a
    geogebra.common.euclidian.AbstractEuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.plugin.jython.PythonBridge getPythonBridge() -> a
    geogebra.common.main.GlobalKeyDispatcher getGlobalKeyDispatcher() -> a
    geogebra.common.plugin.ScriptManagerCommon getScriptManager() -> a
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getActiveEuclidianView() -> a
    geogebra.common.main.AbstractFontManager getFontManager() -> a
    geogebra.common.euclidian.AbstractEuclidianView getEuclidianView1() -> a
    geogebra.common.plugin.GgbAPI getGgbApi() -> a
    geogebra.common.gui.view.algebra.AlgebraView getAlgebraView() -> a
geogebra.main.Application$1 -> geogebra.i.m:
    geogebra.main.Application this$0 -> a
    java.lang.String val$fileArgument -> a
    void run() -> run
geogebra.main.Application$2 -> geogebra.i.n:
    geogebra.main.Application this$0 -> a
    void windowClosing(java.awt.event.WindowEvent) -> windowClosing
geogebra.main.Application$3 -> geogebra.i.o:
    geogebra.main.Application this$0 -> a
    java.lang.String val$msg -> a
    void run() -> run
geogebra.main.Application$4 -> geogebra.i.p:
    geogebra.main.Application this$0 -> a
    java.lang.String val$message -> a
    void run() -> run
geogebra.main.Application$5 -> geogebra.i.q:
    geogebra.main.Application this$0 -> a
    geogebra.euclidian.EuclidianView val$ev -> a
    void run() -> run
geogebra.main.DialogManagerMinimal -> geogebra.i.r:
    java.lang.String prompt(java.lang.String,java.lang.String) -> a
    boolean confirm(java.lang.String) -> a
    boolean showFunctionInspector(geogebra.common.kernel.geos.GeoFunction) -> a
    void showPropertiesDialog(java.util.ArrayList) -> a
    void showNumberInputDialogSegmentFixed(java.lang.String,geogebra.common.kernel.geos.GeoPoint2) -> a
    void showNumberInputDialogAngleFixed(java.lang.String,geogebra.common.kernel.geos.GeoSegment[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void showNumberInputDialogDilate(java.lang.String,geogebra.common.kernel.geos.GeoPolygon[],geogebra.common.kernel.geos.GeoPoint2[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void showBooleanCheckboxCreationDialog(geogebra.common.awt.Point,geogebra.common.kernel.geos.GeoBoolean) -> a
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.AbstractEuclidianView) -> a
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.Object[] showAngleInputDialog(java.lang.String,java.lang.String,java.lang.String) -> a
    boolean showButtonCreationDialog(int,int,boolean) -> a
    void closeAll() -> a
    void showRenameDialog(geogebra.common.kernel.geos.GeoElement,boolean,java.lang.String,boolean) -> a
    void showOptionsDialog(int) -> a
    void showPropertiesDialog() -> b
    void showToolbarConfigDialog() -> c
    geogebra.common.kernel.arithmetic.NumberValue showNumberInputDialog(java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String) -> a
    void showTextDialog(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> a
geogebra.main.FontManager -> geogebra.i.s:
    java.awt.Font boldFont -> a
    java.awt.Font italicFont -> b
    java.awt.Font plainFont -> c
    java.awt.Font smallFont -> d
    java.awt.Font serifFont -> e
    java.awt.Font serifFontBold -> f
    java.awt.Font javaSans -> g
    java.awt.Font javaSerif -> h
    int fontSize -> a
    java.lang.String sansName -> a
    java.lang.String serifName -> b
    java.util.HashMap fontMap -> a
    java.lang.StringBuilder key -> a
    java.lang.String[] FONT_NAMES_SANSSERIF -> a
    java.lang.String[] FONT_NAMES_SERIF -> b
    void setLanguage(java.util.Locale) -> a
    void setFontSize(int) -> a
    void updateDefaultFonts(int,java.lang.String,java.lang.String) -> a
    java.awt.Font getFont(boolean,int,int) -> a
    java.awt.Font getFont(java.lang.String,int,int) -> a
    java.awt.Font getFontCanDisplayAwt(java.lang.String,boolean,int,int) -> a
    java.lang.String getFontCanDisplay(java.util.LinkedList,java.lang.String) -> a
    java.awt.Font getBoldFont() -> a
    java.awt.Font getItalicFont() -> b
    java.awt.Font getPlainFont() -> c
    java.awt.Font getSmallFont() -> d
    java.awt.Font getSerifFont() -> e
    void setLAFFont(java.awt.Font) -> a
    geogebra.common.awt.Font getFontCanDisplay(java.lang.String,boolean,int,int) -> a
geogebra.main.GeoGebraPortablePreferences -> geogebra.i.t:
    java.util.Properties properties -> a
    geogebra.main.GeoGebraPortablePreferences singleton -> a
    geogebra.main.GeoGebraPreferences getPref() -> a
    void loadPreferences() -> d
    void storePreferences() -> e
    java.lang.String loadPreference(java.lang.String,java.lang.String) -> a
    void savePreference(java.lang.String,java.lang.String) -> a
    java.io.File getDefaultFilePath() -> a
    java.io.File getDefaultImagePath() -> b
    void saveDefaultImagePath(java.io.File) -> a
    java.util.Locale getDefaultLocale() -> a
    void saveDefaultLocale(java.util.Locale) -> a
    void loadFileList() -> a
    void saveFileList() -> b
    void saveXMLPreferences(geogebra.main.Application) -> a
    void loadXMLPreferences(geogebra.main.Application) -> b
    void clearPreferences() -> c
    java.lang.String get(java.lang.String,java.lang.String) -> b
    void set(java.lang.String,java.lang.String) -> b
    java.lang.String getB64(geogebra.main.Application) -> a
    void debug(java.lang.String) -> c
geogebra.main.GeoGebraPreferences -> geogebra.i.u:
    java.util.prefs.Preferences ggbPrefs -> a
    java.util.prefs.Preferences ggbPrefsSystem -> b
    java.lang.String factoryDefaultXml -> a
    java.lang.String XML_USER_PREFERENCES -> b
    java.lang.String XML_DEFAULT_OBJECT_PREFERENCES -> c
    java.lang.String XML_FACTORY_DEFAULT -> d
    java.lang.String TOOLS_FILE_GGT -> e
    java.lang.String APP_LOCALE -> f
    java.lang.String APP_CURRENT_IMAGE_PATH -> g
    java.lang.String APP_FILE_ -> h
    java.lang.String PROPERTY_FILEPATH -> i
    geogebra.main.GeoGebraPreferences singleton -> a
    void setPropertyFileName(java.lang.String) -> a
    geogebra.main.GeoGebraPreferences getPref() -> a
    java.lang.String loadPreference(java.lang.String,java.lang.String) -> a
    void savePreference(java.lang.String,java.lang.String) -> a
    boolean loadVersionCheckAllow(java.lang.String) -> a
    void saveVersionCheckAllow(java.lang.String) -> b
    java.io.File getDefaultFilePath() -> a
    java.io.File getDefaultImagePath() -> b
    void saveDefaultImagePath(java.io.File) -> a
    java.util.Locale getDefaultLocale() -> a
    void saveDefaultLocale(java.util.Locale) -> a
    void loadFileList() -> a
    void saveFileList() -> b
    void initDefaultXML(geogebra.main.Application) -> c
    void saveXMLPreferences(geogebra.main.Application) -> a
    void putByteArray(java.util.prefs.Preferences,java.lang.String,byte[]) -> a
    byte[] getByteArray(java.util.prefs.Preferences,java.lang.String,byte[]) -> a
    java.lang.String getXMLPreferences() -> a
    void loadXMLPreferences(geogebra.main.Application) -> b
    void clearPreferences() -> c
    java.lang.String getDefaultPreferences() -> b
geogebra.main.GlassPaneListener -> geogebra.i.v:
    java.awt.Component glassPane -> a
    java.awt.Component destComp -> b
    java.awt.Container contentPane -> a
    void mouseMoved(java.awt.event.MouseEvent) -> mouseMoved
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
    void mouseExited(java.awt.event.MouseEvent) -> mouseExited
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void mouseReleased(java.awt.event.MouseEvent) -> mouseReleased
    void redispatchMouseEvent(java.awt.event.MouseEvent) -> a
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
geogebra.main.GlobalKeyDispatcher -> geogebra.i.w:
    boolean dispatchKeyEvent(java.awt.event.KeyEvent) -> dispatchKeyEvent
    boolean handleKeyPressed(java.awt.event.KeyEvent) -> a
    boolean handleKeyTyped(java.awt.event.KeyEvent) -> c
    boolean handleGeneralKeys(java.awt.event.KeyEvent) -> b
    boolean handleSelectedGeosKeys(java.awt.event.KeyEvent,java.util.ArrayList) -> a
    void handleFunctionKeyForAlgebraInput(int,geogebra.common.kernel.geos.GeoElement) -> a
    boolean changeFontsAndGeoElements(geogebra.common.main.AbstractApplication,int,boolean) -> a
    int getPointSizeInc(int,int) -> a
    void setGeoProperties(geogebra.common.kernel.geos.GeoElement,int,int,int,boolean) -> a
geogebra.main.LoggingOutputStream -> geogebra.i.x:
    java.lang.String lineSeparator -> a
    java.util.logging.Logger logger -> a
    java.util.logging.Level level -> a
    void flush() -> flush
geogebra.main.MyResourceBundle -> geogebra.i.y:
    java.util.ResourceBundle createBundle(java.lang.String,java.util.Locale) -> a
    geogebra.main.MyResourceBundle loadSingleBundleFile(java.lang.String) -> a
geogebra.main.StdOutErrLevel -> geogebra.i.z:
    java.util.logging.Level STDOUT -> a
    java.util.logging.Level STDERR -> b
geogebra.plugin.CallJavaScript -> geogebra.plugin.a:
    void evalScript(geogebra.common.main.AbstractApplication,java.lang.String,java.lang.String) -> a
geogebra.plugin.ClassPathManipulator -> geogebra.plugin.b:
    boolean addURL(java.net.URL,java.lang.ClassLoader) -> a
geogebra.plugin.GeoGebraGlobal -> geogebra.plugin.c:
    geogebra.main.Application app -> a
    java.lang.StringBuilder sb -> a
    int[] linep -> a
    java.lang.Object FTAG -> a
    void init(geogebra.main.Application,org.mozilla.javascript.Scriptable,boolean) -> a
    java.lang.Object execIdCall(org.mozilla.javascript.IdFunctionObject,org.mozilla.javascript.Context,org.mozilla.javascript.Scriptable,org.mozilla.javascript.Scriptable,java.lang.Object[]) -> execIdCall
    java.lang.String argError(java.lang.Object,java.lang.String) -> a
    java.lang.String argNumError(int,java.lang.String) -> a
    void initStandardObjects(geogebra.main.Application,org.mozilla.javascript.Scriptable,java.lang.String,boolean) -> a
geogebra.plugin.GgbAPI -> geogebra.plugin.GgbAPI:
    java.security.MessageDigest messageDigestMD5 -> a
    geogebra.plugin.ClassPathManipulator getClassPathManipulator() -> getClassPathManipulator
    byte[] getGGBfile() -> getGGBfile
    java.lang.String getBase64(boolean) -> getBase64
    void setBase64(java.lang.String) -> setBase64
    void setErrorDialogsActive(boolean) -> setErrorDialogsActive
    void reset() -> reset
    void fileNew() -> fileNew
    void refreshViews() -> refreshViews
    void openFile(java.lang.String) -> openFile
    java.lang.String getGraphicsViewCheckSum(java.lang.String,java.lang.String) -> getGraphicsViewCheckSum
    java.security.MessageDigest getMessageDigestMD5() -> getMessageDigestMD5
    boolean writePNGtoFile(java.lang.String,double,boolean,double) -> writePNGtoFile
    java.lang.String getPNGBase64(double,boolean,double) -> getPNGBase64
    void registerLoggerListener(java.lang.String) -> registerLoggerListener
    void unregisterLoggerListener(java.lang.String) -> unregisterLoggerListener
    void drawToImage(java.lang.String,double[],double[]) -> drawToImage
    void clearImage(java.lang.String) -> clearImage
    java.lang.String prompt(java.lang.Object,java.lang.Object) -> prompt
    void alert(java.lang.String) -> alert
    java.lang.String getIPAddress() -> getIPAddress
    java.lang.String getHostname() -> getHostname
    java.awt.geom.Rectangle2D$Double getCoordSystemRectangle() -> getCoordSystemRectangle
geogebra.plugin.GgbAPI$1 -> geogebra.plugin.d:
    geogebra.plugin.GgbAPI this$0 -> a
    double val$exportScale -> a
    boolean val$transparent -> a
    double val$DPI -> b
    java.io.File val$file -> a
    java.lang.Boolean run() -> a
    java.lang.Object run() -> run
geogebra.plugin.PlugLetIF -> geogebra.plugin.PlugLetIF:
    java.lang.String getMenuText() -> getMenuText
    void init(geogebra.plugin.GgbAPI,java.lang.String) -> init
    void execute() -> execute
    void start() -> start
    void stop() -> stop
    void destroy() -> destroy
geogebra.plugin.PluginManager -> geogebra.plugin.e:
    java.util.Hashtable plugintable -> a
    geogebra.main.Application app -> a
    javax.swing.JMenu pluginmenu -> a
    java.util.ArrayList lines -> a
    geogebra.plugin.ClassPathManipulator cpm -> a
    javax.swing.JMenu getPluginMenu() -> a
    void addPlugin(java.lang.String,java.lang.String) -> a
    void installPlugins() -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void addPaths(java.util.ArrayList) -> a
    geogebra.plugin.PlugLetIF getPluginInstance(java.lang.String) -> a
    void loadProperties() -> b
    void debug(java.lang.String) -> a
    java.net.URL addPathToJar(java.lang.String) -> a
geogebra.plugin.ScriptManager -> geogebra.plugin.f:
    geogebra.plugin.USBFunctions usb -> a
    void ggbOnInit() -> f
    void initJavaScript() -> g
    void callJavaScript(java.lang.String,java.lang.Object[]) -> a
    geogebra.plugin.USBFunctions getUSBFunctions() -> a
    void notifyDraw(java.lang.String,double[],double[]) -> a
geogebra.plugin.USBFunctions -> geogebra.plugin.g:
    geogebra.usb.USBLogger logger -> a
    geogebra.plugin.ScriptManager sm -> a
    org.concord.framework.data.stream.DataListener LoggerListener -> a
    java.util.ArrayList loggerListenerMap -> a
    void registerLoggerListener(java.lang.String) -> a
    void unregisterLoggerListener(java.lang.String) -> b
    java.util.ArrayList access$0(geogebra.plugin.USBFunctions) -> a
    geogebra.plugin.ScriptManager access$1(geogebra.plugin.USBFunctions) -> a
geogebra.plugin.USBFunctions$1 -> geogebra.plugin.h:
    geogebra.plugin.USBFunctions this$0 -> a
    void dataReceived(org.concord.framework.data.stream.DataStreamEvent) -> a
    void dataStreamEvent(org.concord.framework.data.stream.DataStreamEvent) -> b
geogebra.plugin.USBFunctions$2 -> geogebra.plugin.i:
    geogebra.plugin.USBFunctions this$0 -> a
    org.concord.sensor.SensorDataProducer val$sDataProducer -> a
    void run() -> run
geogebra.plugin.jython.AppletPythonBridge -> geogebra.plugin.jython.a:
    void init() -> a
    boolean isReady() -> a
geogebra.plugin.jython.CommonsMathLinearAPI -> geogebra.plugin.jython.CommonsMathLinearAPI:
    java.lang.Class RealVectorClass -> RealVectorClass
    java.lang.Class ArrayRealVectorClass -> ArrayRealVectorClass
    java.lang.Class RealMatrixClass -> RealMatrixClass
    java.lang.Class Array2DRowRealMatrixClass -> Array2DRowRealMatrixClass
    java.lang.Class SingularValueDecompositionImplClass -> SingularValueDecompositionImplClass
    java.lang.Class MathRuntimeExceptionClass -> MathRuntimeExceptionClass
    org.apache.commons.math.linear.ArrayRealVector newArrayRealVector() -> newArrayRealVector
    org.apache.commons.math.linear.ArrayRealVector newArrayRealVector(double[]) -> newArrayRealVector
    org.apache.commons.math.linear.Array2DRowRealMatrix newArray2DRowRealMatrix() -> newArray2DRowRealMatrix
    org.apache.commons.math.linear.Array2DRowRealMatrix newArray2DRowRealMatrix(int,int) -> newArray2DRowRealMatrix
    org.apache.commons.math.linear.Array2DRowRealMatrix newArray2DRowRealMatrix(double[][]) -> newArray2DRowRealMatrix
    org.apache.commons.math.linear.SingularValueDecompositionImpl newSingularValueDecompositionImpl(org.apache.commons.math.linear.RealMatrix) -> newSingularValueDecompositionImpl
    org.apache.commons.math.linear.RealVector add(org.apache.commons.math.linear.RealVector,org.apache.commons.math.linear.RealVector) -> add
    org.apache.commons.math.linear.RealVector subtract(org.apache.commons.math.linear.RealVector,org.apache.commons.math.linear.RealVector) -> subtract
    org.apache.commons.math.linear.RealVector mapMultiply(org.apache.commons.math.linear.RealVector,double) -> mapMultiply
    double dotProduct(org.apache.commons.math.linear.RealVector,org.apache.commons.math.linear.RealVector) -> dotProduct
    double getNorm(org.apache.commons.math.linear.RealVector) -> getNorm
    int getDimension(org.apache.commons.math.linear.RealVector) -> getDimension
    void setEntry(org.apache.commons.math.linear.RealVector,int,double) -> setEntry
    double getEntry(org.apache.commons.math.linear.RealVector,int) -> getEntry
    org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix,org.apache.commons.math.linear.RealMatrix) -> add
    org.apache.commons.math.linear.RealMatrix scalarAdd(org.apache.commons.math.linear.RealMatrix,double) -> scalarAdd
    org.apache.commons.math.linear.RealMatrix subtract(org.apache.commons.math.linear.RealMatrix,org.apache.commons.math.linear.RealMatrix) -> subtract
    org.apache.commons.math.linear.RealMatrix multiply(org.apache.commons.math.linear.RealMatrix,org.apache.commons.math.linear.RealMatrix) -> multiply
    org.apache.commons.math.linear.RealMatrix scalarMultiply(org.apache.commons.math.linear.RealMatrix,double) -> scalarMultiply
    org.apache.commons.math.linear.RealVector operate(org.apache.commons.math.linear.RealMatrix,org.apache.commons.math.linear.RealVector) -> operate
    double getNorm(org.apache.commons.math.linear.RealMatrix) -> getNorm
    double getTrace(org.apache.commons.math.linear.RealMatrix) -> getTrace
    int getRowDimension(org.apache.commons.math.linear.RealMatrix) -> getRowDimension
    int getColumnDimension(org.apache.commons.math.linear.RealMatrix) -> getColumnDimension
    void setEntry(org.apache.commons.math.linear.RealMatrix,int,int,double) -> setEntry
    double getEntry(org.apache.commons.math.linear.RealMatrix,int,int) -> getEntry
    void addToEntry(org.apache.commons.math.linear.RealMatrix,int,int,double) -> addToEntry
    org.apache.commons.math.linear.DecompositionSolver getSolver(org.apache.commons.math.linear.SingularValueDecomposition) -> getSolver
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.DecompositionSolver,org.apache.commons.math.linear.RealMatrix) -> solve
    org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.DecompositionSolver,org.apache.commons.math.linear.RealVector) -> solve
geogebra.plugin.jython.PythonAPI -> geogebra.plugin.jython.PythonAPI:
    java.lang.Class GeoPointClass -> GeoPointClass
    java.lang.Class GeoElementClass -> GeoElementClass
    java.lang.Class GeoNumericClass -> GeoNumericClass
    java.lang.Class GeoAngleClass -> GeoAngleClass
    java.lang.Class GeoVectorClass -> GeoVectorClass
    java.lang.Class GeoFunctionClass -> GeoFunctionClass
    java.lang.Class GeoTextClass -> GeoTextClass
    java.lang.Class GeoButtonClass -> GeoButtonClass
    java.lang.Class GeoConicClass -> GeoConicClass
    java.lang.Class GeoLineClass -> GeoLineClass
    java.lang.Class GeoSegmentClass -> GeoSegmentClass
    java.lang.Class GeoRayClass -> GeoRayClass
    java.lang.Class GeoBooleanClass -> GeoBooleanClass
    java.lang.Class GeoLocusClass -> GeoLocusClass
    java.lang.Class GeoListClass -> GeoListClass
    geogebra.main.Application app -> app
    geogebra.common.kernel.Kernel kernel -> kernel
    geogebra.common.kernel.Construction cons -> cons
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> algProcessor
    geogebra.plugin.jython.PythonAPI instance -> instance
    void init(geogebra.main.Application) -> init
    geogebra.plugin.jython.PythonAPI getInstance() -> getInstance
    geogebra.plugin.jython.PythonAPI$Geo lookupLabel(java.lang.String) -> lookupLabel
    geogebra.plugin.jython.PythonAPI$Geo geoNumber(double) -> geoNumber
    geogebra.plugin.jython.PythonAPI$Geo geoNumber(geogebra.plugin.jython.PythonAPI$Expression) -> geoNumber
    geogebra.plugin.jython.PythonAPI$Geo geoVector(geogebra.plugin.jython.PythonAPI$Expression) -> geoVector
    geogebra.plugin.jython.PythonAPI$Geo geoVector(double,double) -> geoVector
    geogebra.plugin.jython.PythonAPI$Geo geoVector(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoVector
    geogebra.plugin.jython.PythonAPI$Geo geoVector(geogebra.plugin.jython.PythonAPI$Geo) -> geoVector
    geogebra.plugin.jython.PythonAPI$Geo geoLineDirection(geogebra.plugin.jython.PythonAPI$Geo) -> geoLineDirection
    geogebra.plugin.jython.PythonAPI$Geo geoPoint(geogebra.plugin.jython.PythonAPI$Expression) -> geoPoint
    geogebra.plugin.jython.PythonAPI$Geo geoPoint(double,double) -> geoPoint
    geogebra.plugin.jython.PythonAPI$Geo geoPointOnPath(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoPointOnPath
    geogebra.plugin.jython.PythonAPI$Geo geoLinePP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoLinePP
    geogebra.plugin.jython.PythonAPI$Geo geoLinePV(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoLinePV
    geogebra.plugin.jython.PythonAPI$Geo geoLinePL(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoLinePL
    geogebra.plugin.jython.PythonAPI$Geo geoSegment(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoSegment
    geogebra.plugin.jython.PythonAPI$Geo geoRayPP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoRayPP
    geogebra.plugin.jython.PythonAPI$Geo geoFunction(geogebra.plugin.jython.PythonAPI$Expression,geogebra.plugin.jython.PythonAPI$Expression) -> geoFunction
    geogebra.plugin.jython.PythonAPI$Geo geoFunctionNVar(geogebra.plugin.jython.PythonAPI$Expression,geogebra.plugin.jython.PythonAPI$Expression[]) -> geoFunctionNVar
    geogebra.plugin.jython.PythonAPI$Geo geoImplicitPoly(geogebra.plugin.jython.PythonAPI$Geo) -> geoImplicitPoly
    geogebra.plugin.jython.PythonAPI$Geo geoText(java.lang.String) -> geoText
    geogebra.plugin.jython.PythonAPI$Geo geoConic(geogebra.plugin.jython.PythonAPI$Geo[]) -> geoConic
    geogebra.plugin.jython.PythonAPI$Geo geoCircleCP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoCircleCP
    geogebra.plugin.jython.PythonAPI$Geo geoCirclePPP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoCirclePPP
    geogebra.plugin.jython.PythonAPI$Geo geoCircleCS(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoCircleCS
    geogebra.plugin.jython.PythonAPI$Geo geoCircleCR(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoCircleCR
    geogebra.plugin.jython.PythonAPI$Geo geoEllipseFFP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoEllipseFFP
    geogebra.plugin.jython.PythonAPI$Geo geoEllipseFFA(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoEllipseFFA
    geogebra.plugin.jython.PythonAPI$Geo geoHyperbolaFFP(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoHyperbolaFFP
    geogebra.plugin.jython.PythonAPI$Geo geoHyperbolaFFA(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoHyperbolaFFA
    geogebra.plugin.jython.PythonAPI$Geo geoParabola(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> geoParabola
    geogebra.plugin.jython.PythonAPI$Geo geoList(geogebra.plugin.jython.PythonAPI$Geo[]) -> geoList
    geogebra.plugin.jython.PythonAPI$Expression vectorExpression(geogebra.plugin.jython.PythonAPI$Expression,geogebra.plugin.jython.PythonAPI$Expression) -> vectorExpression
    geogebra.plugin.jython.PythonAPI$Expression numberExpression(double) -> numberExpression
    geogebra.plugin.jython.PythonAPI$Expression xCoordExpression(geogebra.plugin.jython.PythonAPI$Geo) -> xCoordExpression
    geogebra.plugin.jython.PythonAPI$Expression yCoordExpression(geogebra.plugin.jython.PythonAPI$Geo) -> yCoordExpression
    geogebra.common.kernel.arithmetic.ExpressionNode getNode(geogebra.common.kernel.arithmetic.ExpressionValue) -> getNode
    geogebra.plugin.jython.PythonAPI$Expression nodeExpression(geogebra.plugin.jython.PythonAPI$Expression) -> nodeExpression
    geogebra.plugin.jython.PythonAPI$Expression nodeExpression(geogebra.plugin.jython.PythonAPI$Expression,geogebra.common.plugin.Operation,geogebra.plugin.jython.PythonAPI$Expression) -> nodeExpression
    geogebra.plugin.jython.PythonAPI$Expression nodeExpression(geogebra.plugin.jython.PythonAPI$Expression,geogebra.common.plugin.Operation) -> nodeExpression
    geogebra.plugin.jython.PythonAPI$Expression variableExpression(java.lang.String) -> variableExpression
    geogebra.plugin.jython.PythonAPI$Geo getGeo(geogebra.plugin.jython.PythonAPI$Expression) -> getGeo
    geogebra.plugin.jython.PythonAPI$Geo intersectLines(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> intersectLines
    geogebra.plugin.jython.PythonAPI$Geo[] wrapGeoElements(geogebra.common.kernel.geos.GeoElement[]) -> wrapGeoElements
    geogebra.common.kernel.geos.GeoElement[] unwrapGeos(geogebra.plugin.jython.PythonAPI$Geo[]) -> unwrapGeos
    geogebra.plugin.jython.PythonAPI$Geo[] intersectLineConic(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> intersectLineConic
    geogebra.plugin.jython.PythonAPI$Geo[] intersectConics(geogebra.plugin.jython.PythonAPI$Geo,geogebra.plugin.jython.PythonAPI$Geo) -> intersectConics
    geogebra.plugin.jython.PythonAPI$Geo[] getSelectedGeos() -> getSelectedGeos
    geogebra.plugin.jython.PythonAPI$Geo[] getGeos(geogebra.common.plugin.GeoClass) -> getGeos
    geogebra.plugin.jython.PythonAPI$Geo[] getAllGeos() -> getAllGeos
    void startSelectionListener() -> startSelectionListener
    void stopSelectionListener() -> stopSelectionListener
    geogebra.common.plugin.GgbAPI getGgbApi() -> getGgbApi
    java.lang.String getInitScript() -> getInitScript
    void setInitScript(java.lang.String) -> setInitScript
geogebra.plugin.jython.PythonAPI$Expression -> geogebra.plugin.jython.PythonAPI$a:
    geogebra.common.kernel.arithmetic.ExpressionValue expr -> a
    java.lang.String toString() -> toString
    geogebra.plugin.jython.PythonAPI$Expression evaluate() -> evaluate
    boolean isNumber() -> isNumber
    double getNumber() -> getNumber
    boolean isVector() -> isVector
    double[] getCoords() -> getCoords
    boolean isBoolean() -> isBoolean
    boolean getBoolean() -> getBoolean
    boolean isNode() -> isNode
    java.lang.String getNodeLabel() -> getNodeLabel
    void setNodeLabel(java.lang.String) -> setNodeLabel
geogebra.plugin.jython.PythonAPI$Geo -> geogebra.plugin.jython.PythonAPI$Geo:
    geogebra.common.kernel.geos.GeoElement geo -> a
    java.lang.String toString() -> toString
    boolean equals(geogebra.plugin.jython.PythonAPI$Geo) -> equals
    boolean __eq__(geogebra.plugin.jython.PythonAPI$Geo) -> __eq__
    int hashCode() -> hashCode
    java.lang.Class getType() -> getType
    java.lang.String getTypeString() -> getTypeString
    void remove() -> remove
    void updateRepaint() -> updateRepaint
    java.lang.String getLabel() -> getLabel
    void setLabel(java.lang.String) -> setLabel
    geogebra.common.awt.Color getColor() -> getColor
    void setColor(geogebra.common.awt.Color) -> setColor
    java.lang.String getCaption() -> getCaption
    void setCaption(java.lang.String) -> setCaption
    int getLabelMode() -> getLabelMode
    void setLabelMode(int) -> setLabelMode
    geogebra.common.awt.Color getLabelColor() -> getLabelColor
    void setLabelColor(geogebra.common.awt.Color) -> setLabelColor
    boolean isLabelVisible() -> isLabelVisible
    void setLabelVisible(boolean) -> setLabelVisible
    geogebra.common.awt.Color getBackgroundColor() -> getBackgroundColor
    void setBackgroundColor(geogebra.common.awt.Color) -> setBackgroundColor
    boolean getTrace() -> getTrace
    void setTrace(boolean) -> setTrace
    int getLineThickness() -> getLineThickness
    void setLineThickness(int) -> setLineThickness
    int getLineType() -> getLineType
    void setLineType(int) -> setLineType
    boolean isEuclidianVisible() -> isEuclidianVisible
    void setEuclidianVisible(boolean) -> setEuclidianVisible
    boolean isAlgebraVisible() -> isAlgebraVisible
    void setAlgebraVisible(boolean) -> setAlgebraVisible
    boolean isAuxiliary() -> isAuxiliary
    void setAuxiliary(boolean) -> setAuxiliary
    boolean keepsType() -> keepsType
    java.lang.String getClickScript() -> getClickScript
    java.lang.String getUpdateScript() -> getUpdateScript
    void setClickScript(java.lang.String) -> setClickScript
    void setUpdateScript(java.lang.String) -> setUpdateScript
    void setCoords(double,double,double) -> setCoords
    boolean isOnPath(geogebra.plugin.jython.PythonAPI$Geo,double) -> isOnPath
    geogebra.plugin.jython.PythonAPI$Geo getStartPoint() -> getStartPoint
    void setStartPoint(geogebra.plugin.jython.PythonAPI$Geo) -> setStartPoint
    geogebra.plugin.jython.PythonAPI$Geo getEndPoint() -> getEndPoint
    void setEndPoint(geogebra.plugin.jython.PythonAPI$Geo) -> setEndPoint
    geogebra.plugin.jython.PythonAPI$Geo getTextOrigin() -> getTextOrigin
    void setNumericValue(double) -> setNumericValue
    void setTextOrigin(geogebra.plugin.jython.PythonAPI$Geo) -> setTextOrigin
    void removeTextOrigin() -> removeTextOrigin
geogebra.plugin.jython.PythonBridge -> geogebra.plugin.jython.b:
    geogebra.main.Application application -> a
    geogebra.plugin.jython.PythonFlatAPI api -> a
    org.python.util.PythonInterpreter interpreter -> a
    geogebra.plugin.jython.PythonScriptInterface pyInterface -> a
    boolean ready -> a
    void init() -> a
    void forceInit() -> e
    boolean isReady() -> a
    void toggleWindow() -> f
    boolean isWindowVisible() -> b
    void handleEvent(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> a
    void click(geogebra.common.kernel.geos.GeoElement) -> g
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void updateAuxiliaryObject(geogebra.common.kernel.geos.GeoElement) -> f
    void repaintView() -> c
    void reset() -> d
    void clearView() -> b
    void setMode(int) -> a
    int getViewID() -> b
    void geoElementSelected(geogebra.common.kernel.geos.GeoElement,boolean) -> a
    void setEventListener(geogebra.common.kernel.geos.GeoElement,java.lang.String,java.lang.String) -> a
    void eval(java.lang.String) -> a
    java.lang.String getCurrentPythonScript() -> a
    void execScript() -> g
geogebra.plugin.jython.PythonFlatAPI -> geogebra.plugin.jython.PythonFlatAPI:
    java.lang.Class GeoPointClass -> GeoPointClass
    java.lang.Class GeoElementClass -> GeoElementClass
    java.lang.Class GeoNumericClass -> GeoNumericClass
    java.lang.Class GeoAngleClass -> GeoAngleClass
    java.lang.Class GeoVectorClass -> GeoVectorClass
    java.lang.Class GeoFunctionClass -> GeoFunctionClass
    java.lang.Class GeoFunctionNVarClass -> GeoFunctionNVarClass
    java.lang.Class GeoTextClass -> GeoTextClass
    java.lang.Class GeoButtonClass -> GeoButtonClass
    java.lang.Class GeoConicClass -> GeoConicClass
    java.lang.Class GeoLineClass -> GeoLineClass
    java.lang.Class GeoSegmentClass -> GeoSegmentClass
    java.lang.Class GeoRayClass -> GeoRayClass
    java.lang.Class GeoBooleanClass -> GeoBooleanClass
    java.lang.Class GeoLocusClass -> GeoLocusClass
    java.lang.Class GeoListClass -> GeoListClass
    java.lang.Class GeoTextFieldClass -> GeoTextFieldClass
    java.lang.Class GeoAxisClass -> GeoAxisClass
    java.lang.Class GeoPolygonClass -> GeoPolygonClass
    java.lang.Class GeoPolyLineClass -> GeoPolyLineClass
    java.lang.Class GeoTurtleClass -> GeoTurtleClass
    geogebra.main.Application app -> app
    geogebra.common.kernel.Kernel kernel -> kernel
    geogebra.common.kernel.Construction cons -> cons
    geogebra.common.kernel.commands.AlgebraProcessor algProcessor -> algProcessor
    geogebra.common.kernel.geos.GeoElement lookupLabel(java.lang.String) -> lookupLabel
    geogebra.common.kernel.geos.GeoNumeric geoNumber(double) -> geoNumber
    geogebra.common.kernel.geos.GeoNumeric geoNumber(geogebra.common.kernel.arithmetic.ExpressionValue) -> geoNumber
    geogebra.common.kernel.geos.GeoVector geoVector(geogebra.common.kernel.arithmetic.ExpressionValue) -> geoVector
    geogebra.common.kernel.geos.GeoVector geoVector(double,double) -> geoVector
    geogebra.common.kernel.geos.GeoVector geoVector(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoVector
    geogebra.common.kernel.geos.GeoVector geoVector(geogebra.common.kernel.geos.GeoPoint2) -> geoVector
    geogebra.common.kernel.geos.GeoVector geoLineDirection(geogebra.common.kernel.geos.GeoLine) -> geoLineDirection
    geogebra.common.kernel.geos.GeoPoint2 geoPoint(geogebra.common.kernel.arithmetic.ExpressionValue) -> geoPoint
    geogebra.common.kernel.geos.GeoPoint2 geoPoint(double,double) -> geoPoint
    geogebra.common.kernel.geos.GeoPoint2 geoPointOnPath(geogebra.common.kernel.Path,geogebra.common.kernel.arithmetic.NumberValue) -> geoPointOnPath
    geogebra.common.kernel.geos.GeoLine geoLinePP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoLinePP
    geogebra.common.kernel.geos.GeoLine geoLinePV(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoVector) -> geoLinePV
    geogebra.common.kernel.geos.GeoLine geoLinePL(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> geoLinePL
    geogebra.common.kernel.geos.GeoSegment geoSegment(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoSegment
    geogebra.common.kernel.geos.GeoRay geoRayPP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoRayPP
    geogebra.common.kernel.geos.GeoFunction geoFunction(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.FunctionVariable) -> geoFunction
    geogebra.common.kernel.geos.GeoFunctionNVar geoFunctionNVar(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.FunctionVariable[]) -> geoFunctionNVar
    geogebra.common.kernel.implicit.GeoImplicitPoly geoImplicitPoly(geogebra.common.kernel.geos.GeoFunctionNVar) -> geoImplicitPoly
    geogebra.common.kernel.geos.GeoText geoText(java.lang.String) -> geoText
    geogebra.common.kernel.geos.GeoConic geoConic(geogebra.common.kernel.geos.GeoPoint2[]) -> geoConic
    geogebra.common.kernel.geos.GeoConic geoCircleCP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoCircleCP
    geogebra.common.kernel.geos.GeoConic geoCirclePPP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoCirclePPP
    geogebra.common.kernel.geos.GeoConic geoCircleCS(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoSegment) -> geoCircleCS
    geogebra.common.kernel.geos.GeoConic geoCircleCR(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> geoCircleCR
    geogebra.common.kernel.geos.GeoConic geoEllipseFFP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoEllipseFFP
    geogebra.common.kernel.geos.GeoConic geoEllipseFFA(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> geoEllipseFFA
    geogebra.common.kernel.geos.GeoConic geoHyperbolaFFP(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> geoHyperbolaFFP
    geogebra.common.kernel.geos.GeoConic geoHyperbolaFFA(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.arithmetic.NumberValue) -> geoHyperbolaFFA
    geogebra.common.kernel.geos.GeoConic geoParabola(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoLine) -> geoParabola
    geogebra.common.kernel.geos.GeoList geoList(geogebra.common.kernel.geos.GeoElement[]) -> geoList
    geogebra.common.kernel.geos.GeoTurtle geoTurtle() -> geoTurtle
    geogebra.common.kernel.geos.GeoPolygon geoPolygon(geogebra.common.kernel.kernelND.GeoPointND[]) -> geoPolygon
    geogebra.common.kernel.geos.GeoPolyLine geoPolyLine(geogebra.common.kernel.kernelND.GeoPointND[]) -> geoPolyLine
    geogebra.common.kernel.arithmetic.MyVecNode vectorExpression(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.kernel.arithmetic.ExpressionValue) -> vectorExpression
    geogebra.common.kernel.arithmetic.MyDouble numberExpression(double) -> numberExpression
    geogebra.common.kernel.arithmetic.ExpressionNode xCoordExpression(geogebra.common.kernel.arithmetic.ExpressionValue) -> xCoordExpression
    geogebra.common.kernel.arithmetic.ExpressionNode yCoordExpression(geogebra.common.kernel.arithmetic.ExpressionValue) -> yCoordExpression
    geogebra.common.kernel.arithmetic.ExpressionNode getNode(geogebra.common.kernel.arithmetic.ExpressionValue) -> getNode
    geogebra.common.kernel.arithmetic.ExpressionNode nodeExpression(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation,geogebra.common.kernel.arithmetic.ExpressionValue) -> nodeExpression
    geogebra.common.kernel.arithmetic.ExpressionNode nodeExpression(geogebra.common.kernel.arithmetic.ExpressionValue,geogebra.common.plugin.Operation) -> nodeExpression
    geogebra.common.kernel.arithmetic.FunctionVariable variableExpression(java.lang.String) -> variableExpression
    geogebra.common.kernel.geos.GeoElement getGeo(geogebra.common.kernel.arithmetic.ExpressionValue) -> getGeo
    geogebra.common.kernel.kernelND.GeoPointND intersectLines(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> intersectLines
    geogebra.common.kernel.geos.GeoPoint2[] intersectLineConic(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoConic) -> intersectLineConic
    geogebra.common.kernel.kernelND.GeoPointND[] intersectConics(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> intersectConics
    void setAxisVisible(geogebra.common.kernel.geos.GeoAxis,boolean) -> setAxisVisible
    boolean isAxisVisible(geogebra.common.kernel.geos.GeoAxis) -> isAxisVisible
    void refreshViews() -> refreshViews
    java.util.ArrayList getSelectedGeos() -> getSelectedGeos
    geogebra.common.kernel.geos.GeoElement[] getGeos(geogebra.common.plugin.GeoClass) -> getGeos
    geogebra.common.kernel.geos.GeoElement[] getAllGeos() -> getAllGeos
    void startSelectionListener() -> startSelectionListener
    void stopSelectionListener() -> stopSelectionListener
    geogebra.common.plugin.GgbAPI getGgbApi() -> getGgbApi
    java.lang.String getInitScript() -> getInitScript
    void setInitScript(java.lang.String) -> setInitScript
    geogebra.common.kernel.geos.GeoElement[] evalCommand(java.lang.String) -> evalCommand
    geogebra.common.kernel.geos.GeoElement[] evalCommand(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionValue[]) -> evalCommand
    void updateMenubar() -> updateMenubar
geogebra.plugin.jython.PythonFlatAPI$Expression -> geogebra.plugin.jython.PythonFlatAPI$Expression:
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.arithmetic.ExpressionValue) -> evaluate
    boolean isNumber(geogebra.common.kernel.arithmetic.ExpressionValue) -> isNumber
    double getNumber(geogebra.common.kernel.arithmetic.NumberValue) -> getNumber
    boolean isVector(geogebra.common.kernel.arithmetic.ExpressionValue) -> isVector
    double[] getCoords(geogebra.common.kernel.arithmetic.MyVecNode) -> getCoords
    boolean isBoolean(geogebra.common.kernel.arithmetic.ExpressionValue) -> isBoolean
    boolean getBoolean(geogebra.common.kernel.arithmetic.BooleanValue) -> getBoolean
    boolean isNode(geogebra.common.kernel.arithmetic.ExpressionValue) -> isNode
    java.lang.String getNodeLabel(geogebra.common.kernel.arithmetic.ExpressionNode) -> getNodeLabel
    void setNodeLabel(geogebra.common.kernel.arithmetic.ExpressionNode,java.lang.String) -> setNodeLabel
geogebra.plugin.jython.PythonFlatAPI$Geo -> geogebra.plugin.jython.PythonFlatAPI$Geo:
    java.lang.Class getType(geogebra.common.kernel.geos.GeoElement) -> getType
    java.lang.String getTypeString(geogebra.common.kernel.geos.GeoElement) -> getTypeString
    void remove(geogebra.common.kernel.geos.GeoElement) -> remove
    boolean isDefined(geogebra.common.kernel.geos.GeoElement) -> isDefined
    boolean isInfinite(geogebra.common.kernel.geos.GeoElement) -> isInfinite
    boolean isFree(geogebra.common.kernel.geos.GeoElement) -> isFree
    void updateRepaint(geogebra.common.kernel.geos.GeoElement) -> updateRepaint
    java.lang.String getLabel(geogebra.common.kernel.geos.GeoElement) -> getLabel
    void setLabel(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> setLabel
    geogebra.common.awt.Color getColor(geogebra.common.kernel.geos.GeoElement) -> getColor
    void setColor(geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Color) -> setColor
    float getAlpha(geogebra.common.kernel.geos.GeoElement) -> getAlpha
    void setAlpha(geogebra.common.kernel.geos.GeoElement,float) -> setAlpha
    java.lang.String getCaption(geogebra.common.kernel.geos.GeoElement) -> getCaption
    void setCaption(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> setCaption
    int getLabelMode(geogebra.common.kernel.geos.GeoElement) -> getLabelMode
    void setLabelMode(geogebra.common.kernel.geos.GeoElement,int) -> setLabelMode
    geogebra.common.awt.Color getLabelColor(geogebra.common.kernel.geos.GeoElement) -> getLabelColor
    void setLabelColor(geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Color) -> setLabelColor
    boolean isLabelVisible(geogebra.common.kernel.geos.GeoElement) -> isLabelVisible
    void setLabelVisible(geogebra.common.kernel.geos.GeoElement,boolean) -> setLabelVisible
    geogebra.common.awt.Color getBackgroundColor(geogebra.common.kernel.geos.GeoElement) -> getBackgroundColor
    void setBackgroundColor(geogebra.common.kernel.geos.GeoElement,geogebra.common.awt.Color) -> setBackgroundColor
    boolean getTrace(geogebra.common.kernel.geos.Traceable) -> getTrace
    void setTrace(geogebra.common.kernel.geos.Traceable,boolean) -> setTrace
    int getLineThickness(geogebra.common.kernel.geos.GeoElement) -> getLineThickness
    void setLineThickness(geogebra.common.kernel.geos.GeoElement,int) -> setLineThickness
    int getLineType(geogebra.common.kernel.geos.GeoElement) -> getLineType
    void setLineType(geogebra.common.kernel.geos.GeoElement,int) -> setLineType
    boolean isEuclidianVisible(geogebra.common.kernel.geos.GeoElement) -> isEuclidianVisible
    void setEuclidianVisible(geogebra.common.kernel.geos.GeoElement,boolean) -> setEuclidianVisible
    boolean isAlgebraVisible(geogebra.common.kernel.geos.GeoElement) -> isAlgebraVisible
    void setAlgebraVisible(geogebra.common.kernel.geos.GeoElement,boolean) -> setAlgebraVisible
    boolean isAuxiliary(geogebra.common.kernel.geos.GeoElement) -> isAuxiliary
    void setAuxiliary(geogebra.common.kernel.geos.GeoElement,boolean) -> setAuxiliary
    boolean keepsType(geogebra.common.kernel.kernelND.GeoConicND) -> keepsType
    int getLayer(geogebra.common.kernel.geos.GeoElement) -> getLayer
    void setLayer(geogebra.common.kernel.geos.GeoElement,int) -> setLayer
    java.lang.String getClickScript(geogebra.common.kernel.geos.GeoElement) -> getClickScript
    java.lang.String getUpdateScript(geogebra.common.kernel.geos.GeoElement) -> getUpdateScript
    void setClickScript(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> setClickScript
    void setUpdateScript(geogebra.common.kernel.geos.GeoElement,java.lang.String) -> setUpdateScript
    int getPointSize(geogebra.common.kernel.geos.GeoPoint2) -> getPointSize
    void setPointSize(geogebra.common.kernel.geos.GeoPoint2,int) -> setPointSize
    void setCoords(geogebra.common.kernel.geos.GeoVec3D,double,double,double) -> setCoords
    boolean isOnPath(geogebra.common.kernel.Path,geogebra.common.kernel.kernelND.GeoPointND,double) -> isOnPath
    geogebra.common.kernel.geos.GeoPoint2 getStartPoint(geogebra.common.kernel.geos.GeoLine) -> getStartPoint
    void setStartPoint(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPoint2) -> setStartPoint
    geogebra.common.kernel.geos.GeoPoint2 getEndPoint(geogebra.common.kernel.geos.GeoLine) -> getEndPoint
    void setEndPoint(geogebra.common.kernel.geos.GeoLine,geogebra.common.kernel.geos.GeoPoint2) -> setEndPoint
    geogebra.common.kernel.kernelND.GeoPointND getTextOrigin(geogebra.common.kernel.geos.GeoText) -> getTextOrigin
    java.lang.String getTextString(geogebra.common.kernel.geos.GeoText) -> getTextString
    void setTextString(geogebra.common.kernel.geos.GeoText,java.lang.String) -> setTextString
    boolean isLatex(geogebra.common.kernel.geos.GeoText) -> isLatex
    void setLatex(geogebra.common.kernel.geos.GeoText,boolean) -> setLatex
    void setNumericValue(geogebra.common.kernel.geos.GeoNumeric,double) -> setNumericValue
    void setTextOrigin(geogebra.common.kernel.geos.GeoText,geogebra.common.kernel.kernelND.GeoPointND) -> setTextOrigin
    void removeTextOrigin(geogebra.common.kernel.geos.GeoText) -> removeTextOrigin
    java.lang.String getText(geogebra.common.kernel.geos.GeoTextField) -> getText
    void setText(geogebra.common.kernel.geos.GeoTextField,java.lang.String) -> setText
    geogebra.common.kernel.geos.GeoElement getListItem(geogebra.common.kernel.geos.GeoList,int) -> getListItem
    void removeListItem(geogebra.common.kernel.geos.GeoList,int) -> removeListItem
    void appendToList(geogebra.common.kernel.geos.GeoList,geogebra.common.kernel.geos.GeoElement) -> appendToList
    int getListLength(geogebra.common.kernel.geos.GeoList) -> getListLength
    void clearList(geogebra.common.kernel.geos.GeoList) -> clearList
    geogebra.common.kernel.Path getPolygonBoundary(geogebra.common.kernel.geos.GeoPolyLineInterface) -> getPolygonBoundary
    geogebra.common.kernel.kernelND.GeoPointND[] getPolygonPoints(geogebra.common.kernel.geos.GeoPolyLineInterface) -> getPolygonPoints
    int getPolygonSize(geogebra.common.kernel.geos.GeoPolygon) -> getPolygonSize
    double getPolygonDirectedArea(geogebra.common.kernel.geos.GeoPolygon) -> getPolygonDirectedArea
    geogebra.common.kernel.geos.GeoSegment[] getPolygonEdges(geogebra.common.kernel.geos.GeoPolygon) -> getPolygonEdges
    int getFunctionArity(geogebra.common.kernel.geos.GeoFunctionNVar) -> getFunctionArity
    void turtleForward(geogebra.common.kernel.geos.GeoTurtle,double) -> turtleForward
    void turtleTurn(geogebra.common.kernel.geos.GeoTurtle,double) -> turtleTurn
    boolean isTurtlePenDown(geogebra.common.kernel.geos.GeoTurtle) -> isTurtlePenDown
    void setTurtlePenDown(geogebra.common.kernel.geos.GeoTurtle,boolean) -> setTurtlePenDown
    geogebra.common.awt.Color getTurtlePenColor(geogebra.common.kernel.geos.GeoTurtle) -> getTurtlePenColor
    void setTurtlePenColor(geogebra.common.kernel.geos.GeoTurtle,geogebra.common.awt.Color) -> setTurtlePenColor
    int getTurtlePenThickness(geogebra.common.kernel.geos.GeoTurtle) -> getTurtlePenThickness
    void setTurtlePenThickness(geogebra.common.kernel.geos.GeoTurtle,int) -> setTurtlePenThickness
    geogebra.common.kernel.kernelND.GeoPointND getTurtlePosition(geogebra.common.kernel.geos.GeoTurtle) -> getTurtlePosition
    void setTurtlePosition(geogebra.common.kernel.geos.GeoTurtle,geogebra.common.kernel.geos.GeoPoint2) -> setTurtlePosition
    void setTurtlePosition(geogebra.common.kernel.geos.GeoTurtle,double,double) -> setTurtlePosition
    double getTurtleAngle(geogebra.common.kernel.geos.GeoTurtle) -> getTurtleAngle
    void setTurtleAngle(geogebra.common.kernel.geos.GeoTurtle,double) -> setTurtleAngle
    void clearTurtle(geogebra.common.kernel.geos.GeoTurtle) -> clearTurtle
    double getTurtleSpeed(geogebra.common.kernel.geos.GeoTurtle) -> getTurtleSpeed
    void setTurtleSpeed(geogebra.common.kernel.geos.GeoTurtle,double) -> setTurtleSpeed
    void rewindTurtle(geogebra.common.kernel.geos.GeoTurtle) -> rewindTurtle
    void stepTurtle(geogebra.common.kernel.geos.GeoTurtle) -> stepTurtle
    void stepTurtle(geogebra.common.kernel.geos.GeoTurtle,double) -> stepTurtle
geogebra.plugin.jython.PythonScriptInterface -> geogebra.plugin.jython.PythonScriptInterface:
    void init(geogebra.plugin.jython.PythonFlatAPI) -> init
    void handleEvent(java.lang.String,geogebra.common.kernel.geos.GeoElement) -> handleEvent
    void notifySelected(geogebra.common.kernel.geos.GeoElement,boolean) -> notifySelected
    void toggleWindow() -> toggleWindow
    boolean isWindowVisible() -> isWindowVisible
    void execute(java.lang.String) -> execute
    void setEventListener(geogebra.common.kernel.geos.GeoElement,java.lang.String,java.lang.String) -> setEventListener
    void reset() -> reset
    java.lang.String getCurrentInitScript() -> getCurrentInitScript
geogebra.plugin.kinect.KinectTest -> geogebra.plugin.a.a:
    org.OpenNI.OutArg scriptNode -> a
    org.OpenNI.Context context -> a
    org.OpenNI.DepthGenerator depthGen -> a
    org.OpenNI.UserGenerator userGen -> a
    org.OpenNI.SkeletonCapability skeletonCap -> a
    org.OpenNI.PoseDetectionCapability poseDetectionCap -> a
    byte[] imgbytes -> a
    float[] histogram -> a
    java.lang.String calibPose -> a
    java.util.HashMap joints -> a
    boolean drawBackground -> a
    boolean drawPixels -> b
    boolean drawSkeleton -> c
    boolean printID -> d
    boolean printState -> e
    java.awt.image.BufferedImage bimg -> a
    int width -> a
    int height -> b
    geogebra.common.kernel.Kernel kernel -> a
    java.awt.Color[] colors -> a
    geogebra.common.kernel.geos.GeoNumeric xHEAD -> a
    geogebra.common.kernel.geos.GeoNumeric xNECK -> b
    geogebra.common.kernel.geos.GeoNumeric xTORSO -> c
    geogebra.common.kernel.geos.GeoNumeric xLEFT_SHOULDER -> d
    geogebra.common.kernel.geos.GeoNumeric xLEFT_ELBOW -> e
    geogebra.common.kernel.geos.GeoNumeric xLEFT_HAND -> f
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_SHOULDER -> g
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_ELBOW -> h
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_HAND -> i
    geogebra.common.kernel.geos.GeoNumeric xLEFT_HIP -> j
    geogebra.common.kernel.geos.GeoNumeric xLEFT_KNEE -> k
    geogebra.common.kernel.geos.GeoNumeric xLEFT_FOOT -> l
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_HIP -> m
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_KNEE -> n
    geogebra.common.kernel.geos.GeoNumeric xRIGHT_FOOT -> o
    geogebra.common.kernel.geos.GeoNumeric yHEAD -> p
    geogebra.common.kernel.geos.GeoNumeric yNECK -> q
    geogebra.common.kernel.geos.GeoNumeric yTORSO -> r
    geogebra.common.kernel.geos.GeoNumeric yLEFT_SHOULDER -> s
    geogebra.common.kernel.geos.GeoNumeric yLEFT_ELBOW -> t
    geogebra.common.kernel.geos.GeoNumeric yLEFT_HAND -> u
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_SHOULDER -> v
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_ELBOW -> w
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_HAND -> x
    geogebra.common.kernel.geos.GeoNumeric yLEFT_HIP -> y
    geogebra.common.kernel.geos.GeoNumeric yLEFT_KNEE -> z
    geogebra.common.kernel.geos.GeoNumeric yLEFT_FOOT -> A
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_HIP -> B
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_KNEE -> C
    geogebra.common.kernel.geos.GeoNumeric yRIGHT_FOOT -> D
    geogebra.common.kernel.geos.GeoNumeric zHEAD -> E
    geogebra.common.kernel.geos.GeoNumeric zNECK -> F
    geogebra.common.kernel.geos.GeoNumeric zTORSO -> G
    geogebra.common.kernel.geos.GeoNumeric zLEFT_SHOULDER -> H
    geogebra.common.kernel.geos.GeoNumeric zLEFT_ELBOW -> I
    geogebra.common.kernel.geos.GeoNumeric zLEFT_HAND -> J
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_SHOULDER -> K
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_ELBOW -> L
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_HAND -> M
    geogebra.common.kernel.geos.GeoNumeric zLEFT_HIP -> N
    geogebra.common.kernel.geos.GeoNumeric zLEFT_KNEE -> O
    geogebra.common.kernel.geos.GeoNumeric zLEFT_FOOT -> P
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_HIP -> Q
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_KNEE -> R
    geogebra.common.kernel.geos.GeoNumeric zRIGHT_FOOT -> S
    java.util.ArrayList numberList -> a
    java.util.TreeSet tempSet -> a
    void calcHist(java.nio.ShortBuffer) -> a
    void updateDepth() -> a
    java.awt.Dimension getPreferredSize() -> getPreferredSize
    void getJoint(int,org.OpenNI.SkeletonJoint) -> a
    void getJoints(int) -> a
    void drawLine(java.awt.Graphics,java.util.HashMap,org.OpenNI.SkeletonJoint,org.OpenNI.SkeletonJoint) -> a
    void drawSkeleton(java.awt.Graphics,int) -> a
    geogebra.common.kernel.geos.GeoNumeric getGeoPoint(java.lang.String) -> a
    java.util.TreeSet getTempSet() -> a
    void paint(java.awt.Graphics) -> paint
    org.OpenNI.SkeletonCapability access$0(geogebra.plugin.kinect.KinectTest) -> a
    org.OpenNI.PoseDetectionCapability access$1(geogebra.plugin.kinect.KinectTest) -> a
geogebra.plugin.kinect.KinectTest$CalibrationCompleteObserver -> geogebra.plugin.a.a$a:
    geogebra.plugin.kinect.KinectTest this$0 -> a
    void update(org.OpenNI.IObservable,org.OpenNI.CalibrationProgressEventArgs) -> a
    void update(org.OpenNI.IObservable,java.lang.Object) -> update
geogebra.plugin.kinect.KinectTest$LostUserObserver -> geogebra.plugin.a.a$b:
    geogebra.plugin.kinect.KinectTest this$0 -> a
    void update(org.OpenNI.IObservable,org.OpenNI.UserEventArgs) -> a
    void update(org.OpenNI.IObservable,java.lang.Object) -> update
geogebra.plugin.kinect.KinectTest$NewUserObserver -> geogebra.plugin.a.a$c:
    geogebra.plugin.kinect.KinectTest this$0 -> a
    void update(org.OpenNI.IObservable,org.OpenNI.UserEventArgs) -> a
    void update(org.OpenNI.IObservable,java.lang.Object) -> update
geogebra.plugin.kinect.KinectTest$PoseDetectedObserver -> geogebra.plugin.a.a$d:
    geogebra.plugin.kinect.KinectTest this$0 -> a
    void update(org.OpenNI.IObservable,org.OpenNI.PoseDetectionEventArgs) -> a
    void update(org.OpenNI.IObservable,java.lang.Object) -> update
geogebra.plugin.kinect.KinectTestApplication -> geogebra.plugin.a.b:
    geogebra.plugin.kinect.KinectTest viewer -> a
    boolean shouldRun -> a
    javax.swing.JFrame frame -> a
    void run() -> a
    void access$0(geogebra.plugin.kinect.KinectTestApplication,boolean) -> a
geogebra.plugin.kinect.KinectTestApplication$1 -> geogebra.plugin.a.c:
    geogebra.plugin.kinect.KinectTestApplication this$0 -> a
    void keyTyped(java.awt.event.KeyEvent) -> keyTyped
    void keyReleased(java.awt.event.KeyEvent) -> keyReleased
    void keyPressed(java.awt.event.KeyEvent) -> keyPressed
geogebra.sound.FunctionSound -> geogebra.j.a:
    geogebra.main.Application app -> a
    geogebra.sound.FunctionSound$SoundThread soundThread -> a
    javax.sound.sampled.AudioFormat af -> a
    javax.sound.sampled.SourceDataLine sdl -> a
    int bitDepth -> a
    int sampleRate -> b
    int maxVolume -> c
    geogebra.common.kernel.geos.GeoFunction f -> a
    double min -> a
    double max -> b
    double t -> c
    boolean initStreamingAudio(int,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
    void pause(boolean) -> a
    void update(javax.sound.sampled.LineEvent) -> update
    int access$0(geogebra.sound.FunctionSound) -> a
    int access$1(geogebra.sound.FunctionSound) -> b
    javax.sound.sampled.SourceDataLine access$2() -> a
    javax.sound.sampled.AudioFormat access$3() -> a
    double access$4(geogebra.sound.FunctionSound) -> a
    void access$5(geogebra.sound.FunctionSound,double) -> a
    double access$6(geogebra.sound.FunctionSound) -> b
    double access$7(geogebra.sound.FunctionSound) -> c
    geogebra.common.kernel.geos.GeoFunction access$8(geogebra.sound.FunctionSound) -> a
    int access$9(geogebra.sound.FunctionSound) -> c
geogebra.sound.FunctionSound$SoundThread -> geogebra.j.a$a:
    boolean stopped -> a
    double samplePeriod -> a
    byte[] buf -> a
    geogebra.sound.FunctionSound this$0 -> a
    void run() -> run
    void generateFunctionSound() -> b
    void loadBuffer8(double) -> a
    void loadBuffer16(double) -> b
    void doFade(short,boolean) -> a
    void stopSound() -> a
geogebra.sound.MidiSound -> geogebra.j.b:
    geogebra.main.Application app -> a
    javax.sound.midi.Synthesizer synthesizer -> a
    javax.sound.midi.Instrument[] instruments -> a
    javax.sound.midi.MidiChannel[] channels -> a
    javax.sound.midi.Sequencer sequencer -> a
    javax.sound.midi.Sequence sequence -> a
    long tickPosition -> a
    org.jfugue.Player player -> a
    boolean initialize() -> a
    void playSequence(javax.sound.midi.Sequence,long) -> a
    void playSequence(javax.sound.midi.Sequence,int,long) -> a
    void pause(boolean) -> a
    void stop() -> a
    void closeMidiSound() -> b
    void meta(javax.sound.midi.MetaMessage) -> meta
    void playSequenceNote(int,double,int,int) -> a
    void playMidiFile(java.lang.String) -> a
    void loadSoundBank(java.io.File,java.net.URL) -> b
    void playSequenceFromJFugueString(java.lang.String,int) -> a
    void playJFugueFromFile(java.io.File,java.net.URL) -> a
geogebra.sound.MidiSound$PlayerThread -> geogebra.j.b$a:
    org.jfugue.Pattern pattern -> a
    org.jfugue.Player player -> a
    geogebra.sound.MidiSound this$0 -> a
    void run() -> run
geogebra.sound.SoundManager -> geogebra.j.c:
    geogebra.main.Application app -> a
    geogebra.sound.MidiSound midiSound -> a
    geogebra.sound.FunctionSound functionSound -> a
    int currentSoundType -> a
    boolean isRunning -> a
    boolean isPaused -> b
    geogebra.sound.MidiSound getMidiSound() -> a
    geogebra.sound.FunctionSound getFunctionSound() -> a
    void playSequenceNote(int,double,int,int) -> a
    void playMidiFile(java.lang.String) -> a
    void playSequenceFromString(java.lang.String,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double,int,int) -> a
    void playFunction(geogebra.common.kernel.geos.GeoFunction,double,double) -> a
    void stopCurrentSound() -> a
    void pauseResumeSound(boolean) -> a
geogebra.usb.USBLogger -> geogebra.k.a:
    org.concord.sensor.SensorDataProducer sDataProducer -> a
geogebra.util.AlgebraViewTransferHandler -> geogebra.l.a:
    geogebra.main.Application app -> a
    java.awt.datatransfer.DataFlavor algebraViewFlavor -> a
    java.awt.datatransfer.DataFlavor[] supportedFlavors -> a
    java.util.ArrayList geoLabelList -> a
    int getSourceActions(javax.swing.JComponent) -> getSourceActions
    boolean canImport(javax.swing.JComponent,java.awt.datatransfer.DataFlavor[]) -> canImport
    java.awt.datatransfer.Transferable createTransferable(javax.swing.JComponent) -> createTransferable
    boolean importData(javax.swing.JComponent,java.awt.datatransfer.Transferable) -> importData
    java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor) -> getTransferData
    java.awt.datatransfer.DataFlavor[] getTransferDataFlavors() -> getTransferDataFlavors
    boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor) -> isDataFlavorSupported
geogebra.util.BarcodeFactory -> geogebra.l.b:
    java.lang.String addStandardUPCEANChecksum(java.lang.String) -> a
geogebra.util.DisposeDialogAction -> geogebra.l.c:
    javax.swing.JDialog dialog -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra.util.DownloadManager -> geogebra.l.d:
    java.lang.String tempDir -> a
    void copyURLToFile(java.net.URL,java.io.File) -> a
    java.lang.String getTempDir() -> a
geogebra.util.GeoGebraLogger -> geogebra.l.e:
    java.io.File logFile -> a
    java.io.FileWriter logFileWriter -> a
    java.lang.String getTimeInfo() -> a
    void setLogFile(java.lang.String) -> b
    void print(java.lang.String,geogebra.common.util.GeoGebraLogger$Level) -> a
geogebra.util.GeoLaTeXCache -> geogebra.l.f:
    java.lang.Object keyLaTeX -> a
    java.lang.Object getCachedLaTeXKey(java.lang.String,int,int,geogebra.common.awt.Color) -> a
    void remove() -> a
geogebra.util.HttpRequest -> geogebra.l.g:
    java.lang.String answer -> b
    void sendRequest(java.lang.String) -> a
    void sendRequestPost(java.lang.String,java.lang.String) -> a
    java.lang.String sendRequestGetResponseSync(java.lang.String) -> a
geogebra.util.ImageManager -> geogebra.l.h:
    java.util.Hashtable iconTable -> a
    java.util.Hashtable internalImageTable -> b
    java.util.Hashtable externalImageTable -> c
    java.awt.Toolkit toolKit -> a
    java.awt.MediaTracker tracker -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String) -> a
    javax.swing.ImageIcon getImageIcon(java.lang.String,java.awt.Color) -> a
    java.awt.Image addBorder(java.awt.Image,java.awt.Color) -> a
    java.awt.Image getInternalImage(java.lang.String) -> a
    void addExternalImage(java.lang.String,java.awt.image.BufferedImage) -> a
    java.awt.image.BufferedImage getExternalImage(java.lang.String) -> a
    java.awt.Image getImageResourceGeoGebra(java.lang.String) -> b
    java.awt.Image getImageResource(java.lang.String) -> c
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image) -> a
    java.awt.image.BufferedImage toBufferedImage(java.awt.Image,int) -> a
    boolean hasAlpha(java.awt.Image) -> a
    javax.swing.ImageIcon getScaledIcon(javax.swing.ImageIcon,int,int) -> a
    java.awt.Image getScaledImage(java.awt.Image,int,int) -> a
    java.lang.String createImage(java.lang.String,geogebra.common.main.AbstractApplication) -> a
geogebra.util.Normalizer -> geogebra.l.i:
    geogebra.util.Normalizer INSTANCE -> a
    geogebra.util.Normalizer getInstance() -> a
    geogebra.util.Normalizer getNormalizerClass() -> b
geogebra.util.Normalizer6 -> geogebra.l.j:
    java.lang.reflect.Method normalize -> a
    java.lang.Object NFD -> a
    java.lang.String transform(java.lang.String) -> a
geogebra.util.NumberFormatDesktop -> geogebra.l.k:
geogebra.util.ScientificFormat -> geogebra.l.l:
    int sigDigit -> a
    int maxWidth -> b
    boolean sciNote -> a
    java.text.DecimalFormat decimalFormat -> a
    double k -> a
    java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition) -> format
    java.lang.Object parseObject(java.lang.String,java.text.ParsePosition) -> parseObject
    int getSigDigits() -> a
    void setSigDigits(int) -> a
    void setMaxWidth(int) -> b
    void setScientificNotationStyle(boolean) -> a
    double Log10(double) -> a
    int resolveErrorSigDigit(double,double) -> a
    java.text.DecimalFormat getDecimalFormat(int) -> a
    java.lang.String format(double) -> a
    java.lang.String format(double,int) -> a
geogebra.util.StringUtil -> geogebra.l.m:
    boolean isRightToLeftChar(char) -> a
    java.lang.String toLower(java.lang.String) -> d
geogebra.util.URLEncoder -> geogebra.l.n:
    java.lang.String encode(java.lang.String) -> a
geogebra.util.Util -> geogebra.l.o:
    char[] hexChar -> a
    java.lang.StringBuilder hexSB -> a
    java.util.Comparator comparator -> a
    double getJavaVersion() -> a
    void addKeyListenerToAll(java.awt.Container,java.awt.event.KeyListener) -> a
    byte[] loadIntoMemory(java.io.InputStream) -> a
    java.lang.String loadIntoString(java.io.InputStream) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> a
    void registerForDisposeOnEscape(javax.swing.JDialog) -> a
    java.lang.String keepOnlyLettersAndDigits(java.lang.String) -> a
    java.lang.String processFilename(java.lang.String) -> b
    java.util.Comparator getFileComparator() -> a
    java.lang.String getIPAddress() -> a
    java.lang.String getHostname() -> b
geogebra.util.Util$1 -> geogebra.l.p:
    int compare(java.io.File,java.io.File) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra.util.Util$2 -> geogebra.l.q:
    java.lang.Object run() -> run
geogebra.util.Util$3 -> geogebra.l.r:
    java.lang.String run() -> a
    java.lang.Object run() -> run
geogebra.util.Validation -> geogebra.l.s:
    geogebra.util.Validation validation -> a
    double validateDouble(javax.swing.JTextField,double) -> a
    double validateDoublePositive(javax.swing.JTextField,double) -> b
geogebra.util.Validation$1 -> geogebra.l.t:
    boolean checkInterval(double) -> a
geogebra.util.Validation$DoubleValidator -> geogebra.l.s$a:
    geogebra.util.Validation this$0 -> a
    double validateDouble(javax.swing.JTextField,double) -> a
    boolean checkInterval(double) -> a
    double access$1(geogebra.util.Validation$DoubleValidator,javax.swing.JTextField,double) -> a
geogebra3D.Application3D -> c.a:
    geogebra3D.euclidian3D.EuclidianView3D euclidianView3D -> a
    geogebra3D.euclidian3D.EuclidianController3D euclidianController3D -> a
    geogebra3D.kernel3D.Kernel3D kernel3D -> a
    geogebra3D.euclidianForPlane.EuclidianViewForPlane euclidianViewForPlane -> a
    int oldCursorMode -> l
    void initKernel() -> y
    boolean tableVisible(int) -> a
    void initImageManager(java.awt.Component) -> a
    void initEuclidianViews() -> z
    geogebra.euclidian.EuclidianController newEuclidianController(geogebra.common.kernel.Kernel) -> a
    geogebra.common.euclidian.AbstractEuclidianView newEuclidianView(boolean[],boolean) -> a
    void setMode(int) -> f
    java.lang.String getCompleteUserInterfaceXML(boolean) -> a
    geogebra3D.euclidian3D.EuclidianView3D getEuclidianView3D() -> a
    boolean hasEuclidianView3D() -> r
    void getEuclidianViewXML(java.lang.StringBuilder,boolean) -> a
    java.awt.image.BufferedImage getExportImage(double,double) -> a
    boolean saveGeoGebraFile(java.io.File) -> a
    geogebra3D.euclidianForPlane.EuclidianViewForPlane createEuclidianViewForPlane(geogebra.common.kernel.kernelND.ViewCreator) -> a
    void refreshViews() -> x
    void toggleAxis3D() -> ai
    void togglePlane() -> aj
    void toggleGrid3D() -> ak
    void setShowAxesSelected3D(javax.swing.JCheckBoxMenuItem) -> d
    void setShowPlaneSelected(javax.swing.JCheckBoxMenuItem) -> e
    void setShowGridSelected3D(javax.swing.JCheckBoxMenuItem) -> f
    geogebra.gui.GuiManager newGuiManager() -> a
    void updateFonts() -> M
    java.lang.String getCommandSyntax(java.lang.String) -> k
    void addToEuclidianView(geogebra.common.kernel.geos.GeoElement) -> e
    void removeFromEuclidianView(geogebra.common.kernel.geos.GeoElement) -> f
    void updateStyleBars() -> D
    geogebra.main.GlobalKeyDispatcher newGlobalKeyDispatcher() -> b
    boolean is3D() -> k
    void handleShiftEvent(boolean) -> A
    geogebra.common.euclidian.EuclidianViewInterfaceCommon getEuclidianView3D() -> b
geogebra3D.GlobalKeyDispatcher3D -> c.b:
geogebra3D.archimedean.support.AbstractArchimedeanSolid -> c.a.a.a:
    geogebra3D.archimedean.support.Point[] vertices -> a
    geogebra3D.archimedean.support.AbstractArchimedeanSolid$Face[] faces -> a
    geogebra.common.kernel.Matrix.Coords[] verticesInABv -> a
    int getVertexCount() -> a
    geogebra.common.kernel.Matrix.Coords[] getVerticesInABv() -> a
    void calcVerticesInABv() -> a
    int getFaceCount() -> b
    geogebra3D.archimedean.support.IFace[] getFaces() -> a
    java.lang.Integer[] sort(com.quantimegroup.solutions.archimedean.utils.ObjectList) -> a
    void setVertices(geogebra3D.archimedean.support.Point[]) -> a
    void setFaces(geogebra3D.archimedean.support.AbstractArchimedeanSolid$Face[]) -> a
    java.lang.String toString() -> toString
geogebra3D.archimedean.support.AbstractArchimedeanSolid$1 -> c.a.a.b:
    com.quantimegroup.solutions.archimedean.utils.ObjectList val$vertices -> a
    com.quantimegroup.solutions.archimedean.utils.OrderedTriple val$zeroAngleVector -> a
    int compare(java.lang.Integer,java.lang.Integer) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra3D.archimedean.support.AbstractArchimedeanSolid$Face -> c.a.a.a$a:
    int[] vertexIndices -> a
    geogebra3D.archimedean.support.AbstractArchimedeanSolid this$0 -> a
    int[] getVertexIndices() -> a
    int getVertexCount() -> a
    java.lang.String toString() -> toString
geogebra3D.archimedean.support.ArchimedeanSolidFactory -> c.a.a.c:
    geogebra3D.archimedean.support.IArchimedeanSolid create(com.quantimegroup.solutions.archimedean.common.SolidDefinition) -> a
    geogebra3D.archimedean.support.IArchimedeanSolid create(java.lang.String) -> a
    com.quantimegroup.solutions.archimedean.common.SolidDefinition getSolidDefinition(java.lang.String) -> a
geogebra3D.archimedean.support.ArchimedeanSolidFactory$1 -> c.a.a.d:
geogebra3D.archimedean.support.IArchimedeanSolid -> c.a.a.e:
    int getVertexCount() -> a
    geogebra.common.kernel.Matrix.Coords[] getVerticesInABv() -> a
    int getFaceCount() -> b
    geogebra3D.archimedean.support.IFace[] getFaces() -> a
geogebra3D.archimedean.support.IFace -> c.a.a.f:
    int[] getVertexIndices() -> a
    int getVertexCount() -> a
geogebra3D.archimedean.support.Point -> c.a.a.g:
    java.lang.String toString() -> toString
geogebra3D.euclidian3D.BucketAssigner -> c.b.a:
    int getBucketIndex(java.lang.Object,int) -> a
geogebra3D.euclidian3D.CurveTriList -> c.b.b:
    float currScale -> a
    float[] cosines -> a
    float[] sines -> b
    boolean initialized -> a
    geogebra3D.euclidian3D.TriListElem add(float[],float[],float[],float[],boolean) -> a
    geogebra3D.euclidian3D.TriListElem add(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    float[] calcVertices(geogebra3D.euclidian3D.CurveTriListElem) -> a
    float[] calcNormals(geogebra3D.euclidian3D.CurveTriListElem) -> b
    void rescale(float) -> a
geogebra3D.euclidian3D.CurveTriListElem -> c.b.c:
    float[] v0 -> a
    float[] v1 -> b
    float[] t0 -> c
    float[] t1 -> d
    float scale -> a
    float[][][] pts -> a
    float[][][] nrms -> b
    void genPoints(float[],float[],int,float[]) -> a
geogebra3D.euclidian3D.DrawAngle3D -> c.b.d:
    geogebra.common.kernel.Matrix.Coords labelCenter -> a
    void updateColors() -> b
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    void drawSurfaceGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> j
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a
    void updateLabel() -> e
    float getLabelOffsetX() -> a
    float getLabelOffsetY() -> b
geogebra3D.euclidian3D.DrawAxis3D -> c.b.e:
    java.util.TreeMap labels -> a
    double drawMinFinal -> a
    double drawMaxFinal -> b
    boolean outsideBox -> c
    void drawLabel(geogebra3D.euclidian3D.opengl.Renderer) -> e
    void setWaitForReset() -> g
    void updateLabel() -> e
    boolean updateForItSelf() -> a
    void updateDecorations() -> h
    double getNumbersDistance() -> b_
    void updateForView() -> d
    void updateDrawMinMax() -> i
    void setDrawMinMax(double,double) -> b
    void setDrawMinMaxImmediatly(double[][]) -> a
    boolean isVisible() -> b
    double[] getDrawMinMax() -> a
geogebra3D.euclidian3D.DrawClippingCube3D -> c.b.f:
    float clippingBorder -> c
    double[][] minMax -> a
    geogebra.common.kernel.Matrix.Coords[] vertices -> a
    int REDUCTION_SMALL -> a
    int REDUCTION_MEDIUM -> b
    int REDUCTION_LARGE -> c
    double[] REDUCTION_VALUES -> a
    int reduction -> d
    void setReduction(int) -> a
    int getReduction() -> b
    double[][] updateMinMax() -> a
    void setVertices() -> h
    geogebra.common.kernel.Matrix.Coords getVertex(int) -> a
    geogebra.common.kernel.Matrix.Coords getVertexWithBorder(int,int,int) -> a
    boolean updateForItSelf() -> a
    void updateEquations() -> i
    void updateForView() -> d
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    int getPickOrder() -> a
geogebra3D.euclidian3D.DrawConic3D -> c.b.g:
    void updateColors() -> b
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    double acosh(double) -> a
    boolean updateForItSelf() -> a
    double getStart() -> c_
    double getExtent() -> d
    void updateCircle(geogebra3D.euclidian3D.opengl.PlotterBrush) -> a
    void updateEllipse(geogebra3D.euclidian3D.opengl.PlotterBrush) -> b
    void updateForView() -> d
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    void drawSurfaceGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> j
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    void updatePreview() -> d_
    void updateMousePos(double,double) -> a
geogebra3D.euclidian3D.DrawConicPart3D -> c.b.h:
    double getStart() -> c_
    double getExtent() -> d
    void updateCircle(geogebra3D.euclidian3D.opengl.PlotterBrush) -> a
    void updateEllipse(geogebra3D.euclidian3D.opengl.PlotterBrush) -> b
    void updateSectorSegments(geogebra3D.euclidian3D.opengl.PlotterBrush,int,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double,double) -> a
geogebra3D.euclidian3D.DrawConify3D -> c.b.i:
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra3D.euclidian3D.DrawCoordSys1D -> c.b.j:
    double[] drawMinMax -> a
    java.util.ArrayList selectedPoints -> a
    void setDrawMinMax(double,double) -> b
    double[] getDrawMinMax() -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    boolean updateForItSelf() -> a
    void updateForItSelf(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    int getLineThickness() -> b
    int getPickOrder() -> a
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
geogebra3D.euclidian3D.DrawCurve3D -> c.b.k:
    boolean useOldCurves -> c
    geogebra3D.euclidian3D.plots.CurveMesh mesh -> a
    geogebra3D.kernel3D.GeoCurveCartesian3D curve -> a
    double[] domain -> a
    double[] cullingBox -> b
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    boolean updateDomain() -> k
    void updateCullingBox() -> h
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
geogebra3D.euclidian3D.DrawExtrusion3D -> c.b.l:
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.geos.GeoNumeric) -> a
geogebra3D.euclidian3D.DrawExtrusionOrConify3D -> c.b.m:
    java.util.ArrayList selectedPolygons -> a
    java.util.ArrayList selectedConics -> b
    geogebra3D.kernel3D.ExtrusionComputer extrusionComputer -> a
    geogebra.common.kernel.geos.GeoNumeric height -> a
    geogebra.common.kernel.geos.GeoElement basis -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    boolean updateForItSelf() -> a
    void updateMousePos(double,double) -> a
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.geos.GeoNumeric) -> a
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.geos.GeoNumeric) -> a
    void updatePreview() -> d_
    void disposePreview() -> c
    void createPolyhedron() -> h
geogebra3D.euclidian3D.DrawImplicitFunction3Var -> c.b.n:
    geogebra3D.euclidian3D.plots.MarchingCubes mc -> a
    double savedRadius -> a
    void updateRadius() -> h
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
geogebra3D.euclidian3D.DrawLabel3D -> c.b.o:
    java.lang.String text -> a
    java.awt.Font font -> a
    geogebra.common.kernel.Matrix.Coords color -> a
    geogebra.common.kernel.Matrix.Coords origin -> b
    float xOffset -> a
    float yOffset -> b
    float xOffset2 -> c
    float yOffset2 -> d
    boolean anchor -> b
    boolean isVisible -> c
    int height -> a
    int width -> b
    int height2 -> c
    int width2 -> d
    java.nio.ByteBuffer buffer -> a
    int textureIndex -> e
    geogebra3D.euclidian3D.EuclidianView3D view -> a
    boolean waitForReset -> d
    java.awt.Graphics2D tempGraphics -> a
    boolean hasIndex -> a
    void update(java.lang.String,java.awt.Font,java.awt.Color,geogebra.common.kernel.Matrix.Coords,float,float) -> a
    java.awt.geom.Rectangle2D getBounds() -> a
    void draw(java.awt.Graphics2D) -> a
    void setWaitForReset() -> a
    void setAnchor(boolean) -> a
    void draw(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void updateTexture() -> b
    void setIsVisible(boolean) -> b
    byte[] ARGBtoAlpha(int[]) -> a
    int firstPowerOfTwoGreaterThan(int) -> a
geogebra3D.euclidian3D.DrawLabel3DForText -> c.b.p:
    geogebra.common.kernel.geos.GeoText geo -> a
    java.awt.geom.Rectangle2D getBounds() -> a
    void draw(java.awt.Graphics2D) -> a
    void setGeo(geogebra.common.kernel.geos.GeoText) -> a
geogebra3D.euclidian3D.DrawLine3D -> c.b.q:
    boolean updateForItSelf() -> a
    void updateForItSelf(boolean) -> a
    void updateDrawMinMax(boolean) -> b
    void updateDrawMinMax() -> i
    void updateForView() -> d
geogebra3D.euclidian3D.DrawList3D -> c.b.r:
    geogebra.common.kernel.geos.GeoList geoList -> a
    geogebra3D.euclidian3D.DrawList3DArray drawables -> a
    boolean isVisible -> b
    geogebra3D.euclidian3D.EuclidianView3D view3D -> a
    geogebra3D.euclidian3D.DrawList3DArray getDrawables3D() -> a
    void drawOutline(geogebra3D.euclidian3D.opengl.Renderer) -> a_
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawLabel(geogebra3D.euclidian3D.opengl.Renderer) -> e
    boolean drawLabelForPicking(geogebra3D.euclidian3D.opengl.Renderer) -> a
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    boolean isTransparent() -> c
    boolean updateForItSelf() -> a
    void updateForView() -> d
    void updateLabel() -> e
    double getColorShift() -> a
geogebra3D.euclidian3D.DrawList3DArray -> c.b.s:
    void update(geogebra.common.euclidian.DrawableND) -> a
    geogebra.common.euclidian.DrawableND createDrawableND(geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.euclidian3D.DrawPlane3D -> c.b.t:
    int gridIndex -> a
    int gridOutlineIndex -> b
    double[] minmaxXFinal -> a
    double[] minmaxYFinal -> b
    boolean viewDirectionIsParallel -> c
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawPlate(geogebra3D.euclidian3D.opengl.Renderer) -> j
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawGeometryHidden(geogebra3D.euclidian3D.opengl.Renderer) -> h
    boolean isGridVisible() -> v_
    boolean updateForItSelf() -> a
    boolean updateGeometry() -> w_
    void updateForView() -> d
    void setWaitForUpdate() -> f
    void setMinMax() -> h
    void setMinMax(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
geogebra3D.euclidian3D.DrawPlaneConstant3D -> c.b.u:
    geogebra3D.euclidian3D.DrawAxis3D xAxis -> a
    geogebra3D.euclidian3D.DrawAxis3D yAxis -> b
    boolean updateForItSelf() -> a
    void updateForView() -> d
    void setMinMax() -> h
    boolean isGridVisible() -> v_
geogebra3D.euclidian3D.DrawPoint3D -> c.b.v:
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHidden(geogebra3D.euclidian3D.opengl.Renderer) -> h
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void disposePreview() -> c
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    float getLabelOffsetX() -> a
    float getLabelOffsetY() -> b
    double getColorShift() -> a
geogebra3D.euclidian3D.DrawPointDecorations -> c.b.w:
    geogebra.common.kernel.Matrix.CoordMatrix4x4 planeMatrix -> a
    geogebra.common.kernel.Matrix.Coords p1 -> a
    geogebra.common.kernel.Matrix.Coords p2 -> b
    boolean isVisible() -> b
    void setPoint(geogebra3D.kernel3D.GeoPoint3D) -> a
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawOutline(geogebra3D.euclidian3D.opengl.Renderer) -> a_
    boolean updateForItSelf() -> a
    void updateLabel() -> e
    int getLineThickness() -> b
    void updateForView() -> d
    int getPickOrder() -> a
    boolean isTransparent() -> c
    double getColorShift() -> a
    void updateColors() -> b
geogebra3D.euclidian3D.DrawPolyLine3D -> c.b.x:
    double[] drawMinMax -> a
    java.util.ArrayList selectedPoints -> a
    double[] getDrawMinMax() -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    boolean updateForItSelf() -> a
    int getLineThickness() -> b
    int getPickOrder() -> a
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
    void updateForView() -> d
geogebra3D.euclidian3D.DrawPolygon3D -> c.b.y:
    java.util.ArrayList selectedPoints -> a
    java.util.ArrayList segments -> b
    java.util.ArrayList segmentsPoints -> c
    boolean freezePreview -> c
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    boolean updateForItSelf() -> a
    void freezePreview() -> h
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
    void disposePreview() -> c
    boolean doHighlighting() -> d
geogebra3D.euclidian3D.DrawQuadric3D -> c.b.z:
    java.util.ArrayList selectedPoints -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    boolean updateForItSelf() -> a
    double[] getMinMax() -> a
    void setSurfaceV(float,float,geogebra3D.euclidian3D.opengl.PlotterSurface) -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
geogebra3D.euclidian3D.DrawQuadric3DPart -> c.b.A:
    double[] getMinMax() -> a
    void setSurfaceV(float,float,geogebra3D.euclidian3D.opengl.PlotterSurface) -> a
    void updateForView() -> d
geogebra3D.euclidian3D.DrawRay3D -> c.b.B:
    boolean updateForItSelf() -> a
    void updateForItSelf(boolean) -> a
    void updateDrawMinMax() -> h
    void updateForView() -> d
geogebra3D.euclidian3D.DrawSegment3D -> c.b.C:
    boolean doHighlighting() -> d
    void updateForView() -> d
geogebra3D.euclidian3D.DrawSurface3D -> c.b.D:
    geogebra3D.euclidian3D.plots.SurfaceMesh2 mesh -> a
    geogebra.common.kernel.kernelND.SurfaceEvaluable surface -> a
    boolean unboundedDomain -> c
    double[] activeDomain -> a
    double[] cullingBox -> b
    boolean updateDomain() -> k
    boolean updateCullingBox() -> l
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    void updateColors() -> b
geogebra3D.euclidian3D.DrawText3D -> c.b.E:
    geogebra3D.euclidian3D.DrawLabel3D newDrawLabel3D(geogebra3D.euclidian3D.EuclidianView3D) -> a
    void updateForView() -> d
    boolean updateForItSelf() -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void updateLabel() -> e
    java.awt.Font getFont() -> a
    boolean isLabelVisible() -> e
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a
    int getPickOrder() -> a
geogebra3D.euclidian3D.DrawVector3D -> c.b.F:
    java.util.ArrayList selectedPoints -> a
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    boolean updateForItSelf() -> a
    void updateForView() -> d
    int getPickOrder() -> a
    void updateMousePos(double,double) -> a
    void updatePreview() -> d_
geogebra3D.euclidian3D.Drawable3D -> c.b.G:
    geogebra3D.euclidian3D.EuclidianView3D m_view3D -> a
    boolean waitForUpdate -> b
    boolean labelWaitForUpdate -> c
    boolean waitForReset -> a
    int geomIndex -> a
    int surfaceIndex -> b
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra3D.euclidian3D.DrawLabel3D label -> a
    float zPickMax -> a
    float zPickMin -> b
    geogebra.common.kernel.Matrix.Coords color -> a
    geogebra.common.kernel.Matrix.Coords colorHighlighted -> b
    geogebra.common.kernel.Matrix.Coords surfaceColor -> c
    geogebra.common.kernel.Matrix.Coords surfaceColorHighlighted -> d
    boolean waitForUpdateVisualStyle -> d
    float alpha -> c
    long time -> a
    geogebra3D.euclidian3D.DrawLabel3D newDrawLabel3D(geogebra3D.euclidian3D.EuclidianView3D) -> a
    void realtimeUpdate() -> j
    void update() -> a
    void updateLabel() -> e
    float getLabelOffsetX() -> a
    float getLabelOffsetY() -> b
    void updateForView() -> d
    boolean updateForItSelf() -> a
    void setWaitForUpdate() -> f
    boolean waitForUpdate() -> h
    void setLabelWaitForUpdate() -> k
    void setWaitForReset() -> g
    void setWaitForUpdateVisualStyle() -> l
    void removeGeometryIndex(int) -> b
    void setGeometryIndex(int) -> c
    int getGeometryIndex() -> c
    void setSurfaceIndex(int) -> d
    int getSurfaceIndex() -> d
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a
    geogebra3D.euclidian3D.EuclidianView3D getView3D() -> a
    void setView3D(geogebra3D.euclidian3D.EuclidianView3D) -> a
    boolean isVisible() -> b
    void drawGeometry(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawOutline(geogebra3D.euclidian3D.opengl.Renderer) -> a_
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    geogebra3D.euclidian3D.Drawable3D drawForPicking(geogebra3D.euclidian3D.opengl.Renderer,boolean) -> a
    void drawLabel(geogebra3D.euclidian3D.opengl.Renderer) -> e
    boolean drawLabelForPicking(geogebra3D.euclidian3D.opengl.Renderer) -> a
    boolean drawLabel(geogebra3D.euclidian3D.opengl.Renderer,boolean) -> a
    boolean isLabelVisible() -> e
    int getPickOrder() -> a
    boolean isTransparent() -> c
    int comparePickingTo(geogebra3D.euclidian3D.Drawable3D,boolean) -> a
    boolean doHighlighting() -> d
    void setHighlightingColor() -> m
    void setSurfaceHighlightingColor() -> n
    void updateColors() -> b
    void setColorsOutlined() -> o
    void setColors(double,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void setAlpha(float) -> a
    float getAlpha() -> c
    void updateAlpha() -> p
    boolean hasTransparentAlpha() -> i
    double getColorShift() -> a
    void setLight(geogebra3D.euclidian3D.opengl.Renderer) -> i
    geogebra.common.kernel.geos.GeoElement getGeoElement() -> a
    void setGeoElement(geogebra.common.kernel.geos.GeoElement) -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists,int) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists,int) -> b
    void disposePreview() -> c
    void drawPreview(geogebra.common.awt.Graphics2D) -> b
    void setTime() -> q
    long getDeltaT() -> a
    boolean timesUpForUpdate() -> j
geogebra3D.euclidian3D.Drawable3D$drawableComparator -> c.b.G$a:
    int compare(geogebra3D.euclidian3D.Drawable3D,geogebra3D.euclidian3D.Drawable3D) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra3D.euclidian3D.Drawable3D$setComparator -> c.b.G$b:
    int compare(java.util.TreeSet,java.util.TreeSet) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
geogebra3D.euclidian3D.Drawable3DCurves -> c.b.H:
    boolean elementHasChanged -> b
    void setWaitForUpdate() -> f
    void drawOutline(geogebra3D.euclidian3D.opengl.Renderer) -> a_
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawGeometryHidden(geogebra3D.euclidian3D.opengl.Renderer) -> h
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    boolean isTransparent() -> c
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    double getColorShift() -> a
geogebra3D.euclidian3D.Drawable3DLists -> c.b.I:
    geogebra3D.euclidian3D.Drawable3DLists$Drawable3DList[] lists -> a
    geogebra3D.euclidian3D.EuclidianView3D view3D -> a
    void add(geogebra3D.euclidian3D.Drawable3D) -> a
    void add(java.util.LinkedList) -> a
    void remove(geogebra3D.euclidian3D.Drawable3D) -> b
    void remove(java.util.LinkedList) -> b
    geogebra3D.euclidian3D.Drawable3DLists$Drawable3DList getList(int) -> a
    boolean containsClippedSurfaces() -> a
    java.lang.String toString() -> toString
    void clear() -> a
    void updateAll() -> b
    void resetAllDrawables() -> c
    void resetAllVisualStyles() -> d
    void drawHiddenNotTextured(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawNotTransparentSurfaces(geogebra3D.euclidian3D.opengl.Renderer) -> b
    void drawNotTransparentSurfacesClosed(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawNotTransparentSurfacesClipped(geogebra3D.euclidian3D.opengl.Renderer) -> d
    void drawHiddenTextured(geogebra3D.euclidian3D.opengl.Renderer) -> e
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> f
    void drawTranspClosed(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void drawTranspClipped(geogebra3D.euclidian3D.opengl.Renderer) -> h
    void draw(geogebra3D.euclidian3D.opengl.Renderer) -> i
    void drawLabel(geogebra3D.euclidian3D.opengl.Renderer) -> j
    void drawSurfacesForHiding(geogebra3D.euclidian3D.opengl.Renderer) -> k
    void drawClosedSurfacesForHiding(geogebra3D.euclidian3D.opengl.Renderer) -> l
    void drawClippedSurfacesForHiding(geogebra3D.euclidian3D.opengl.Renderer) -> m
    void drawForPicking(geogebra3D.euclidian3D.opengl.Renderer) -> n
    void drawLabelForPicking(geogebra3D.euclidian3D.opengl.Renderer) -> o
geogebra3D.euclidian3D.Drawable3DLists$Drawable3DList -> c.b.I$a:
    geogebra3D.euclidian3D.Drawable3DLists this$0 -> a
    java.lang.String toString() -> toString
geogebra3D.euclidian3D.Drawable3DSurfaces -> c.b.J:
    boolean elementHasChanged -> b
    void drawGeometryHiding(geogebra3D.euclidian3D.opengl.Renderer) -> f
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> d
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void drawOutline(geogebra3D.euclidian3D.opengl.Renderer) -> a_
    void drawNotTransparentSurface(geogebra3D.euclidian3D.opengl.Renderer) -> b
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void updateColors() -> b
    void updateForView() -> d
    void setWaitForUpdate() -> f
    boolean isTransparent() -> c
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void removeFromDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> b
    double getColorShift() -> a
geogebra3D.euclidian3D.EuclidianController3D -> c.b.K:
    double[] xMinMax -> b
    double[] yMinMax -> c
    double[] zMinMax -> d
    geogebra.common.kernel.Matrix.CoordMatrix4x4 currentPlane -> a
    geogebra3D.euclidian3D.EuclidianView3D view3D -> a
    java.awt.Point mouseLocOld -> a
    geogebra.common.kernel.Matrix.Coords positionOld -> b
    boolean freePointJustCreated -> r
    boolean viewRotationOccured -> s
    double animatedRotSpeed -> k
    long timeOld -> a
    int xOld -> m
    geogebra3D.euclidian3D.Hits3D goodHits -> a
    java.util.ArrayList tempArrayList4 -> C
    java.util.ArrayList intersectionCurves -> D
    java.util.ArrayList selectedCS2D -> z
    java.util.ArrayList selectedPolygons3D -> E
    geogebra.common.kernel.kernelND.GeoPointND[] pyramidBasis -> a
    boolean mouseMoved -> t
    java.awt.event.MouseEvent mouseEvent -> a
    java.awt.Color intersectionCurveColorPlanarPlanar -> a
    java.util.ArrayList selectedCS1D -> A
    java.util.ArrayList selectedQuadric -> B
    geogebra.common.kernel.geos.GeoElement handledGeo -> g
    geogebra.common.kernel.Matrix.Coords startPoint3D -> c
    geogebra.common.kernel.Matrix.Coords startPoint3DxOy -> d
    double zRW -> l
    geogebra.common.kernel.Matrix.Coords translationVec3D -> e
    void setView(geogebra3D.euclidian3D.EuclidianView3D) -> a
    double[] getMinMax(double,double,double) -> a
    void setMovedGeoPoint(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getCurrentPlane() -> a
    void setCurrentPlane(geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    void movePointOnCurrentPlane(geogebra3D.kernel3D.GeoPoint3D,boolean) -> a
    void checkXYMinMax(geogebra.common.kernel.Matrix.Coords) -> a
    void setMouseInformation(geogebra3D.kernel3D.GeoPoint3D) -> a
    void moveTextAbsoluteLocation() -> n
    void movePoint(boolean) -> e
    geogebra.common.euclidian.Hits getRegionHits(geogebra.common.euclidian.Hits) -> a
    geogebra3D.kernel3D.GeoPoint3D getNewPointFree(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND getNewPoint(geogebra.common.euclidian.Hits,boolean,boolean,boolean,boolean) -> a
    void createNewPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createNewPointIntersection(geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.euclidian.Hits) -> a
    boolean spherePointRadius(geogebra.common.euclidian.Hits) -> q
    geogebra.common.kernel.geos.GeoElement[] orthogonalPlane(geogebra.common.euclidian.Hits) -> E
    boolean circleAxisPoint(geogebra.common.euclidian.Hits) -> r
    boolean circlePointRadiusDirection(geogebra.common.euclidian.Hits) -> s
    boolean planePointLine(geogebra.common.euclidian.Hits) -> t
    boolean viewInFrontOf(geogebra.common.euclidian.Hits) -> u
    boolean parallelPlane(geogebra.common.euclidian.Hits) -> v
    boolean extrusionOrConify(geogebra.common.euclidian.Hits) -> w
    boolean pyramidOrPrism(geogebra.common.euclidian.Hits) -> x
    geogebra.common.kernel.geos.GeoElement getMovedGeoPoint() -> a
    void wrapMouseReleased(geogebra.common.euclidian.event.AbstractEvent) -> k
    void processReleaseForMovedGeoPoint(geogebra.common.euclidian.event.AbstractEvent) -> b
    void processMouseMoved(geogebra.common.euclidian.event.AbstractEvent) -> c
    void mousePressed(java.awt.event.MouseEvent) -> mousePressed
    void processMouseMoved() -> v
    void initNewMode(int) -> b
    geogebra.common.euclidian.Previewable switchPreviewableForInitNewMode(int) -> a
    void clearSelections() -> i
    boolean move(geogebra.common.euclidian.Hits) -> f
    void processModeLock() -> l
    void processRightPressFor3D() -> r
    boolean processRotate3DView() -> k
    boolean processRightReleaseFor3D() -> h
    boolean switchModeForProcessMode(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> b
    void switchModeForRemovePolygons(geogebra.common.euclidian.Hits) -> a
    geogebra.common.kernel.geos.GeoElement[] switchModeForThreePoints(int) -> a
    geogebra.common.kernel.geos.GeoElement[] switchModeForCircleOrSphere2(int) -> b
    void createNewPointForModePoint(geogebra.common.euclidian.Hits,boolean) -> a
    void createNewPointForModeOther(geogebra.common.euclidian.Hits) -> b
    void switchModeForMousePressed(geogebra.common.euclidian.event.AbstractEvent) -> h
    boolean switchModeForMouseReleased(int,geogebra.common.euclidian.Hits,boolean) -> a
    geogebra.common.euclidian.Hits addPointCreatedForMouseReleased(geogebra.common.euclidian.Hits) -> b
    void showDrawingPadPopup(geogebra.common.awt.Point) -> a
    geogebra.common.kernel.geos.GeoElement[] intersect(geogebra.common.euclidian.Hits) -> g
    java.util.ArrayList getIntersectionCurves() -> b
    boolean intersectionCurve(geogebra.common.euclidian.Hits) -> y
    boolean createIntersectionCurve(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void processIntersectionCurve(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement,geogebra3D.euclidian3D.Drawable3D) -> a
    void decideIntersection(geogebra.common.euclidian.Hits) -> c
    void transformCoords() -> k
    int addSelectedCS2D(geogebra.common.euclidian.Hits,int,boolean) -> q
    int selCS2D() -> r
    geogebra.common.kernel.kernelND.GeoCoordSys2D[] getSelectedCS2D() -> a
    int selQuadric() -> s
    int addSelectedQuadric(geogebra.common.euclidian.Hits,int,boolean) -> r
    geogebra3D.kernel3D.GeoQuadric3D[] getSelectedQuadric() -> a
    geogebra.common.kernel.geos.GeoElement chooseGeo(java.util.ArrayList,boolean) -> a
    int addselectedCS2D(geogebra.common.euclidian.Hits,int,boolean) -> s
    int selCoordSys2D() -> t
    geogebra.common.kernel.kernelND.GeoCoordSys2D[] getselectedCS2D() -> b
    boolean cursor3DVisibleForCurrentMode(int) -> b
    void setHandledGeo(geogebra.common.kernel.geos.GeoElement) -> c
    boolean viewHasHitsForMouseDragged() -> j
    void mouseDragged(java.awt.event.MouseEvent) -> mouseDragged
    void updateTranslationVector() -> w
    void setStartPointLocation() -> q
    void udpateStartPoint() -> x
    void setStartPointLocationWithOrigin(double,double) -> a
    void calcRWcoords() -> j
    void moveDependent(boolean) -> s
    void moveMultipleObjects(boolean) -> t
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.euclidian.Hits) -> j
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    boolean refreshHighlighting(geogebra.common.euclidian.Hits,geogebra.common.euclidian.event.AbstractEvent) -> a
    void showPopupMenuChooseGeo(java.util.ArrayList,geogebra.common.euclidian.Hits) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D -> c.b.L:
    geogebra.gui.util.PopupMenuButton btnRotateView -> c
    geogebra.gui.util.MyToggleButton btnShowPlane -> d
    geogebra.gui.util.MyToggleButton btnViewDefault -> e
    geogebra.gui.util.MyToggleButton btnViewXY -> f
    geogebra.gui.util.MyToggleButton btnViewXZ -> g
    geogebra.gui.util.MyToggleButton btnViewYZ -> h
    geogebra.gui.util.PopupMenuButton btnViewProjection -> d
    void addGraphicsDecorationsButtons() -> d
    void addBtnPointCapture() -> e
    void addBtnRotateView() -> f
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    void processSource(java.lang.Object,java.util.ArrayList) -> a
    void createButtons() -> g
    void setLabels() -> a
    void updateGUI() -> h
    geogebra.gui.util.PopupMenuButton[] newPopupBtnList() -> a
    geogebra.gui.util.MyToggleButton[] newToggleBtnList() -> a
    geogebra.common.euclidian.EuclidianViewInterfaceCommon access$0(geogebra3D.euclidian3D.EuclidianStyleBar3D) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$1 -> c.b.M:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$2 -> c.b.N:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$3 -> c.b.O:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$4 -> c.b.P:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$5 -> c.b.Q:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$6 -> c.b.R:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianStyleBar3D$ProjectionPopup -> c.b.L$a:
    geogebra3D.euclidian3D.EuclidianStyleBar3D this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    void update(java.lang.Object[]) -> a
geogebra3D.euclidian3D.EuclidianView3D -> c.b.S:
    geogebra3D.kernel3D.Kernel3D kernel3D -> a
    geogebra.main.Application app -> a
    geogebra3D.euclidian3D.EuclidianController3D euclidianController3D -> a
    geogebra3D.euclidian3D.opengl.Renderer renderer -> a
    boolean automaticGridDistance -> f
    double automaticGridDistanceFactor -> b
    double[] gridDistances -> a
    boolean[] showAxesNumbers -> a
    java.lang.String[] axesLabels -> a
    java.lang.String[] axesUnitLabels -> b
    boolean[] piAxisUnit -> b
    double[] axesNumberingDistances -> b
    boolean[] automaticAxesNumberingDistances -> c
    int[] axesTickStyles -> a
    double[] axisCross -> c
    boolean[] positiveAxes -> d
    boolean[] drawBorderAxes -> e
    double XZero -> c
    double YZero -> d
    double ZZero -> e
    double XZeroOld -> f
    double YZeroOld -> g
    double ZZeroOld -> h
    boolean waitForUpdate -> g
    geogebra3D.euclidian3D.Drawable3DLists drawable3DLists -> a
    java.util.LinkedList drawable3DListToBeAdded -> a
    java.util.LinkedList drawable3DListToBeRemoved -> b
    java.util.TreeMap geosToBeAdded -> a
    java.util.TreeSet geosToAddToHits -> a
    java.util.TreeMap drawable3DMap -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 m -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 mInv -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 mInvTranspose -> c
    geogebra.common.kernel.Matrix.CoordMatrix4x4 undoRotationMatrix -> d
    double a -> i
    double b -> j
    double aOld -> k
    double bOld -> l
    double aNew -> m
    double bNew -> n
    geogebra3D.euclidian3D.Hits3D hits -> b
    geogebra.common.kernel.Matrix.Coords o -> a
    geogebra.common.kernel.Matrix.Coords vx -> b
    geogebra.common.kernel.Matrix.Coords vy -> c
    geogebra.common.kernel.Matrix.Coords vz -> d
    geogebra.common.kernel.Matrix.Coords vzNeg -> e
    geogebra.common.kernel.Matrix.Coords viewDirection -> f
    geogebra.common.kernel.Matrix.Coords eyePosition -> g
    geogebra3D.kernel3D.GeoPlane3D xOyPlane -> a
    geogebra.common.kernel.kernelND.GeoAxisND[] axis -> a
    geogebra3D.kernel3D.GeoClippingCube3D clippingCube -> a
    geogebra3D.euclidian3D.DrawPlane3D xOyPlaneDrawable -> a
    geogebra3D.euclidian3D.DrawAxis3D[] axisDrawable -> a
    geogebra3D.euclidian3D.DrawClippingCube3D clippingCubeDrawable -> a
    geogebra3D.euclidian3D.DrawPointDecorations pointDecorations -> a
    boolean decorationVisible -> h
    geogebra.common.euclidian.Previewable previewDrawable -> a
    geogebra3D.kernel3D.GeoPoint3D cursor3D -> a
    geogebra3D.kernel3D.GeoPoint3D cursorOnXOYPlane -> b
    geogebra3D.euclidian3D.DrawLine3D previewDrawLine3D -> a
    geogebra3D.euclidian3D.DrawConic3D previewDrawConic3D -> a
    geogebra3D.kernel3D.GeoLine3D previewLine -> a
    geogebra3D.kernel3D.GeoConic3D previewConic -> a
    geogebra.common.kernel.geos.GeoElement[] cursor3DIntersectionOf -> a
    int cursor3DType -> e
    int cursor -> f
    boolean animatedScale -> i
    double animatedScaleStart -> o
    double animatedScaleEnd -> p
    double animatedScaleTimeFactor -> q
    long animatedScaleTimeStart -> a
    double animatedScaleStartX -> r
    double animatedScaleStartY -> s
    double animatedScaleStartZ -> t
    double animatedScaleEndX -> u
    double animatedScaleEndY -> v
    double animatedScaleEndZ -> w
    boolean animatedContinueRot -> j
    double animatedRotSpeed -> x
    long animatedRotTimeStart -> b
    boolean animatedRot -> k
    boolean isFrozen -> l
    java.awt.Rectangle selectionRectangle -> a
    boolean yAxisIsUp -> m
    double scale -> y
    geogebra.common.kernel.Matrix.Coords pickPoint -> h
    geogebra.common.kernel.Matrix.Coords viewDirectionPersp -> i
    boolean useClippingCube -> n
    boolean showClippingCube -> o
    int intersectionThickness -> g
    geogebra.common.kernel.kernelND.GeoPointND intersectionPoint -> a
    boolean defaultCursorWillBeHitCursor -> p
    geogebra3D.euclidian3D.Hits3D tempArrayList -> a
    boolean viewChangedByZoom -> q
    boolean viewChangedByTranslate -> r
    boolean viewChangedByRotate -> s
    int pointCapturingMode -> h
    int projection -> i
    double projectionPerspectiveValue -> z
    boolean isAnaglyphGrayScaled -> t
    boolean isAnaglyphShutDownGreen -> u
    double eyeSepFactor -> A
    double cavAngle -> B
    double cavFactor -> C
    java.awt.Color bgColor -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> b
    geogebra.main.Application getApplication() -> a
    void start() -> ag
    void initAxisAndPlane() -> H
    java.util.ArrayList getStickyPointList() -> a
    geogebra3D.kernel3D.Kernel3D getKernel() -> a
    geogebra3D.euclidian3D.EuclidianController3D getEuclidianController() -> a
    geogebra3D.euclidian3D.opengl.Renderer getRenderer() -> a
    void add(geogebra.common.kernel.geos.GeoElement) -> a
    void addNow(geogebra.common.kernel.geos.GeoElement) -> h
    void addToDrawable3DLists(geogebra3D.euclidian3D.Drawable3D) -> a
    geogebra3D.euclidian3D.Drawable3D createDrawable(geogebra.common.kernel.geos.GeoElement) -> a
    void toSceneCoords3D(geogebra.common.kernel.Matrix.Coords) -> a
    void changeCoords(geogebra.common.kernel.Matrix.CoordMatrix,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getToSceneMatrix() -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getToSceneMatrixTranspose() -> b
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getToScreenMatrix() -> c
    geogebra.common.kernel.Matrix.CoordMatrix getRotationMatrix() -> c
    geogebra.common.kernel.Matrix.CoordMatrix getScaleMatrix() -> d
    geogebra.common.kernel.Matrix.CoordMatrix getTranslationMatrix() -> e
    void updateMatrix() -> I
    void updateEye() -> ah
    geogebra.common.kernel.Matrix.Coords getViewDirection() -> a
    geogebra.common.kernel.Matrix.Coords getEyePosition() -> b
    void setRotXYinDegrees(double,double) -> a
    void setCoordSystemFromMouseMove(int,int,int) -> a
    double getXZero() -> c
    double getYZero() -> d
    double getZZero() -> o
    void setXZero(double) -> c
    void setYZero(double) -> d
    void setZZero(double) -> e
    void setZeroFromXML(double,double,double) -> a
    double[] getXMinMax() -> d
    double[] getYMinMax() -> e
    double[] getZMinMax() -> f
    double getXscale() -> e
    double getYscale() -> f
    double getZscale() -> p
    void setScale(double) -> f
    double getScale() -> q
    void rememberOrigins() -> g
    void update() -> J
    void setWaitForUpdate() -> K
    void setMode(int) -> a
    geogebra.common.kernel.Matrix.Coords getPickPoint(int,int) -> a
    geogebra.common.kernel.Matrix.Coords getPickFromScenePoint(geogebra.common.kernel.Matrix.Coords,int,int) -> a
    void attachView() -> a
    void clearView() -> b
    void initView(boolean) -> l
    void remove(geogebra.common.kernel.geos.GeoElement) -> b
    void remove(geogebra3D.euclidian3D.Drawable3D) -> b
    void rename(geogebra.common.kernel.geos.GeoElement) -> e
    void repaintView() -> c
    void reset() -> d
    void update(geogebra.common.kernel.geos.GeoElement) -> c
    void updateVisualStyle(geogebra.common.kernel.geos.GeoElement) -> d
    void update(geogebra3D.euclidian3D.Drawable3D) -> c
    geogebra.common.euclidian.DrawableND getDrawableND(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoElement getLabelHit(geogebra.common.awt.Point) -> a
    geogebra.common.euclidian.Previewable getPreviewDrawable() -> a
    geogebra.common.awt.Rectangle getSelectionRectangle() -> a
    boolean getShowMouseCoords() -> g
    boolean getShowXaxis() -> j
    boolean getShowYaxis() -> k
    void setShowAxis(int,boolean,boolean) -> a
    void setShowAxes(boolean,boolean) -> a
    void setShowPlate(boolean) -> o
    void setShowGrid(boolean) -> p
    int getViewHeight() -> g
    int getViewWidth() -> f
    boolean hitAnimationButton(geogebra.common.euclidian.event.AbstractEvent) -> a
    void resetMode() -> j
    boolean isAnimated() -> F
    boolean isRotAnimated() -> t
    boolean isRotAnimatedContinue() -> u
    boolean isInside(geogebra.common.kernel.Matrix.Coords) -> a
    boolean useClippingCube() -> v
    void setUseClippingCube(boolean) -> q
    boolean showClippingCube() -> w
    void setShowClippingCube(boolean) -> r
    void setClippingReduction(int) -> n
    int getClippingReduction() -> u
    void setAnimatedCoordSystem(double,double,double,double,int,boolean) -> a
    void setRotContinueAnimation(long,double) -> a
    void setRotAnimation(geogebra.common.kernel.Matrix.Coords) -> b
    void setRotAnimation(double,double,boolean) -> a
    void stopRotAnimation() -> L
    void animate() -> ai
    void setHits(geogebra.common.awt.Point) -> a
    void setHits3D(java.awt.Point) -> a
    void addToHits3D(geogebra3D.euclidian3D.Drawable3D) -> d
    geogebra3D.euclidian3D.Hits3D getHits3D() -> a
    geogebra.common.euclidian.Hits getHits() -> a
    void setSelectionRectangle(geogebra.common.awt.Rectangle) -> a
    void setShowAxesRatio(boolean) -> g
    void setShowMouseCoords(boolean) -> e
    void zoom(double,double,double,int,boolean) -> a
    geogebra3D.kernel3D.GeoPoint3D getCursor3D() -> a
    void setCursor3DType(int) -> o
    int getCursor3DType() -> v
    void setIntersectionThickness(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    int getIntersectionThickness() -> w
    void setIntersectionPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND getIntersectionPoint() -> a
    geogebra.common.euclidian.Previewable createPreviewLine(java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewLine() -> b
    geogebra.common.euclidian.Previewable createPreviewConic() -> c
    geogebra.common.euclidian.Previewable createPreviewSegment(java.util.ArrayList) -> d
    geogebra.common.euclidian.Previewable createPreviewRay(java.util.ArrayList) -> e
    geogebra.common.euclidian.Previewable createPreviewVector(java.util.ArrayList) -> f
    geogebra.common.euclidian.Previewable createPreviewPolygon(java.util.ArrayList) -> g
    geogebra.common.euclidian.Previewable createPreviewPyramid(java.util.ArrayList) -> j
    geogebra.common.euclidian.Previewable createPreviewConic(int,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewSphere(java.util.ArrayList) -> k
    geogebra.common.euclidian.Previewable createPreviewExtrusion(java.util.ArrayList,java.util.ArrayList) -> c
    geogebra.common.euclidian.Previewable createPreviewConify(java.util.ArrayList,java.util.ArrayList) -> d
    void updatePreviewable() -> o
    void updateCursor3D(geogebra.common.euclidian.Hits) -> a
    void updateCursorOnXOYPlane() -> aj
    void switchMoveCursor() -> M
    boolean moveCursorIsVisible() -> G
    void updateCursor3D() -> N
    void updateMatrixForCursor3D() -> O
    void setPreview(geogebra.common.euclidian.Previewable) -> a
    void initPointDecorations() -> ak
    void updatePointDecorations(geogebra3D.kernel3D.GeoPoint3D) -> a
    void drawCursor(geogebra3D.euclidian3D.opengl.Renderer) -> a
    void drawPointAlready(int) -> r
    void setMoveCursor() -> E
    void setCursor(int) -> p
    int getCursor() -> x
    void setDefaultCursorWillBeHitCursor() -> P
    void setDragCursor() -> B
    void setDefaultCursor() -> z
    void setHitCursor() -> A
    void getXML(java.lang.StringBuilder,boolean) -> a
    void toggleAxis() -> Q
    boolean axesAreAllVisible() -> x
    void togglePlane() -> R
    void toggleGrid() -> S
    geogebra3D.kernel3D.GeoPlane3D getxOyPlane() -> a
    boolean owns(geogebra.common.kernel.geos.GeoElement) -> d
    void drawTransp(geogebra3D.euclidian3D.opengl.Renderer) -> b
    void drawHiding(geogebra3D.euclidian3D.opengl.Renderer) -> c
    void draw(geogebra3D.euclidian3D.opengl.Renderer) -> d
    void drawHidden(geogebra3D.euclidian3D.opengl.Renderer) -> e
    void drawForPicking(geogebra3D.euclidian3D.opengl.Renderer) -> f
    void drawLabel(geogebra3D.euclidian3D.opengl.Renderer) -> g
    void setWaitForUpdateOwnDrawables() -> T
    void resetOwnDrawables() -> U
    void resetAllDrawables() -> V
    void resetAllVisualStyles() -> W
    geogebra.common.kernel.Matrix.Coords getClippingVertex(int) -> a
    void viewChangedOwnDrawables() -> al
    void updateOwnDrawablesNow() -> X
    java.lang.String[] getAxesLabels() -> a
    void setAxesLabels(java.lang.String[]) -> a
    void setAxisLabel(int,java.lang.String) -> a
    java.lang.String[] getAxesUnitLabels() -> b
    void setShowAxesNumbers(boolean[]) -> c
    void setAxesUnitLabels(java.lang.String[]) -> b
    boolean[] getShowAxesNumbers() -> d
    void setShowAxisNumbers(int,boolean) -> b
    void setAxesNumberingDistance(double,int) -> b
    int[] getAxesTickStyles() -> a
    void setAxisTickStyle(int,int) -> a
    geogebra.common.euclidian.Previewable createPreviewParallelLine(java.util.ArrayList,java.util.ArrayList) -> a
    geogebra.common.euclidian.Previewable createPreviewPerpendicularLine(java.util.ArrayList,java.util.ArrayList) -> b
    geogebra.common.euclidian.Previewable createPreviewPerpendicularBisector(java.util.ArrayList) -> b
    geogebra.common.euclidian.Previewable createPreviewAngleBisector(java.util.ArrayList) -> c
    geogebra.common.euclidian.Previewable createPreviewPolyLine(java.util.ArrayList) -> i
    void setAxisCross(int,double) -> a
    void setPositiveAxis(int,boolean) -> a
    double[] getAxesCross() -> b
    void setAxesCross(double[]) -> b
    boolean[] getPositiveAxes() -> a
    void setPositiveAxes(boolean[]) -> a
    boolean getShowGrid() -> h
    boolean getGridIsBold() -> e
    boolean getAllowShowMouseCoords() -> f
    int getAxesLineStyle() -> n
    int getGridLineStyle() -> m
    boolean isAutomaticGridDistance() -> d
    double[] getGridDistances() -> a
    void setAxesColor(geogebra.common.awt.Color) -> a
    void setGridColor(geogebra.common.awt.Color) -> c
    void showGrid(boolean) -> h
    void setGridIsBold(boolean) -> i
    void setAllowShowMouseCoords(boolean) -> f
    void setGridType(int) -> e
    void setAxesLineStyle(int) -> i
    void setGridLineStyle(int) -> m
    void setAutomaticGridDistance(boolean) -> c
    void setGridDistances(double[]) -> a
    void setAutomaticAxesNumberingDistance(boolean,int) -> a
    void setAxesTickStyles(int[]) -> a
    boolean[] getDrawBorderAxes() -> b
    void setDrawBorderAxes(boolean[]) -> b
    boolean[] isAutomaticAxesNumberingDistance() -> c
    double[] getAxesNumberingDistances() -> c
    int getMode() -> d
    void setResizeXAxisCursor() -> C
    void setResizeYAxisCursor() -> D
    void setViewChangedByZoom() -> am
    void setViewChangedByTranslate() -> an
    void setViewChangedByRotate() -> ao
    void setViewChanged() -> Y
    boolean viewChangedByZoom() -> y
    boolean viewChangedByTranslate() -> z
    boolean viewChanged() -> A
    void resetViewChanged() -> Z
    int getPointCapturingMode() -> a
    void setPointCapturing(int) -> b
    java.lang.String getFromPlaneString() -> b
    java.lang.String getTranslatedFromPlaneString() -> c
    geogebra.common.euclidian.Previewable createPreviewAngle(java.util.ArrayList) -> h
    boolean isDefault2D() -> c
    boolean hasForParent(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> c
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    void setProjection(int) -> q
    int getProjection() -> y
    void setProjectionOrthographic() -> aa
    void setProjectionPerspective() -> ab
    void setProjectionPerspectiveValue(double) -> g
    void updateProjectionPerspectiveValue() -> ap
    double getProjectionPerspectiveValue() -> r
    void setAnaglyph() -> ac
    boolean isAnaglyphGrayScaled() -> B
    void setAnaglyphGrayScaled(boolean) -> s
    boolean isGrayScaled() -> C
    boolean isAnaglyphShutDownGreen() -> D
    void setAnaglyphShutDownGreen(boolean) -> t
    boolean isShutDownGreen() -> E
    void setEyeSepFactor(double) -> h
    double getEyeSepFactor() -> s
    int getViewID() -> b
    void setCav() -> ad
    void setCavAngle(double) -> i
    double getCavAngle() -> t
    void setCavFactor(double) -> j
    double getCavFactor() -> u
    boolean getShowAxis(int) -> c
    void replaceBoundObject(geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.geos.GeoNumeric) -> a
    java.awt.Color getBackground() -> a
    void setBackground(java.awt.Color) -> a
    void addOneGeoToPick() -> ae
    void removeOneGeoToPick() -> af
    java.awt.Graphics2D getGraphicsForPen() -> a
    int getFontSize() -> i
    void setBackground(geogebra.common.awt.Color) -> b
    geogebra.common.awt.Color getBackgroundCommon() -> c
    int getEuclidianViewNo() -> e
    void drawAxes(geogebra.common.awt.Graphics2D) -> j
    geogebra.euclidian.EuclidianStyleBar newEuclidianStyleBar() -> a
    void initCursor() -> n
    int print(java.awt.Graphics,java.awt.print.PageFormat,int) -> print
    void setShowAxis(boolean) -> m
    geogebra.common.kernel.Kernel getKernel() -> a
    geogebra.common.main.AbstractApplication getApplication() -> a
    geogebra.common.euclidian.AbstractEuclidianController getEuclidianController() -> a
    geogebra.euclidian.EuclidianController getEuclidianController() -> a
    geogebra.common.euclidian.DrawableND createDrawable(geogebra.common.kernel.geos.GeoElement) -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra3D.euclidian3D.Hits3D -> c.b.T:
    geogebra3D.euclidian3D.Hits3D$TreeSetOfDrawable3D[] hitSet -> a
    geogebra3D.euclidian3D.Hits3D$TreeSetOfDrawable3D hitsOthers -> a
    geogebra3D.euclidian3D.Hits3D$TreeSetOfDrawable3D hitsLabels -> b
    java.util.TreeSet hitSetSet -> a
    geogebra.common.euclidian.Hits topHits -> a
    java.util.ArrayList drawables3D -> a
    int cs2DCount -> a
    int QuadCount -> b
    geogebra3D.euclidian3D.Hits3D clone() -> a
    geogebra.common.euclidian.Hits newHits() -> b
    boolean add(geogebra.common.kernel.geos.GeoElement) -> a
    void init() -> a
    void addDrawable3D(geogebra3D.euclidian3D.Drawable3D,boolean) -> a
    void sort() -> l
    java.util.ArrayList getDrawables() -> a
    geogebra.common.euclidian.Hits getTopHits() -> c
    geogebra.common.kernel.geos.GeoElement getLabelHit() -> a
    void removePolygonsIfNotOnlyCS2D() -> m
    void removeAllPolygonsButOne() -> i
    geogebra.common.euclidian.Hits createNewHits() -> d
    geogebra.common.euclidian.Hits clone() -> a
geogebra3D.euclidian3D.Hits3D$TreeSetOfDrawable3D -> c.b.T$a:
    geogebra3D.euclidian3D.Hits3D this$0 -> a
geogebra3D.euclidian3D.TriList -> c.b.U:
    int capacity -> a
    int chunkSize -> b
    int count -> c
    int margin -> d
    java.nio.FloatBuffer vertexBuf -> a
    java.nio.FloatBuffer normalBuf -> b
    geogebra3D.euclidian3D.TriListElem front -> a
    geogebra3D.euclidian3D.TriListElem back -> b
    boolean dynamicSize -> a
    int sizeMultiplier -> e
    void expand() -> a
    int getTriAmt() -> a
    int getChunkAmt() -> b
    java.nio.FloatBuffer getTriangleBuffer() -> a
    java.nio.FloatBuffer getNormalBuffer() -> b
    void setFloats(float[],float[],int) -> a
    float[] getVertices(geogebra3D.euclidian3D.TriListElem) -> a
    void setVertices(geogebra3D.euclidian3D.TriListElem,float[]) -> a
    void setNormals(geogebra3D.euclidian3D.TriListElem,float[]) -> b
    float[] getVertices(int) -> a
    float[] getNormals(int) -> b
    geogebra3D.euclidian3D.TriListElem add(float[],float[]) -> a
    void add(geogebra3D.euclidian3D.TriListElem,float[],float[]) -> a
    void transferFloats(int,int) -> a
    boolean remove(geogebra3D.euclidian3D.TriListElem) -> a
    boolean hide(geogebra3D.euclidian3D.TriListElem) -> b
    java.util.Iterator iterator() -> iterator
    boolean show(geogebra3D.euclidian3D.TriListElem) -> c
geogebra3D.euclidian3D.TriList$1 -> c.b.V:
    geogebra3D.euclidian3D.TriListElem el -> a
    int bucket -> a
    geogebra3D.euclidian3D.TriList this$0 -> a
    boolean hasNext() -> hasNext
    geogebra3D.euclidian3D.TriListElem next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
geogebra3D.euclidian3D.TriListElem -> c.b.W:
    int index -> a
    geogebra3D.euclidian3D.TriListElem next -> a
    geogebra3D.euclidian3D.TriListElem prev -> b
    float[] vertices -> e
    float[] normals -> f
    char flags -> a
    java.lang.Object owner -> a
    void pushVertices(float[]) -> a
    void setOwner(java.lang.Object) -> a
    java.lang.Object getOwner() -> a
    void pushNormals(float[]) -> b
    float[] popVertices() -> a
    float[] popNormals() -> b
    void setIndex(int) -> a
    int getIndex() -> a
    geogebra3D.euclidian3D.TriListElem getNext() -> a
    void setNext(geogebra3D.euclidian3D.TriListElem) -> a
    geogebra3D.euclidian3D.TriListElem getPrev() -> b
    void setPrev(geogebra3D.euclidian3D.TriListElem) -> b
geogebra3D.euclidian3D.opengl.Component3D -> c.b.a.a:
geogebra3D.euclidian3D.opengl.Component3DCapabilities -> c.b.a.b:
    void initSingleton() -> a
geogebra3D.euclidian3D.opengl.Manager -> c.b.a.c:
    float colorFactor -> a
    geogebra3D.euclidian3D.opengl.PlotterCursor cursor -> a
    geogebra3D.euclidian3D.opengl.PlotterViewButtons viewButtons -> a
    geogebra3D.euclidian3D.opengl.PlotterViewInFrontOf viewInFrontOf -> a
    geogebra3D.euclidian3D.opengl.PlotterBrush brush -> a
    geogebra3D.euclidian3D.opengl.PlotterSurface surface -> a
    geogebra3D.euclidian3D.opengl.PlotterText text -> a
    geogebra3D.euclidian3D.EuclidianView3D view3D -> a
    geogebra3D.euclidian3D.opengl.Renderer renderer -> a
    geogebra.common.kernel.Matrix.Coords clockU -> a
    geogebra.common.kernel.Matrix.Coords clockV -> b
    geogebra.common.kernel.Matrix.Coords cylinderStart -> c
    geogebra.common.kernel.Matrix.Coords cylinderEnd -> d
    geogebra3D.euclidian3D.opengl.PlotterViewInFrontOf getViewInFrontOf() -> a
    geogebra3D.euclidian3D.opengl.PlotterBrush getBrush() -> a
    geogebra3D.euclidian3D.opengl.PlotterSurface getSurface() -> a
    geogebra3D.euclidian3D.opengl.PlotterText getText() -> a
    void update() -> a
    int startNewList() -> a
    void endList() -> b
    void startGeometry(int) -> a
    void endGeometry() -> c
    int startPolygon(float,float,float) -> a
    void endPolygon() -> d
    void draw(int) -> b
    void remove(int) -> c
    void vertex(float,float,float) -> a
    void vertex(geogebra.common.kernel.Matrix.Coords) -> a
    void normal(float,float,float) -> b
    void normal(geogebra.common.kernel.Matrix.Coords) -> b
    void texture(float,float) -> a
    void color(float,float,float) -> c
    void color(float,float,float,float) -> a
    void addVertexToPolygon(double,double,double) -> a
    geogebra.common.kernel.Matrix.Coords getHigthlighting(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
geogebra3D.euclidian3D.opengl.ManagerGLList -> c.b.a.d:
    javax.media.opengl.glu.GLUtessellator tesselator -> a
    int genLists(int) -> a
    int startNewList() -> a
    void newList(int) -> d
    void endList() -> b
    void startGeometry(int) -> a
    void endGeometry() -> c
    int startPolygon(float,float,float) -> a
    void endPolygon() -> d
    void remove(int) -> c
    void draw(int) -> b
    void texture(float,float) -> a
    void normal(float,float,float) -> b
    void vertex(float,float,float) -> a
    void color(float,float,float) -> c
    void color(float,float,float,float) -> a
    void addVertexToPolygon(double,double,double) -> a
geogebra3D.euclidian3D.opengl.PlotterBrush -> c.b.a.e:
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    int index -> a
    geogebra3D.euclidian3D.opengl.PlotterBrushSection start -> a
    geogebra3D.euclidian3D.opengl.PlotterBrushSection end -> b
    float thickness -> a
    int lineThickness -> b
    float scale -> b
    float length -> c
    float red -> d
    float green -> e
    float blue -> f
    float alpha -> g
    boolean hasColor -> a
    float texturePosZero -> h
    float textureValZero -> i
    float[] textureX -> a
    float[] textureY -> b
    int textureTypeX -> c
    int textureTypeY -> d
    float curvePos -> j
    int arrowType -> e
    float ARROW_LENGTH -> k
    float ARROW_WIDTH -> l
    boolean ticks -> b
    float ticksDistance -> m
    float ticksOffset -> n
    int latitude -> f
    boolean firstCurvePoint -> c
    void start(int) -> a
    int end() -> a
    void down(geogebra.common.kernel.Matrix.Coords) -> a
    void down(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void moveTo(geogebra.common.kernel.Matrix.Coords) -> b
    void moveTo(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> b
    void join() -> a
    void draw(geogebra3D.euclidian3D.opengl.PlotterBrushSection,double,double,int) -> a
    void segment(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    void circle(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    void arc(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    void arcEllipse(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double,double) -> a
    void quarterHyperbola(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> b
    void parabola(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> c
    void parabola(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double) -> a
    void draw(geogebra3D.euclidian3D.plots.CurveMesh) -> a
    float setThickness(int,float) -> a
    void setThickness(float) -> a
    void setColor(java.awt.Color,float) -> a
    void setColor(java.awt.Color) -> a
    void setCurvePos(float) -> b
    void addCurvePos(float) -> c
    void setAffineTexture(float,float) -> a
    void setPlainTexture() -> b
    void setTextureType(int) -> c
    float getTexture(float,int) -> a
    void setTextureX(float,float) -> b
    void setTextureX(float) -> f
    void setTextureY(float) -> g
    void setArrowType(int) -> b
    void setTicks(boolean) -> a
    void setTicksDistance(float) -> d
    void setTicksOffset(float) -> e
    boolean hasTicks() -> a
geogebra3D.euclidian3D.opengl.PlotterBrushSection -> c.b.a.f:
    geogebra.common.kernel.Matrix.Coords center -> a
    geogebra.common.kernel.Matrix.Coords clockU -> b
    geogebra.common.kernel.Matrix.Coords clockV -> c
    geogebra.common.kernel.Matrix.Coords direction -> d
    geogebra.common.kernel.Matrix.Coords normal -> e
    double normalDevD -> a
    double normalDevN -> b
    float thickness -> a
    geogebra.common.kernel.Matrix.Coords[] getNormalAndPosition(double,double) -> a
    geogebra.common.kernel.Matrix.Coords getCenter() -> a
geogebra3D.euclidian3D.opengl.PlotterCursor -> c.b.a.g:
    int TYPE_CROSS2D -> a
    int TYPE_DIAMOND -> b
    int TYPE_CYLINDER -> c
    int TYPE_CROSS3D -> d
    int TYPE_ALREADY_XY -> e
    int TYPE_ALREADY_Z -> f
    int TYPE_CUBE -> g
    int TYPE_LENGTH -> h
    float size -> a
    float thickness -> b
    float thickness2 -> c
    float depth -> d
    float size_start_move -> e
    float size_move -> f
    float thickness3 -> g
    float size_cube -> h
    int[] index -> a
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    boolean isTypeAlready(int) -> a
    int getIndex(int) -> a
    void cursor(int) -> a
    void cursorCross2D() -> a
    void cursorCross3D() -> b
    void cursorDiamond() -> c
    void cursorCylinder() -> d
    void quadSymxOyRotOz90SymOz(float,float,float,float,float,float,float,float,float,float,float,float) -> a
    void quadRotOz90SymOz(float,float,float,float,float,float,float,float,float,float,float,float) -> b
    void quadSymOz(float,float,float,float,float,float,float,float,float,float,float,float) -> c
geogebra3D.euclidian3D.opengl.PlotterSurface -> c.b.a.h:
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    int index -> a
    geogebra.common.kernel.arithmetic.Functional2Var functional2Var -> a
    geogebra.common.kernel.geos.GeoFunctionNVar function -> a
    float uMin -> a
    float uMax -> b
    float vMin -> c
    float vMax -> d
    int uNb -> b
    int vNb -> c
    float du -> e
    float dv -> f
    float uMinFade -> g
    float uMaxFade -> h
    float vMinFade -> i
    float vMaxFade -> j
    float uMinFadeNb -> k
    float uMaxFadeNb -> l
    float vMinFadeNb -> m
    float vMaxFadeNb -> n
    void start() -> a
    void start(geogebra.common.kernel.arithmetic.Functional2Var) -> a
    void start(geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    int end() -> a
    void setU(float,float) -> a
    void setV(float,float) -> b
    void setNbU(int) -> a
    void setNbV(int) -> b
    void setUFading(float,float) -> c
    void setVFading(float,float) -> d
    void draw() -> b
    void drawSphere(int,geogebra.common.kernel.Matrix.Coords,double) -> a
    geogebra.common.kernel.Matrix.Coords sphericalCoords(int,int,int,int) -> a
    void draw(geogebra3D.euclidian3D.plots.SurfaceMesh2) -> a
    void draw(geogebra3D.euclidian3D.plots.MarchingCubes,geogebra3D.euclidian3D.opengl.Renderer) -> a
    void parallelogram(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double) -> a
    void ellipsePart(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double,double) -> a
    void drawQuad(int,int) -> a
    void drawTNV(int,int) -> b
    void drawNV(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    float getTextureCoord(int,int,float,float) -> a
geogebra3D.euclidian3D.opengl.PlotterText -> c.b.a.i:
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    void rectangle(int,int,int,int,int) -> a
geogebra3D.euclidian3D.opengl.PlotterViewButtons -> c.b.a.j:
    float size -> d
    float shift -> e
    float shift2 -> f
    float transparency -> g
    float SHIFT -> a
    float HEIGHT -> b
    float WIDTH -> c
    float handleSize -> h
    float thickness -> i
    float handleSizeStart -> j
    int[] index -> a
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    void button(int) -> a
geogebra3D.euclidian3D.opengl.PlotterViewInFrontOf -> c.b.a.k:
    float start -> a
    float end -> b
    int[] index -> a
    geogebra3D.euclidian3D.opengl.Manager manager -> a
    int getIndex() -> a
geogebra3D.euclidian3D.opengl.Renderer -> c.b.a.l:
    javax.media.opengl.glu.GLU glu -> a
    geogebra3D.euclidian3D.opengl.Component3D canvas -> a
    javax.media.opengl.GL gl -> a
    javax.media.opengl.glu.GLUquadric quadric -> a
    com.sun.opengl.util.FPSAnimator animator -> a
    geogebra3D.euclidian3D.Drawable3D[] drawHits -> a
    int pickingLoop -> a
    geogebra3D.euclidian3D.Drawable3DLists drawable3DLists -> a
    geogebra3D.euclidian3D.EuclidianView3D view3D -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 m_drawingMatrix -> a
    geogebra3D.euclidian3D.opengl.Manager geometryManager -> a
    geogebra3D.euclidian3D.opengl.Textures textures -> a
    int m_arrowType -> i
    int dilation -> j
    double[] dilationValues -> a
    int mouseX -> k
    int mouseY -> l
    boolean waitForPick -> a
    boolean doPick -> b
    int pickingMode -> m
    int[] GL_CLIP_PLANE -> a
    boolean enableClipPlanes -> c
    boolean waitForUpdateClipPlanes -> d
    boolean needExportImage -> e
    java.awt.image.BufferedImage bi -> a
    int oldGeoToPickSize -> n
    int geoToPickSize -> o
    java.nio.IntBuffer selectBuffer -> a
    boolean needsNewPickingBuffer -> f
    int light -> p
    float[] light0Position -> a
    boolean waitForUpdateClearColor -> g
    int left -> b
    int right -> c
    int bottom -> d
    int top -> e
    int front -> f
    int back -> g
    int frontExtended -> h
    double near -> a
    double perspLeft -> b
    double perspRight -> c
    double perspBottom -> d
    double perspTop -> e
    double perspFar -> f
    double perspNear -> g
    double perspDistratio -> h
    double perspFocus -> i
    geogebra.common.kernel.Matrix.Coords perspEye -> a
    double anaglyphEyeSep -> j
    double anaglyphEyeSep1 -> k
    int eye -> q
    double cavX -> l
    double cavY -> m
    geogebra.common.kernel.Matrix.Coords cavOrthoDirection -> b
    javax.media.opengl.GL getGL(javax.media.opengl.GLAutoDrawable) -> a
    void setDrawable3DLists(geogebra3D.euclidian3D.Drawable3DLists) -> a
    void display() -> a
    void setCulling(boolean) -> a
    void setBlending(boolean) -> b
    void drawTransp() -> q
    void drawNotTransp() -> r
    void display(javax.media.opengl.GLAutoDrawable) -> display
    void drawFaceToScreen() -> s
    void setEnableClipPlanes(boolean) -> c
    void enableClipPlane(int) -> c
    void disableClipPlane(int) -> d
    void enableClipPlanes() -> t
    void enableClipPlanesIfNeeded() -> b
    void disableClipPlanes() -> u
    void disableClipPlanesIfNeeded() -> c
    void setClipPlane(int,double[]) -> a
    void draw() -> v
    void needExportImage() -> d
    void setExportImage() -> w
    java.awt.image.BufferedImage getExportImage() -> a
    void reshape(javax.media.opengl.GLAutoDrawable,int,int,int,int) -> reshape
    void displayChanged(javax.media.opengl.GLAutoDrawable,boolean,boolean) -> displayChanged
    void setColor(geogebra.common.kernel.Matrix.Coords) -> a
    void setLayer(float) -> a
    void setMatrix(geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    void initMatrix() -> e
    void initMatrix(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    void initMatrix(double[]) -> a
    void resetMatrix() -> f
    geogebra3D.euclidian3D.opengl.Manager getGeometryManager() -> a
    geogebra3D.euclidian3D.opengl.Textures getTextures() -> a
    void drawCursor(int) -> a
    void drawViewInFrontOf() -> g
    int startPolygon(float,float,float) -> a
    void addToPolygon(double,double,double) -> a
    void endPolygon() -> h
    void drawPolygon(int) -> b
    void setMouseLoc(int,int,int) -> a
    void addOneGeoToPick() -> i
    void removeOneGeoToPick() -> j
    java.nio.IntBuffer newIntBuffer(int) -> a
    java.nio.ByteBuffer newByteBuffer(int) -> a
    java.nio.IntBuffer createSelectBufferForPicking(int) -> b
    geogebra3D.euclidian3D.Drawable3D[] createDrawableListForPicking(int) -> a
    void setGLForPicking() -> x
    void pushSceneMatrix() -> y
    void storePickingInfos(geogebra3D.euclidian3D.Hits3D,int) -> a
    void doPick() -> k
    void pickIntersectionCurves() -> l
    void pick(geogebra3D.euclidian3D.Drawable3D) -> a
    void pick(geogebra3D.euclidian3D.Drawable3D,boolean) -> a
    void pickLabel(geogebra3D.euclidian3D.Drawable3D) -> b
    float getDepth(int,java.nio.IntBuffer) -> a
    void enableLight(int) -> e
    void setLightPosition() -> z
    void setWaitForUpdateClearColor() -> m
    void updateClearColor() -> A
    void init(javax.media.opengl.GLAutoDrawable) -> init
    int getLeft() -> a
    int getRight() -> b
    int getBottom() -> c
    int getTop() -> d
    float getFront(boolean) -> a
    float getBack(boolean) -> b
    double[] getIntervalInFrustum(double[],geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    double[] updateIntervalInFrustum(double[],double,double) -> a
    void setView() -> B
    void setProjectionMatrix() -> C
    void updateOrthoValues() -> n
    void viewOrtho() -> D
    void setNear(double) -> a
    void updatePerspValues() -> E
    geogebra.common.kernel.Matrix.Coords getPerspEye() -> a
    void viewPersp() -> F
    void updateAnaglyphValues() -> o
    void viewAnaglyph() -> G
    void setColorMask() -> H
    void updateCavValues() -> p
    void viewCav() -> I
    geogebra.common.kernel.Matrix.Coords getCavOrthoDirection() -> b
    void setView(int,int,int,int) -> a
geogebra3D.euclidian3D.opengl.RendererTesselCallBack -> c.b.a.m:
    geogebra3D.euclidian3D.opengl.Renderer renderer -> a
    void begin(int) -> begin
    void end() -> end
    void vertex(java.lang.Object) -> vertex
    void vertexData(java.lang.Object,java.lang.Object) -> vertexData
    void combine(double[],java.lang.Object[],float[],java.lang.Object[]) -> combine
    void combineData(double[],java.lang.Object[],float[],java.lang.Object[],java.lang.Object) -> combineData
    void error(int) -> error
    void beginData(int,java.lang.Object) -> beginData
    void endData(java.lang.Object) -> endData
    void edgeFlag(boolean) -> edgeFlag
    void edgeFlagData(boolean,java.lang.Object) -> edgeFlagData
    void errorData(int,java.lang.Object) -> errorData
geogebra3D.euclidian3D.opengl.Textures -> c.b.a.n:
    javax.media.opengl.GL gl -> a
    geogebra.util.ImageManager imageManager -> a
    int[] texturesIndex -> a
    int DASH_NONE -> a
    int DASH_SHORT -> b
    int DASH_LONG -> c
    int DASH_DOTTED -> d
    int DASH_DOTTED_DASHED -> e
    int DASH_NONE_HIDDEN -> f
    int DASH_SHORT_HIDDEN -> g
    int DASH_LONG_HIDDEN -> h
    int DASH_DOTTED_HIDDEN -> i
    int DASH_DOTTED_DASHED_HIDDEN -> j
    int DASH_NUMBER -> p
    boolean[][] DASH_DESCRIPTION -> a
    int FADING -> k
    int BUTTON_OK -> l
    int BUTTON_OK_PICKED -> m
    int BUTTON_CANCEL -> n
    int BUTTON_CANCEL_PICKED -> o
    int TEXTURES_NUMBER -> q
    void init(javax.media.opengl.GL) -> a
    void loadTextureNearest(int) -> a
    void loadTextureLinear(int) -> b
    void setTextureNearest(int) -> c
    void setTextureLinear(int) -> d
    void initDashTexture(int,boolean[]) -> a
    void setDashFromLineType(int) -> e
    void setDashFromLineTypeHidden(int) -> f
    void initFadingTexture(int) -> h
    void initViewButtonsTextures(int,java.lang.String) -> a
    java.awt.image.BufferedImage readImage(java.lang.String) -> a
    void setTextureLinear() -> a
    void setTextureNearest() -> b
    void removeTexture(int) -> g
    int createAlphaTexture(int,int,java.nio.ByteBuffer) -> a
geogebra3D.euclidian3D.plots.CullInfo2 -> c.b.b.a:
    geogebra3D.euclidian3D.plots.CullInfo2 ALLIN -> a
    geogebra3D.euclidian3D.plots.CullInfo2 SOMEIN -> b
    geogebra3D.euclidian3D.plots.CullInfo2 OUT -> c
    geogebra3D.euclidian3D.plots.CullInfo2[] ENUM$VALUES -> a
    geogebra3D.euclidian3D.plots.CullInfo2[] values() -> values
    geogebra3D.euclidian3D.plots.CullInfo2 valueOf(java.lang.String) -> valueOf
geogebra3D.euclidian3D.plots.CurveMesh -> c.b.b.b:
    double deltaParam -> a
    double invDeltaParam -> b
    double maxErrorCoeff -> d
    double levelOfDetail -> c
    double desiredMaxError -> e
    geogebra3D.euclidian3D.plots.CurveSegment root -> a
    geogebra3D.kernel3D.GeoCurveCartesian3D curve -> a
    java.util.HashMap precalcVertices -> a
    void initCurve() -> c
    void split(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    void merge(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    void setCullingBox(double[]) -> a
    void setLevelOfDetail(double) -> a
    void updateCullingInfo() -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side tooCoarse() -> a
    int getVisibleChunks() -> a
    int getVerticesPerChunk() -> b
    void updateScale(float) -> a
    void updateParameters() -> b
geogebra3D.euclidian3D.plots.CurveMeshTriList -> c.b.b.c:
    int currentVersion -> a
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean hide(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    boolean show(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> c
    void reinsert(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    geogebra3D.euclidian3D.TriListElem add(geogebra3D.euclidian3D.plots.CurveSegment,boolean) -> a
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> b
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    void recalculate(int) -> a
geogebra3D.euclidian3D.plots.CurveSegment -> c.b.b.d:
    double error -> a
    double length -> b
    double param -> c
    geogebra.common.kernel.Matrix.Coords vertex -> a
    geogebra.common.kernel.Matrix.Coords alt -> b
    geogebra.common.kernel.Matrix.Coords altDer -> c
    double altParam -> d
    geogebra.common.kernel.Matrix.Coords deriv -> d
    geogebra3D.euclidian3D.TriListElem triListElem -> a
    geogebra3D.euclidian3D.plots.CurveSegment nextInList -> a
    geogebra3D.euclidian3D.plots.CurveSegment prevInList -> b
    double warpedDiscontThreshold -> e
    void init() -> d
    geogebra.common.kernel.Matrix.Coords calcMainVertex(double) -> a
    geogebra.common.kernel.Matrix.Coords calcVertex(double) -> b
    geogebra.common.kernel.Matrix.Coords getVertex(int) -> a
    geogebra.common.kernel.Matrix.Coords getDerivative(int) -> b
    double getParam(int) -> a
    void setBoundingBox() -> e
    void generateError() -> f
    geogebra.common.kernel.Matrix.Coords approxDeriv(double,geogebra.common.kernel.Matrix.Coords) -> a
    void setHidden(boolean) -> a
    void reinsertInQueue() -> a
    void cullChildren() -> b
    void createChild(int) -> a
    double getError() -> a
    boolean recalculate(int,boolean) -> a
geogebra3D.euclidian3D.plots.CurveSplitBucketAssigner -> c.b.b.e:
    int getBucketIndex(java.lang.Object,int) -> a
geogebra3D.euclidian3D.plots.DynamicMesh2 -> c.b.b.f:
    geogebra3D.euclidian3D.plots.FastBucketPQ mergeQueue -> a
    geogebra3D.euclidian3D.plots.FastBucketPQ splitQueue -> b
    double[] cullingBox -> a
    geogebra3D.euclidian3D.plots.DynamicMeshTriList2 drawList -> a
    int stepRefinement -> d
    int nChildren -> a
    int nParents -> b
    int currentVersion -> c
    boolean noUpdate -> a
    boolean optimize() -> a
    void setCullingBox(double[]) -> a
    java.nio.FloatBuffer getVertices() -> a
    java.nio.FloatBuffer getNormals() -> b
    int getTriangleCount() -> c
    boolean optimizeSub(int) -> a
    void updateCullingInfo() -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side tooCoarse() -> a
    void merge(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    void split(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    void updateParameters() -> b
geogebra3D.euclidian3D.plots.DynamicMesh2$Side -> c.b.b.f$a:
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side MERGE -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side SPLIT -> b
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side NONE -> c
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side[] ENUM$VALUES -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side[] values() -> values
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side valueOf(java.lang.String) -> valueOf
geogebra3D.euclidian3D.plots.DynamicMeshElement2 -> c.b.b.g:
    boolean isSplit -> d
    geogebra3D.euclidian3D.plots.DynamicMeshElement2[] children -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2[] parents -> b
    int level -> a
    boolean ignoreFlag -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2 mesh -> a
    boolean isSingular -> b
    double[] boundingBox -> a
    geogebra3D.euclidian3D.plots.CullInfo2 cullInfo -> a
    int lastVersion -> b
    boolean updateInDrawList -> c
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 bucket_prev -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 bucket_next -> b
    int bucket_index -> c
    geogebra3D.euclidian3D.plots.FastBucketPQ bucket_owner -> a
    int getLevel() -> a
    boolean isSplit() -> a
    void setSplit(boolean) -> b
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 getChild(int) -> a
    void createChild(int) -> a
    double getError() -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 getParent(int) -> b
    void updateCullInfo() -> c
    geogebra3D.euclidian3D.plots.CullInfo2 getCullInfo() -> a
    boolean ignoreCull() -> b
    boolean isSingular() -> c
    void setHidden(boolean) -> a
    void reinsertInQueue() -> a
    void cullChildren() -> b
    boolean childrenSplit() -> d
    boolean readyForMerge(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean recalculate(int,boolean) -> a
geogebra3D.euclidian3D.plots.DynamicMeshTriList2 -> c.b.b.h:
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> b
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    boolean hide(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    boolean show(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> c
    void recalculate(int) -> a
    void reinsert(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    java.nio.FloatBuffer getTriangleBuffer() -> a
    java.nio.FloatBuffer getNormalBuffer() -> b
    int getTriAmt() -> a
geogebra3D.euclidian3D.plots.FastBucketPQ -> c.b.b.i:
    geogebra3D.euclidian3D.plots.DynamicMeshElement2[] buckets -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2[] backs -> b
    geogebra3D.euclidian3D.BucketAssigner bucketAssigner -> a
    int bucketAmt -> a
    int count -> b
    int maxBucket -> c
    boolean reverse -> a
    int getIndex(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean addToZeroBucket(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> c
    boolean add(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 peek() -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 poll() -> b
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 forcePoll() -> c
    void recalculate(int,geogebra3D.euclidian3D.plots.DynamicMeshTriList2) -> a
geogebra3D.euclidian3D.plots.MCAssigner -> c.b.b.j:
    int getBucketIndex(java.lang.Object,int) -> a
geogebra3D.euclidian3D.plots.MCElement -> c.b.b.k:
    double[][] cornerParams -> a
    int signs -> a
    double[] cornerVals -> a
    double[][] edges -> b
    double[][] cz -> c
geogebra3D.euclidian3D.plots.MCROAM -> c.b.b.l:
    geogebra3D.euclidian3D.plots.MCTriList triList -> a
    geogebra3D.euclidian3D.plots.FastBucketPQ pSplit -> a
    int cntr -> a
    boolean refine() -> a
    void split(geogebra3D.euclidian3D.plots.MCTriangle,geogebra3D.euclidian3D.plots.MCTriangle,geogebra3D.euclidian3D.plots.MCTriangle,geogebra3D.euclidian3D.plots.MCTriangle) -> a
    void link(geogebra3D.euclidian3D.plots.MCTriangle,geogebra3D.euclidian3D.plots.MCTriangle) -> a
    boolean tooCoarse() -> b
geogebra3D.euclidian3D.plots.MCTriList -> c.b.b.m:
    geogebra.common.kernel.geos.GeoFunctionNVar f -> a
    double delta -> a
    void gen(geogebra3D.euclidian3D.plots.MCElement,java.util.List) -> a
    void calcNormals(float[],float[]) -> a
    void calcNormal(float[],float[],int) -> b
    double[][][] getTriangles(geogebra3D.euclidian3D.plots.MCElement) -> a
    void add(geogebra3D.euclidian3D.plots.MCTriangle) -> a
    void remove(geogebra3D.euclidian3D.plots.MCTriangle) -> b
geogebra3D.euclidian3D.plots.MCTriangle -> c.b.b.n:
    geogebra3D.euclidian3D.plots.MCTriangle[] neighbors -> a
    geogebra.common.kernel.Matrix.Coords[] corners -> a
    geogebra.common.kernel.Matrix.Coords midpoint -> a
    geogebra.common.kernel.geos.GeoFunctionNVar func -> a
    double error -> a
    geogebra3D.euclidian3D.TriListElem triListElem -> a
    void calcError() -> e
    void resort() -> d
    void addNeighbor(geogebra3D.euclidian3D.plots.MCTriangle) -> a
    void setNeighbors(java.util.List) -> a
    void createChild(int) -> a
    double getError() -> a
    void setHidden(boolean) -> a
    void reinsertInQueue() -> a
    void cullChildren() -> b
    boolean recalculate(int,boolean) -> a
    void switchNeighbor(geogebra3D.euclidian3D.plots.MCTriangle,geogebra3D.euclidian3D.plots.MCTriangle) -> a
geogebra3D.euclidian3D.plots.MarchingCubes -> c.b.b.o:
    int INITIAL_ELEMENTS -> a
    int REFINEMENTS -> b
    int C0 -> c
    int C1 -> d
    int C2 -> e
    int C3 -> f
    int C4 -> g
    int C5 -> h
    int C6 -> i
    int C7 -> j
    java.util.LinkedList elems -> a
    java.util.LinkedList allelems -> b
    geogebra.common.kernel.geos.GeoFunctionNVar f -> a
    geogebra3D.euclidian3D.plots.MCTriList drawList -> a
    double rad -> a
    geogebra3D.euclidian3D.plots.MCROAM mcRoam -> a
    java.util.LinkedList tris -> c
    boolean update() -> a
    geogebra.common.kernel.Matrix.Coords project(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.geos.GeoFunctionNVar) -> a
    void render() -> a
    void octreeRefine() -> b
    void init() -> c
    int getVisibleChunks() -> a
    java.nio.FloatBuffer getVertices() -> a
    java.nio.FloatBuffer getNormals() -> b
geogebra3D.euclidian3D.plots.SurfaceDiamond2 -> c.b.b.p:
    double[] errors -> b
    double area -> a
    geogebra3D.euclidian3D.TriListElem[] triangles -> a
    double[] params -> c
    geogebra.common.kernel.Matrix.Coords vertex -> a
    geogebra.common.kernel.Matrix.Coords normal -> c
    geogebra.common.kernel.Matrix.Coords alt -> b
    double[] ancestorDiff -> d
    double[] originalParams -> e
    geogebra3D.euclidian3D.plots.SurfaceDiamond2[] ancestors -> a
    int[] indices -> a
    void init() -> g
    geogebra.common.kernel.Matrix.Coords approxNormal(double,double) -> a
    void calcMainVertex(double,double) -> a
    geogebra.common.kernel.Matrix.Coords calcVertex(double,double) -> b
    boolean childCreated(int) -> a
    void createChild(int) -> a
    void cullChildren() -> b
    void freeTriangle(int) -> b
    void generateError() -> d
    double getError() -> a
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
    geogebra3D.euclidian3D.plots.DynamicMeshElement2 getOtherParent(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    geogebra3D.euclidian3D.TriListElem getTriangle(int) -> a
    geogebra.common.kernel.Matrix.Coords getVertex(geogebra3D.euclidian3D.plots.SurfaceDiamond2) -> a
    boolean readyForMerge(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean recalculate(int,boolean) -> a
    void reinsertInQueue() -> a
    void setArea() -> e
    void setBoundingBox() -> f
    void setChild(int,geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    void setHidden(boolean) -> a
    void setTriangle(int,geogebra3D.euclidian3D.TriListElem) -> a
geogebra3D.euclidian3D.plots.SurfaceMesh2 -> c.b.b.q:
    double maxErrorCoeff -> b
    double levelOfDetail -> a
    geogebra.common.kernel.kernelND.SurfaceEvaluable function -> a
    geogebra3D.euclidian3D.plots.SurfaceDiamond2 root -> a
    double desiredMaxError -> c
    geogebra.common.kernel.kernelND.SurfaceEvaluable getFunction() -> a
    void initMesh(double,double,double,double) -> a
    void setCullingBox(double[]) -> a
    void setLevelOfDetail(double) -> a
    geogebra3D.euclidian3D.plots.DynamicMesh2$Side tooCoarse() -> a
    void updateCullingInfo() -> a
geogebra3D.euclidian3D.plots.SurfaceSplitBucketAssigner2 -> c.b.b.r:
    int getBucketIndex(java.lang.Object,int) -> a
geogebra3D.euclidian3D.plots.SurfaceTriList2 -> c.b.b.s:
    int currentVersion -> a
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    void add(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> b
    char getFlags(float[],float[]) -> a
    void calcFloats(geogebra3D.euclidian3D.plots.SurfaceDiamond2,int,float[],float[]) -> a
    boolean hide(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> b
    boolean hide(geogebra3D.euclidian3D.plots.SurfaceDiamond2,int) -> a
    boolean show(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> c
    boolean show(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> b
    void reinsert(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2) -> a
    boolean remove(geogebra3D.euclidian3D.plots.DynamicMeshElement2,int) -> a
    void recalculate(int) -> a
geogebra3D.euclidianFor3D.DrawAngleFor3D -> c.c.a:
    boolean inView(geogebra.common.kernel.Matrix.Coords) -> a
    double getRawAngle() -> a
geogebra3D.euclidianFor3D.EuclidianControllerFor3D -> c.c.b:
    geogebra.common.kernel.geos.GeoAngle createAngle(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] translate(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Path) -> a
    boolean attach(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.Region) -> a
    boolean detach(geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPointFrom2D(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.kernelND.GeoPointND getSingleIntersectionPoint(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.euclidianFor3D.EuclidianViewFor3D -> c.c.c:
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.euclidian.DrawableND newDrawable(geogebra.common.kernel.geos.GeoElement) -> f
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra3D.euclidianForPlane.EuclidianControllerForPlane -> c.d.a:
    geogebra.common.kernel.Matrix.Coords getCoordsFromView(double,double) -> a
    void movePoint(boolean) -> e
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Path,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint(boolean,geogebra.common.kernel.Region,boolean) -> a
    geogebra.common.kernel.geos.GeoElement[] createCircle2(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] orthogonal(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    void processModeLock(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void processModeLock(geogebra.common.kernel.Path) -> a
    java.util.ArrayList removeParentsOfView(java.util.ArrayList) -> a
geogebra3D.euclidianForPlane.EuclidianViewForPlane -> c.d.b:
    geogebra.common.kernel.kernelND.GeoCoordSys2D plane -> a
    int id -> e
    geogebra.common.kernel.Matrix.CoordMatrix4x4 planeMatrix -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 transformedMatrix -> b
    geogebra.common.kernel.Matrix.CoordMatrix inverseTransformedMatrix -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 transform -> c
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    boolean isDefault2D() -> c
    void updateForPlane() -> l
    boolean isVisibleInThisView(geogebra.common.kernel.geos.GeoElement) -> a
    void attachView() -> a
    void addExistingGeos() -> H
    geogebra.common.kernel.Matrix.Coords getCoordsForView(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsFromView(geogebra.common.kernel.Matrix.Coords) -> b
    geogebra.common.kernel.Matrix.CoordMatrix getMatrix() -> a
    geogebra.common.kernel.Matrix.CoordMatrix getInverseMatrix() -> b
    void updateMatrix() -> I
    void setTransform(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.awt.AffineTransform getTransform(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords[]) -> a
    java.lang.String getFromPlaneString() -> b
    java.lang.String getTranslatedFromPlaneString() -> c
    geogebra.common.kernel.kernelND.GeoPlaneND getPlaneContaining() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND getDirection() -> a
    boolean hasForParent(geogebra.common.kernel.geos.GeoElement) -> b
    boolean isMoveable(geogebra.common.kernel.geos.GeoElement) -> c
    java.util.ArrayList getFreeInputPoints(geogebra.common.kernel.algos.AlgoElement) -> a
    void setId(int) -> n
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> b
geogebra3D.gui.ContextMenuChooseGeo -> c.e.a:
    geogebra.common.euclidian.AbstractEuclidianView view -> a
    java.util.TreeSet metas -> a
    int index -> a
    javax.swing.JMenu moreMenu -> a
    void setChooseGeoTitle(java.lang.String) -> b
    void addGeo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.gui.ContextMenuChooseGeo$1 -> c.e.b:
    geogebra3D.gui.ContextMenuChooseGeo this$0 -> a
    void mouseClicked(java.awt.event.MouseEvent) -> mouseClicked
geogebra3D.gui.ContextMenuChooseGeo$GeoAction -> c.e.a$a:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra3D.gui.ContextMenuChooseGeo this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra3D.gui.ContextMenuChooseGeo$MyMouseAdapter -> c.e.a$b:
    geogebra.common.kernel.geos.GeoElement geo -> a
    geogebra3D.gui.ContextMenuChooseGeo this$0 -> a
    void mouseEntered(java.awt.event.MouseEvent) -> mouseEntered
geogebra3D.gui.ContextMenuGraphicsWindow3D -> c.e.c:
    void addAxesAndGridCheckBoxes() -> b
    void showOptionsDialog() -> c
geogebra3D.gui.GuiManager3D -> c.e.d:
    javax.swing.AbstractAction showAxes3DAction -> a
    javax.swing.AbstractAction showGrid3DAction -> b
    javax.swing.AbstractAction showPlaneAction -> c
    void initialize() -> i
    void initLayoutPanels() -> k
    boolean initActions() -> n
    javax.swing.AbstractAction getShowAxes3DAction() -> e
    javax.swing.AbstractAction getShowGrid3DAction() -> f
    javax.swing.AbstractAction getShowPlaneAction() -> g
    void showDrawingPadPopup3D(geogebra.common.euclidian.EuclidianViewInterfaceCommon,geogebra.common.awt.Point) -> b
    void showPopupChooseGeo(java.util.ArrayList,java.util.ArrayList,geogebra.euclidianND.EuclidianViewND,geogebra.common.awt.Point) -> a
    geogebra.gui.view.algebra.AlgebraView newAlgebraView(geogebra.gui.view.algebra.AlgebraController) -> a
    geogebra.euclidian.EuclidianView newEuclidianView(boolean[],boolean,int) -> a
geogebra3D.gui.GuiManager3D$1 -> c.e.e:
    geogebra3D.gui.GuiManager3D this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra3D.gui.GuiManager3D$2 -> c.e.f:
    geogebra3D.gui.GuiManager3D this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra3D.gui.GuiManager3D$3 -> c.e.g:
    geogebra3D.gui.GuiManager3D this$0 -> a
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra3D.gui.OptionsDialog3D -> c.e.h:
    geogebra3D.gui.OptionsEuclidian3D euclidianPanel3D -> a
    void createTabs() -> d
    void addTabs() -> e
    void setLabels() -> a
geogebra3D.gui.OptionsDialog3D$Factory -> c.e.h$a:
    geogebra.gui.dialog.options.OptionsDialog create(geogebra.main.Application) -> a
geogebra3D.gui.OptionsEuclidian3D -> c.e.i:
    geogebra3D.gui.OptionsEuclidian3D$AxisPanel3D zAxisPanel -> a
    javax.swing.JCheckBox cbUseClipping -> f
    javax.swing.JCheckBox cbShowClipping -> g
    javax.swing.JRadioButton radioClippingSmall -> a
    javax.swing.JRadioButton radioClippingMedium -> b
    javax.swing.JRadioButton radioClippingLarge -> c
    javax.swing.JLabel[] projectionLabel -> a
    javax.swing.JTextField tfPersp -> e
    javax.swing.JTextField tfAnaglyph -> f
    javax.swing.JTextField tfCavAngle -> g
    javax.swing.JTextField tfCavFactor -> h
    javax.swing.JLabel tfPerspLabel -> a
    javax.swing.JLabel tfAnaglyphLabel -> b
    javax.swing.JLabel tfCavAngleLabel -> c
    javax.swing.JLabel tfCavFactorLabel -> d
    geogebra3D.gui.OptionsEuclidian3D$ProjectionButtons projectionButtons -> a
    javax.swing.JCheckBox cbAnaglyphGray -> h
    javax.swing.JLabel cbAnaglyphGrayLabel -> e
    javax.swing.JCheckBox cbAnaglyphShutDownGreen -> i
    javax.swing.JLabel cbAnaglyphShutDownGreenLabel -> f
    javax.swing.JPanel buildBasicNorthPanel() -> a
    void enableStuff(boolean) -> a
    void setViewFromIndex(int) -> a
    void updateGUI() -> j
    void setLabelsForCbView() -> l
    void createCbView() -> c
    void addCbView() -> d
    void updateGUIforCbView() -> i
    void setCbViewSelectedIndex() -> h
    void initAxisPanels() -> b
    void addTabs() -> e
    void addAxisTabs() -> f
    javax.swing.JPanel buildProjectionPanel() -> b
    void setTabLabels() -> k
    void setLabels() -> a
    void doActionPerformed(java.lang.Object) -> a
    geogebra.euclidianND.EuclidianViewND access$0(geogebra3D.gui.OptionsEuclidian3D) -> a
    geogebra.main.Application access$1(geogebra3D.gui.OptionsEuclidian3D) -> a
geogebra3D.gui.OptionsEuclidian3D$AxisPanel3D -> c.e.i$a:
    geogebra3D.gui.OptionsEuclidian3D this$0 -> a
    void enableStuff(boolean) -> a
    java.lang.String getString() -> a
geogebra3D.gui.OptionsEuclidian3D$ProjectionButtons -> c.e.i$b:
    javax.swing.JButton[] buttons -> a
    int buttonSelected -> a
    geogebra3D.euclidian3D.EuclidianView3D view -> a
    geogebra3D.gui.OptionsEuclidian3D this$0 -> a
    javax.swing.JButton getButton(int) -> a
    void setSelected(int) -> a
    javax.swing.JButton access$1(geogebra3D.gui.OptionsEuclidian3D$ProjectionButtons,int) -> a
geogebra3D.gui.dialogs.DialogManager3D -> c.e.a.a:
    void showNumberInputDialogCirclePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.euclidian.AbstractEuclidianView) -> a
    void showNumberInputDialogCirclePointDirectionRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    void showNumberInputDialogSpherePointRadius(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND) -> a
geogebra3D.gui.dialogs.DialogManager3D$Factory -> c.e.a.a$a:
    geogebra.gui.dialog.DialogManagerDesktop create(geogebra.main.Application) -> a
geogebra3D.gui.dialogs.InputDialogCirclePointDirectionRadius -> c.e.a.b:
    geogebra.common.kernel.kernelND.GeoPointND geoPoint -> a
    geogebra.common.kernel.kernelND.GeoDirectionND forAxis -> a
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra3D.gui.dialogs.InputDialogSpherePointRadius -> c.e.a.c:
    geogebra.common.kernel.kernelND.GeoPointND geoPoint -> a
    geogebra.common.kernel.geos.GeoElement createOutput(geogebra.common.kernel.arithmetic.NumberValue) -> a
geogebra3D.gui.layout.panels.EuclidianDockPanel3D -> c.e.b.a.a:
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
geogebra3D.gui.layout.panels.EuclidianDockPanelForPlane -> c.e.b.a.b:
    geogebra3D.euclidianForPlane.EuclidianViewForPlane view -> a
    int viewId -> a
    java.lang.String getPlainTitle() -> c
    javax.swing.JComponent loadComponent() -> b
    javax.swing.JComponent loadStyleBar() -> a
    geogebra.euclidianND.EuclidianViewND getEuclidianView() -> a
geogebra3D.gui.view.algebra.AlgebraHelperBar3D -> c.e.c.a.a:
    javax.swing.JButton treeModeView -> a
    void addButtons() -> a
    void updateLabels() -> c
    void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
geogebra3D.gui.view.algebra.AlgebraView3D -> c.e.c.a.b:
    java.util.HashMap viewNodesMap -> a
    javax.swing.tree.DefaultMutableTreeNode rootView -> c
    geogebra.gui.view.algebra.AlgebraHelperBar newAlgebraHelperBar() -> b
    javax.swing.tree.DefaultMutableTreeNode getParentNode(geogebra.common.kernel.geos.GeoElement,int) -> a
    void clearTree() -> l
    void initModel() -> f
    void removeAuxiliaryNode() -> g
    void setTreeLabels() -> k
geogebra3D.io.MyXMLHandler3D -> c.f.a:
    void startEuclidianView3DElement(java.lang.String,java.util.LinkedHashMap) -> b
    void startGeoElement(java.lang.String,java.util.LinkedHashMap) -> c
    boolean handleCoordSystem3D(geogebra3D.euclidian3D.EuclidianView3D,java.util.LinkedHashMap) -> e
    boolean handleFading(java.util.LinkedHashMap) -> a
    boolean handleLevelOfDetail(java.util.LinkedHashMap) -> b
    boolean handlePlane(geogebra3D.euclidian3D.EuclidianView3D,java.util.LinkedHashMap) -> a
    boolean handlePlate(geogebra3D.euclidian3D.EuclidianView3D,java.util.LinkedHashMap) -> b
    boolean handleGrid(geogebra3D.euclidian3D.EuclidianView3D,java.util.LinkedHashMap) -> c
    boolean handleClipping(geogebra3D.euclidian3D.EuclidianView3D,java.util.LinkedHashMap) -> d
    geogebra.common.kernel.kernelND.GeoPointND handleAbsoluteStartPoint(java.util.LinkedHashMap) -> a
    boolean handleBgColor(geogebra.common.euclidian.EuclidianViewInterfaceCommon,java.util.LinkedHashMap) -> b
    geogebra.common.awt.Color handleColorAttrs(java.util.LinkedHashMap) -> a
    boolean handleAxis(geogebra.common.euclidian.EuclidianViewInterfaceCommon,java.util.LinkedHashMap) -> a
geogebra3D.kernel3D.AlgoAnglePoints3D -> c.g.a:
    geogebra.common.kernel.Matrix.Coords vn -> a
    geogebra.common.kernel.geos.GeoAngle newGeoAngle(geogebra.common.kernel.Construction) -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getVn() -> a
geogebra3D.kernel3D.AlgoArchimedeanSolid -> c.g.b:
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygons -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegments -> b
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoDirectionND v -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 matrix -> a
    geogebra.common.kernel.Matrix.Coords[] coords -> a
    java.lang.String name -> a
    java.lang.String className -> b
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.kernelND.GeoPointND getA() -> a
    geogebra.common.kernel.kernelND.GeoPointND getB() -> b
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    void setInput() -> a
    void createOutputSegments() -> e
    void createOutputPolygons() -> f
    void updateOutput() -> p
    void createPolyhedron() -> q
    void compute() -> b
    void setUndefined() -> v
    void update() -> i
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoCircle3DAxisPoint -> c.g.c:
    geogebra.common.kernel.kernelND.GeoLineND axis -> a
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra3D.kernel3D.GeoConic3D circle -> a
    geogebra.common.kernel.Matrix.CoordSys coordsys -> a
    geogebra3D.kernel3D.GeoConic3D getCircle() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoCircle3DPointDirection -> c.g.d:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra.common.kernel.geos.GeoElement secondInput -> a
    geogebra.common.kernel.kernelND.GeoDirectionND forAxis -> a
    geogebra3D.kernel3D.GeoConic3D circle -> a
    geogebra.common.kernel.Matrix.CoordSys coordsys -> a
    geogebra3D.kernel3D.GeoConic3D getCircle() -> a
    void compute() -> b
    double getRadius() -> a
    geogebra.common.kernel.kernelND.GeoPointND getCenter() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND getDirection() -> a
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
    geogebra.common.kernel.kernelND.GeoDirectionND getForAxis() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getCommandString() -> c
geogebra3D.kernel3D.AlgoCircle3DPointPointDirection -> c.g.e:
    double getRadius() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String getCommandString() -> c
geogebra3D.kernel3D.AlgoCircle3DPointRadiusDirection -> c.g.f:
    double getRadius() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String getCommandString() -> c
geogebra3D.kernel3D.AlgoCircle3DThreePoints -> c.g.g:
    geogebra.common.kernel.Matrix.CoordSys coordSys -> a
    geogebra.common.kernel.geos.GeoPoint2[] points2D -> a
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    void setPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void createCircle() -> a
    void setInput() -> e
    void setOutput() -> f
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoConeInfinitePointPointNumber -> c.g.h:
    java.lang.String getPlainName() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoConeInfinitePointVectorNumber -> c.g.i:
    java.lang.String getPlainName() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoConePointLineAngle -> c.g.j:
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getPlainName() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoCurveCartesian3D -> c.g.k:
    geogebra.common.kernel.kernelND.GeoCurveCartesianND createCurve(geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.Function[]) -> a
geogebra3D.kernel3D.AlgoCylinderAxisRadius -> c.g.l:
    geogebra.common.kernel.kernelND.GeoLineND axis -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoCylinderInfinitePointPointNumber -> c.g.m:
    java.lang.String getPlainName() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoCylinderInfinitePointVectorNumber -> c.g.n:
    java.lang.String getPlainName() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoDependentPlane3D -> c.g.o:
    geogebra.common.kernel.arithmetic.Equation equation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue[] ev -> a
    geogebra3D.kernel3D.GeoPlane3D p -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
    geogebra3D.kernel3D.GeoPlane3D getPlane() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoDependentPoint3D -> c.g.p:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra3D.kernel3D.GeoPoint3D P -> a
    double[] temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
    geogebra3D.kernel3D.GeoPoint3D getPoint3D() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoDependentVector3D -> c.g.q:
    geogebra.common.kernel.arithmetic.ExpressionNode root -> a
    geogebra3D.kernel3D.GeoVector3D vec -> a
    double[] temp -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
    geogebra3D.kernel3D.GeoVector3D getVector3D() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoElement3D -> c.g.r:
    void setInputOutput(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> b
    void setInputOutput(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[]) -> a
    void setInputOutput(geogebra.common.kernel.geos.GeoElement[],geogebra.common.kernel.geos.GeoElement[],boolean) -> a
    void setInputOutput() -> e_
    void setInputOutput(boolean) -> c
geogebra3D.kernel3D.AlgoForExtrusion -> c.g.s:
    void remove() -> c
    geogebra.common.kernel.geos.GeoElement getOutput(int) -> a
    void setExtrusionComputer(geogebra3D.kernel3D.ExtrusionComputer) -> a
    void removeOutputFromAlgebraView() -> n
    void removeOutputFromPicking() -> o
    void setOutputPointsEuclidianVisible(boolean) -> a
    void notifyUpdateOutputPoints() -> a
    geogebra.common.kernel.geos.GeoElement getGeoToHandle() -> a
    void setOutputOtherEuclidianVisible(boolean) -> b
    void notifyUpdateOutputOther() -> f_
geogebra3D.kernel3D.AlgoFunctionNVarND -> c.g.t:
    geogebra.common.kernel.geos.GeoFunctionNVar inputFunction -> a
    geogebra.common.kernel.geos.GeoFunctionNVar function -> b
    geogebra.common.kernel.arithmetic.NumberValue[] from -> a
    geogebra.common.kernel.arithmetic.NumberValue[] to -> b
    void setInputOutput(geogebra.common.kernel.arithmetic.NumberValue[],geogebra.common.kernel.geos.GeoNumeric[]) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar getFunction() -> a
    void compute() -> b
    double[] getDouble(geogebra.common.kernel.arithmetic.NumberValue[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoIntersect3D -> c.g.u:
    int numberOfUsers -> a
    void avoidDoubleTangentPoint() -> a
    int getClosestPointIndex(double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra3D.kernel3D.GeoPoint3D[] getIntersectionPoints() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getLastDefinedIntersectionPoints() -> b
    int getClosestPointIndex(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void compute() -> b
    void initForNearToRelationship() -> d
    geogebra.common.kernel.kernelND.GeoPointND[] getLastDefinedIntersectionPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND[] getIntersectionPoints() -> b
geogebra3D.kernel3D.AlgoIntersectCS1D1D -> c.g.v:
    void compute() -> b
    java.lang.String getIntersectionTypeString() -> c
geogebra3D.kernel3D.AlgoIntersectCS1D2D -> c.g.w:
    int RESULTCATEGORY_GENERAL -> a
    int RESULTCATEGORY_PARALLEL -> b
    int RESULTCATEGORY_CONTAINED -> c
    void setCoordSys(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    void compute() -> b
    int getConfigLinePlane(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.Matrix.Coords getIntersectLinePlane(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    java.lang.String getIntersectionTypeString() -> c
geogebra3D.kernel3D.AlgoIntersectCS2D2D -> c.g.x:
    int RESULTCATEGORY_NA -> a
    int RESULTCATEGORY_GENERAL -> b
    int RESULTCATEGORY_PARALLEL -> c
    int RESULTCATEGORY_CONTAINED -> d
    geogebra3D.kernel3D.GeoElement3D createIntersection(geogebra.common.kernel.Construction) -> a
    void compute() -> b
    geogebra3D.kernel3D.GeoLine3D getIntersectPlanePlane(geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra3D.kernel3D.GeoLine3D getIntersectPlanePlane(geogebra.common.kernel.Construction,geogebra.common.kernel.Matrix.CoordSys,geogebra.common.kernel.Matrix.CoordSys) -> a
    int getConfigPlanePlane(geogebra.common.kernel.Matrix.CoordSys,geogebra.common.kernel.Matrix.CoordSys) -> a
    java.lang.String getIntersectionTypeString() -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoIntersectConics3D -> c.g.y:
    geogebra.common.kernel.kernelND.GeoConicND A -> a
    geogebra.common.kernel.kernelND.GeoConicND B -> b
    geogebra3D.kernel3D.GeoPoint3D[] P -> a
    geogebra3D.kernel3D.GeoPoint3D[] D -> b
    geogebra.common.kernel.geos.GeoLine l2d -> a
    geogebra.common.kernel.geos.GeoConic A2d -> a
    geogebra.common.kernel.geos.GeoConic B2d -> b
    geogebra.common.kernel.geos.GeoPoint2[] points2d -> a
    geogebra.common.kernel.algos.AlgoIntersectConics algo2d -> a
    geogebra.common.kernel.Matrix.CoordMatrix AUGMENT_DIM -> a
    geogebra.common.kernel.Matrix.CoordMatrix REDUCE_DIM -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra3D.kernel3D.GeoPoint3D[] getIntersectionPoints() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getLastDefinedIntersectionPoints() -> b
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void compute() -> b
    void checkIsOnB(geogebra3D.kernel3D.GeoPoint3D) -> a
    void setPointsUndefined() -> f
    void initForNearToRelationship() -> d
geogebra3D.kernel3D.AlgoIntersectCoordSys -> c.g.z:
    geogebra.common.kernel.geos.GeoElement cs1 -> a
    geogebra.common.kernel.geos.GeoElement cs2 -> b
    geogebra3D.kernel3D.GeoElement3D intersection -> a
    void setCoordSys(geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra3D.kernel3D.GeoElement3D createIntersection(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoElement getCS1() -> a
    geogebra.common.kernel.geos.GeoElement getCS2() -> b
    geogebra3D.kernel3D.GeoElement3D getIntersection() -> a
    boolean outputIsDefined() -> l
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getIntersectionTypeString() -> c
geogebra3D.kernel3D.AlgoIntersectLineConic3D -> c.g.A:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.kernelND.GeoConicND c -> a
    geogebra3D.kernel3D.GeoPoint3D[] P -> a
    geogebra3D.kernel3D.GeoPoint3D[] D -> b
    geogebra.common.kernel.geos.GeoLine g2d -> a
    geogebra.common.kernel.geos.GeoPoint2[] points2d -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra3D.kernel3D.GeoPoint3D[] getIntersectionPoints() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getLastDefinedIntersectionPoints() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void compute() -> b
    void checkIsOnLine(geogebra3D.kernel3D.GeoPoint3D) -> a
    void setPointsUndefined() -> f
    void initForNearToRelationship() -> d
geogebra3D.kernel3D.AlgoIntersectLinePolygon3D -> c.g.B:
    int spaceDim -> a
    geogebra.common.kernel.geos.GeoPolygon p -> a
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> a
    java.util.TreeMap newCoords -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    void intersectionsCoords(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolygon,java.util.TreeMap) -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setLabels(java.lang.String[]) -> a
    void setInputOutput() -> e_
geogebra3D.kernel3D.AlgoIntersectLinePolygon3D$1 -> c.g.C:
    geogebra3D.kernel3D.AlgoIntersectLinePolygon3D this$0 -> a
    geogebra3D.kernel3D.GeoPoint3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoIntersectLinePolygonalRegion3D -> c.g.D:
    int spaceDim -> b
    boolean lineInPlaneOfPolygon -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPoints() -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputSegments() -> b
    void intersectionsCoords(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolygon,java.util.TreeMap) -> a
    void intersectionsSegments(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoPolygon,java.util.TreeMap,java.util.TreeMap) -> a
    void compute() -> b
    void calcLineInPlaneOfPolygon() -> f
    void setLabels(java.lang.String[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void init() -> a
geogebra3D.kernel3D.AlgoIntersectLinePolygonalRegion3D$1 -> c.g.E:
    geogebra3D.kernel3D.AlgoIntersectLinePolygonalRegion3D this$0 -> a
    geogebra3D.kernel3D.GeoPoint3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoIntersectLinePolygonalRegion3D$2 -> c.g.F:
    geogebra3D.kernel3D.AlgoIntersectLinePolygonalRegion3D this$0 -> a
    geogebra3D.kernel3D.GeoSegment3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoIntersectLineQuadric3D -> c.g.G:
    geogebra.common.kernel.kernelND.GeoLineND g -> a
    geogebra.common.kernel.kernelND.GeoQuadricND q -> a
    geogebra3D.kernel3D.GeoPoint3D[] D -> c
    geogebra3D.kernel3D.GeoPoint3D[] P -> a
    geogebra3D.kernel3D.GeoPoint3D[] Q -> b
    int intersectionType -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra3D.kernel3D.GeoPoint3D[] getIntersectionPoints() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getLastDefinedIntersectionPoints() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void compute() -> b
    void initForNearToRelationship() -> d
geogebra3D.kernel3D.AlgoIntersectPlaneConic -> c.g.H:
    geogebra.common.kernel.kernelND.GeoCoordSys2D plane -> a
    void setInputOutput() -> e
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoIntersectPlanePolygon -> c.g.I:
    geogebra3D.kernel3D.GeoPlane3D plane -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
geogebra3D.kernel3D.AlgoIntersectPlanePolygonalRegion -> c.g.J:
    geogebra3D.kernel3D.GeoPlane3D plane -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    void setStyle(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void calcLineInPlaneOfPolygon() -> f
geogebra3D.kernel3D.AlgoIntersectPlaneQuadric -> c.g.K:
    geogebra3D.kernel3D.GeoPlane3D plane -> a
    geogebra3D.kernel3D.GeoQuadric3D quadric -> a
    geogebra3D.kernel3D.GeoConic3D conic -> a
    geogebra3D.kernel3D.GeoConic3D getConic() -> a
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoIntersectSingle3D -> c.g.L:
    geogebra3D.kernel3D.AlgoIntersect3D algo -> a
    int index -> a
    geogebra.common.kernel.kernelND.GeoPointND refPoint -> a
    geogebra3D.kernel3D.GeoPoint3D point -> a
    geogebra3D.kernel3D.GeoPoint3D[] parentOutput -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void setInputOutput() -> e
    geogebra3D.kernel3D.GeoPoint3D getPoint() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getIntersectionPoints() -> a
    geogebra3D.kernel3D.GeoPoint3D[] getLastDefinedIntersectionPoints() -> b
    boolean isNearToAlgorithm() -> b
    void initForNearToRelationship() -> d
    void compute() -> b
    void remove() -> c
geogebra3D.kernel3D.AlgoJoinPoints3D -> c.g.M:
    geogebra.common.kernel.kernelND.GeoPointND P -> a
    geogebra.common.kernel.kernelND.GeoPointND Q -> b
    geogebra.common.kernel.geos.GeoElement poly -> a
    geogebra3D.kernel3D.GeoCoordSys1D cs -> a
    geogebra.common.plugin.GeoClass geoClassType -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void setInputOutput() -> e_
    geogebra.common.kernel.kernelND.GeoPointND getP() -> a
    geogebra.common.kernel.kernelND.GeoPointND getQ() -> b
    geogebra3D.kernel3D.GeoCoordSys1D getCS() -> a
    void compute() -> b
    void remove() -> c
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra3D.kernel3D.AlgoLengthVector3D -> c.g.N:
    geogebra.common.kernel.kernelND.GeoVectorND v -> a
    geogebra.common.kernel.geos.GeoNumeric num -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoNumeric getLength() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoLinePoint -> c.g.O:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra.common.kernel.geos.GeoElement inputParallel -> a
    geogebra3D.kernel3D.GeoLine3D line -> a
    geogebra3D.kernel3D.GeoLine3D getLine() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
    geogebra.common.kernel.geos.GeoElement getInputParallel() -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoLinePointLine3D -> c.g.P:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
geogebra3D.kernel3D.AlgoLinePointVector3D -> c.g.Q:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
geogebra3D.kernel3D.AlgoMidpoint3D -> c.g.R:
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint(geogebra.common.kernel.Construction) -> a
    geogebra3D.kernel3D.GeoPoint3D getPoint() -> a
    void copyCoords(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void computeMidCoords() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
geogebra3D.kernel3D.AlgoMidpointSegment3D -> c.g.S:
    geogebra.common.kernel.kernelND.GeoSegmentND segment -> a
    void setInputOutput() -> e
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoOrtho -> c.g.T:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra.common.kernel.geos.GeoElement inputOrtho -> a
    geogebra3D.kernel3D.GeoLine3D line -> a
    geogebra3D.kernel3D.GeoLine3D getLine() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
    geogebra.common.kernel.geos.GeoElement getInputOrtho() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoOrthoLineLine -> c.g.U:
    geogebra.common.kernel.kernelND.GeoLineND line1 -> a
    geogebra3D.kernel3D.GeoLine3D line -> a
    geogebra.common.kernel.Matrix.Coords origin -> a
    geogebra.common.kernel.Matrix.Coords direction2 -> b
    geogebra.common.kernel.Matrix.Coords origin1 -> c
    geogebra.common.kernel.Matrix.Coords direction1 -> d
    geogebra3D.kernel3D.GeoLine3D getLine() -> a
    void compute() -> b
    void setOriginAndDirection2() -> e
geogebra3D.kernel3D.AlgoOrthoLineLineLine -> c.g.V:
    geogebra.common.kernel.kernelND.GeoLineND line2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setOriginAndDirection2() -> e
geogebra3D.kernel3D.AlgoOrthoLineLinePointPlane -> c.g.W:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra.common.kernel.kernelND.GeoDirectionND direction -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setOriginAndDirection2() -> e
geogebra3D.kernel3D.AlgoOrthoLinePointLine3D -> c.g.X:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.kernelND.GeoLineND getInputLine() -> a
    void compute() -> b
geogebra3D.kernel3D.AlgoOrthoLinePointPlane -> c.g.Y:
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.kernelND.GeoCoordSys2D getCS() -> a
    void compute() -> b
geogebra3D.kernel3D.AlgoOrthoPlane -> c.g.Z:
    geogebra3D.kernel3D.GeoPlane3D plane -> a
    geogebra3D.kernel3D.GeoPlane3D getPlane() -> a
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
    geogebra.common.kernel.Matrix.Coords getPoint() -> b
    void compute() -> b
geogebra3D.kernel3D.AlgoOrthoPlaneBisectorPointPoint -> c.g.aa:
    geogebra.common.kernel.kernelND.GeoPointND point1 -> a
    geogebra.common.kernel.kernelND.GeoPointND point2 -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
    geogebra.common.kernel.Matrix.Coords getPoint() -> b
geogebra3D.kernel3D.AlgoOrthoPlaneBisectorSegment -> c.g.ab:
    geogebra.common.kernel.kernelND.GeoSegmentND segment -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
    geogebra.common.kernel.Matrix.Coords getPoint() -> b
geogebra3D.kernel3D.AlgoOrthoPlanePoint -> c.g.ac:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra.common.kernel.geos.GeoElement secondInput -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra.common.kernel.Matrix.Coords getPoint() -> b
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoOrthoPlanePointLine -> c.g.ad:
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
geogebra3D.kernel3D.AlgoOrthoPlanePointVector -> c.g.ae:
    geogebra.common.kernel.Matrix.Coords getNormal() -> a
geogebra3D.kernel3D.AlgoOrthoVectorPlane -> c.g.af:
    geogebra.common.kernel.kernelND.GeoCoordSys2D plane -> a
    geogebra3D.kernel3D.GeoVector3D vector -> a
    geogebra3D.kernel3D.GeoVector3D getVector() -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getCoords() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPlaneCS2D -> c.g.ag:
    geogebra.common.kernel.kernelND.GeoCoordSys2D cs -> a
    geogebra.common.kernel.kernelND.GeoCoordSys2D csInput -> b
    void compute() -> b
    geogebra.common.kernel.kernelND.GeoCoordSys2D getCoordSys() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPlaneThreePoints -> c.g.ah:
    geogebra.common.kernel.kernelND.GeoCoordSys2D cs -> a
    geogebra.common.kernel.kernelND.GeoPointND A -> a
    geogebra.common.kernel.kernelND.GeoPointND B -> b
    geogebra.common.kernel.kernelND.GeoPointND C -> c
    void compute() -> b
    geogebra.common.kernel.kernelND.GeoCoordSys2D getCoordSys() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPlaneThroughPoint -> c.g.ai:
    geogebra.common.kernel.kernelND.GeoPointND point -> a
    geogebra3D.kernel3D.GeoPlane3D plane -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra3D.kernel3D.GeoPlane3D getPlane() -> a
    geogebra.common.kernel.kernelND.GeoPointND getPoint() -> a
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPlaneThroughPointAndLine -> c.g.aj:
    geogebra.common.kernel.kernelND.GeoLineND line -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPlaneThroughPointAndPlane -> c.g.ak:
    geogebra.common.kernel.kernelND.GeoCoordSys2D cs -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
geogebra3D.kernel3D.AlgoPoint3DInRegion -> c.g.al:
    geogebra.common.kernel.Region region -> a
    geogebra3D.kernel3D.GeoPoint3D P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
    geogebra3D.kernel3D.GeoPoint3D getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPoint3DOnPath -> c.g.am:
    geogebra.common.kernel.Path path -> a
    geogebra3D.kernel3D.GeoPoint3D P -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> e_
    geogebra3D.kernel3D.GeoPoint3D getP() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoPolyLine3D -> c.g.an:
    void createPolyLine(boolean) -> c
    geogebra.common.kernel.algos.Algos getClassName() -> a
    int getRelatedModeID() -> a
    void updatePointArray(geogebra.common.kernel.geos.GeoList) -> a
    void update() -> i
    void compute() -> b
    void setInputOutput() -> a
    geogebra.common.kernel.geos.GeoElement[] createEfficientInput() -> e
geogebra3D.kernel3D.AlgoPolygon3D -> c.g.ao:
    boolean createSegments -> a
    void createPolygon(boolean) -> c
    void compute() -> b
geogebra3D.kernel3D.AlgoPolyhedron -> c.g.ap:
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPoints -> c
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolyhedron -> d
    geogebra3D.kernel3D.GeoPolyhedron polyhedron -> a
    boolean isOldFileVersion -> a
    void setIsOldFileVersion() -> r
    boolean isOldFileVersion() -> l
    void createFaces() -> s
    void createOutputSegments() -> e
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputSegmentsHandler() -> a
    void createOutputPolygons() -> f
    geogebra.common.kernel.algos.AlgoElement$OutputHandler createOutputPolygonsHandler() -> b
    void addAlgoToInput() -> t
    void updateOutput() -> p
    void setOutput() -> u
    geogebra3D.kernel3D.GeoPolyhedron getPolyhedron() -> a
    void getOutputXML(java.lang.StringBuilder) -> b
geogebra3D.kernel3D.AlgoPolyhedron$1 -> c.g.aq:
    geogebra3D.kernel3D.AlgoPolyhedron this$0 -> a
    geogebra3D.kernel3D.GeoPolyhedron newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoPolyhedron$2 -> c.g.ar:
    geogebra3D.kernel3D.AlgoPolyhedron this$0 -> a
    geogebra3D.kernel3D.GeoPoint3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoPolyhedron$3 -> c.g.as:
    geogebra3D.kernel3D.AlgoPolyhedron this$0 -> a
    geogebra3D.kernel3D.GeoSegment3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoPolyhedron$4 -> c.g.at:
    geogebra3D.kernel3D.AlgoPolyhedron this$0 -> a
    geogebra3D.kernel3D.GeoPolygon3D newElement() -> a
    geogebra.common.kernel.geos.GeoElement newElement() -> a
geogebra3D.kernel3D.AlgoPolyhedronPoints -> c.g.au:
    geogebra.common.kernel.kernelND.GeoPointND[] bottomPoints -> b
    geogebra.common.kernel.kernelND.GeoPointND[] points -> a
    geogebra.common.kernel.kernelND.GeoPointND topPoint -> a
    geogebra.common.kernel.geos.GeoPolygon bottom -> a
    geogebra.common.kernel.arithmetic.NumberValue height -> a
    boolean bottomAsInput -> a
    int bottomPointsLength -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegmentsBottom -> a
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegmentsSide -> b
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputSegmentsTop -> e
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygonsBottom -> f
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygonsSide -> g
    geogebra.common.kernel.algos.AlgoElement$OutputHandler outputPolygonsTop -> h
    int shift -> b
    void createOutputSegments() -> e
    void createOutputPolygons() -> f
    void setLabels(java.lang.String[]) -> a
    void augmentOutputSize(int) -> b
    int getSideLengthFromLabelsLength(int) -> a
    void updateOutputPoints() -> q
    void createPolyhedron() -> v
    void updateOutput(int,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void setBottom(geogebra3D.kernel3D.GeoPolyhedron) -> a
    geogebra.common.kernel.geos.GeoPolygon getBottom() -> a
    int getShift() -> f
    boolean preCompute() -> m
    geogebra.common.kernel.kernelND.GeoPointND[] getBottomPoints() -> a
    geogebra.common.kernel.kernelND.GeoPointND getTopPoint() -> a
    void setOutputOtherEuclidianVisible(boolean) -> b
    void notifyUpdateOutputOther() -> f_
    void setOutputPointsEuclidianVisible(boolean) -> a
    void notifyUpdateOutputPoints() -> a
    geogebra.common.kernel.geos.GeoPolygon getTopFace() -> b
geogebra3D.kernel3D.AlgoPolyhedronPointsPrism -> c.g.av:
    geogebra.common.kernel.Matrix.Coords uptranslation -> a
    geogebra.common.kernel.Matrix.Coords interiorPoint -> b
    void createPolyhedron() -> v
    geogebra.common.kernel.kernelND.GeoPointND getTopPoint(int) -> a
    void updateOutput(int,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void updateTop(int) -> c
    void updateSide(int,geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    void updateOutputPoints() -> q
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void updateOutput() -> p
    int getSideLengthFromLabelsLength(int) -> a
geogebra3D.kernel3D.AlgoPolyhedronPointsPrismForExtrusion -> c.g.aw:
    geogebra3D.kernel3D.ExtrusionComputer extrusionComputer -> a
    void setExtrusionComputer(geogebra3D.kernel3D.ExtrusionComputer) -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getGeoToHandle() -> a
geogebra3D.kernel3D.AlgoPolyhedronPointsPyramid -> c.g.ax:
    geogebra.common.kernel.Matrix.Coords interiorPoint -> a
    geogebra.common.kernel.Matrix.Coords bottomCenter -> b
    void createPolyhedron() -> v
    void updateOutput(int,geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void updateSide(int,geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    void updateOutputPoints() -> q
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void updateOutput() -> p
    int getSideLengthFromLabelsLength(int) -> a
geogebra3D.kernel3D.AlgoPolyhedronPointsPyramidForExtrusion -> c.g.ay:
    geogebra3D.kernel3D.ExtrusionComputer extrusionComputer -> a
    void setExtrusionComputer(geogebra3D.kernel3D.ExtrusionComputer) -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getGeoToHandle() -> a
geogebra3D.kernel3D.AlgoQuadric -> c.g.az:
    geogebra3D.kernel3D.GeoQuadric3D quadric -> a
    geogebra.common.kernel.geos.GeoElement secondInput -> a
    geogebra.common.kernel.arithmetic.NumberValue number -> a
    geogebra3D.kernel3D.AlgoQuadricComputer computer -> a
    geogebra3D.kernel3D.AlgoQuadricComputer getComputer() -> a
    geogebra.common.kernel.geos.GeoElement getSecondInput() -> a
    geogebra.common.kernel.geos.GeoElement getNumber() -> b
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    geogebra3D.kernel3D.GeoQuadric3D getQuadric() -> a
geogebra3D.kernel3D.AlgoQuadricComputer -> c.g.aA:
    geogebra3D.kernel3D.GeoQuadric3D newQuadric(geogebra.common.kernel.Construction) -> a
    void setQuadric(geogebra3D.kernel3D.GeoQuadric3D,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    double getNumber(double) -> a
geogebra3D.kernel3D.AlgoQuadricComputerCone -> c.g.aB:
    void setQuadric(geogebra3D.kernel3D.GeoQuadric3D,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    double getNumber(double) -> a
geogebra3D.kernel3D.AlgoQuadricComputerCylinder -> c.g.aC:
    void setQuadric(geogebra3D.kernel3D.GeoQuadric3D,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    double getNumber(double) -> a
geogebra3D.kernel3D.AlgoQuadricComputerSide -> c.g.aD:
    geogebra3D.kernel3D.GeoQuadric3D newQuadric(geogebra.common.kernel.Construction) -> a
    void setQuadric(geogebra3D.kernel3D.GeoQuadric3D,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    double getNumber(double) -> a
geogebra3D.kernel3D.AlgoQuadricEnd -> c.g.aE:
    geogebra3D.kernel3D.GeoQuadric3DLimited quadric -> a
    geogebra3D.kernel3D.GeoConic3D section -> a
    geogebra.common.kernel.Matrix.CoordSys coordsys -> a
    geogebra3D.kernel3D.GeoConic3D getSection() -> a
    void compute() -> b
    geogebra.common.kernel.Matrix.Coords getOrigin(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getV1(geogebra.common.kernel.Matrix.Coords) -> a
geogebra3D.kernel3D.AlgoQuadricEndBottom -> c.g.aF:
    geogebra.common.kernel.Matrix.Coords getOrigin(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getV1(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricEndTop -> c.g.aG:
    geogebra.common.kernel.Matrix.Coords getOrigin(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getV1(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricEnds -> c.g.aH:
    geogebra3D.kernel3D.GeoQuadric3DLimited quadric -> a
    geogebra3D.kernel3D.GeoConic3D section1 -> a
    geogebra3D.kernel3D.GeoConic3D section2 -> b
    geogebra.common.kernel.Matrix.CoordSys coordsys1 -> a
    geogebra.common.kernel.Matrix.CoordSys coordsys2 -> b
    geogebra3D.kernel3D.GeoConic3D getSection1() -> a
    geogebra3D.kernel3D.GeoConic3D getSection2() -> b
    void compute() -> b
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void remove() -> c
geogebra3D.kernel3D.AlgoQuadricLimitedConicHeight -> c.g.aI:
    geogebra.common.kernel.kernelND.GeoConicND bottom -> a
    geogebra.common.kernel.arithmetic.NumberValue height -> a
    geogebra3D.kernel3D.GeoQuadric3DPart side -> a
    geogebra3D.kernel3D.GeoConic3D top -> a
    geogebra3D.kernel3D.GeoQuadric3DLimited quadric -> a
    void createTop() -> e
    void setOutput() -> f
    void compute() -> b
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra3D.kernel3D.GeoQuadric3DLimited getQuadric() -> a
    void update() -> i
    void getOutputXML(java.lang.StringBuilder) -> b
    void setOutputPointsEuclidianVisible(boolean) -> a
    void notifyUpdateOutputPoints() -> a
    geogebra.common.kernel.geos.GeoElement getTopFace() -> b
    void setOutputOtherEuclidianVisible(boolean) -> b
    void notifyUpdateOutputOther() -> f_
geogebra3D.kernel3D.AlgoQuadricLimitedConicHeightCone -> c.g.aJ:
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricLimitedConicHeightConeForExtrusion -> c.g.aK:
    geogebra3D.kernel3D.ExtrusionComputer extrusionComputer -> a
    void setExtrusionComputer(geogebra3D.kernel3D.ExtrusionComputer) -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getGeoToHandle() -> a
geogebra3D.kernel3D.AlgoQuadricLimitedConicHeightCylinder -> c.g.aL:
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricLimitedConicHeightCylinderForExtrusion -> c.g.aM:
    geogebra3D.kernel3D.ExtrusionComputer extrusionComputer -> a
    void setExtrusionComputer(geogebra3D.kernel3D.ExtrusionComputer) -> a
    void compute() -> b
    geogebra.common.kernel.geos.GeoElement getGeoToHandle() -> a
geogebra3D.kernel3D.AlgoQuadricLimitedPointPointRadius -> c.g.aN:
    geogebra.common.kernel.kernelND.GeoPointND origin -> a
    geogebra.common.kernel.kernelND.GeoPointND secondPoint -> b
    geogebra.common.kernel.arithmetic.NumberValue radius -> a
    geogebra3D.kernel3D.GeoQuadric3DPart side -> a
    geogebra3D.kernel3D.GeoConic3D bottom -> a
    geogebra3D.kernel3D.GeoConic3D top -> b
    geogebra3D.kernel3D.GeoQuadric3DLimited quadric -> a
    void setOutput() -> e
    void createEnds() -> f
    void compute() -> b
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra3D.kernel3D.GeoQuadric3DLimited getQuadric() -> a
    void update() -> i
geogebra3D.kernel3D.AlgoQuadricLimitedPointPointRadiusCone -> c.g.aO:
    void createEnds() -> f
    void setOutput() -> e
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricLimitedPointPointRadiusCylinder -> c.g.aP:
    void createEnds() -> f
    void setOutput() -> e
    void setQuadric(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoQuadricPointNumber -> c.g.aQ:
    geogebra.common.kernel.kernelND.GeoPointND origin -> a
    void compute() -> b
    geogebra.common.kernel.kernelND.GeoPointND getOrigin() -> a
    java.lang.String getPlainName() -> c
geogebra3D.kernel3D.AlgoQuadricPointPointNumber -> c.g.aR:
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoQuadricPointVectorNumber -> c.g.aS:
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoQuadricSide -> c.g.aT:
    boolean isHelperAlgo -> a
    geogebra3D.kernel3D.GeoQuadric3DLimited getInputQuadric() -> a
    void compute() -> b
    void remove() -> c
    geogebra.common.kernel.Matrix.Coords getDirection() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoSpherePointRadius -> c.g.aU:
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra3D.kernel3D.GeoQuadric3D getSphere() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoSphereTwoPoints -> c.g.aV:
    geogebra.common.kernel.kernelND.GeoQuadricND createSphereND(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    geogebra3D.kernel3D.GeoQuadric3D getSphere() -> a
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoSurfaceCartesian3D -> c.g.aW:
    geogebra.common.kernel.arithmetic.NumberValue[] coords -> a
    geogebra.common.kernel.arithmetic.NumberValue[] from -> b
    geogebra.common.kernel.arithmetic.NumberValue[] to -> c
    geogebra.common.kernel.geos.GeoNumeric[] localVar -> a
    geogebra.common.kernel.kernelND.GeoSurfaceCartesianND surface -> a
    geogebra.common.kernel.kernelND.GeoSurfaceCartesianND createCurve(geogebra.common.kernel.Construction,geogebra.common.kernel.arithmetic.FunctionNVar[]) -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
    void setInputOutput() -> a
    geogebra.common.kernel.kernelND.GeoSurfaceCartesianND getSurface() -> a
    void compute() -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a
geogebra3D.kernel3D.AlgoTranslate3D -> c.g.aX:
    geogebra.common.kernel.Matrix.Coords getVectorCoords() -> a
    geogebra.common.kernel.geos.GeoElement copy(geogebra.common.kernel.geos.GeoElement) -> b
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.kernel3D.AlgoUnitOrthoVectorPlane -> c.g.aY:
    geogebra.common.kernel.Matrix.Coords getCoords() -> a
    geogebra.common.kernel.algos.Algos getClassName() -> a
geogebra3D.kernel3D.AlgoVector3D -> c.g.aZ:
    geogebra.common.kernel.kernelND.GeoVectorND createNewVector() -> a
    geogebra.common.kernel.kernelND.GeoPointND newStartPoint() -> a
    void setCoords() -> e
geogebra3D.kernel3D.Construction3D -> c.g.ba:
    geogebra3D.kernel3D.Kernel3D kernel3D -> a
    geogebra3D.kernel3D.GeoAxis3D zAxis3D -> a
    geogebra3D.kernel3D.GeoPlane3DConstant xOyPlane -> a
    geogebra3D.kernel3D.GeoClippingCube3D clippingCube -> a
    java.lang.String zAxis3DLocalName -> a
    java.lang.String xOyPlaneLocalName -> b
    void initAxis() -> b
    geogebra.common.kernel.kernelND.GeoAxisND getXAxis3D() -> a
    geogebra.common.kernel.kernelND.GeoAxisND getYAxis3D() -> b
    geogebra3D.kernel3D.GeoAxis3D getZAxis3D() -> a
    geogebra3D.kernel3D.GeoPlane3DConstant getXOYPlane() -> a
    geogebra3D.kernel3D.GeoClippingCube3D getClippingCube() -> a
    void newConstructionDefaults() -> a
    void initGeoTables() -> k
    void updateLocalAxesNames() -> c
geogebra3D.kernel3D.ConstructionDefaults3D -> c.g.bb:
    java.awt.Color colVector -> a
    java.awt.Color colConic3D -> b
    java.awt.Color colCurveCartesian3D -> c
    java.awt.Color colPolygon3D -> d
    java.awt.Color colPlane3D -> j
    java.awt.Color colPolyhedron -> k
    java.awt.Color colQuadric -> l
    java.awt.Color colIntersectionCurve -> e
    java.awt.Color colIntersectionLine -> f
    java.awt.Color colXAXIS -> g
    java.awt.Color colYAXIS -> h
    java.awt.Color colZAXIS -> i
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    void createDefaultGeoElements() -> b
    int getDefaultType(geogebra.common.kernel.geos.GeoElement) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> a
geogebra3D.kernel3D.ExtrusionComputer -> c.g.bc:
    geogebra3D.kernel3D.AlgoForExtrusion algo -> a
    int computed -> a
    void compute() -> a
    int getComputed() -> a
    geogebra3D.kernel3D.AlgoForExtrusion getAlgo() -> a
geogebra3D.kernel3D.Geo3DVec -> c.g.bd:
    double x -> a
    double y -> b
    double z -> c
    int mode -> a
    geogebra.common.kernel.Kernel kernel -> a
    java.lang.StringBuilder sbToString -> a
    geogebra.common.kernel.arithmetic.ExpressionValue deepCopy(geogebra.common.kernel.Kernel) -> a
    void resolveVariables() -> a
    double getX() -> a
    double getY() -> b
    double getZ() -> c
    void add(geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec) -> a
    void add(geogebra3D.kernel3D.Geo3DVec,geogebra.common.kernel.geos.GeoVec2D,geogebra3D.kernel3D.Geo3DVec) -> a
    void add(geogebra.common.kernel.geos.GeoVec2D,geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec) -> a
    void vectorProduct(geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec) -> b
    void sub(geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec) -> c
    void sub(geogebra3D.kernel3D.Geo3DVec,geogebra.common.kernel.geos.GeoVec2D,geogebra3D.kernel3D.Geo3DVec) -> b
    void sub(geogebra.common.kernel.geos.GeoVec2D,geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec) -> b
    void mult(geogebra3D.kernel3D.Geo3DVec,double,geogebra3D.kernel3D.Geo3DVec) -> a
    void inner(geogebra3D.kernel3D.Geo3DVec,geogebra3D.kernel3D.Geo3DVec,geogebra.common.kernel.arithmetic.MyDouble) -> a
    void div(geogebra3D.kernel3D.Geo3DVec,double,geogebra3D.kernel3D.Geo3DVec) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isConstant() -> b_
    boolean isLeaf() -> b
    java.util.HashSet getVariables() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    boolean isNumberValue() -> c
    boolean isVectorValue() -> d
    boolean isBooleanValue() -> j_
    boolean isPolynomialInstance() -> d_
    boolean isTextValue() -> e_
    boolean isExpressionNode() -> i_
    boolean isListValue() -> j
    boolean contains(geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    boolean isVector3DValue() -> k
    double[] getPointAsDouble() -> b
    geogebra3D.kernel3D.Geo3DVec get3DVec() -> a
    java.lang.String toOutputValueString(geogebra.common.kernel.StringTemplate) -> c
    geogebra.common.kernel.Kernel getKernel() -> a
    boolean isEqual(geogebra.common.kernel.kernelND.Geo3DVec) -> a
    void multiplyMatrix(geogebra.common.kernel.arithmetic.MyList,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
geogebra3D.kernel3D.GeoAngle3D -> c.g.be:
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean hasOrientation() -> n
geogebra3D.kernel3D.GeoAxis3D -> c.g.bf:
    java.lang.String axisLabel -> c
    int type -> l
    geogebra.common.util.NumberFormatAdapter numberFormat -> a
    double numbersDistance -> a
    int numbersXOffset -> m
    int numbersYOffset -> n
    int ticksize -> o
    int getType() -> c
    boolean isAvailableAtConstructionStep(int) -> a
    boolean isDefined() -> v
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getAxisLabel() -> d
    void setAxisLabel(java.lang.String) -> a
    boolean isLabelSet() -> g_
    java.lang.String getUnitLabel() -> e
    int getTickStyle() -> f
    boolean getShowNumbers() -> n
    void updateDecorations(double,geogebra.common.util.NumberFormatAdapter,int,int,int,int) -> a
    double getNumbersDistance() -> c
    geogebra.common.util.NumberFormatAdapter getNumberFormat() -> a
    int getNumbersXOffset() -> h
    int getNumbersYOffset() -> i
    int getTickSize() -> g
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
geogebra3D.kernel3D.GeoClippingCube3D -> c.g.bg:
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isDefined() -> v
    void setUndefined() -> f
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getTypeString() -> c
    java.lang.String getClassName() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.kernel3D.GeoConic3D -> c.g.bh:
    geogebra.common.kernel.Matrix.CoordSys coordSys -> a
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    boolean isIntersection -> j
    void setCoordSys(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    geogebra.common.kernel.Matrix.Coords getEigenvec3D(int) -> a
    geogebra.common.kernel.Matrix.Coords getMidpoint3D() -> e
    geogebra.common.kernel.Matrix.Coords getDirection3D(int) -> b
    geogebra.common.kernel.Matrix.Coords getOrigin3D(int) -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isGeoElement3D() -> aC
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean hasValueStringChangeableRegardingView() -> R
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    java.lang.String getClassName() -> b
    boolean isVector3DValue() -> k
    void setCircle(geogebra.common.kernel.geos.GeoPoint2,geogebra.common.kernel.geos.GeoPoint2) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    boolean isRegion() -> U
    void setIsIntersection(boolean) -> a
    boolean isIntersection() -> C
    void doTranslate(geogebra.common.kernel.Matrix.Coords) -> c
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
geogebra3D.kernel3D.GeoCoordSys1D -> c.g.bi:
    geogebra.common.kernel.Matrix.CoordSys coordsys -> a
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    geogebra.common.kernel.kernelND.GeoPointND endPoint -> b
    boolean isIntersection -> g
    java.util.ArrayList pointsOnLine -> c
    boolean isDefined() -> v
    void setUndefined() -> f
    void setCoordFromPoints(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> b
    void setCoord(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> c
    void setCoord(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCoord(geogebra3D.kernel3D.GeoCoordSys1D) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra3D.kernel3D.GeoCoordSys1D create(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.Matrix.Coords getPoint(double) -> a
    geogebra.common.kernel.Matrix.Coords getPointInD(int,double) -> a
    double getUnit() -> d
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    boolean isPath() -> T
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    double getParamOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean isOnFullLine(geogebra.common.kernel.Matrix.Coords,double) -> a
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getDrawingMatrix() -> a
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    boolean getTrace() -> C
    geogebra.common.kernel.Matrix.Coords getCartesianEquationVector(geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getStartInhomCoords() -> c
    geogebra.common.kernel.Matrix.Coords getEndInhomCoords() -> d
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    geogebra.common.kernel.kernelND.GeoPointND getEndPoint() -> b
    void setIsIntersection(boolean) -> a
    boolean isIntersection() -> N
    boolean isTranslateable() -> q_
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void addPointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> c
geogebra3D.kernel3D.GeoCoords4D -> c.g.bj:
    void setCoords(double,double,double,double) -> b
geogebra3D.kernel3D.GeoCurveCartesian3D -> c.g.bk:
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    geogebra.common.kernel.Matrix.Coords evaluateCurve(double) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isVector3DValue() -> k
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    boolean isGeoElement3D() -> aC
geogebra3D.kernel3D.GeoElement3D -> c.g.bl:
    geogebra.common.kernel.Matrix.CoordMatrix4x4 m_drawingMatrix -> a
    geogebra.common.kernel.geos.GeoElement geo2D -> a
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    boolean isGeoElement3D() -> aC
    geogebra.common.kernel.Matrix.CoordMatrix4x4 getDrawingMatrix() -> a
    void setDrawingMatrix(geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    void setAlphaValue(float) -> a
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    java.lang.StringBuilder getSbToString() -> a
    java.lang.StringBuilder getSbBuildValueString() -> b
    boolean isVector3DValue() -> k
geogebra3D.kernel3D.GeoLine3D -> c.g.bm:
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> c
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> e
    geogebra3D.kernel3D.GeoCoordSys1D create(geogebra.common.kernel.Construction) -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getClassName() -> b
    boolean isGeoLine() -> aO
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
geogebra3D.kernel3D.GeoPlane3D -> c.g.bn:
    char[] Labels -> a
    boolean KEEP_LEADING_SIGN -> i
    double xmin -> a
    double xmax -> b
    double ymin -> c
    double ymax -> d
    boolean gridVisible -> g
    boolean plateVisible -> h
    double dx -> e
    double dy -> f
    geogebra.common.kernel.Matrix.CoordSys coordsys -> a
    java.lang.String[] VAR_STRING -> a
    float fading -> b
    geogebra3D.euclidianForPlane.EuclidianViewForPlane euclidianViewForPlane -> a
    void setEquation(double,double,double,double,boolean) -> a
    void setEquation(double,double,double,double) -> a
    void setCoords(double,double,double,double) -> b
    void setEquation(double[],boolean) -> a
    boolean isRegion() -> U
    geogebra.common.kernel.Matrix.Coords[] getNormalProjection(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] getProjection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean isInRegion(double,double) -> a
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    geogebra.common.kernel.Matrix.Coords getPoint(double,double) -> a_
    void setGridCorners(double,double,double,double) -> c
    void setGridDistances(double,double) -> a
    double getXmin() -> a
    double getYmin() -> b
    double getXmax() -> c
    double getYmax() -> d
    boolean isGridVisible() -> C
    void setGridVisible(boolean) -> a
    boolean isPlateVisible() -> J
    void setPlateVisible(boolean) -> d
    double getGridXd() -> e
    double getGridYd() -> f
    geogebra.common.kernel.Matrix.CoordMatrix getParametricMatrix() -> a
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    boolean isFillable() -> F
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    boolean isDefined() -> v
    boolean isMoveable() -> an
    java.lang.String getDefaultLabel() -> o
    void getXMLtags(java.lang.StringBuilder) -> b
    boolean isGeoPlane() -> aP
    void setFading(float) -> a_
    float getFading() -> a_
    void createView2D() -> b
    void update() -> i
    void updateViewForPlane() -> e
    void updateViewForPlaneDirection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    double getMeasure() -> k
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
geogebra3D.kernel3D.GeoPlane3DConstant -> c.g.bo:
    boolean isAvailableAtConstructionStep(int) -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
geogebra3D.kernel3D.GeoPoint3D -> c.g.bp:
    boolean isInfinite -> g
    boolean isDefined -> h
    int pointSize -> l
    geogebra.common.kernel.Matrix.Coords willingCoords -> c
    geogebra.common.kernel.Matrix.Coords willingDirection -> d
    geogebra.common.kernel.Path path -> a
    geogebra.common.kernel.PathParameter pp -> a
    geogebra.common.kernel.Region region -> a
    geogebra.common.kernel.RegionParameters regionParameters -> a
    double x2D -> a
    double y2D -> b
    double z2D -> c
    geogebra.common.kernel.Matrix.Coords inhom -> a
    geogebra.common.kernel.LocateableList locateableList -> a
    java.util.TreeSet tempSet -> a
    int moveMode -> m
    geogebra.common.kernel.Matrix.Coords moveNormalDirection -> e
    boolean showUndefinedInAlgebraView -> i
    void setVisualStyle(geogebra.common.kernel.geos.GeoElement) -> b
    void setPath(geogebra.common.kernel.Path) -> a
    void setRegion(geogebra.common.kernel.Region) -> a
    double distance(geogebra.common.kernel.kernelND.GeoPointND) -> a
    double getX() -> a
    double getY() -> b
    double getZ() -> c
    void setCoords(geogebra.common.kernel.Matrix.Coords,boolean) -> a
    void setCoords(geogebra.common.kernel.Matrix.Coords) -> b
    void setCoords(double,double,double,double) -> b
    void setCoords(double,double,double) -> a
    void updateCoords() -> e
    geogebra.common.kernel.Matrix.Coords getInhomCoords() -> c
    geogebra.common.kernel.Matrix.Coords getInhomCoordsInD(int) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD2(geogebra.common.kernel.Matrix.CoordSys) -> a
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> b
    void getInhomCoords(double[]) -> a_
    double[] vectorTo(geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean movePoint(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean hasPath() -> M
    boolean isPointOnPath() -> al
    geogebra.common.kernel.Path getPath() -> a
    geogebra.common.kernel.PathParameter getPathParameter() -> a
    void doPath() -> H
    boolean isChangeable() -> ak
    boolean hasRegion() -> P
    boolean isPointInRegion() -> bi
    void doRegion() -> I
    geogebra.common.kernel.RegionParameters getRegionParameters() -> a
    geogebra.common.kernel.Region getRegion() -> a
    void updateCoords2D() -> g
    void updateCoords2D(geogebra.common.kernel.Region,boolean) -> a
    void setCoords2D(double,double,double) -> b
    double getX2D() -> e
    double getY2D() -> f
    int getMode() -> y
    void updateCoordsFrom2D(boolean,geogebra.common.kernel.Matrix.CoordSys) -> a
    void setWillingCoords(geogebra.common.kernel.Matrix.Coords) -> c
    void setWillingDirection(geogebra.common.kernel.Matrix.Coords) -> d
    geogebra.common.kernel.Matrix.Coords getWillingCoords() -> d
    geogebra.common.kernel.Matrix.Coords getWillingDirection() -> e
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra3D.kernel3D.GeoPoint3D copy() -> a
    boolean isGeoPoint() -> aS
    boolean isDefined() -> v
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    boolean showInEuclidianView() -> c_
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean hasValueStringChangeableRegardingView() -> R
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean hasChangeableCoordParentNumbers() -> bb
    int getPointSize() -> w
    int getPointStyle() -> x
    boolean getTrace() -> C
    void setPointSize(int) -> u
    void setPointStyle(int) -> v
    void getXMLtags(java.lang.StringBuilder) -> b
    java.lang.String getStartPointXML() -> e
    boolean isAbsoluteStartPoint() -> O
    geogebra.common.kernel.LocateableList getLocateableList() -> a
    void doRemove() -> d
    void update() -> i
    java.util.TreeSet getTempSet() -> f
    boolean isFinite() -> N
    boolean isInfinite() -> Q
    boolean isVector3DValue() -> k
    double[] getPointAsDouble() -> b
    geogebra3D.kernel3D.Geo3DVec get3DVec() -> a
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    void switchMoveMode() -> j
    void setMoveMode(int) -> a
    int getMoveMode() -> c
    int getRealMoveMode() -> f
    void setMoveNormalDirection(geogebra.common.kernel.Matrix.Coords) -> e
    geogebra.common.kernel.Matrix.Coords getMoveNormalDirection() -> f
    void showUndefinedInAlgebraView(boolean) -> d
    boolean showInAlgebraView() -> t
    void set(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void setParentAlgorithm(geogebra.common.kernel.algos.AlgoElement) -> c
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    void matrixTransform(double,double,double,double) -> a
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
    geogebra.common.kernel.kernelND.GeoPointND copy() -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
geogebra3D.kernel3D.GeoPolyLine3D -> c.g.bq:
    boolean defined -> g
    geogebra.common.kernel.Matrix.Coords direction1 -> a
    geogebra.common.kernel.Matrix.Coords direction2 -> b
    geogebra.common.kernel.Matrix.Coords direction3 -> c
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    boolean isPlanar -> h
    geogebra.common.kernel.Matrix.Coords normal -> d
    geogebra3D.kernel3D.GeoSegment3D seg -> a
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isGeoElement3D() -> aC
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.kernelND.GeoPointND createNewPoint() -> a
    void setSegmentPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    boolean isOnPath(geogebra.common.kernel.kernelND.GeoPointND,double) -> a
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void calcLength() -> g
    void rotate(geogebra.common.kernel.arithmetic.NumberValue) -> a
    void matrixTransform(double,double,double,double) -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void mirror(geogebra.common.kernel.geos.GeoLine) -> a
    boolean isAllVertexLabelsSet() -> J
    void matrixTransform(double,double,double,double,double,double,double,double,double) -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint(int) -> a
    void toGeoCurveCartesian(geogebra.common.kernel.geos.GeoCurveCartesian) -> a
geogebra3D.kernel3D.GeoPolygon3D -> c.g.br:
    geogebra.common.kernel.Matrix.CoordSys coordSys -> a
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    geogebra.common.kernel.geos.GeoPoint2[] points2D -> a
    boolean isPartOfClosedSurface -> g
    boolean createSegments -> h
    boolean reverseNormal -> i
    geogebra.common.kernel.geos.GeoElement meta -> a
    geogebra3D.euclidianForPlane.EuclidianViewForPlane euclidianViewForPlane -> a
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    boolean isGeoElement3D() -> aC
    void removeSegment(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    geogebra.common.kernel.geos.GeoPoint2 getPoint(int) -> a
    geogebra.common.kernel.Matrix.Coords getPoint3D(int) -> a
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    void setReverseNormal() -> H
    geogebra.common.kernel.kernelND.GeoPointND[] getPoints() -> a
    void setEuclidianVisible(boolean) -> c
    java.lang.String getClassName() -> b
    void setCoordSys(geogebra.common.kernel.Matrix.CoordSys) -> a
    boolean checkPointsAreOnCoordSys() -> P
    boolean updateCoordSys() -> bt
    geogebra.common.kernel.Matrix.CoordSys getCoordSys() -> a
    boolean isDefined() -> v
    void setIsPartOfClosedSurface(boolean) -> d
    boolean isPartOfClosedSurface() -> O
    boolean isFromMeta() -> bs
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
    void setFromMeta(geogebra.common.kernel.geos.GeoElement) -> c
    void pathChanged(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void pointChanged(geogebra.common.kernel.kernelND.GeoPointND) -> b
    void setRegionChanged(geogebra.common.kernel.kernelND.GeoPointND,double,double) -> a
    boolean isInRegion(geogebra.common.kernel.kernelND.GeoPointND,boolean) -> a
    geogebra.common.kernel.geos.GeoPolygon newGeoPolygon(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] copyPoints(geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.kernelND.GeoPointND newGeoPoint() -> a
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    void createView2D() -> b
    void update() -> i
geogebra3D.kernel3D.GeoPolyhedron -> c.g.bs:
    int type -> l
    java.util.TreeMap segmentsIndex -> a
    long segmentsIndexMax -> a
    java.util.TreeMap segments -> b
    java.util.TreeMap segmentsLinked -> c
    java.util.TreeMap polygonsIndex -> d
    java.util.ArrayList polygonsDescriptions -> c
    int polygonsIndexMax -> m
    java.util.TreeMap polygons -> e
    java.util.TreeSet polygonsLinked -> a
    java.util.ArrayList pointsCreated -> d
    geogebra.common.kernel.ConstructionElementCycle currentFace -> a
    java.lang.StringBuffer sb -> a
    boolean isDefined -> g
    java.util.Collection getSegmentsLinked() -> a
    java.util.Collection getPolygonsLinked() -> b
    void setType(int) -> a
    void startNewFace() -> e
    void addPointToCurrentFace(geogebra.common.kernel.kernelND.GeoPointND) -> a
    void endCurrentFace() -> g
    void updateFacesDeprecated() -> j
    geogebra3D.kernel3D.GeoPolygon3D createPolygon(int) -> a
    void createFaces() -> H
    geogebra3D.kernel3D.GeoPolygon3D createPolygon(geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    void addPolygonLinked(geogebra.common.kernel.geos.GeoPolygon) -> a
    void addPointCreated(geogebra3D.kernel3D.GeoPoint3D) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND createSegment(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND getSegment(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    void addSegmentLinked(geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void initLabels(java.lang.String[]) -> a
    void defaultPointsLabels() -> K
    int usableLabel(geogebra.common.kernel.geos.GeoElement) -> a
    void defaultPolygonsLabels() -> L
    void defaultSegmentLabels() -> M
    geogebra3D.kernel3D.GeoSegment3D[] getSegments() -> a
    geogebra3D.kernel3D.GeoPolygon3D[] getFaces() -> a
    java.util.Collection getFacesCollection() -> c
    geogebra3D.kernel3D.GeoPolygon3D getFace(int) -> b
    java.util.Collection getPolygons() -> d
    void setInteriorPoint(geogebra.common.kernel.Matrix.Coords) -> a
    void setReverseNormals() -> I
    void setEuclidianVisible(boolean) -> c
    void setObjColor(geogebra.common.awt.Color) -> b
    void setLineType(int) -> m
    void setLineTypeHidden(int) -> n
    void setLineThickness(int) -> l
    void setAlphaValue(float) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    boolean isDefined() -> v
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    void setDefined() -> J
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String getClassName() -> b
    boolean isFillable() -> F
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    boolean isPath() -> T
    void remove() -> c
geogebra3D.kernel3D.GeoQuadric3D -> c.g.bt:
    java.lang.String[] vars3D -> a
    geogebra.common.kernel.Matrix.CoordMatrix4x4 eigenMatrix -> a
    void setSphereNDMatrix(geogebra.common.kernel.Matrix.Coords,double) -> b
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    void setCone(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> a
    void setCylinder(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> b
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String getClassName() -> b
    boolean isFillable() -> F
    boolean isGeoElement3D() -> aC
    boolean isVector3DValue() -> k
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    boolean isRegion() -> U
    geogebra.common.kernel.Matrix.Coords getNormalProjectionParameters(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords[] getNormalProjection(geogebra.common.kernel.Matrix.Coords) -> a
    geogebra.common.kernel.Matrix.Coords getPoint(double,double) -> a_
    geogebra.common.kernel.Matrix.Coords[] getProjection(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean isInRegion(double,double) -> a
    geogebra.common.kernel.Matrix.Coords getDirectionToCenter(geogebra.common.kernel.Matrix.Coords) -> b
    void pointChangedForRegion(geogebra.common.kernel.kernelND.GeoPointND) -> c
    void regionChanged(geogebra.common.kernel.kernelND.GeoPointND) -> d
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
    boolean isTranslateable() -> q_
geogebra3D.kernel3D.GeoQuadric3DLimited -> c.g.bu:
    geogebra3D.kernel3D.GeoQuadric3DPart side -> a
    geogebra.common.kernel.kernelND.GeoConicND bottom -> a
    geogebra3D.kernel3D.GeoConic3D top -> a
    double min -> a
    double max -> b
    double volume -> c
    void setParts(geogebra3D.kernel3D.GeoQuadric3DPart,geogebra.common.kernel.kernelND.GeoConicND,geogebra3D.kernel3D.GeoConic3D) -> a
    geogebra.common.kernel.kernelND.GeoConicND getBottom() -> a
    geogebra3D.kernel3D.GeoConic3D getTop() -> a
    geogebra3D.kernel3D.GeoQuadric3DPart getSide() -> a
    void updatePartsVisualStyle() -> e
    void initLabelsIncludingBottom(java.lang.String[]) -> a
    void initLabelsNoBottom(java.lang.String[]) -> b
    double getMin() -> b
    double getMax() -> c
    void setCylinder(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> a
    void setCone(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double,double,double) -> b
    void setObjColor(geogebra.common.awt.Color) -> b
    boolean isFillable() -> F
    void setEuclidianVisible(boolean) -> c
    boolean isPath() -> T
    void setLineType(int) -> m
    void setLineTypeHidden(int) -> n
    void setLineThickness(int) -> l
    void setAlphaValue(float) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    void calcVolume() -> g
    double getVolume() -> d
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    void setSphereND(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isNumberValue() -> c
geogebra3D.kernel3D.GeoQuadric3DPart -> c.g.bv:
    double min -> a
    double max -> b
    double area -> c
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setLimits(double,double) -> a
    double getMinParameter(int) -> a
    double getMaxParameter(int) -> b
    void set(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords,double) -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.kernel.Matrix.Coords getNormalProjectionParameters(geogebra.common.kernel.Matrix.Coords) -> a
    void calcArea() -> e
    double getArea() -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isNumberValue() -> c
geogebra3D.kernel3D.GeoRay3D -> c.g.bw:
    boolean allowOutlyingIntersections -> g
    boolean keepTypeOnGeometricTransform -> h
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    geogebra3D.kernel3D.GeoCoordSys1D create(geogebra.common.kernel.Construction) -> a
    double getMinParameter() -> b
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    boolean isLimitedPath() -> o_
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isAllEndpointsLabelsSet() -> M
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
geogebra3D.kernel3D.GeoSegment3D -> c.g.bx:
    geogebra.common.kernel.geos.GeoElement geoParent -> a
    boolean allowOutlyingIntersections -> g
    boolean keepTypeOnGeometricTransform -> h
    boolean forceSimpleTransform -> i
    geogebra.common.kernel.geos.GeoElement meta -> b
    double getLength() -> c
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra3D.kernel3D.GeoCoordSys1D create(geogebra.common.kernel.Construction) -> a
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    boolean isGeoSegment() -> aV
    void setTwoPointsCoords(geogebra.common.kernel.Matrix.Coords,geogebra.common.kernel.Matrix.Coords) -> a
    boolean isOnPath(geogebra.common.kernel.Matrix.Coords,double) -> b
    boolean respectLimitedPath(geogebra.common.kernel.Matrix.Coords,double) -> c
    geogebra.common.kernel.PathMover createPathMover() -> a
    double getMaxParameter() -> a_
    double getMinParameter() -> b
    boolean isClosedPath() -> u_
    double getPointX(double) -> b
    double getPointY(double) -> c
    geogebra.common.kernel.Matrix.Coords getPointCoords(double) -> b
    geogebra.common.kernel.geos.GeoElement getStartPointAsGeoElement() -> c
    geogebra.common.kernel.geos.GeoElement getEndPointAsGeoElement() -> g
    boolean isGeoLine() -> aO
    boolean isDefined() -> v
    boolean isLimitedPath() -> o_
    boolean allowOutlyingIntersections() -> H
    void setAllowOutlyingIntersections(boolean) -> d
    boolean keepsTypeOnGeometricTransform() -> J
    void setKeepTypeOnGeometricTransform(boolean) -> e
    geogebra.common.kernel.geos.GeoElement[] createTransformedObject(geogebra.common.kernel.Transform,java.lang.String) -> a
    boolean isAllEndpointsLabelsSet() -> M
    geogebra.common.kernel.geos.GeoElement copyInternal(geogebra.common.kernel.Construction) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.arithmetic.MyDouble getNumber() -> K
    double getDouble() -> a
    boolean isNumberValue() -> c
    boolean isFromMeta() -> bs
    geogebra.common.kernel.geos.GeoElement getMeta() -> a
    void setFromMeta(geogebra.common.kernel.geos.GeoElement) -> c
    void modifyInputPoints(geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    void removePointOnLine(geogebra.common.kernel.kernelND.GeoPointND) -> d
geogebra3D.kernel3D.GeoSurfaceCartesian3D -> c.g.by:
    geogebra3D.euclidian3D.Drawable3D drawable3D -> a
    geogebra.common.kernel.kernelND.LevelOfDetail levelOfDetail -> a
    geogebra.common.kernel.Matrix.Coords evaluateSurface(double,double) -> c
    geogebra.common.kernel.Matrix.Coords evaluateSurface(double[]) -> a
    geogebra.common.kernel.geos.GeoElement copy() -> b
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    java.lang.String getTypeString() -> c
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.Matrix.Coords getMainDirection() -> b
    boolean isGeoElement3D() -> aC
    boolean isFillable() -> F
    geogebra.common.kernel.Matrix.Coords evaluatePoint(double,double) -> a
    geogebra.common.kernel.Matrix.Coords evaluateNormal(double,double) -> b
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.LevelOfDetail getLevelOfDetail() -> a
    boolean hasLevelOfDetail() -> aD
geogebra3D.kernel3D.GeoVec -> c.g.bz:
    geogebra.common.kernel.Matrix.Coords v -> b
    int m_length -> l
    void setCoords(geogebra.common.kernel.Matrix.Coords) -> b
    void setCoords(double[]) -> b
    void setCoords(geogebra.common.kernel.kernelND.GeoPointND) -> d
    geogebra.common.kernel.Matrix.Coords getCoords() -> g
    void translate(geogebra.common.kernel.Matrix.Coords) -> a
geogebra3D.kernel3D.GeoVec4D -> c.g.bA:
    void setCoords(double,double,double,double) -> b
    double getX() -> a
    double getY() -> b
    double getZ() -> c
    double getW() -> d
    void getXMLtags(java.lang.StringBuilder) -> b
geogebra3D.kernel3D.GeoVector3D -> c.g.bB:
    geogebra.common.kernel.kernelND.GeoPointND startPoint -> a
    geogebra.common.kernel.Matrix.CoordMatrix matrix -> a
    geogebra.common.kernel.Matrix.Coords labelPosition -> a
    java.lang.StringBuilder sbToString -> a
    java.lang.StringBuilder sbBuildValueString -> b
    java.lang.StringBuilder sb -> c
    void setCoords(double[]) -> b
    void updateStartPointPosition() -> e
    geogebra.common.kernel.Matrix.Coords getLabelPosition() -> a_
    geogebra.common.kernel.geos.GeoElement copy() -> b
    geogebra.common.plugin.GeoClass getGeoClassType() -> a
    java.lang.String getTypeString() -> c
    boolean isDefined() -> v
    boolean isEqual(geogebra.common.kernel.geos.GeoElement) -> a
    boolean isInfinite() -> Q
    boolean isFinite() -> M
    void set(geogebra.common.kernel.geos.GeoElement) -> a
    void setUndefined() -> f
    boolean showInAlgebraView() -> t
    boolean showInEuclidianView() -> c_
    java.lang.String getClassName() -> b
    boolean isVector3DValue() -> k
    boolean isPath() -> T
    boolean isGeoVector() -> aX
    java.lang.String toString(geogebra.common.kernel.StringTemplate) -> a_
    java.lang.String toValueString(geogebra.common.kernel.StringTemplate) -> b
    java.lang.StringBuilder buildValueString(geogebra.common.kernel.StringTemplate) -> a
    void setCoordSep(geogebra.common.kernel.StringTemplate) -> a
    java.lang.String toLaTeXString(boolean,geogebra.common.kernel.StringTemplate) -> a
    void getXMLtags(java.lang.StringBuilder) -> b
    geogebra.common.kernel.kernelND.GeoPointND getStartPoint() -> a
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> b_
    geogebra.common.kernel.kernelND.GeoPointND[] getStartPoints() -> a
    void initStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> b
    boolean isAlwaysFixed() -> a
    void removeStartPoint(geogebra.common.kernel.kernelND.GeoPointND) -> a_
    void setStartPoint(geogebra.common.kernel.kernelND.GeoPointND,int) -> a
    void setWaitForStartPoint() -> b_
    geogebra3D.kernel3D.Geo3DVec get3DVec() -> a
    double[] getPointAsDouble() -> b
    geogebra.common.kernel.Matrix.Coords getCoordsInD(int) -> a
    boolean getTrace() -> C
    geogebra.common.kernel.Matrix.Coords getDirectionInD3() -> a
    boolean isLaTeXDrawableGeo(java.lang.String) -> e
    java.util.ArrayList getColumnHeadings() -> b
    java.util.ArrayList getSpreadsheetTraceList() -> a
    geogebra.common.kernel.kernelND.Geo3DVec get3DVec() -> a
geogebra3D.kernel3D.Kernel3D -> c.g.bC:
    geogebra3D.Application3D app3D -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass -> a
    geogebra.common.kernel.kernelND.GeoAxisND getXAxis3D() -> a
    geogebra.common.kernel.kernelND.GeoAxisND getYAxis3D() -> b
    geogebra3D.kernel3D.GeoAxis3D getZAxis3D() -> a
    geogebra3D.kernel3D.GeoPlane3DConstant getXOYPlane() -> a
    geogebra3D.kernel3D.GeoClippingCube3D getClippingCube() -> a
    java.lang.String getModeText(int) -> a
    geogebra.common.kernel.Manager3DInterface newManager3D(geogebra.common.kernel.Kernel) -> a
    boolean isZvarAllowed() -> k
    void newConstruction() -> a
    geogebra.common.io.MyXMLHandler newMyXMLHandler(geogebra.common.kernel.Kernel,geogebra.common.kernel.Construction) -> a
    geogebra.common.kernel.arithmetic.ExpressionNodeEvaluator newExpressionNodeEvaluator() -> a
    geogebra.common.kernel.commands.AlgebraProcessor newAlgebraProcessor(geogebra.common.kernel.Kernel) -> a
    java.util.TreeSet getPointSet() -> a
    geogebra.common.kernel.geos.GeoElement createGeoElement(geogebra.common.kernel.Construction,java.lang.String) -> a
    boolean handleCoords(geogebra.common.kernel.geos.GeoElement,java.util.LinkedHashMap) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND getDefaultPlane() -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLines(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.geos.GeoElement copy3D(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement copyInternal3D(geogebra.common.kernel.Construction,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.kernelND.GeoRayND RayND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND SegmentND(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] PolygonND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> c
    geogebra.common.kernel.geos.GeoElement[] PolyLineND(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> d
    int[] $SWITCH_TABLE$geogebra$common$plugin$GeoClass() -> c
geogebra3D.kernel3D.Manager3D -> c.g.bD:
    geogebra.common.kernel.Kernel kernel -> a
    geogebra.common.kernel.Construction cons -> a
    geogebra3D.kernel3D.GeoPoint3D Point3D(java.lang.String,double,double,double) -> a
    geogebra3D.kernel3D.GeoPoint3D DependentPoint3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra3D.kernel3D.GeoVector3D DependentVector3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra3D.kernel3D.GeoVector3D Vector3D(java.lang.String,double,double,double) -> a
    geogebra3D.kernel3D.GeoVector3D Vector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoPoint3D Point3DIn(java.lang.String,geogebra.common.kernel.Region,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra3D.kernel3D.GeoPoint3D Point3DIn(java.lang.String,geogebra.common.kernel.Region) -> a
    geogebra3D.kernel3D.GeoPoint3D Point3D(java.lang.String,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    geogebra3D.kernel3D.GeoPoint3D Point3D(java.lang.String,geogebra.common.kernel.Path) -> a
    geogebra3D.kernel3D.GeoPoint3D Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra3D.kernel3D.GeoSegment3D Segment3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoLine3D Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoLineND Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra3D.kernel3D.GeoRay3D Ray3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.kernelND.GeoLineND OrthogonalLine3D(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoVectorND OrthogonalVector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoVectorND UnitOrthogonalVector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> b
    geogebra.common.kernel.geos.GeoElement[] Polygon3D(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> a
    geogebra.common.kernel.geos.GeoElement[] PolyLine3D(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> b
    geogebra.common.kernel.geos.GeoElement[] PolyLine3D(java.lang.String[],geogebra.common.kernel.geos.GeoList) -> a
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> c
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement[] Prism(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND[]) -> d
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.geos.GeoElement[] Pyramid(java.lang.String[],geogebra.common.kernel.geos.GeoPolygon,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra3D.kernel3D.GeoPlane3D Plane3D(java.lang.String,double,double,double,double) -> a
    geogebra3D.kernel3D.GeoPlane3D DependentPlane3D(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra3D.kernel3D.GeoPlane3D Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra3D.kernel3D.GeoPlane3D Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra3D.kernel3D.GeoPlane3D OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra3D.kernel3D.GeoPlane3D OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra3D.kernel3D.GeoPlane3D PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoPlane3D PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra3D.kernel3D.GeoQuadric3D Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoQuadric3D Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoQuadric3D Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoQuadric3D Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoQuadric3D Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] ConeLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] ConeLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoQuadric3D Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra3D.kernel3D.GeoQuadric3D Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra3D.kernel3D.GeoQuadric3D Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement[] CylinderLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.geos.GeoElement[] CylinderLimited(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra3D.kernel3D.GeoQuadric3DPart QuadricSide(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra3D.kernel3D.GeoConic3D QuadricBottom(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra3D.kernel3D.GeoConic3D QuadricTop(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> b
    geogebra3D.kernel3D.GeoConic3D Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoConic3D Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND) -> a
    geogebra3D.kernel3D.GeoPlane3D Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.GeoPlane3D Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra3D.kernel3D.GeoPlane3D Plane3D(geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoElement Intersect(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionPoint(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionPoint(java.lang.String[],geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> a
    geogebra.common.kernel.geos.GeoElement[] IntersectionSegment(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> b
    geogebra.common.kernel.geos.GeoElement[] IntersectionSegment(java.lang.String[],geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.geos.GeoSurfaceFinite) -> b
    geogebra3D.kernel3D.GeoConic3D Intersect(java.lang.String,geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra3D.kernel3D.GeoConic3D Intersect(geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar Function2Var(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoFunctionNVar Function2Var(java.lang.String,geogebra.common.kernel.geos.GeoFunctionNVar,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoCurveCartesian3D CurveCartesian3D(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement SurfaceCartesian3D(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.AlgoIntersectLineConic3D getIntersectionAlgorithm(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra3D.kernel3D.GeoPoint3D[] IntersectLineConic(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,int) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.AlgoIntersectConics3D getIntersectionAlgorithm(geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra3D.kernel3D.GeoPoint3D[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,int) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.AlgoIntersectLineQuadric3D getIntersectionAlgorithm(geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectLineQuadric(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,int) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,double,double,geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    geogebra3D.kernel3D.GeoPoint3D IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra3D.kernel3D.AlgoIntersectPlaneConic getIntersectionAlgorithm(geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectPlaneConic(java.lang.String[],geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.geos.GeoElement IntersectPlanes(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoElement IntersectPlanes(geogebra.common.kernel.kernelND.GeoCoordSys2D,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoAngle Angle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoNumeric Length(java.lang.String,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra3D.kernel3D.GeoPolyhedron ArchimedeanSolid(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement[] Translate3D(java.lang.String,geogebra.common.kernel.geos.GeoElement,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.Geo3DVec newGeo3DVec(double,double,double) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Circle3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.geos.GeoElement Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoCoordSys2D) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND Plane3D(java.lang.String,double,double,double,double) -> a
    geogebra.common.kernel.kernelND.GeoConicND QuadricTop(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> b
    geogebra.common.kernel.geos.GeoElement Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> c
    geogebra.common.kernel.geos.GeoElement Sphere(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectConicsSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.geos.GeoElement Line3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> b
    geogebra.common.kernel.kernelND.GeoConicND QuadricBottom(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND QuadricSide(java.lang.String,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cone(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoSegmentND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND PlaneBisector(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3D(java.lang.String,geogebra.common.kernel.Path) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3D(java.lang.String,geogebra.common.kernel.Path,double,double,double,boolean) -> a
    geogebra.common.kernel.geos.GeoElement Point3D(java.lang.String,double,double,double) -> a
    geogebra.common.kernel.geos.GeoElement DependentVector3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> b
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,double,double,geogebra.common.kernel.Matrix.CoordMatrix4x4) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineQuadricSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoQuadricND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.geos.GeoElement ArchimedeanSolid(java.lang.String[],geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoDirectionND,java.lang.String) -> a
    geogebra.common.kernel.geos.GeoElement CurveCartesian3D(java.lang.String,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.geos.GeoNumeric,geogebra.common.kernel.arithmetic.NumberValue,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectConics(java.lang.String[],geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoQuadricND Cylinder(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND,geogebra.common.kernel.arithmetic.NumberValue) -> b
    geogebra.common.kernel.kernelND.GeoPlaneND DependentPlane3D(java.lang.String,geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.kernelND.GeoConicND Intersect(geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoConicND Intersect(java.lang.String,geogebra.common.kernel.kernelND.GeoPlaneND,geogebra.common.kernel.kernelND.GeoQuadricND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3DIn(java.lang.String,geogebra.common.kernel.Region) -> a
    geogebra.common.kernel.kernelND.GeoPointND Point3DIn(java.lang.String,geogebra.common.kernel.Region,geogebra.common.kernel.Matrix.Coords,boolean) -> a
    geogebra.common.kernel.kernelND.GeoPointND[] IntersectLineConic(java.lang.String[],geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND) -> a
    geogebra.common.kernel.kernelND.GeoPointND Midpoint(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoSegmentND Segment3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement DependentPoint3D(java.lang.String,geogebra.common.kernel.arithmetic.ExpressionNode) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.kernel.kernelND.GeoPointND IntersectLineConicSingle(java.lang.String,geogebra.common.kernel.kernelND.GeoLineND,geogebra.common.kernel.kernelND.GeoConicND,double,double,geogebra.common.kernel.Matrix.CoordMatrix) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoVectorND) -> a
    geogebra.common.kernel.kernelND.GeoPlaneND OrthogonalPlane3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoLineND) -> b
    geogebra.common.kernel.kernelND.GeoRayND Ray3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement Vector3D(java.lang.String,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND) -> a
    geogebra.common.kernel.geos.GeoElement Vector3D(java.lang.String,double,double,double) -> b
geogebra3D.kernel3D.Transform3D -> c.g.bE:
geogebra3D.kernel3D.TransformTranslate3D -> c.g.bF:
    geogebra.common.kernel.geos.GeoElement transVec -> a
    geogebra.common.kernel.algos.AlgoTransformation getTransformAlgo(geogebra.common.kernel.geos.GeoElement) -> a
geogebra3D.kernel3D.arithmetic.ExpressionNodeEvaluator3D -> c.g.a.a:
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation -> a
    geogebra.common.kernel.arithmetic.ExpressionValue evaluate(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.StringTemplate) -> a
    int[] $SWITCH_TABLE$geogebra$common$plugin$Operation() -> a
geogebra3D.kernel3D.commands.AlgebraProcessor3D -> c.g.b.a:
    geogebra.common.kernel.geos.GeoElement[] processPointVector3D(geogebra.common.kernel.arithmetic.ExpressionNode,geogebra.common.kernel.arithmetic.ExpressionValue) -> a
    void checkNoTermsInZ(geogebra.common.kernel.arithmetic.Equation) -> a
    geogebra.common.kernel.geos.GeoElement[] processLine(geogebra.common.kernel.arithmetic.Equation) -> b
    geogebra.common.kernel.geos.GeoElement[] processPlane(geogebra.common.kernel.arithmetic.Equation) -> e
geogebra3D.kernel3D.commands.CmdAngle3D -> c.g.b.b:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdArchimedeanSolid -> c.g.b.c:
    java.lang.String name -> a
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdBottom -> c.g.b.d:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdCircle3D -> c.g.b.e:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdCone -> c.g.b.f:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] conePointPointRadius(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.main.MyError argErr(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.main.MyError argNumErr(int) -> a
geogebra3D.kernel3D.commands.CmdConeInfinite -> c.g.b.g:
    geogebra.common.kernel.geos.GeoElement[] conePointPointRadius(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.main.MyError argErr(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.main.MyError argNumErr(int) -> a
geogebra3D.kernel3D.commands.CmdCurveCartesian3D -> c.g.b.h:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdCylinder -> c.g.b.i:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.kernel.geos.GeoElement[] cylinderPointPointRadius(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.main.MyError argErr(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.main.MyError argNumErr(int) -> a
geogebra3D.kernel3D.commands.CmdCylinderInfinite -> c.g.b.j:
    geogebra.common.kernel.geos.GeoElement[] cylinderPointPointRadius(geogebra.common.kernel.arithmetic.Command,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.kernelND.GeoPointND,geogebra.common.kernel.arithmetic.NumberValue) -> a
    geogebra.common.main.MyError argErr(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.main.MyError argNumErr(int) -> a
geogebra3D.kernel3D.commands.CmdFunction2Var -> c.g.b.k:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdIntersect3D -> c.g.b.l:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdIntersectionPaths3D -> c.g.b.m:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdLength3D -> c.g.b.n:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdLine3D -> c.g.b.o:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdMidpoint3D -> c.g.b.p:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdOrthogonalLine3D -> c.g.b.q:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdOrthogonalPlane -> c.g.b.r:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdOrthogonalVector3D -> c.g.b.s:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPlane -> c.g.b.t:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPlaneBisector -> c.g.b.u:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPoint3D -> c.g.b.v:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPointIn3D -> c.g.b.w:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPolyLine3D -> c.g.b.x:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPolygon3D -> c.g.b.y:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPrism -> c.g.b.z:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdPyramid -> c.g.b.A:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdQuadricSide -> c.g.b.B:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
    geogebra.common.main.MyError argErr(geogebra.common.kernel.geos.GeoElement) -> a
    geogebra.common.main.MyError argNumErr(int) -> a
geogebra3D.kernel3D.commands.CmdRay3D -> c.g.b.C:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdSegment3D -> c.g.b.D:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdSphere3D -> c.g.b.E:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdSurfaceCartesian3D -> c.g.b.F:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdTop -> c.g.b.G:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdTranslate3D -> c.g.b.H:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdUnitOrthogonalVector3D -> c.g.b.I:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CmdVector3D -> c.g.b.J:
    geogebra.common.kernel.geos.GeoElement[] process(geogebra.common.kernel.arithmetic.Command) -> a
geogebra3D.kernel3D.commands.CommandDispatcher3D -> c.g.b.K:
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands -> a
    geogebra.common.kernel.commands.CommandProcessor commandTableSwitch(java.lang.String) -> a
    int[] $SWITCH_TABLE$geogebra$common$kernel$commands$Commands() -> a
geogebra3D.util.ImageManager3D -> c.h.a:
    java.awt.Image getImageResourceGeoGebra(java.lang.String) -> b
jd2xx.JD2XX -> jd2xx.JD2XX:
    int OK -> OK
    int INVALID_HANDLE -> INVALID_HANDLE
    int DEVICE_NOT_FOUND -> DEVICE_NOT_FOUND
    int DEVICE_NOT_OPENED -> DEVICE_NOT_OPENED
    int IO_ERROR -> IO_ERROR
    int INSUFFICIENT_RESOURCES -> INSUFFICIENT_RESOURCES
    int INVALID_PARAMETER -> INVALID_PARAMETER
    int INVALID_BAUD_RATE -> INVALID_BAUD_RATE
    int DEVICE_NOT_OPENED_FOR_ERASE -> DEVICE_NOT_OPENED_FOR_ERASE
    int DEVICE_NOT_OPENED_FOR_WRITE -> DEVICE_NOT_OPENED_FOR_WRITE
    int FAILED_TO_WRITE_DEVICE -> FAILED_TO_WRITE_DEVICE
    int EEPROM_READ_FAILED -> EEPROM_READ_FAILED
    int EEPROM_WRITE_FAILED -> EEPROM_WRITE_FAILED
    int EEPROM_ERASE_FAILED -> EEPROM_ERASE_FAILED
    int EEPROM_NOT_PRESENT -> EEPROM_NOT_PRESENT
    int EEPROM_NOT_PROGRAMMED -> EEPROM_NOT_PROGRAMMED
    int INVALID_ARGS -> INVALID_ARGS
    int NOT_SUPPORTED -> NOT_SUPPORTED
    int OTHER_ERROR -> OTHER_ERROR
    int DEVICE_LIST_NOT_READY -> DEVICE_LIST_NOT_READY
    int OPEN_BY_SERIAL_NUMBER -> OPEN_BY_SERIAL_NUMBER
    int OPEN_BY_DESCRIPTION -> OPEN_BY_DESCRIPTION
    int OPEN_BY_LOCATION -> OPEN_BY_LOCATION
    int LIST_NUMBER_ONLY -> LIST_NUMBER_ONLY
    int LIST_BY_INDEX -> LIST_BY_INDEX
    int LIST_ALL -> LIST_ALL
    int LIST_MASK -> LIST_MASK
    int BAUD_300 -> BAUD_300
    int BAUD_600 -> BAUD_600
    int BAUD_1200 -> BAUD_1200
    int BAUD_2400 -> BAUD_2400
    int BAUD_4800 -> BAUD_4800
    int BAUD_9600 -> BAUD_9600
    int BAUD_14400 -> BAUD_14400
    int BAUD_19200 -> BAUD_19200
    int BAUD_38400 -> BAUD_38400
    int BAUD_57600 -> BAUD_57600
    int BAUD_115200 -> BAUD_115200
    int BAUD_230400 -> BAUD_230400
    int BAUD_460800 -> BAUD_460800
    int BAUD_921600 -> BAUD_921600
    int BITS_8 -> BITS_8
    int BITS_7 -> BITS_7
    int BITS_6 -> BITS_6
    int BITS_5 -> BITS_5
    int STOP_BITS_1 -> STOP_BITS_1
    int STOP_BITS_1_5 -> STOP_BITS_1_5
    int STOP_BITS_2 -> STOP_BITS_2
    int PARITY_NONE -> PARITY_NONE
    int PARITY_ODD -> PARITY_ODD
    int PARITY_EVEN -> PARITY_EVEN
    int PARITY_MARK -> PARITY_MARK
    int PARITY_SPACE -> PARITY_SPACE
    int FLOW_NONE -> FLOW_NONE
    int FLOW_RTS_CTS -> FLOW_RTS_CTS
    int FLOW_DTR_DSR -> FLOW_DTR_DSR
    int FLOW_XON_XOFF -> FLOW_XON_XOFF
    int PURGE_RX -> PURGE_RX
    int PURGE_TX -> PURGE_TX
    int EVENT_RXCHAR -> EVENT_RXCHAR
    int EVENT_MODEM_STATUS -> EVENT_MODEM_STATUS
    int EVENT_LINE_STATUS -> EVENT_LINE_STATUS
    int DEFAULT_RX_TIMEOUT -> DEFAULT_RX_TIMEOUT
    int DEFAULT_TX_TIMEOUT -> DEFAULT_TX_TIMEOUT
    int DEVICE_BM -> DEVICE_BM
    int DEVICE_AM -> DEVICE_AM
    int DEVICE_100AX -> DEVICE_100AX
    int DEVICE_UNKNOWN -> DEVICE_UNKNOWN
    int DEVICE_2232C -> DEVICE_2232C
    int DEVICE_232R -> DEVICE_232R
    int DEVICE_2232H -> DEVICE_2232H
    int DEVICE_4232H -> DEVICE_4232H
    int DEVICE_232H -> DEVICE_232H
    int FLAGS_OPENED -> FLAGS_OPENED
    int FLAGS_HISPEED -> FLAGS_HISPEED
    int BITMODE_RESET -> BITMODE_RESET
    int BITMODE_ASYNC_BITBANG -> BITMODE_ASYNC_BITBANG
    int BITMODE_MPSSE -> BITMODE_MPSSE
    int BITMODE_SYNC_BITBANG -> BITMODE_SYNC_BITBANG
    int BITMODE_MCU_HOST -> BITMODE_MCU_HOST
    int BITMODE_FAST_SERIAL -> BITMODE_FAST_SERIAL
    int BITMODE_CBUS_BITBANG -> BITMODE_CBUS_BITBANG
    int BITMODE_SYNC_FIFO -> BITMODE_SYNC_FIFO
    int FT232R_CBUS_TXDEN -> FT232R_CBUS_TXDEN
    int FT232R_CBUS_PWRON -> FT232R_CBUS_PWRON
    int FT232R_CBUS_RXLED -> FT232R_CBUS_RXLED
    int FT232R_CBUS_TXLED -> FT232R_CBUS_TXLED
    int FT232R_CBUS_TXRXLED -> FT232R_CBUS_TXRXLED
    int FT232R_CBUS_SLEEP -> FT232R_CBUS_SLEEP
    int FT232R_CBUS_CLK48 -> FT232R_CBUS_CLK48
    int FT232R_CBUS_CLK24 -> FT232R_CBUS_CLK24
    int FT232R_CBUS_CLK12 -> FT232R_CBUS_CLK12
    int FT232R_CBUS_CLK6 -> FT232R_CBUS_CLK6
    int FT232R_CBUS_IOMODE -> FT232R_CBUS_IOMODE
    int FT232R_CBUS_BITBANG_WR -> FT232R_CBUS_BITBANG_WR
    int FT232R_CBUS_BITBANG_RD -> FT232R_CBUS_BITBANG_RD
    int FT232H_CBUS_TRISTATE -> FT232H_CBUS_TRISTATE
    int FT232H_CBUS_TXLED -> FT232H_CBUS_TXLED
    int FT232H_CBUS_RXLED -> FT232H_CBUS_RXLED
    int FT232H_CBUS_TXRXLED -> FT232H_CBUS_TXRXLED
    int FT232H_CBUS_PWREN -> FT232H_CBUS_PWREN
    int FT232H_CBUS_SLEEP -> FT232H_CBUS_SLEEP
    int FT232H_CBUS_DRIVE_0 -> FT232H_CBUS_DRIVE_0
    int FT232H_CBUS_DRIVE_1 -> FT232H_CBUS_DRIVE_1
    int FT232H_CBUS_IOMODE -> FT232H_CBUS_IOMODE
    int FT232H_CBUS_TXDEN -> FT232H_CBUS_TXDEN
    int FT232H_CBUS_CLK30 -> FT232H_CBUS_CLK30
    int FT232H_CBUS_CLK15 -> FT232H_CBUS_CLK15
    int FT232H_CBUS_CLK7_5 -> FT232H_CBUS_CLK7_5
    int handle -> handle
    int event -> event
    int mask -> mask
    boolean kill -> kill
    jd2xx.JD2XXEventListener listener -> listener
    java.lang.Thread notifier -> notifier
    int getLibraryVersion() -> getLibraryVersion
    int createDeviceInfoList() -> createDeviceInfoList
    jd2xx.JD2XX$DeviceInfo getDeviceInfoDetail(int) -> getDeviceInfoDetail
    void open(int) -> open
    void close() -> close
    java.lang.Object[] listDevices(int) -> listDevices
    void openEx(java.lang.String,int) -> openEx
    void openEx(int,int) -> openEx
    int read(byte[],int,int) -> read
    int write(byte[],int,int) -> write
    void setBaudRate(int) -> setBaudRate
    void setDivisor(int) -> setDivisor
    void setDataCharacteristics(int,int,int) -> setDataCharacteristics
    void setFlowControl(int,int,int) -> setFlowControl
    void resetDevice() -> resetDevice
    void setDtr() -> setDtr
    void clrDtr() -> clrDtr
    void setRts() -> setRts
    void clrRts() -> clrRts
    int getModemStatus() -> getModemStatus
    void setChars(int,boolean,int,boolean) -> setChars
    void purge(int) -> purge
    void setTimeouts(int,int) -> setTimeouts
    int getQueueStatus() -> getQueueStatus
    void setBreakOn() -> setBreakOn
    void setBreakOff() -> setBreakOff
    int[] getStatus() -> getStatus
    void setEventNotification(int,int) -> setEventNotification
    void setWaitMask(int) -> setWaitMask
    int waitOnMask() -> waitOnMask
    int getEventStatus() -> getEventStatus
    short readEE(int) -> readEE
    void writeEE(int,short) -> writeEE
    void eraseEE() -> eraseEE
    void eeProgram(jd2xx.JD2XX$ProgramData) -> eeProgram
    void eeProgramEx(jd2xx.JD2XX$ProgramData,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> eeProgramEx
    jd2xx.JD2XX$ProgramData eeRead() -> eeRead
    jd2xx.JD2XX$ProgramData eeReadEx(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> eeReadEx
    int eeUASize() -> eeUASize
    void eeUAWrite(byte[]) -> eeUAWrite
    byte[] eeUARead(int) -> eeUARead
    void setLatencyTimer(int) -> setLatencyTimer
    int getLatencyTimer() -> getLatencyTimer
    void setBitMode(int,int) -> setBitMode
    int getBitMode() -> getBitMode
    void setUSBParameters(int,int) -> setUSBParameters
    void setDeadmanTimeout(int) -> setDeadmanTimeout
    jd2xx.JD2XX$DeviceInfo getDeviceInfo() -> getDeviceInfo
    void stopInTask() -> stopInTask
    void restartInTask() -> restartInTask
    void setResetPipeRetryCount(int) -> setResetPipeRetryCount
    void resetPort() -> resetPort
    void cyclePort() -> cyclePort
    int getDriverVersion() -> getDriverVersion
    void rescan() -> rescan
    void reload(int,int) -> reload
    int getComPortNumber() -> getComPortNumber
    int eeReadConfig(int) -> eeReadConfig
    void eeWriteConfig(int,int) -> eeWriteConfig
    int eeReadEcc(int) -> eeReadEcc
    int getQueueStatusEx() -> getQueueStatusEx
    void registerEvent(int) -> registerEvent
    void signalEvent() -> signalEvent
    int waitEvent() -> waitEvent
    void finalize() -> finalize
    void openBySerialNumber(java.lang.String) -> openBySerialNumber
    void openByDescription(java.lang.String) -> openByDescription
    void openByLocation(int) -> openByLocation
    java.lang.Object[] listDevicesBySerialNumber() -> listDevicesBySerialNumber
    java.lang.Object[] listDevicesByDescription() -> listDevicesByDescription
    java.lang.Object[] listDevicesByLocation() -> listDevicesByLocation
    java.lang.String read(int) -> read
    int read(byte[]) -> read
    int read() -> read
    int write(int) -> write
    int write(byte[]) -> write
    void addEventListener(jd2xx.JD2XXEventListener) -> addEventListener
    void removeEventListener() -> removeEventListener
    void dispatchEvent(int) -> dispatchEvent
    void notifyOnEvent(int,boolean) -> notifyOnEvent
    void notifyOnRxchar(boolean) -> notifyOnRxchar
    void notifyOnModemStatus(boolean) -> notifyOnModemStatus
    void run() -> run
    void main(java.lang.String[]) -> main
jd2xx.JD2XX$1 -> jd2xx.a:
    void jd2xxEvent(jd2xx.JD2XXEvent) -> jd2xxEvent
jd2xx.JD2XX$DeviceInfo -> jd2xx.JD2XX$DeviceInfo:
    int index -> index
    int flags -> flags
    int type -> type
    int id -> id
    int location -> location
    java.lang.String serial -> serial
    java.lang.String description -> description
    int handle -> handle
    java.lang.String toString() -> toString
jd2xx.JD2XX$ProgramData -> jd2xx.JD2XX$ProgramData:
    int signature1 -> signature1
    int signature2 -> signature2
    int version -> version
    int vendorID -> vendorID
    int productID -> productID
    java.lang.String manufacturer -> manufacturer
    java.lang.String manufacturerID -> manufacturerID
    java.lang.String description -> description
    java.lang.String serialNumber -> serialNumber
    int maxPower -> maxPower
    boolean pnp -> pnp
    boolean selfPowered -> selfPowered
    boolean remoteWakeup -> remoteWakeup
    boolean rev4 -> rev4
    boolean isoIn -> isoIn
    boolean isoOut -> isoOut
    boolean pullDownEnable -> pullDownEnable
    boolean serNumEnable -> serNumEnable
    boolean usbVersionEnable -> usbVersionEnable
    int usbVersion -> usbVersion
    boolean rev5 -> rev5
    boolean isoInA -> isoInA
    boolean isoInB -> isoInB
    boolean isoOutA -> isoOutA
    boolean isoOutB -> isoOutB
    boolean pullDownEnable5 -> pullDownEnable5
    boolean serNumEnable5 -> serNumEnable5
    boolean usbVersionEnable5 -> usbVersionEnable5
    int usbVersion5 -> usbVersion5
    boolean aIsHighCurrent -> aIsHighCurrent
    boolean bIsHighCurrent -> bIsHighCurrent
    boolean ifAIsFifo -> ifAIsFifo
    boolean ifAIsFifoTar -> ifAIsFifoTar
    boolean ifAIsFastSer -> ifAIsFastSer
    boolean aIsVCP -> aIsVCP
    boolean ifBIsFifo -> ifBIsFifo
    boolean ifBIsFifoTar -> ifBIsFifoTar
    boolean ifBIsFastSer -> ifBIsFastSer
    boolean bIsVCP -> bIsVCP
    boolean useExtOsc -> useExtOsc
    boolean highDriveIOs -> highDriveIOs
    int endpointSize -> endpointSize
    boolean pullDownEnableR -> pullDownEnableR
    boolean serNumEnableR -> serNumEnableR
    boolean invertTXD -> invertTXD
    boolean invertRXD -> invertRXD
    boolean invertRTS -> invertRTS
    boolean invertCTS -> invertCTS
    boolean invertDTR -> invertDTR
    boolean invertDSR -> invertDSR
    boolean invertDCD -> invertDCD
    boolean invertRI -> invertRI
    int cbus0 -> cbus0
    int cbus1 -> cbus1
    int cbus2 -> cbus2
    int cbus3 -> cbus3
    int cbus4 -> cbus4
    boolean rIsD2XX -> rIsD2XX
    boolean pullDownEnable7 -> pullDownEnable7
    boolean serNumEnable7 -> serNumEnable7
    boolean alSlowSlew -> alSlowSlew
    boolean alSchmittInput -> alSchmittInput
    int alDriveCurrent -> alDriveCurrent
    boolean ahSlowSlew -> ahSlowSlew
    boolean ahSchmittInput -> ahSchmittInput
    int ahDriveCurrent -> ahDriveCurrent
    boolean blSlowSlew -> blSlowSlew
    boolean blSchmittInput -> blSchmittInput
    int blDriveCurrent -> blDriveCurrent
    boolean bhSlowSlew -> bhSlowSlew
    boolean bhSchmittInput -> bhSchmittInput
    int bhDriveCurrent -> bhDriveCurrent
    boolean ifAIsFifo7 -> ifAIsFifo7
    boolean ifAIsFifoTar7 -> ifAIsFifoTar7
    boolean ifAIsFastSer7 -> ifAIsFastSer7
    boolean aIsVCP7 -> aIsVCP7
    boolean ifBIsFifo7 -> ifBIsFifo7
    boolean ifBIsFifoTar7 -> ifBIsFifoTar7
    boolean ifBIsFastSer7 -> ifBIsFastSer7
    boolean bIsVCP7 -> bIsVCP7
    boolean powerSaveEnable -> powerSaveEnable
    boolean pullDownEnable8 -> pullDownEnable8
    boolean serNumEnable8 -> serNumEnable8
    boolean aSlowSlew -> aSlowSlew
    boolean aSchmittInput -> aSchmittInput
    int aDriveCurrent -> aDriveCurrent
    boolean bSlowSlew -> bSlowSlew
    boolean bSchmittInput -> bSchmittInput
    int bDriveCurrent -> bDriveCurrent
    boolean cSlowSlew -> cSlowSlew
    boolean cSchmittInput -> cSchmittInput
    int cDriveCurrent -> cDriveCurrent
    boolean dSlowSlew -> dSlowSlew
    boolean dSchmittInput -> dSchmittInput
    int dDriveCurrent -> dDriveCurrent
    boolean aRIIsTXDEN -> aRIIsTXDEN
    boolean bRIIsTXDEN -> bRIIsTXDEN
    boolean cRIIsTXDEN -> cRIIsTXDEN
    boolean dRIIsTXDEN -> dRIIsTXDEN
    boolean aIsVCP8 -> aIsVCP8
    boolean bIsVCP8 -> bIsVCP8
    boolean cIsVCP8 -> cIsVCP8
    boolean dIsVCP8 -> dIsVCP8
    boolean pullDownEnableH -> pullDownEnableH
    boolean serNumEnableH -> serNumEnableH
    boolean acSlowSlewH -> acSlowSlewH
    boolean acSchmittInputH -> acSchmittInputH
    int acDriveCurrentH -> acDriveCurrentH
    boolean adSlowSlewH -> adSlowSlewH
    boolean adSchmittInputH -> adSchmittInputH
    int adDriveCurrentH -> adDriveCurrentH
    int cbus0H -> cbus0H
    int cbus1H -> cbus1H
    int cbus2H -> cbus2H
    int cbus3H -> cbus3H
    int cbus4H -> cbus4H
    int cbus5H -> cbus5H
    int cbus6H -> cbus6H
    int cbus7H -> cbus7H
    int cbus8H -> cbus8H
    int cbus9H -> cbus9H
    boolean isFifoH -> isFifoH
    boolean isFifoTarH -> isFifoTarH
    boolean isFastSerH -> isFastSerH
    boolean isFt1248H -> isFt1248H
    boolean ft1248CpolH -> ft1248CpolH
    boolean ft1248LsbH -> ft1248LsbH
    boolean ft1248FlowControlH -> ft1248FlowControlH
    boolean isVCPH -> isVCPH
    boolean powerSaveEnableH -> powerSaveEnableH
    java.lang.String toString() -> toString
jd2xx.JD2XXEvent -> jd2xx.JD2XXEvent:
    int EVENT_RXCHAR -> EVENT_RXCHAR
    int EVENT_MODEM_STATUS -> EVENT_MODEM_STATUS
    int eventType -> eventType
    int getEventType() -> getEventType
jd2xx.JD2XXEventListener -> jd2xx.JD2XXEventListener:
    void jd2xxEvent(jd2xx.JD2XXEvent) -> jd2xxEvent
jd2xx.JD2XXInputStream -> jd2xx.JD2XXInputStream:
    jd2xx.JD2XX jd2xx -> jd2xx
    void close() -> close
    int read() -> read
    int read(byte[]) -> read
jd2xx.JD2XXOutputStream -> jd2xx.JD2XXOutputStream:
    jd2xx.JD2XX jd2xx -> jd2xx
    void close() -> close
    void write(int) -> write
    void write(byte[]) -> write
org.OpenNI.ActiveHandDirectionEventArgs -> org.OpenNI.ActiveHandDirectionEventArgs:
    int id -> id
    org.OpenNI.Point3D position -> position
    float time -> time
    org.OpenNI.Direction direction -> direction
    int getId() -> getId
    org.OpenNI.Point3D getPosition() -> getPosition
    float getTime() -> getTime
    org.OpenNI.Direction getDirection() -> getDirection
org.OpenNI.ActiveHandEventArgs -> org.OpenNI.ActiveHandEventArgs:
    int id -> id
    org.OpenNI.Point3D position -> position
    float time -> time
    int getId() -> getId
    org.OpenNI.Point3D getPosition() -> getPosition
    float getTime() -> getTime
org.OpenNI.AlternativeViewpointCapability -> org.OpenNI.AlternativeViewpointCapability:
    org.OpenNI.StateChangedObservable viewPointChanged -> viewPointChanged
    boolean isViewpointSupported(org.OpenNI.ProductionNode) -> isViewpointSupported
    void setViewpoint(org.OpenNI.ProductionNode) -> setViewpoint
    void resetViewpoint() -> resetViewpoint
    boolean isViewpointAs(org.OpenNI.ProductionNode) -> isViewpointAs
    org.OpenNI.IStateChangedObservable getViewPointChangedEvent() -> getViewPointChangedEvent
org.OpenNI.AlternativeViewpointCapability$1 -> org.OpenNI.AlternativeViewpointCapability$1:
    org.OpenNI.AlternativeViewpointCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.AntiFlickerCapability -> org.OpenNI.AntiFlickerCapability:
    org.OpenNI.StateChangedObservable powerLineFrequencyChanged -> powerLineFrequencyChanged
    org.OpenNI.PowerLineFrequency getPowerLineFrequency() -> getPowerLineFrequency
    void setPowerLineFrequency(org.OpenNI.PowerLineFrequency) -> setPowerLineFrequency
    org.OpenNI.IStateChangedObservable getPowerLineFrequencyChangedEvent() -> getPowerLineFrequencyChangedEvent
org.OpenNI.AntiFlickerCapability$1 -> org.OpenNI.AntiFlickerCapability$1:
    org.OpenNI.AntiFlickerCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.AudioGenerator -> org.OpenNI.AudioGenerator:
    org.OpenNI.StateChangedObservable waveOutputModeChanged -> waveOutputModeChanged
    org.OpenNI.AudioGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.AudioGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.AudioGenerator create(org.OpenNI.Context) -> create
    org.OpenNI.WaveOutputMode[] getSupportedMapOutputModes() -> getSupportedMapOutputModes
    org.OpenNI.WaveOutputMode getWaveOutputMode() -> getWaveOutputMode
    void setWaveOutputMode(org.OpenNI.WaveOutputMode) -> setWaveOutputMode
    org.OpenNI.IStateChangedObservable getMapOutputModeChangedEvent() -> getMapOutputModeChangedEvent
    void getMetaData(org.OpenNI.AudioMetaData) -> getMetaData
    org.OpenNI.AudioMetaData getMetaData() -> getMetaData
org.OpenNI.AudioGenerator$1 -> org.OpenNI.AudioGenerator$1:
    org.OpenNI.AudioGenerator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.AudioMetaData -> org.OpenNI.AudioMetaData:
    int sampleRate -> sampleRate
    short bitsPerSample -> bitsPerSample
    byte numberOfChannels -> numberOfChannels
    int getSampleRate() -> getSampleRate
    void setSampleRate(int) -> setSampleRate
    short getBitsPerSample() -> getBitsPerSample
    void setBitsPerSample(short) -> setBitsPerSample
    byte getNumberOfChannels() -> getNumberOfChannels
    void setNumberOfChannels(byte) -> setNumberOfChannels
    java.nio.ByteBuffer createByteBuffer() -> createByteBuffer
org.OpenNI.BoundingBox3D -> org.OpenNI.BoundingBox3D:
    org.OpenNI.Point3D leftBottomNear -> leftBottomNear
    org.OpenNI.Point3D rightTopFar -> rightTopFar
    org.OpenNI.Point3D getLeftBottomNear() -> getLeftBottomNear
    org.OpenNI.Point3D getRightTopFar() -> getRightTopFar
    org.OpenNI.Point3D getMins() -> getMins
    org.OpenNI.Point3D getMaxs() -> getMaxs
org.OpenNI.CalibrationProgressEventArgs -> org.OpenNI.CalibrationProgressEventArgs:
    int user -> user
    org.OpenNI.CalibrationProgressStatus state -> state
    int getUser() -> getUser
    org.OpenNI.CalibrationProgressStatus getStatus() -> getStatus
org.OpenNI.CalibrationProgressStatus -> org.OpenNI.CalibrationProgressStatus:
    org.OpenNI.CalibrationProgressStatus OK -> OK
    org.OpenNI.CalibrationProgressStatus NO_USER -> NO_USER
    org.OpenNI.CalibrationProgressStatus ARM -> ARM
    org.OpenNI.CalibrationProgressStatus LEG -> LEG
    org.OpenNI.CalibrationProgressStatus HEAD -> HEAD
    org.OpenNI.CalibrationProgressStatus TORSO -> TORSO
    org.OpenNI.CalibrationProgressStatus TOP_FOV -> TOP_FOV
    org.OpenNI.CalibrationProgressStatus SIDE_FOV -> SIDE_FOV
    org.OpenNI.CalibrationProgressStatus POSE -> POSE
    org.OpenNI.CalibrationProgressStatus MANUAL_ABORT -> MANUAL_ABORT
    org.OpenNI.CalibrationProgressStatus MANUAL_RESET -> MANUAL_RESET
    org.OpenNI.CalibrationProgressStatus TIMEOUT_FAIL -> TIMEOUT_FAIL
    int val -> val
    org.OpenNI.CalibrationProgressStatus[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.CalibrationProgressStatus fromNative(int) -> fromNative
    org.OpenNI.CalibrationProgressStatus[] values() -> values
    org.OpenNI.CalibrationProgressStatus valueOf(java.lang.String) -> valueOf
org.OpenNI.CalibrationStartEventArgs -> org.OpenNI.CalibrationStartEventArgs:
    int user -> user
    int getUser() -> getUser
org.OpenNI.Capability -> org.OpenNI.Capability:
    org.OpenNI.Capability ExtendedSerialization -> ExtendedSerialization
    org.OpenNI.Capability Mirror -> Mirror
    org.OpenNI.Capability AlternativeViewPoint -> AlternativeViewPoint
    org.OpenNI.Capability Cropping -> Cropping
    org.OpenNI.Capability UserPosition -> UserPosition
    org.OpenNI.Capability Skeleton -> Skeleton
    org.OpenNI.Capability PoseDetection -> PoseDetection
    org.OpenNI.Capability LockAware -> LockAware
    org.OpenNI.Capability ErrorState -> ErrorState
    org.OpenNI.Capability FrameSync -> FrameSync
    org.OpenNI.Capability DeviceIdentification -> DeviceIdentification
    org.OpenNI.Capability Brightness -> Brightness
    org.OpenNI.Capability Contrast -> Contrast
    org.OpenNI.Capability Hue -> Hue
    org.OpenNI.Capability Saturation -> Saturation
    org.OpenNI.Capability Sharpness -> Sharpness
    org.OpenNI.Capability Gamma -> Gamma
    org.OpenNI.Capability WhiteBalance -> WhiteBalance
    org.OpenNI.Capability BacklightCompensation -> BacklightCompensation
    org.OpenNI.Capability Gain -> Gain
    org.OpenNI.Capability Pan -> Pan
    org.OpenNI.Capability Tilt -> Tilt
    org.OpenNI.Capability Roll -> Roll
    org.OpenNI.Capability Zoom -> Zoom
    org.OpenNI.Capability Exposure -> Exposure
    org.OpenNI.Capability Iris -> Iris
    org.OpenNI.Capability Focus -> Focus
    org.OpenNI.Capability LowLightCompensation -> LowLightCompensation
    org.OpenNI.Capability AntiFlicker -> AntiFlicker
    java.lang.String name -> name
    org.OpenNI.Capability[] ENUM$VALUES -> ENUM$VALUES
    java.lang.String getName() -> getName
    org.OpenNI.Capability[] values() -> values
    org.OpenNI.Capability valueOf(java.lang.String) -> valueOf
org.OpenNI.CapabilityBase -> org.OpenNI.CapabilityBase:
    org.OpenNI.ProductionNode node -> node
org.OpenNI.Codec -> org.OpenNI.Codec:
    org.OpenNI.Codec create(org.OpenNI.Context,org.OpenNI.CodecID,org.OpenNI.ProductionNode) -> create
    org.OpenNI.CodecID getCodecID() -> getCodecID
    int EncodeData(long,int,long,int) -> EncodeData
    int DecodeData(long,int,long,int) -> DecodeData
org.OpenNI.CodecID -> org.OpenNI.CodecID:
    org.OpenNI.CodecID Null -> Null
    org.OpenNI.CodecID Uncompressed -> Uncompressed
    org.OpenNI.CodecID Jpeg -> Jpeg
    org.OpenNI.CodecID Z16 -> Z16
    org.OpenNI.CodecID Z16WithTables -> Z16WithTables
    org.OpenNI.CodecID Z8 -> Z8
    int value -> value
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int toNative() -> toNative
org.OpenNI.Context -> org.OpenNI.Context:
    org.OpenNI.Observable errorStateChangedEvent -> errorStateChangedEvent
    java.util.Hashtable allNodes -> allNodes
    java.util.Hashtable allContexts -> allContexts
    org.OpenNI.Context createFromXmlFile(java.lang.String,org.OpenNI.OutArg) -> createFromXmlFile
    org.OpenNI.Context fromNative(long) -> fromNative
    org.OpenNI.Version getVersion() -> getVersion
    org.OpenNI.ScriptNode runXmlScriptFromFile(java.lang.String) -> runXmlScriptFromFile
    org.OpenNI.ScriptNode runXmlScript(java.lang.String) -> runXmlScript
    org.OpenNI.Player openFileRecordingEx(java.lang.String) -> openFileRecordingEx
    void release() -> release
    void addLicense(org.OpenNI.License) -> addLicense
    org.OpenNI.License[] enumerateLicenses() -> enumerateLicenses
    org.OpenNI.NodeInfoList enumerateProductionTrees(org.OpenNI.NodeType,org.OpenNI.Query) -> enumerateProductionTrees
    org.OpenNI.NodeInfoList enumerateProductionTrees(org.OpenNI.NodeType) -> enumerateProductionTrees
    org.OpenNI.ProductionNode createProductionTree(org.OpenNI.NodeInfo) -> createProductionTree
    org.OpenNI.ProductionNode createAnyProductionTree(org.OpenNI.NodeType,org.OpenNI.Query) -> createAnyProductionTree
    org.OpenNI.NodeInfoList enumerateExistingNodes() -> enumerateExistingNodes
    org.OpenNI.NodeInfoList enumerateExistingNodes(org.OpenNI.NodeType) -> enumerateExistingNodes
    org.OpenNI.ProductionNode findExistingNode(org.OpenNI.NodeType) -> findExistingNode
    org.OpenNI.ProductionNode getProductionNodeByName(java.lang.String) -> getProductionNodeByName
    org.OpenNI.NodeInfo getProductionNodeInfoByName(java.lang.String) -> getProductionNodeInfoByName
    void startGeneratingAll() -> startGeneratingAll
    void stopGeneratingAll() -> stopGeneratingAll
    boolean getGlobalMirror() -> getGlobalMirror
    void setGlobalMirror(boolean) -> setGlobalMirror
    void waitAndUpdateAll() -> waitAndUpdateAll
    void waitOneUpdateAll(org.OpenNI.ProductionNode) -> waitOneUpdateAll
    void waitAnyUpdateAll() -> waitAnyUpdateAll
    void waitNoneUpdateAll() -> waitNoneUpdateAll
    org.OpenNI.IObservable getErrorStateChangedEvent() -> getErrorStateChangedEvent
    org.OpenNI.ProductionNode createProductionNodeFromNative(long) -> createProductionNodeFromNative
    void freeObject(long) -> freeObject
    long init() -> init
    long initFromXmlEx(java.lang.String,org.OpenNI.OutArg) -> initFromXmlEx
    org.OpenNI.ProductionNode createProductionNodeObject(long,org.OpenNI.NodeType) -> createProductionNodeObject
    org.OpenNI.ProductionNode createProductionNodeObject(long) -> createProductionNodeObject
org.OpenNI.Context$1 -> org.OpenNI.Context$1:
    org.OpenNI.Context this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.Cropping -> org.OpenNI.Cropping:
    int xOffset -> xOffset
    int yOffset -> yOffset
    int xSize -> xSize
    int ySize -> ySize
    boolean enabled -> enabled
    int getXOffset() -> getXOffset
    void setXOffset(int) -> setXOffset
    int getYOffset() -> getYOffset
    void setYOffset(int) -> setYOffset
    int getXSize() -> getXSize
    void setXSize(int) -> setXSize
    int getYSize() -> getYSize
    void setYSize(int) -> setYSize
    boolean isEnabled() -> isEnabled
    void setEnabled(boolean) -> setEnabled
org.OpenNI.CroppingCapability -> org.OpenNI.CroppingCapability:
    org.OpenNI.StateChangedObservable croppingChanged -> croppingChanged
    void setCropping(org.OpenNI.Cropping) -> setCropping
    org.OpenNI.Cropping getCropping() -> getCropping
    org.OpenNI.IStateChangedObservable getCroppingChangedEvent() -> getCroppingChangedEvent
org.OpenNI.CroppingCapability$1 -> org.OpenNI.CroppingCapability$1:
    org.OpenNI.CroppingCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.DepthGenerator -> org.OpenNI.DepthGenerator:
    org.OpenNI.StateChangedObservable fovChanged -> fovChanged
    org.OpenNI.DepthMap currDepthMap -> currDepthMap
    int currDepthMapFrameID -> currDepthMapFrameID
    org.OpenNI.DepthGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.DepthGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.DepthGenerator create(org.OpenNI.Context) -> create
    org.OpenNI.DepthMap getDepthMap() -> getDepthMap
    int getDeviceMaxDepth() -> getDeviceMaxDepth
    org.OpenNI.FieldOfView getFieldOfView() -> getFieldOfView
    org.OpenNI.IStateChangedObservable getFieldOfViewChangedEvent() -> getFieldOfViewChangedEvent
    org.OpenNI.Point3D[] convertProjectiveToRealWorld(org.OpenNI.Point3D[]) -> convertProjectiveToRealWorld
    org.OpenNI.Point3D convertProjectiveToRealWorld(org.OpenNI.Point3D) -> convertProjectiveToRealWorld
    org.OpenNI.Point3D[] convertRealWorldToProjective(org.OpenNI.Point3D[]) -> convertRealWorldToProjective
    org.OpenNI.Point3D convertRealWorldToProjective(org.OpenNI.Point3D) -> convertRealWorldToProjective
    org.OpenNI.UserPositionCapability getUserPositionCapability() -> getUserPositionCapability
    void getMetaData(org.OpenNI.DepthMetaData) -> getMetaData
    org.OpenNI.DepthMetaData getMetaData() -> getMetaData
org.OpenNI.DepthGenerator$1 -> org.OpenNI.DepthGenerator$1:
    org.OpenNI.DepthGenerator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.DepthMap -> org.OpenNI.DepthMap:
org.OpenNI.DepthMetaData -> org.OpenNI.DepthMetaData:
    int zRes -> zRes
    int getZRes() -> getZRes
    void setZRes(int) -> setZRes
    org.OpenNI.DepthMap getData() -> getData
    org.OpenNI.Map getData() -> getData
org.OpenNI.Device -> org.OpenNI.Device:
    org.OpenNI.Device create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.Device create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.Device create(org.OpenNI.Context) -> create
    org.OpenNI.DeviceIdentificationCapability getDeviceIdentificationCapability() -> getDeviceIdentificationCapability
org.OpenNI.DeviceIdentificationCapability -> org.OpenNI.DeviceIdentificationCapability:
    java.lang.String getDeviceName() -> getDeviceName
    java.lang.String getVendorSpecificData() -> getVendorSpecificData
    java.lang.String getSerialNumber() -> getSerialNumber
org.OpenNI.Direction -> org.OpenNI.Direction:
    org.OpenNI.Direction ILLEGAL -> ILLEGAL
    org.OpenNI.Direction LEFT -> LEFT
    org.OpenNI.Direction RIGHT -> RIGHT
    org.OpenNI.Direction UP -> UP
    org.OpenNI.Direction DOWN -> DOWN
    org.OpenNI.Direction FORWARD -> FORWARD
    org.OpenNI.Direction BACKWARD -> BACKWARD
    int val -> val
    org.OpenNI.Direction[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.Direction fromNative(int) -> fromNative
    org.OpenNI.Direction[] values() -> values
    org.OpenNI.Direction valueOf(java.lang.String) -> valueOf
org.OpenNI.EnumerationErrors -> org.OpenNI.EnumerationErrors:
    boolean isEmpty() -> isEmpty
    java.lang.String toString() -> toString
    void freeObject(long) -> freeObject
    long create() -> create
org.OpenNI.ErrorStateCapability -> org.OpenNI.ErrorStateCapability:
    org.OpenNI.StateChangedObservable errorStateChanged -> errorStateChanged
    java.lang.String getErrorState() -> getErrorState
    org.OpenNI.IStateChangedObservable getErrorStateChangedEvent() -> getErrorStateChangedEvent
org.OpenNI.ErrorStateCapability$1 -> org.OpenNI.ErrorStateCapability$1:
    org.OpenNI.ErrorStateCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.ErrorStateEventArgs -> org.OpenNI.ErrorStateEventArgs:
    java.lang.String currError -> currError
    java.lang.String getCurrentError() -> getCurrentError
org.OpenNI.EventArgs -> org.OpenNI.EventArgs:
org.OpenNI.FieldOfView -> org.OpenNI.FieldOfView:
    double hFOV -> hFOV
    double vFOV -> vFOV
    double getHFOV() -> getHFOV
    void setHFOV(double) -> setHFOV
    double getVFOV() -> getVFOV
    void setVFOV(double) -> setVFOV
org.OpenNI.FrameSyncCapability -> org.OpenNI.FrameSyncCapability:
    org.OpenNI.StateChangedObservable frameSyncChanged -> frameSyncChanged
    boolean canFrameSyncWith(org.OpenNI.Generator) -> canFrameSyncWith
    void frameSyncWith(org.OpenNI.Generator) -> frameSyncWith
    void stopFrameSyncWith(org.OpenNI.Generator) -> stopFrameSyncWith
    boolean isFrameSyncedWith(org.OpenNI.Generator) -> isFrameSyncedWith
    org.OpenNI.IStateChangedObservable getFrameSyncChangedEvent() -> getFrameSyncChangedEvent
org.OpenNI.FrameSyncCapability$1 -> org.OpenNI.FrameSyncCapability$1:
    org.OpenNI.FrameSyncCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.GeneralException -> org.OpenNI.GeneralException:
    long serialVersionUID -> serialVersionUID
org.OpenNI.GeneralIntCapability -> org.OpenNI.GeneralIntCapability:
    org.OpenNI.StateChangedObservable valueChanged -> valueChanged
    java.lang.String capName -> capName
    int min -> min
    int max -> max
    int step -> step
    int defaultVal -> defaultVal
    boolean autoSupported -> autoSupported
    int getMin() -> getMin
    int getMax() -> getMax
    int getStep() -> getStep
    int getDefault() -> getDefault
    boolean isAutoSupported() -> isAutoSupported
    int getValue() -> getValue
    void setValue(int) -> setValue
    org.OpenNI.IStateChangedObservable getValueChangedEvent() -> getValueChangedEvent
    java.lang.String getCapName() -> getCapName
org.OpenNI.GeneralIntCapability$1 -> org.OpenNI.GeneralIntCapability$1:
    org.OpenNI.GeneralIntCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.Generator -> org.OpenNI.Generator:
    org.OpenNI.StateChangedObservable generationRunningChanged -> generationRunningChanged
    org.OpenNI.StateChangedObservable newDataAvailable -> newDataAvailable
    void startGenerating() -> startGenerating
    boolean isGenerating() -> isGenerating
    void stopGenerating() -> stopGenerating
    org.OpenNI.IStateChangedObservable getGenerationRunningChangedEvent() -> getGenerationRunningChangedEvent
    boolean isNewDataAvailable() -> isNewDataAvailable
    long getAvailableTimestamp() -> getAvailableTimestamp
    org.OpenNI.IStateChangedObservable getNewDataAvailableEvent() -> getNewDataAvailableEvent
    void waitAndUpdateData() -> waitAndUpdateData
    boolean isDataNew() -> isDataNew
    int getDataSize() -> getDataSize
    long getDataPtr() -> getDataPtr
    java.nio.ByteBuffer createDataByteBuffer() -> createDataByteBuffer
    void copyDataToBuffer(java.nio.ByteBuffer,int) -> copyDataToBuffer
    long getTimestamp() -> getTimestamp
    int getFrameID() -> getFrameID
    org.OpenNI.MirrorCapability getMirrorCapability() -> getMirrorCapability
    org.OpenNI.AlternativeViewpointCapability getAlternativeViewpointCapability() -> getAlternativeViewpointCapability
    org.OpenNI.FrameSyncCapability getFrameSyncCapability() -> getFrameSyncCapability
org.OpenNI.Generator$1 -> org.OpenNI.Generator$1:
    org.OpenNI.Generator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.Generator$2 -> org.OpenNI.Generator$2:
    org.OpenNI.Generator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.GestureGenerator -> org.OpenNI.GestureGenerator:
    org.OpenNI.Observable gestureRecognizedEvent -> gestureRecognizedEvent
    org.OpenNI.Observable gestureProgressEvent -> gestureProgressEvent
    org.OpenNI.Observable gestureIntermediateStageCompletedEvent -> gestureIntermediateStageCompletedEvent
    org.OpenNI.Observable gestureReadyForNextIntermediateStageEvent -> gestureReadyForNextIntermediateStageEvent
    org.OpenNI.StateChangedObservable gestureChangedEvent -> gestureChangedEvent
    org.OpenNI.GestureGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.GestureGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.GestureGenerator create(org.OpenNI.Context) -> create
    void addGesture(java.lang.String) -> addGesture
    void addGesture(java.lang.String,org.OpenNI.BoundingBox3D) -> addGesture
    void removeGesture(java.lang.String) -> removeGesture
    int getNumberOfAvailableGestures() -> getNumberOfAvailableGestures
    boolean isGestureAvailable(java.lang.String) -> isGestureAvailable
    boolean isGestureProgressSupported(java.lang.String) -> isGestureProgressSupported
    java.lang.String[] enumerateAllGestures() -> enumerateAllGestures
    java.lang.String[] getAllActiveGestures() -> getAllActiveGestures
    org.OpenNI.IObservable getGestureRecognizedEvent() -> getGestureRecognizedEvent
    org.OpenNI.IObservable getGestureProgressEvent() -> getGestureProgressEvent
    org.OpenNI.IObservable getGestureIntermediateStageCompletedEvent() -> getGestureIntermediateStageCompletedEvent
    org.OpenNI.IObservable getGestureReadyForNextIntermediateStageEvent() -> getGestureReadyForNextIntermediateStageEvent
    org.OpenNI.IStateChangedObservable getGestureChangedEvent() -> getGestureChangedEvent
org.OpenNI.GestureGenerator$1 -> org.OpenNI.GestureGenerator$1:
    org.OpenNI.GestureGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,org.OpenNI.Point3D,org.OpenNI.Point3D) -> callback
org.OpenNI.GestureGenerator$2 -> org.OpenNI.GestureGenerator$2:
    org.OpenNI.GestureGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,org.OpenNI.Point3D,float) -> callback
org.OpenNI.GestureGenerator$3 -> org.OpenNI.GestureGenerator$3:
    org.OpenNI.GestureGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,org.OpenNI.Point3D) -> callback
org.OpenNI.GestureGenerator$4 -> org.OpenNI.GestureGenerator$4:
    org.OpenNI.GestureGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,org.OpenNI.Point3D) -> callback
org.OpenNI.GestureGenerator$5 -> org.OpenNI.GestureGenerator$5:
    org.OpenNI.GestureGenerator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.GesturePositionEventArgs -> org.OpenNI.GesturePositionEventArgs:
    java.lang.String gesture -> gesture
    org.OpenNI.Point3D position -> position
    java.lang.String getGesture() -> getGesture
    org.OpenNI.Point3D getPosition() -> getPosition
org.OpenNI.GestureProgressEventArgs -> org.OpenNI.GestureProgressEventArgs:
    java.lang.String gesture -> gesture
    org.OpenNI.Point3D position -> position
    float progress -> progress
    java.lang.String getGesture() -> getGesture
    org.OpenNI.Point3D getPosition() -> getPosition
    float getProgress() -> getProgress
org.OpenNI.GestureRecognizedEventArgs -> org.OpenNI.GestureRecognizedEventArgs:
    java.lang.String gesture -> gesture
    org.OpenNI.Point3D idPosition -> idPosition
    org.OpenNI.Point3D endPosition -> endPosition
    java.lang.String getGesture() -> getGesture
    org.OpenNI.Point3D getIdPosition() -> getIdPosition
    org.OpenNI.Point3D getEndPosition() -> getEndPosition
org.OpenNI.HandTouchingFOVEdgeCapability -> org.OpenNI.HandTouchingFOVEdgeCapability:
    org.OpenNI.Observable handTouchingFOVEdgeEvent -> handTouchingFOVEdgeEvent
    org.OpenNI.IObservable getHandTouchingFOVEdgeEvent() -> getHandTouchingFOVEdgeEvent
org.OpenNI.HandTouchingFOVEdgeCapability$1 -> org.OpenNI.HandTouchingFOVEdgeCapability$1:
    org.OpenNI.HandTouchingFOVEdgeCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,org.OpenNI.Point3D,float,int) -> callback
org.OpenNI.HandleWrapper -> org.OpenNI.HandleWrapper:
    int handle -> handle
    int toNative() -> toNative
org.OpenNI.HandsGenerator -> org.OpenNI.HandsGenerator:
    org.OpenNI.Observable handCreateEvent -> handCreateEvent
    org.OpenNI.Observable handUpdateEvent -> handUpdateEvent
    org.OpenNI.Observable handDestroyEvent -> handDestroyEvent
    org.OpenNI.HandsGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.HandsGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.HandsGenerator create(org.OpenNI.Context) -> create
    void StopTracking(int) -> StopTracking
    void StopTrackingAll() -> StopTrackingAll
    void StartTracking(org.OpenNI.Point3D) -> StartTracking
    void SetSmoothing(float) -> SetSmoothing
    org.OpenNI.HandTouchingFOVEdgeCapability getHandTouchingFOVEdgeCapability() -> getHandTouchingFOVEdgeCapability
    org.OpenNI.IObservable getHandCreateEvent() -> getHandCreateEvent
    org.OpenNI.IObservable getHandUpdateEvent() -> getHandUpdateEvent
    org.OpenNI.IObservable getHandDestroyEvent() -> getHandDestroyEvent
org.OpenNI.HandsGenerator$1 -> org.OpenNI.HandsGenerator$1:
    org.OpenNI.HandsGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,org.OpenNI.Point3D,float) -> callback
org.OpenNI.HandsGenerator$2 -> org.OpenNI.HandsGenerator$2:
    org.OpenNI.HandsGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,org.OpenNI.Point3D,float) -> callback
org.OpenNI.HandsGenerator$3 -> org.OpenNI.HandsGenerator$3:
    org.OpenNI.HandsGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,float) -> callback
org.OpenNI.IObservable -> org.OpenNI.IObservable:
    void addObserver(org.OpenNI.IObserver) -> addObserver
    void deleteObserver(org.OpenNI.IObserver) -> deleteObserver
org.OpenNI.IObserver -> org.OpenNI.IObserver:
    void update(org.OpenNI.IObservable,java.lang.Object) -> update
org.OpenNI.IRGenerator -> org.OpenNI.IRGenerator:
    org.OpenNI.IRMap currIRMap -> currIRMap
    int currIRMapFrameID -> currIRMapFrameID
    org.OpenNI.IRGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.IRGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.IRGenerator create(org.OpenNI.Context) -> create
    org.OpenNI.IRMap getIRMap() -> getIRMap
    void getMetaData(org.OpenNI.IRMetaData) -> getMetaData
    org.OpenNI.IRMetaData getMetaData() -> getMetaData
org.OpenNI.IRMap -> org.OpenNI.IRMap:
org.OpenNI.IRMetaData -> org.OpenNI.IRMetaData:
    org.OpenNI.IRMap getData() -> getData
    org.OpenNI.Map getData() -> getData
org.OpenNI.IStateChangedObservable -> org.OpenNI.IStateChangedObservable:
org.OpenNI.ImageGenerator -> org.OpenNI.ImageGenerator:
    org.OpenNI.ImageMap currImageMap -> currImageMap
    int currImageMapFrameID -> currImageMapFrameID
    org.OpenNI.StateChangedObservable pixelFormatChanged -> pixelFormatChanged
    org.OpenNI.ImageGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.ImageGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.ImageGenerator create(org.OpenNI.Context) -> create
    boolean isPixelFormatSupported(org.OpenNI.PixelFormat) -> isPixelFormatSupported
    void setPixelFormat(org.OpenNI.PixelFormat) -> setPixelFormat
    org.OpenNI.PixelFormat getPixelFormat() -> getPixelFormat
    org.OpenNI.ImageMap getImageMap() -> getImageMap
    org.OpenNI.IStateChangedObservable getPixelFormatChangedEvent() -> getPixelFormatChangedEvent
    void getMetaData(org.OpenNI.ImageMetaData) -> getMetaData
    org.OpenNI.ImageMetaData getMetaData() -> getMetaData
org.OpenNI.ImageGenerator$1 -> org.OpenNI.ImageGenerator$1:
    org.OpenNI.ImageGenerator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.ImageMap -> org.OpenNI.ImageMap:
    java.nio.ByteBuffer createByteBuffer() -> createByteBuffer
org.OpenNI.ImageMetaData -> org.OpenNI.ImageMetaData:
    void setPixelFormat(org.OpenNI.PixelFormat) -> setPixelFormat
    org.OpenNI.ImageMap getData() -> getData
    org.OpenNI.Map getData() -> getData
org.OpenNI.InactiveHandEventArgs -> org.OpenNI.InactiveHandEventArgs:
    int id -> id
    float time -> time
    int getId() -> getId
    float getTime() -> getTime
org.OpenNI.License -> org.OpenNI.License:
    java.lang.String vendor -> vendor
    java.lang.String key -> key
    java.lang.String getVendor() -> getVendor
    java.lang.String getKey() -> getKey
org.OpenNI.LockHandle -> org.OpenNI.LockHandle:
org.OpenNI.Log -> org.OpenNI.Log:
org.OpenNI.Log$Severity -> org.OpenNI.Log$Severity:
    org.OpenNI.Log$Severity VERBOSE -> VERBOSE
    org.OpenNI.Log$Severity INFO -> INFO
    org.OpenNI.Log$Severity WARNING -> WARNING
    org.OpenNI.Log$Severity ERROR -> ERROR
    int val -> val
    org.OpenNI.Log$Severity[] ENUM$VALUES -> ENUM$VALUES
    int getValue() -> getValue
    org.OpenNI.Log$Severity[] values() -> values
    org.OpenNI.Log$Severity valueOf(java.lang.String) -> valueOf
org.OpenNI.Map -> org.OpenNI.Map:
    long ptr -> ptr
    int xRes -> xRes
    int yRes -> yRes
    int bytesPerPixel -> bytesPerPixel
    long getNativePtr() -> getNativePtr
    void setNativePtr(long) -> setNativePtr
    java.nio.ByteBuffer createByteBuffer() -> createByteBuffer
    void copyToBuffer(java.nio.ByteBuffer,int) -> copyToBuffer
    long getPixelPtr(int,int) -> getPixelPtr
    int getXRes() -> getXRes
    void setXRes(int) -> setXRes
    int getYRes() -> getYRes
    void setYRes(int) -> setYRes
    int getBytesPerPixel() -> getBytesPerPixel
    void setBytesPerPixel(int) -> setBytesPerPixel
org.OpenNI.MapGenerator -> org.OpenNI.MapGenerator:
    org.OpenNI.StateChangedObservable mapOutputModeChanged -> mapOutputModeChanged
    org.OpenNI.MapOutputMode[] getSupportedMapOutputModes() -> getSupportedMapOutputModes
    org.OpenNI.MapOutputMode getMapOutputMode() -> getMapOutputMode
    void setMapOutputMode(org.OpenNI.MapOutputMode) -> setMapOutputMode
    org.OpenNI.IStateChangedObservable getMapOutputModeChangedEvent() -> getMapOutputModeChangedEvent
    org.OpenNI.CroppingCapability getCroppingCapability() -> getCroppingCapability
    org.OpenNI.GeneralIntCapability getBrightnessCapability() -> getBrightnessCapability
    org.OpenNI.GeneralIntCapability getContrastCapability() -> getContrastCapability
    org.OpenNI.GeneralIntCapability getSaturationCapability() -> getSaturationCapability
    org.OpenNI.GeneralIntCapability getHueCapability() -> getHueCapability
    org.OpenNI.GeneralIntCapability getSharpnessCapability() -> getSharpnessCapability
    org.OpenNI.GeneralIntCapability getGammaCapability() -> getGammaCapability
    org.OpenNI.GeneralIntCapability getWhiteBalanceCapability() -> getWhiteBalanceCapability
    org.OpenNI.GeneralIntCapability getBacklightCompensationCapability() -> getBacklightCompensationCapability
    org.OpenNI.GeneralIntCapability getGainCapability() -> getGainCapability
    org.OpenNI.GeneralIntCapability getPanCapability() -> getPanCapability
    org.OpenNI.GeneralIntCapability getTiltCapability() -> getTiltCapability
    org.OpenNI.GeneralIntCapability getRollCapability() -> getRollCapability
    org.OpenNI.GeneralIntCapability getZoomCapability() -> getZoomCapability
    org.OpenNI.GeneralIntCapability getExposureCapability() -> getExposureCapability
    org.OpenNI.GeneralIntCapability getIrisCapability() -> getIrisCapability
    org.OpenNI.GeneralIntCapability getFocusCapability() -> getFocusCapability
    org.OpenNI.GeneralIntCapability getLowLightCompensationCapability() -> getLowLightCompensationCapability
    org.OpenNI.AntiFlickerCapability getAntiFlickerCapability() -> getAntiFlickerCapability
org.OpenNI.MapGenerator$1 -> org.OpenNI.MapGenerator$1:
    org.OpenNI.MapGenerator this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.MapMetaData -> org.OpenNI.MapMetaData:
    int xRes -> xRes
    int yRes -> yRes
    int xOffset -> xOffset
    int yOffset -> yOffset
    int fullXRes -> fullXRes
    int fullYRes -> fullYRes
    org.OpenNI.PixelFormat pixelFormat -> pixelFormat
    int FPS -> FPS
    org.OpenNI.Map map -> map
    int getXRes() -> getXRes
    void setXRes(int) -> setXRes
    int getYRes() -> getYRes
    void setYRes(int) -> setYRes
    int getXOffset() -> getXOffset
    void setXOffset(int) -> setXOffset
    int getYOffset() -> getYOffset
    void setYOffset(int) -> setYOffset
    int getFullXRes() -> getFullXRes
    void setFullXRes(int) -> setFullXRes
    int getFullYRes() -> getFullYRes
    void setFullYRes(int) -> setFullYRes
    org.OpenNI.PixelFormat getPixelFormat() -> getPixelFormat
    int getFPS() -> getFPS
    void setFPS(int) -> setFPS
    org.OpenNI.Map getData() -> getData
    void setDataPtr(long) -> setDataPtr
    void setPixelFormat(org.OpenNI.PixelFormat) -> setPixelFormat
org.OpenNI.MapOutputMode -> org.OpenNI.MapOutputMode:
    int xRes -> xRes
    int yRes -> yRes
    int FPS -> FPS
    void setXRes(int) -> setXRes
    void setYRes(int) -> setYRes
    void setFPS(int) -> setFPS
    int getXRes() -> getXRes
    int getYRes() -> getYRes
    int getFPS() -> getFPS
org.OpenNI.MirrorCapability -> org.OpenNI.MirrorCapability:
    org.OpenNI.StateChangedObservable mirrorChanged -> mirrorChanged
    boolean isMirrored() -> isMirrored
    void setMirror(boolean) -> setMirror
    org.OpenNI.IStateChangedObservable getMirrorChangedEvent() -> getMirrorChangedEvent
org.OpenNI.MirrorCapability$1 -> org.OpenNI.MirrorCapability$1:
    org.OpenNI.MirrorCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.NativeMethods -> org.OpenNI.NativeMethods:
    byte readByte(long) -> readByte
    short readShort(long) -> readShort
    int readInt(long) -> readInt
    long readLong(long) -> readLong
    void copyToBuffer(java.nio.ByteBuffer,long,int) -> copyToBuffer
    long createProductionNodeDescription(int,java.lang.String,java.lang.String,byte,byte,short,int) -> createProductionNodeDescription
    void freeProductionNodeDescription(long) -> freeProductionNodeDescription
    java.lang.String xnGetStatusString(int) -> xnGetStatusString
    int xnInit(org.OpenNI.OutArg) -> xnInit
    int xnContextRunXmlScriptFromFileEx(long,java.lang.String,long,org.OpenNI.OutArg) -> xnContextRunXmlScriptFromFileEx
    int xnContextRunXmlScriptEx(long,java.lang.String,long,org.OpenNI.OutArg) -> xnContextRunXmlScriptEx
    int xnInitFromXmlFileEx(java.lang.String,org.OpenNI.OutArg,long,org.OpenNI.OutArg) -> xnInitFromXmlFileEx
    int xnContextOpenFileRecordingEx(long,java.lang.String,org.OpenNI.OutArg) -> xnContextOpenFileRecordingEx
    int xnContextAddRef(long) -> xnContextAddRef
    void xnContextRelease(long) -> xnContextRelease
    int xnEnumerateProductionTrees(long,int,long,org.OpenNI.OutArg,long) -> xnEnumerateProductionTrees
    int xnCreateProductionTree(long,long,org.OpenNI.OutArg) -> xnCreateProductionTree
    int xnCreateAnyProductionTree(long,int,long,org.OpenNI.OutArg,long) -> xnCreateAnyProductionTree
    int xnEnumerateExistingNodes(long,org.OpenNI.OutArg) -> xnEnumerateExistingNodes
    int xnEnumerateExistingNodesByType(long,int,org.OpenNI.OutArg) -> xnEnumerateExistingNodesByType
    int xnFindExistingRefNodeByType(long,int,org.OpenNI.OutArg) -> xnFindExistingRefNodeByType
    int xnGetRefNodeHandleByName(long,java.lang.String,org.OpenNI.OutArg) -> xnGetRefNodeHandleByName
    int xnWaitAndUpdateAll(long) -> xnWaitAndUpdateAll
    int xnWaitOneUpdateAll(long,long) -> xnWaitOneUpdateAll
    int xnWaitAnyUpdateAll(long) -> xnWaitAnyUpdateAll
    int xnWaitNoneUpdateAll(long) -> xnWaitNoneUpdateAll
    int xnStartGeneratingAll(long) -> xnStartGeneratingAll
    int xnStopGeneratingAll(long) -> xnStopGeneratingAll
    int xnSetGlobalMirror(long,boolean) -> xnSetGlobalMirror
    boolean xnGetGlobalMirror(long) -> xnGetGlobalMirror
    int xnGetGlobalErrorState(long) -> xnGetGlobalErrorState
    int xnRegisterToGlobalErrorStateChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGlobalErrorStateChange
    void xnUnregisterFromGlobalErrorStateChange(long,long) -> xnUnregisterFromGlobalErrorStateChange
    int xnAddLicense(long,java.lang.String,java.lang.String) -> xnAddLicense
    int xnEnumerateLicenses(long,org.OpenNI.OutArg) -> xnEnumerateLicenses
    int xnEnumerationErrorsAllocate(org.OpenNI.OutArg) -> xnEnumerationErrorsAllocate
    void xnEnumerationErrorsFree(long) -> xnEnumerationErrorsFree
    int xnEnumerationErrorsToString(long,org.OpenNI.OutArg) -> xnEnumerationErrorsToString
    int xnEnumerationErrorsClear(long) -> xnEnumerationErrorsClear
    long xnEnumerationErrorsGetFirst(long) -> xnEnumerationErrorsGetFirst
    boolean xnEnumerationErrorsIteratorIsValid(long) -> xnEnumerationErrorsIteratorIsValid
    int xnNodeInfoSetInstanceName(long,java.lang.String) -> xnNodeInfoSetInstanceName
    org.OpenNI.ProductionNodeDescription xnNodeInfoGetDescription(long) -> xnNodeInfoGetDescription
    int xnNodeInfoGetTreeStringRepresentation(long,org.OpenNI.OutArg) -> xnNodeInfoGetTreeStringRepresentation
    java.lang.String xnNodeInfoGetInstanceName(long) -> xnNodeInfoGetInstanceName
    java.lang.String xnNodeInfoGetCreationInfo(long) -> xnNodeInfoGetCreationInfo
    long xnNodeInfoGetNeededNodes(long) -> xnNodeInfoGetNeededNodes
    long xnNodeInfoGetRefHandle(long) -> xnNodeInfoGetRefHandle
    int xnNodeInfoListAllocate(org.OpenNI.OutArg) -> xnNodeInfoListAllocate
    void xnNodeInfoListFree(long) -> xnNodeInfoListFree
    int xnNodeInfoListAdd(long,long,java.lang.String,long) -> xnNodeInfoListAdd
    int xnNodeInfoListAddNode(long,long) -> xnNodeInfoListAddNode
    int xnNodeInfoListAddNodeFromList(long,long) -> xnNodeInfoListAddNodeFromList
    int xnNodeInfoListRemove(long,long) -> xnNodeInfoListRemove
    int xnNodeInfoListClear(long) -> xnNodeInfoListClear
    int xnNodeInfoListAppend(long,long) -> xnNodeInfoListAppend
    boolean xnNodeInfoListIsEmpty(long) -> xnNodeInfoListIsEmpty
    long xnNodeInfoListGetFirst(long) -> xnNodeInfoListGetFirst
    boolean xnNodeInfoListIteratorIsValid(long) -> xnNodeInfoListIteratorIsValid
    long xnNodeInfoListGetCurrent(long) -> xnNodeInfoListGetCurrent
    long xnNodeInfoListGetNext(long) -> xnNodeInfoListGetNext
    int xnNodeQueryAllocate(org.OpenNI.OutArg) -> xnNodeQueryAllocate
    void xnNodeQueryFree(long) -> xnNodeQueryFree
    int xnNodeQuerySetVendor(long,java.lang.String) -> xnNodeQuerySetVendor
    int xnNodeQuerySetName(long,java.lang.String) -> xnNodeQuerySetName
    int xnNodeQuerySetMinVersion(long,byte,byte,short,int) -> xnNodeQuerySetMinVersion
    int xnNodeQuerySetMaxVersion(long,byte,byte,short,int) -> xnNodeQuerySetMaxVersion
    int xnNodeQueryAddSupportedCapability(long,java.lang.String) -> xnNodeQueryAddSupportedCapability
    int xnNodeQueryAddSupportedMapOutputMode(long,int,int,int) -> xnNodeQueryAddSupportedMapOutputMode
    int xnNodeQuerySetSupportedMinUserPositions(long,int) -> xnNodeQuerySetSupportedMinUserPositions
    int xnNodeQuerySetExistingNodeOnly(long,boolean) -> xnNodeQuerySetExistingNodeOnly
    int xnNodeQuerySetNonExistingNodeOnly(long,boolean) -> xnNodeQuerySetNonExistingNodeOnly
    int xnNodeQueryAddNeededNode(long,java.lang.String) -> xnNodeQueryAddNeededNode
    int xnNodeQuerySetCreationInfo(long,java.lang.String) -> xnNodeQuerySetCreationInfo
    int xnNodeQueryFilterList(long,long,long) -> xnNodeQueryFilterList
    int xnProductionNodeAddRef(long) -> xnProductionNodeAddRef
    void xnProductionNodeRelease(long) -> xnProductionNodeRelease
    long xnGetNodeInfo(long) -> xnGetNodeInfo
    java.lang.String xnGetNodeName(long) -> xnGetNodeName
    long xnGetRefContextFromNodeHandle(long) -> xnGetRefContextFromNodeHandle
    boolean xnIsCapabilitySupported(long,java.lang.String) -> xnIsCapabilitySupported
    int xnSetIntProperty(long,java.lang.String,long) -> xnSetIntProperty
    int xnSetRealProperty(long,java.lang.String,double) -> xnSetRealProperty
    int xnSetStringProperty(long,java.lang.String,java.lang.String) -> xnSetStringProperty
    int xnSetGeneralProperty(long,java.lang.String,int,long) -> xnSetGeneralProperty
    int xnSetGeneralPropertyArray(long,java.lang.String,byte[]) -> xnSetGeneralPropertyArray
    int xnGetIntProperty(long,java.lang.String,org.OpenNI.OutArg) -> xnGetIntProperty
    int xnGetRealProperty(long,java.lang.String,org.OpenNI.OutArg) -> xnGetRealProperty
    int xnGetStringProperty(long,java.lang.String,org.OpenNI.OutArg) -> xnGetStringProperty
    int xnGetGeneralProperty(long,java.lang.String,int,long) -> xnGetGeneralProperty
    int xnGetGeneralPropertyArray(long,java.lang.String,byte[]) -> xnGetGeneralPropertyArray
    int xnLockNodeForChanges(long,org.OpenNI.OutArg) -> xnLockNodeForChanges
    int xnUnlockNodeForChanges(long,int) -> xnUnlockNodeForChanges
    int xnLockedNodeStartChanges(long,int) -> xnLockedNodeStartChanges
    int xnLockedNodeEndChanges(long,int) -> xnLockedNodeEndChanges
    int xnAddNeededNode(long,long) -> xnAddNeededNode
    int xnRemoveNeededNode(long,long) -> xnRemoveNeededNode
    int xnCreateDevice(long,org.OpenNI.OutArg,long,long) -> xnCreateDevice
    int xnGetDeviceName(long,org.OpenNI.OutArg) -> xnGetDeviceName
    int xnGetVendorSpecificData(long,org.OpenNI.OutArg) -> xnGetVendorSpecificData
    int xnGetSerialNumber(long,org.OpenNI.OutArg) -> xnGetSerialNumber
    int xnGetNodeErrorState(long) -> xnGetNodeErrorState
    int xnRegisterToNodeErrorStateChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToNodeErrorStateChange
    void xnUnregisterFromNodeErrorStateChange(long,long) -> xnUnregisterFromNodeErrorStateChange
    int xnGetGeneralIntRange(long,java.lang.String,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetGeneralIntRange
    int xnGetGeneralIntValue(long,java.lang.String,org.OpenNI.OutArg) -> xnGetGeneralIntValue
    int xnSetGeneralIntValue(long,java.lang.String,int) -> xnSetGeneralIntValue
    int xnRegisterToGeneralIntValueChange(long,java.lang.String,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGeneralIntValueChange
    void xnUnregisterFromGeneralIntValueChange(long,java.lang.String,long) -> xnUnregisterFromGeneralIntValueChange
    int xnStartGenerating(long) -> xnStartGenerating
    boolean xnIsGenerating(long) -> xnIsGenerating
    int xnStopGenerating(long) -> xnStopGenerating
    int xnRegisterToGenerationRunningChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGenerationRunningChange
    void xnUnregisterFromGenerationRunningChange(long,long) -> xnUnregisterFromGenerationRunningChange
    int xnRegisterToNewDataAvailable(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToNewDataAvailable
    void xnUnregisterFromNewDataAvailable(long,long) -> xnUnregisterFromNewDataAvailable
    boolean xnIsNewDataAvailable(long,org.OpenNI.OutArg) -> xnIsNewDataAvailable
    int xnWaitAndUpdateData(long) -> xnWaitAndUpdateData
    boolean xnIsDataNew(long) -> xnIsDataNew
    long xnGetData(long) -> xnGetData
    int xnGetDataSize(long) -> xnGetDataSize
    long xnGetTimestamp(long) -> xnGetTimestamp
    int xnGetFrameID(long) -> xnGetFrameID
    int xnSetMirror(long,boolean) -> xnSetMirror
    boolean xnIsMirrored(long) -> xnIsMirrored
    int xnRegisterToMirrorChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToMirrorChange
    void xnUnregisterFromMirrorChange(long,long) -> xnUnregisterFromMirrorChange
    boolean xnIsViewPointSupported(long,long) -> xnIsViewPointSupported
    int xnSetViewPoint(long,long) -> xnSetViewPoint
    int xnResetViewPoint(long) -> xnResetViewPoint
    boolean xnIsViewPointAs(long,long) -> xnIsViewPointAs
    int xnRegisterToViewPointChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToViewPointChange
    void xnUnregisterFromViewPointChange(long,long) -> xnUnregisterFromViewPointChange
    boolean xnCanFrameSyncWith(long,long) -> xnCanFrameSyncWith
    int xnFrameSyncWith(long,long) -> xnFrameSyncWith
    int xnStopFrameSyncWith(long,long) -> xnStopFrameSyncWith
    boolean xnIsFrameSyncedWith(long,long) -> xnIsFrameSyncedWith
    int xnRegisterToFrameSyncChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToFrameSyncChange
    void xnUnregisterFromFrameSyncChange(long,long) -> xnUnregisterFromFrameSyncChange
    int xnGetSupportedMapOutputModesCount(long) -> xnGetSupportedMapOutputModesCount
    int xnGetSupportedMapOutputModes(long,org.OpenNI.MapOutputMode[]) -> xnGetSupportedMapOutputModes
    int xnSetMapOutputMode(long,int,int,int) -> xnSetMapOutputMode
    int xnGetMapOutputMode(long,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetMapOutputMode
    int xnRegisterToMapOutputModeChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToMapOutputModeChange
    void xnUnregisterFromMapOutputModeChange(long,long) -> xnUnregisterFromMapOutputModeChange
    int xnGetBytesPerPixel(long) -> xnGetBytesPerPixel
    int xnSetCropping(long,int,int,int,int,boolean) -> xnSetCropping
    int xnGetCropping(long,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetCropping
    int xnRegisterToCroppingChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToCroppingChange
    void xnUnregisterFromCroppingChange(long,long) -> xnUnregisterFromCroppingChange
    int xnSetPowerLineFrequency(long,int) -> xnSetPowerLineFrequency
    int xnGetPowerLineFrequency(long) -> xnGetPowerLineFrequency
    int xnRegisterToPowerLineFrequencyChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToPowerLineFrequencyChange
    void xnUnregisterFromPowerLineFrequencyChange(long,long) -> xnUnregisterFromPowerLineFrequencyChange
    int xnCreateDepthGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateDepthGenerator
    short xnGetDeviceMaxDepth(long) -> xnGetDeviceMaxDepth
    int xnGetDepthFieldOfView(long,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetDepthFieldOfView
    int xnRegisterToDepthFieldOfViewChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToDepthFieldOfViewChange
    void xnUnregisterFromDepthFieldOfViewChange(long,long) -> xnUnregisterFromDepthFieldOfViewChange
    int xnConvertProjectiveToRealWorld(long,org.OpenNI.Point3D[],org.OpenNI.Point3D[]) -> xnConvertProjectiveToRealWorld
    int xnConvertRealWorldToProjective(long,org.OpenNI.Point3D[],org.OpenNI.Point3D[]) -> xnConvertRealWorldToProjective
    long xnGetDepthMap(long) -> xnGetDepthMap
    void xnGetDepthMetaData(long,org.OpenNI.DepthMetaData) -> xnGetDepthMetaData
    int xnGetSupportedUserPositionsCount(long) -> xnGetSupportedUserPositionsCount
    int xnSetUserPosition(long,int,float,float,float,float,float,float) -> xnSetUserPosition
    int xnGetUserPosition(long,int,org.OpenNI.OutArg) -> xnGetUserPosition
    int xnRegisterToUserPositionChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToUserPositionChange
    void xnUnregisterFromUserPositionChange(long,long) -> xnUnregisterFromUserPositionChange
    int xnCreateImageGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateImageGenerator
    long xnGetImageMap(long) -> xnGetImageMap
    boolean xnIsPixelFormatSupported(long,int) -> xnIsPixelFormatSupported
    int xnSetPixelFormat(long,int) -> xnSetPixelFormat
    int xnGetPixelFormat(long) -> xnGetPixelFormat
    int xnRegisterToPixelFormatChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToPixelFormatChange
    void xnUnregisterFromPixelFormatChange(long,long) -> xnUnregisterFromPixelFormatChange
    void xnGetImageMetaData(long,org.OpenNI.ImageMetaData) -> xnGetImageMetaData
    int xnCreateIRGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateIRGenerator
    long xnGetIRMap(long) -> xnGetIRMap
    void xnGetIRMetaData(long,org.OpenNI.IRMetaData) -> xnGetIRMetaData
    int xnCreateGestureGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateGestureGenerator
    int xnAddGesture(long,java.lang.String) -> xnAddGesture
    int xnAddGesture(long,java.lang.String,float,float,float,float,float,float) -> xnAddGesture
    int xnRemoveGesture(long,java.lang.String) -> xnRemoveGesture
    int xnGetAllActiveGestures(long,org.OpenNI.OutArg) -> xnGetAllActiveGestures
    int xnGetNumberOfAvailableGestures(long) -> xnGetNumberOfAvailableGestures
    int xnEnumerateAllGestures(long,org.OpenNI.OutArg) -> xnEnumerateAllGestures
    boolean xnIsGestureAvailable(long,java.lang.String) -> xnIsGestureAvailable
    boolean xnIsGestureProgressSupported(long,java.lang.String) -> xnIsGestureProgressSupported
    int xnRegisterGestureCallbacks(long,java.lang.Object,java.lang.String,java.lang.String,org.OpenNI.OutArg) -> xnRegisterGestureCallbacks
    void xnUnregisterGestureCallbacks(long,long) -> xnUnregisterGestureCallbacks
    int xnRegisterToGestureChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGestureChange
    void xnUnregisterFromGestureChange(long,long) -> xnUnregisterFromGestureChange
    int xnRegisterToGestureIntermediateStageCompleted(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGestureIntermediateStageCompleted
    void xnUnregisterFromGestureIntermediateStageCompleted(long,long) -> xnUnregisterFromGestureIntermediateStageCompleted
    int xnRegisterToGestureReadyForNextIntermediateStage(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToGestureReadyForNextIntermediateStage
    void xnUnregisterFromGestureReadyForNextIntermediateStage(long,long) -> xnUnregisterFromGestureReadyForNextIntermediateStage
    int xnCreateSceneAnalyzer(long,org.OpenNI.OutArg,long,long) -> xnCreateSceneAnalyzer
    long xnGetLabelMap(long) -> xnGetLabelMap
    int xnGetFloor(long,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetFloor
    void xnGetSceneMetaData(long,org.OpenNI.SceneMetaData) -> xnGetSceneMetaData
    int xnCreateUserGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateUserGenerator
    int xnGetNumberOfUsers(long) -> xnGetNumberOfUsers
    int xnGetUsers(long,org.OpenNI.OutArg) -> xnGetUsers
    int xnGetUserCoM(long,int,org.OpenNI.OutArg) -> xnGetUserCoM
    int xnGetUserPixels(long,int,org.OpenNI.SceneMetaData) -> xnGetUserPixels
    int xnRegisterUserCallbacks(long,java.lang.Object,java.lang.String,java.lang.String,org.OpenNI.OutArg) -> xnRegisterUserCallbacks
    void xnUnregisterUserCallbacks(long,long) -> xnUnregisterUserCallbacks
    int xnRegisterToUserExit(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToUserExit
    void xnUnregisterFromUserExit(long,long) -> xnUnregisterFromUserExit
    int xnRegisterToUserReEnter(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToUserReEnter
    void xnUnregisterFromUserReEnter(long,long) -> xnUnregisterFromUserReEnter
    boolean xnIsJointAvailable(long,int) -> xnIsJointAvailable
    boolean xnIsProfileAvailable(long,int) -> xnIsProfileAvailable
    int xnSetSkeletonProfile(long,int) -> xnSetSkeletonProfile
    int xnSetJointActive(long,int,boolean) -> xnSetJointActive
    boolean xnIsJointActive(long,int) -> xnIsJointActive
    int xnRegisterToJointConfigurationChange(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToJointConfigurationChange
    void xnUnregisterFromJointConfigurationChange(long,long) -> xnUnregisterFromJointConfigurationChange
    int xnEnumerateActiveJoints(long,org.OpenNI.OutArg) -> xnEnumerateActiveJoints
    int xnGetSkeletonJoint(long,int,int,org.OpenNI.OutArg) -> xnGetSkeletonJoint
    int xnGetSkeletonJointPosition(long,int,int,org.OpenNI.OutArg) -> xnGetSkeletonJointPosition
    int xnGetSkeletonJointOrientation(long,int,int,org.OpenNI.OutArg) -> xnGetSkeletonJointOrientation
    boolean xnIsSkeletonTracking(long,int) -> xnIsSkeletonTracking
    boolean xnIsSkeletonCalibrated(long,int) -> xnIsSkeletonCalibrated
    boolean xnIsSkeletonCalibrating(long,int) -> xnIsSkeletonCalibrating
    int xnRequestSkeletonCalibration(long,int,boolean) -> xnRequestSkeletonCalibration
    int xnAbortSkeletonCalibration(long,int) -> xnAbortSkeletonCalibration
    int xnSaveSkeletonCalibrationDataToFile(long,int,java.lang.String) -> xnSaveSkeletonCalibrationDataToFile
    int xnLoadSkeletonCalibrationDataFromFile(long,int,java.lang.String) -> xnLoadSkeletonCalibrationDataFromFile
    int xnSaveSkeletonCalibrationData(long,int,int) -> xnSaveSkeletonCalibrationData
    int xnLoadSkeletonCalibrationData(long,int,int) -> xnLoadSkeletonCalibrationData
    int xnClearSkeletonCalibrationData(long,int) -> xnClearSkeletonCalibrationData
    boolean xnIsSkeletonCalibrationData(long,int) -> xnIsSkeletonCalibrationData
    int xnStartSkeletonTracking(long,int) -> xnStartSkeletonTracking
    int xnStopSkeletonTracking(long,int) -> xnStopSkeletonTracking
    int xnResetSkeleton(long,int) -> xnResetSkeleton
    boolean xnNeedPoseForSkeletonCalibration(long) -> xnNeedPoseForSkeletonCalibration
    int xnGetSkeletonCalibrationPose(long,org.OpenNI.OutArg) -> xnGetSkeletonCalibrationPose
    int xnSetSkeletonSmoothing(long,float) -> xnSetSkeletonSmoothing
    int xnRegisterToCalibrationStart(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToCalibrationStart
    void xnUnregisterFromCalibrationStart(long,long) -> xnUnregisterFromCalibrationStart
    int xnRegisterToCalibrationInProgress(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToCalibrationInProgress
    void xnUnregisterFromCalibrationInProgress(long,long) -> xnUnregisterFromCalibrationInProgress
    int xnRegisterToCalibrationComplete(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToCalibrationComplete
    void xnUnregisterFromCalibrationComplete(long,long) -> xnUnregisterFromCalibrationComplete
    int xnGetNumberOfPoses(long) -> xnGetNumberOfPoses
    int xnGetAllAvailablePoses(long,org.OpenNI.OutArg) -> xnGetAllAvailablePoses
    int xnStartPoseDetection(long,java.lang.String,int) -> xnStartPoseDetection
    int xnStopPoseDetection(long,int) -> xnStopPoseDetection
    int xnStopSinglePoseDetection(long,int,java.lang.String) -> xnStopSinglePoseDetection
    int xnRegisterToPoseDetected(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToPoseDetected
    void xnUnregisterFromPoseDetected(long,long) -> xnUnregisterFromPoseDetected
    int xnRegisterToOutOfPose(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToOutOfPose
    void xnUnregisterFromOutOfPose(long,long) -> xnUnregisterFromOutOfPose
    int xnRegisterToPoseDetectionInProgress(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToPoseDetectionInProgress
    void xnUnregisterFromPoseDetectionInProgress(long,long) -> xnUnregisterFromPoseDetectionInProgress
    boolean xnIsPoseSupported(long,java.lang.String) -> xnIsPoseSupported
    int xnGetPoseStatus(long,int,java.lang.String,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetPoseStatus
    int xnCreateHandsGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateHandsGenerator
    int xnRegisterHandCallbacks(long,java.lang.Object,java.lang.String,java.lang.String,java.lang.String,org.OpenNI.OutArg) -> xnRegisterHandCallbacks
    void xnUnregisterHandCallbacks(long,long) -> xnUnregisterHandCallbacks
    int xnStopTracking(long,int) -> xnStopTracking
    int xnStopTrackingAll(long) -> xnStopTrackingAll
    int xnStartTracking(long,float,float,float) -> xnStartTracking
    int xnSetTrackingSmoothing(long,float) -> xnSetTrackingSmoothing
    int xnRegisterToHandTouchingFOVEdge(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToHandTouchingFOVEdge
    void xnUnregisterFromHandTouchingFOVEdge(long,long) -> xnUnregisterFromHandTouchingFOVEdge
    int xnCreateAudioGenerator(long,org.OpenNI.OutArg,long,long) -> xnCreateAudioGenerator
    long xnGetAudioBuffer(long) -> xnGetAudioBuffer
    int xnGetSupportedWaveOutputModesCount(long) -> xnGetSupportedWaveOutputModesCount
    int xnGetSupportedWaveOutputModes(long,org.OpenNI.WaveOutputMode[]) -> xnGetSupportedWaveOutputModes
    int xnSetWaveOutputMode(long,int,short,byte) -> xnSetWaveOutputMode
    int xnGetWaveOutputMode(long,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetWaveOutputMode
    int xnRegisterToWaveOutputModeChanges(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToWaveOutputModeChanges
    void xnUnregisterFromWaveOutputModeChanges(long,long) -> xnUnregisterFromWaveOutputModeChanges
    void xnGetAudioMetaData(long,org.OpenNI.AudioMetaData) -> xnGetAudioMetaData
    int xnCreateCodec(long,int,long,org.OpenNI.OutArg) -> xnCreateCodec
    int xnGetCodecID(long) -> xnGetCodecID
    int xnEncodeData(long,long,int,long,int,org.OpenNI.OutArg) -> xnEncodeData
    int xnDecodeData(long,long,int,long,int,org.OpenNI.OutArg) -> xnDecodeData
    int xnCreateRecorder(long,java.lang.String,org.OpenNI.OutArg) -> xnCreateRecorder
    int xnSetRecorderDestination(long,int,java.lang.String) -> xnSetRecorderDestination
    int xnGetRecorderDestination(long,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetRecorderDestination
    int xnAddNodeToRecording(long,long,int) -> xnAddNodeToRecording
    int xnRemoveNodeFromRecording(long,long) -> xnRemoveNodeFromRecording
    int xnRecord(long) -> xnRecord
    java.lang.String xnGetRecorderFormat(long) -> xnGetRecorderFormat
    int xnCreatePlayer(long,java.lang.String,org.OpenNI.OutArg) -> xnCreatePlayer
    int xnSetPlayerRepeat(long,boolean) -> xnSetPlayerRepeat
    int xnSetPlayerSource(long,int,java.lang.String) -> xnSetPlayerSource
    int xnGetPlayerSource(long,org.OpenNI.OutArg,org.OpenNI.OutArg) -> xnGetPlayerSource
    int xnPlayerReadNext(long) -> xnPlayerReadNext
    int xnSeekPlayerToTimeStamp(long,long,int) -> xnSeekPlayerToTimeStamp
    int xnSeekPlayerToFrame(long,java.lang.String,int,int) -> xnSeekPlayerToFrame
    int xnTellPlayerTimestamp(long,org.OpenNI.OutArg) -> xnTellPlayerTimestamp
    int xnTellPlayerFrame(long,java.lang.String,org.OpenNI.OutArg) -> xnTellPlayerFrame
    int xnGetPlayerNumFrames(long,java.lang.String,org.OpenNI.OutArg) -> xnGetPlayerNumFrames
    java.lang.String xnGetPlayerSupportedFormat(long) -> xnGetPlayerSupportedFormat
    int xnEnumeratePlayerNodes(long,org.OpenNI.OutArg) -> xnEnumeratePlayerNodes
    boolean xnIsPlayerAtEOF(long) -> xnIsPlayerAtEOF
    int xnRegisterToEndOfFileReached(long,java.lang.Object,java.lang.String,org.OpenNI.OutArg) -> xnRegisterToEndOfFileReached
    void xnUnregisterFromEndOfFileReached(long,long) -> xnUnregisterFromEndOfFileReached
    int xnSetPlaybackSpeed(long,double) -> xnSetPlaybackSpeed
    double xnGetPlaybackSpeed(long) -> xnGetPlaybackSpeed
    int xnCreateScriptNode(long,java.lang.String,org.OpenNI.OutArg) -> xnCreateScriptNode
    java.lang.String xnScriptNodeGetSupportedFormat(long) -> xnScriptNodeGetSupportedFormat
    int xnLoadScriptFromFile(long,java.lang.String) -> xnLoadScriptFromFile
    int xnLoadScriptFromString(long,java.lang.String) -> xnLoadScriptFromString
    int xnScriptNodeRun(long,long) -> xnScriptNodeRun
    java.lang.String xnProductionNodeTypeToString(int) -> xnProductionNodeTypeToString
    int xnResolutionGetXRes(int) -> xnResolutionGetXRes
    int xnResolutionGetYRes(int) -> xnResolutionGetYRes
    int xnResolutionGetFromXYRes(int,int) -> xnResolutionGetFromXYRes
    int xnResolutionGetFromName(java.lang.String) -> xnResolutionGetFromName
    java.lang.String xnResolutionGetName(int) -> xnResolutionGetName
    int xnGetVersion(org.OpenNI.OutArg) -> xnGetVersion
    boolean xnIsTypeGenerator(int) -> xnIsTypeGenerator
    boolean xnIsTypeDerivedFrom(int,int) -> xnIsTypeDerivedFrom
    int xnGetBytesPerPixelForPixelFormat(int) -> xnGetBytesPerPixelForPixelFormat
org.OpenNI.NodeInfo -> org.OpenNI.NodeInfo:
    org.OpenNI.ProductionNodeDescription getDescription() -> getDescription
    java.lang.String getInstanceName() -> getInstanceName
    java.lang.String getCreationInfo() -> getCreationInfo
    org.OpenNI.NodeInfoList getNeededNodes() -> getNeededNodes
    org.OpenNI.ProductionNode getInstance() -> getInstance
    java.lang.String toString() -> toString
    void freeObject(long) -> freeObject
org.OpenNI.NodeInfoList -> org.OpenNI.NodeInfoList:
    void add(org.OpenNI.ProductionNodeDescription,java.lang.String,org.OpenNI.NodeInfoList) -> add
    void addNode(org.OpenNI.NodeInfo) -> addNode
    void addNodeFromList(java.util.Iterator) -> addNodeFromList
    void remove(java.util.Iterator) -> remove
    void clear() -> clear
    void append(org.OpenNI.NodeInfoList) -> append
    boolean isEmpty() -> isEmpty
    void filter(org.OpenNI.Query,org.OpenNI.Context) -> filter
    java.util.Iterator iterator() -> iterator
    void freeObject(long) -> freeObject
org.OpenNI.NodeInfoList$NodeInfoListIterator -> org.OpenNI.NodeInfoList$NodeInfoListIterator:
    long it -> it
    org.OpenNI.NodeInfoList this$0 -> this$0
    boolean hasNext() -> hasNext
    org.OpenNI.NodeInfo next() -> next
    void remove() -> remove
    java.lang.Object next() -> next
org.OpenNI.NodeType -> org.OpenNI.NodeType:
    org.OpenNI.NodeType INVALID -> INVALID
    org.OpenNI.NodeType DEVICE -> DEVICE
    org.OpenNI.NodeType DEPTH -> DEPTH
    org.OpenNI.NodeType IMAGE -> IMAGE
    org.OpenNI.NodeType AUDIO -> AUDIO
    org.OpenNI.NodeType IR -> IR
    org.OpenNI.NodeType USER -> USER
    org.OpenNI.NodeType RECORDER -> RECORDER
    org.OpenNI.NodeType PLAYER -> PLAYER
    org.OpenNI.NodeType GESTURE -> GESTURE
    org.OpenNI.NodeType SCENE -> SCENE
    org.OpenNI.NodeType HANDS -> HANDS
    org.OpenNI.NodeType CODEC -> CODEC
    org.OpenNI.NodeType PRODUCTION_NODE -> PRODUCTION_NODE
    org.OpenNI.NodeType GENERATOR -> GENERATOR
    org.OpenNI.NodeType MAP_GENERATOR -> MAP_GENERATOR
    org.OpenNI.NodeType SCRIPT_NODE -> SCRIPT_NODE
    int val -> val
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    int toNative() -> toNative
    java.lang.String toString() -> toString
    boolean isGenerator() -> isGenerator
    boolean isDerivedFrom(org.OpenNI.NodeType) -> isDerivedFrom
org.OpenNI.NodeWrapper -> org.OpenNI.NodeWrapper:
    org.OpenNI.Context context -> context
    org.OpenNI.Context getContext() -> getContext
    java.lang.String getName() -> getName
    void freeObject(long) -> freeObject
org.OpenNI.ObjectWrapper -> org.OpenNI.ObjectWrapper:
    long ptr -> ptr
    long toNative() -> toNative
    void finalize() -> finalize
    void dispose() -> dispose
    void freeObject(long) -> freeObject
org.OpenNI.Observable -> org.OpenNI.Observable:
    java.util.ArrayList observers -> observers
    long hCallback -> hCallback
    void addObserver(org.OpenNI.IObserver) -> addObserver
    void deleteObserver(org.OpenNI.IObserver) -> deleteObserver
    void notify(java.lang.Object) -> notify
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.OutArg -> org.OpenNI.OutArg:
    java.lang.Object value -> value
org.OpenNI.OutputMetaData -> org.OpenNI.OutputMetaData:
    long timestamp -> timestamp
    int frameID -> frameID
    int dataSize -> dataSize
    boolean isNew -> isNew
    long dataPtr -> dataPtr
    long getTimestamp() -> getTimestamp
    void setTimestamp(long) -> setTimestamp
    int getFrameID() -> getFrameID
    void setFrameID(int) -> setFrameID
    int getDataSize() -> getDataSize
    void setDataSize(int) -> setDataSize
    boolean getIsNew() -> getIsNew
    void setIsNew(boolean) -> setIsNew
    long getDataPtr() -> getDataPtr
    void setDataPtr(long) -> setDataPtr
org.OpenNI.PixelFormat -> org.OpenNI.PixelFormat:
    org.OpenNI.PixelFormat RGB24 -> RGB24
    org.OpenNI.PixelFormat YUV422 -> YUV422
    org.OpenNI.PixelFormat GRAYSCALE_8BIT -> GRAYSCALE_8BIT
    org.OpenNI.PixelFormat GRAYSCALE_16BIT -> GRAYSCALE_16BIT
    int val -> val
    org.OpenNI.PixelFormat[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    int getBytesPerPixel() -> getBytesPerPixel
    org.OpenNI.PixelFormat fromNative(int) -> fromNative
    org.OpenNI.PixelFormat[] values() -> values
    org.OpenNI.PixelFormat valueOf(java.lang.String) -> valueOf
org.OpenNI.Plane3D -> org.OpenNI.Plane3D:
    org.OpenNI.Point3D normal -> normal
    org.OpenNI.Point3D point -> point
    org.OpenNI.Point3D getNormal() -> getNormal
    org.OpenNI.Point3D getPoint() -> getPoint
org.OpenNI.Player -> org.OpenNI.Player:
    org.OpenNI.StateChangedObservable eofReached -> eofReached
    org.OpenNI.Player create(org.OpenNI.Context,java.lang.String) -> create
    java.lang.String getFormat() -> getFormat
    void setSource(org.OpenNI.RecordMedium,java.lang.String) -> setSource
    org.OpenNI.RecordMedium getSourceMedium() -> getSourceMedium
    java.lang.String getSource() -> getSource
    void setRepeat(boolean) -> setRepeat
    void readNext() -> readNext
    void seekToTimestamp(org.OpenNI.PlayerSeekOrigin,long) -> seekToTimestamp
    void seekToFrame(org.OpenNI.ProductionNode,org.OpenNI.PlayerSeekOrigin,int) -> seekToFrame
    long tellTimestamp() -> tellTimestamp
    int tellFrame(org.OpenNI.ProductionNode) -> tellFrame
    int getNumberOfFrames(org.OpenNI.ProductionNode) -> getNumberOfFrames
    org.OpenNI.NodeInfoList enumerateNodes() -> enumerateNodes
    boolean isEOF() -> isEOF
    org.OpenNI.IStateChangedObservable getEOFReachedEvent() -> getEOFReachedEvent
    double getPlaybackSpeed() -> getPlaybackSpeed
    void setPlaybackSpeed(double) -> setPlaybackSpeed
org.OpenNI.Player$1 -> org.OpenNI.Player$1:
    org.OpenNI.Player this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.PlayerSeekOrigin -> org.OpenNI.PlayerSeekOrigin:
    org.OpenNI.PlayerSeekOrigin SET -> SET
    org.OpenNI.PlayerSeekOrigin CURRENT -> CURRENT
    org.OpenNI.PlayerSeekOrigin END -> END
    int val -> val
    org.OpenNI.PlayerSeekOrigin[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.PlayerSeekOrigin fromNative(int) -> fromNative
    org.OpenNI.PlayerSeekOrigin[] values() -> values
    org.OpenNI.PlayerSeekOrigin valueOf(java.lang.String) -> valueOf
org.OpenNI.Point3D -> org.OpenNI.Point3D:
    float X -> X
    float Y -> Y
    float Z -> Z
    void setPoint(float,float,float) -> setPoint
    float getX() -> getX
    float getY() -> getY
    float getZ() -> getZ
org.OpenNI.PoseDetectionCapability -> org.OpenNI.PoseDetectionCapability:
    org.OpenNI.Observable poseDetectedEvent -> poseDetectedEvent
    org.OpenNI.Observable outOfPoseEvent -> outOfPoseEvent
    org.OpenNI.Observable poseDetectionInProgressEvent -> poseDetectionInProgressEvent
    int getNumberOfPoses() -> getNumberOfPoses
    boolean isPoseSupported(java.lang.String) -> isPoseSupported
    void getPoseStatus(int,java.lang.String,org.OpenNI.OutArg,org.OpenNI.OutArg,org.OpenNI.OutArg) -> getPoseStatus
    java.lang.String[] getAllAvailablePoses() -> getAllAvailablePoses
    void StartPoseDetection(java.lang.String,int) -> StartPoseDetection
    void StopPoseDetection(int) -> StopPoseDetection
    void startPoseDetection(java.lang.String,int) -> startPoseDetection
    void stopPoseDetection(int) -> stopPoseDetection
    void stopSinglePoseDetection(int,java.lang.String) -> stopSinglePoseDetection
    org.OpenNI.IObservable getPoseDetectedEvent() -> getPoseDetectedEvent
    org.OpenNI.IObservable getOutOfPoseEvent() -> getOutOfPoseEvent
    org.OpenNI.IObservable getPoseDetectionInProgressEvent() -> getPoseDetectionInProgressEvent
org.OpenNI.PoseDetectionCapability$1 -> org.OpenNI.PoseDetectionCapability$1:
    org.OpenNI.PoseDetectionCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,int) -> callback
org.OpenNI.PoseDetectionCapability$2 -> org.OpenNI.PoseDetectionCapability$2:
    org.OpenNI.PoseDetectionCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,int) -> callback
org.OpenNI.PoseDetectionCapability$3 -> org.OpenNI.PoseDetectionCapability$3:
    org.OpenNI.PoseDetectionCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(java.lang.String,int,int) -> callback
org.OpenNI.PoseDetectionEventArgs -> org.OpenNI.PoseDetectionEventArgs:
    java.lang.String pose -> pose
    int user -> user
    java.lang.String getPose() -> getPose
    int getUser() -> getUser
org.OpenNI.PoseDetectionInProgressEventArgs -> org.OpenNI.PoseDetectionInProgressEventArgs:
    java.lang.String pose -> pose
    int user -> user
    org.OpenNI.PoseDetectionStatus status -> status
    java.lang.String getPose() -> getPose
    int getUser() -> getUser
    org.OpenNI.PoseDetectionStatus getStatus() -> getStatus
org.OpenNI.PoseDetectionState -> org.OpenNI.PoseDetectionState:
    org.OpenNI.PoseDetectionState InPose -> InPose
    org.OpenNI.PoseDetectionState OutOfPose -> OutOfPose
    org.OpenNI.PoseDetectionState Undefined -> Undefined
    int val -> val
    org.OpenNI.PoseDetectionState[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.PoseDetectionState fromNative(int) -> fromNative
    org.OpenNI.PoseDetectionState[] values() -> values
    org.OpenNI.PoseDetectionState valueOf(java.lang.String) -> valueOf
org.OpenNI.PoseDetectionStatus -> org.OpenNI.PoseDetectionStatus:
    org.OpenNI.PoseDetectionStatus OK -> OK
    org.OpenNI.PoseDetectionStatus NO_USER -> NO_USER
    org.OpenNI.PoseDetectionStatus TOP_FOV -> TOP_FOV
    org.OpenNI.PoseDetectionStatus SIDE_FOV -> SIDE_FOV
    org.OpenNI.PoseDetectionStatus ERROR -> ERROR
    org.OpenNI.PoseDetectionStatus NO_TRACKING -> NO_TRACKING
    int val -> val
    org.OpenNI.PoseDetectionStatus[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.PoseDetectionStatus fromNative(int) -> fromNative
    org.OpenNI.PoseDetectionStatus[] values() -> values
    org.OpenNI.PoseDetectionStatus valueOf(java.lang.String) -> valueOf
org.OpenNI.PowerLineFrequency -> org.OpenNI.PowerLineFrequency:
    org.OpenNI.PowerLineFrequency OFF -> OFF
    org.OpenNI.PowerLineFrequency HZ50 -> HZ50
    org.OpenNI.PowerLineFrequency HZ60 -> HZ60
    int val -> val
    org.OpenNI.PowerLineFrequency[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.PowerLineFrequency fromNative(int) -> fromNative
    org.OpenNI.PowerLineFrequency[] values() -> values
    org.OpenNI.PowerLineFrequency valueOf(java.lang.String) -> valueOf
org.OpenNI.ProductionNode -> org.OpenNI.ProductionNode:
    org.OpenNI.ProductionNode fromNative(long) -> fromNative
    org.OpenNI.NodeInfo getInfo() -> getInfo
    void addNeededNode(org.OpenNI.ProductionNode) -> addNeededNode
    void removeNeededNode(org.OpenNI.ProductionNode) -> removeNeededNode
    boolean isCapabilitySupported(java.lang.String) -> isCapabilitySupported
    void setIntProperty(java.lang.String,long) -> setIntProperty
    void setRealProperty(java.lang.String,double) -> setRealProperty
    void setStringProperty(java.lang.String,java.lang.String) -> setStringProperty
    void setGeneralProperty(java.lang.String,int,long) -> setGeneralProperty
    void setGeneralProperty(java.lang.String,byte[]) -> setGeneralProperty
    long getIntProperty(java.lang.String) -> getIntProperty
    double getRealProperty(java.lang.String) -> getRealProperty
    java.lang.String getStringProperty(java.lang.String) -> getStringProperty
    void getGeneralProperty(java.lang.String,int,long) -> getGeneralProperty
    void getGeneralProperty(java.lang.String,byte[]) -> getGeneralProperty
    org.OpenNI.LockHandle lockForChanges() -> lockForChanges
    void unlockForChanges(org.OpenNI.LockHandle) -> unlockForChanges
    void lockedNodeStartChanges(org.OpenNI.LockHandle) -> lockedNodeStartChanges
    void lockedNodeEndChanges(org.OpenNI.LockHandle) -> lockedNodeEndChanges
    org.OpenNI.ErrorStateCapability getErrorStateCapability() -> getErrorStateCapability
    org.OpenNI.GeneralIntCapability getGeneralIntCapability(org.OpenNI.Capability) -> getGeneralIntCapability
org.OpenNI.ProductionNodeDescription -> org.OpenNI.ProductionNodeDescription:
    org.OpenNI.NodeType type -> type
    java.lang.String vendor -> vendor
    java.lang.String name -> name
    org.OpenNI.Version version -> version
    org.OpenNI.NodeType getType() -> getType
    java.lang.String getVendor() -> getVendor
    java.lang.String getName() -> getName
    org.OpenNI.Version getVersion() -> getVersion
    long createNative() -> createNative
    void freeNative(long) -> freeNative
org.OpenNI.Query -> org.OpenNI.Query:
    void setVendor(java.lang.String) -> setVendor
    void setName(java.lang.String) -> setName
    void setMinVersion(org.OpenNI.Version) -> setMinVersion
    void setMaxVersion(org.OpenNI.Version) -> setMaxVersion
    void addSupportedCapability(org.OpenNI.Capability) -> addSupportedCapability
    void addSupportedMapOutputMode(org.OpenNI.MapOutputMode) -> addSupportedMapOutputMode
    void addSupportedMinUserPositions(int) -> addSupportedMinUserPositions
    void setExistingNodeOnly(boolean) -> setExistingNodeOnly
    void setNonExistingNodeOnly(boolean) -> setNonExistingNodeOnly
    void addNeededNode(org.OpenNI.ProductionNode) -> addNeededNode
    void setCreationInfo(java.lang.String) -> setCreationInfo
    void freeObject(long) -> freeObject
    long allocate() -> allocate
org.OpenNI.RecordMedium -> org.OpenNI.RecordMedium:
    org.OpenNI.RecordMedium FILE -> FILE
    int val -> val
    org.OpenNI.RecordMedium[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.RecordMedium fromNative(int) -> fromNative
    org.OpenNI.RecordMedium[] values() -> values
    org.OpenNI.RecordMedium valueOf(java.lang.String) -> valueOf
org.OpenNI.Recorder -> org.OpenNI.Recorder:
    org.OpenNI.Recorder create(org.OpenNI.Context,java.lang.String) -> create
    java.lang.String getFormat() -> getFormat
    void setDestination(org.OpenNI.RecordMedium,java.lang.String) -> setDestination
    org.OpenNI.RecordMedium getDestinationMedium() -> getDestinationMedium
    java.lang.String getDestination() -> getDestination
    void addNodeToRecording(org.OpenNI.ProductionNode,org.OpenNI.CodecID) -> addNodeToRecording
    void addNodeToRecording(org.OpenNI.ProductionNode) -> addNodeToRecording
    void removeNodeToRecording(org.OpenNI.ProductionNode) -> removeNodeToRecording
    void Record() -> Record
org.OpenNI.Resolution -> org.OpenNI.Resolution:
    org.OpenNI.Resolution CUSTOM -> CUSTOM
    org.OpenNI.Resolution QQVGA -> QQVGA
    org.OpenNI.Resolution CGA -> CGA
    org.OpenNI.Resolution QVGA -> QVGA
    org.OpenNI.Resolution VGA -> VGA
    org.OpenNI.Resolution SVGA -> SVGA
    org.OpenNI.Resolution XGA -> XGA
    org.OpenNI.Resolution P720 -> P720
    org.OpenNI.Resolution SXGA -> SXGA
    org.OpenNI.Resolution UXGA -> UXGA
    org.OpenNI.Resolution P1080 -> P1080
    int val -> val
    int xRes -> xRes
    int yRes -> yRes
    java.lang.String name -> name
    org.OpenNI.Resolution[] ENUM$VALUES -> ENUM$VALUES
    int getxRes() -> getxRes
    int getyRes() -> getyRes
    java.lang.String getName() -> getName
    int toNative() -> toNative
    org.OpenNI.Resolution fromNative(int) -> fromNative
    org.OpenNI.Resolution fromName(java.lang.String) -> fromName
    org.OpenNI.Resolution fromXYRes(int,int) -> fromXYRes
    org.OpenNI.Resolution[] values() -> values
    org.OpenNI.Resolution valueOf(java.lang.String) -> valueOf
org.OpenNI.SceneAnalyzer -> org.OpenNI.SceneAnalyzer:
    org.OpenNI.SceneMap currSceneMap -> currSceneMap
    int currSceneMapFrameID -> currSceneMapFrameID
    org.OpenNI.SceneAnalyzer create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.SceneAnalyzer create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.SceneAnalyzer create(org.OpenNI.Context) -> create
    org.OpenNI.SceneMap getSceneMap() -> getSceneMap
    void getMetaData(org.OpenNI.SceneMetaData) -> getMetaData
    org.OpenNI.SceneMetaData getMetaData() -> getMetaData
    org.OpenNI.Plane3D getFloor() -> getFloor
org.OpenNI.SceneMap -> org.OpenNI.SceneMap:
org.OpenNI.SceneMetaData -> org.OpenNI.SceneMetaData:
    org.OpenNI.SceneMap getData() -> getData
    org.OpenNI.Map getData() -> getData
org.OpenNI.ScriptNode -> org.OpenNI.ScriptNode:
    org.OpenNI.ScriptNode create(org.OpenNI.Context,java.lang.String) -> create
    java.lang.String getSupportedFormat() -> getSupportedFormat
    void loadScriptFromFile(java.lang.String) -> loadScriptFromFile
    void loadScriptFromString(java.lang.String) -> loadScriptFromString
    void Run(org.OpenNI.EnumerationErrors) -> Run
org.OpenNI.ShortMap -> org.OpenNI.ShortMap:
    int BYTES_PER_PIXEL -> BYTES_PER_PIXEL
    short readPixel(int,int) -> readPixel
    java.nio.ShortBuffer createShortBuffer() -> createShortBuffer
org.OpenNI.SkeletonCapability -> org.OpenNI.SkeletonCapability:
    org.OpenNI.StateChangedObservable jointConfigurationChangeEvent -> jointConfigurationChangeEvent
    org.OpenNI.Observable calibrationStartEvent -> calibrationStartEvent
    org.OpenNI.Observable calibrationInProgressEvent -> calibrationInProgressEvent
    org.OpenNI.Observable calibrationCompleteEvent -> calibrationCompleteEvent
    boolean isJointAvailable(org.OpenNI.SkeletonJoint) -> isJointAvailable
    boolean isProfileAvailable(org.OpenNI.SkeletonProfile) -> isProfileAvailable
    void setSkeletonProfile(org.OpenNI.SkeletonProfile) -> setSkeletonProfile
    void setJointActive(org.OpenNI.SkeletonJoint,boolean) -> setJointActive
    boolean isJointActive(org.OpenNI.SkeletonJoint) -> isJointActive
    org.OpenNI.SkeletonJoint[] enumerateActiveJoints() -> enumerateActiveJoints
    org.OpenNI.SkeletonJointTransformation getSkeletonJoint(int,org.OpenNI.SkeletonJoint) -> getSkeletonJoint
    org.OpenNI.SkeletonJointPosition getSkeletonJointPosition(int,org.OpenNI.SkeletonJoint) -> getSkeletonJointPosition
    org.OpenNI.SkeletonJointOrientation getSkeletonJointOrientation(int,org.OpenNI.SkeletonJoint) -> getSkeletonJointOrientation
    boolean isSkeletonTracking(int) -> isSkeletonTracking
    boolean isSkeletonCalibrated(int) -> isSkeletonCalibrated
    boolean isSkeletonCalibrating(int) -> isSkeletonCalibrating
    void requestSkeletonCalibration(int,boolean) -> requestSkeletonCalibration
    void requestSkeletonCalibration(int) -> requestSkeletonCalibration
    void abortSkeletonCalibration(int) -> abortSkeletonCalibration
    void saveSkeletonCalibrationDataToFile(int,java.lang.String) -> saveSkeletonCalibrationDataToFile
    void loadSkeletonCalibrationDatadFromFile(int,java.lang.String) -> loadSkeletonCalibrationDatadFromFile
    void saveSkeletonCalibrationData(int,int) -> saveSkeletonCalibrationData
    void loadSkeletonCalibrationData(int,int) -> loadSkeletonCalibrationData
    void clearSkeletonCalibrationData(int) -> clearSkeletonCalibrationData
    boolean isSkeletonCalibrationData(int) -> isSkeletonCalibrationData
    void startTracking(int) -> startTracking
    void stopTracking(int) -> stopTracking
    void reset(int) -> reset
    boolean needPoseForCalibration() -> needPoseForCalibration
    java.lang.String getSkeletonCalibrationPose() -> getSkeletonCalibrationPose
    void setSmoothing(float) -> setSmoothing
    org.OpenNI.IStateChangedObservable getJointConfigurationChangeEvent() -> getJointConfigurationChangeEvent
    org.OpenNI.IObservable getCalibrationStartEvent() -> getCalibrationStartEvent
    org.OpenNI.IObservable getCalibrationInProgressEvent() -> getCalibrationInProgressEvent
    org.OpenNI.IObservable getCalibrationCompleteEvent() -> getCalibrationCompleteEvent
org.OpenNI.SkeletonCapability$1 -> org.OpenNI.SkeletonCapability$1:
    org.OpenNI.SkeletonCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.SkeletonCapability$2 -> org.OpenNI.SkeletonCapability$2:
    org.OpenNI.SkeletonCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.SkeletonCapability$3 -> org.OpenNI.SkeletonCapability$3:
    org.OpenNI.SkeletonCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,int) -> callback
org.OpenNI.SkeletonCapability$4 -> org.OpenNI.SkeletonCapability$4:
    org.OpenNI.SkeletonCapability this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int,int) -> callback
org.OpenNI.SkeletonJoint -> org.OpenNI.SkeletonJoint:
    org.OpenNI.SkeletonJoint HEAD -> HEAD
    org.OpenNI.SkeletonJoint NECK -> NECK
    org.OpenNI.SkeletonJoint TORSO -> TORSO
    org.OpenNI.SkeletonJoint WAIST -> WAIST
    org.OpenNI.SkeletonJoint LEFT_COLLAR -> LEFT_COLLAR
    org.OpenNI.SkeletonJoint LEFT_SHOULDER -> LEFT_SHOULDER
    org.OpenNI.SkeletonJoint LEFT_ELBOW -> LEFT_ELBOW
    org.OpenNI.SkeletonJoint LEFT_WRIST -> LEFT_WRIST
    org.OpenNI.SkeletonJoint LEFT_HAND -> LEFT_HAND
    org.OpenNI.SkeletonJoint LEFT_FINGER_TIP -> LEFT_FINGER_TIP
    org.OpenNI.SkeletonJoint RIGHT_COLLAR -> RIGHT_COLLAR
    org.OpenNI.SkeletonJoint RIGHT_SHOULDER -> RIGHT_SHOULDER
    org.OpenNI.SkeletonJoint RIGHT_ELBOW -> RIGHT_ELBOW
    org.OpenNI.SkeletonJoint RIGHT_WRIST -> RIGHT_WRIST
    org.OpenNI.SkeletonJoint RIGHT_HAND -> RIGHT_HAND
    org.OpenNI.SkeletonJoint RIGHT_FINGER_TIP -> RIGHT_FINGER_TIP
    org.OpenNI.SkeletonJoint LEFT_HIP -> LEFT_HIP
    org.OpenNI.SkeletonJoint LEFT_KNEE -> LEFT_KNEE
    org.OpenNI.SkeletonJoint LEFT_ANKLE -> LEFT_ANKLE
    org.OpenNI.SkeletonJoint LEFT_FOOT -> LEFT_FOOT
    org.OpenNI.SkeletonJoint RIGHT_HIP -> RIGHT_HIP
    org.OpenNI.SkeletonJoint RIGHT_KNEE -> RIGHT_KNEE
    org.OpenNI.SkeletonJoint RIGHT_ANKLE -> RIGHT_ANKLE
    org.OpenNI.SkeletonJoint RIGHT_FOOT -> RIGHT_FOOT
    int val -> val
    org.OpenNI.SkeletonJoint[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.SkeletonJoint fromNative(int) -> fromNative
    org.OpenNI.SkeletonJoint[] values() -> values
    org.OpenNI.SkeletonJoint valueOf(java.lang.String) -> valueOf
org.OpenNI.SkeletonJointOrientation -> org.OpenNI.SkeletonJointOrientation:
    float x1 -> x1
    float y1 -> y1
    float z1 -> z1
    float x2 -> x2
    float y2 -> y2
    float z2 -> z2
    float x3 -> x3
    float y3 -> y3
    float z3 -> z3
    float confidence -> confidence
    float getX1() -> getX1
    float getY1() -> getY1
    float getZ1() -> getZ1
    float getX2() -> getX2
    float getY2() -> getY2
    float getZ2() -> getZ2
    float getX3() -> getX3
    float getY3() -> getY3
    float getZ3() -> getZ3
    float getConfidence() -> getConfidence
org.OpenNI.SkeletonJointPosition -> org.OpenNI.SkeletonJointPosition:
    org.OpenNI.Point3D position -> position
    float confidence -> confidence
    org.OpenNI.Point3D getPosition() -> getPosition
    float getConfidence() -> getConfidence
org.OpenNI.SkeletonJointTransformation -> org.OpenNI.SkeletonJointTransformation:
    org.OpenNI.SkeletonJointPosition position -> position
    org.OpenNI.SkeletonJointOrientation orientation -> orientation
    org.OpenNI.SkeletonJointPosition getPosition() -> getPosition
    org.OpenNI.SkeletonJointOrientation getOrientation() -> getOrientation
org.OpenNI.SkeletonPoseProcessingMode -> org.OpenNI.SkeletonPoseProcessingMode:
    org.OpenNI.SkeletonPoseProcessingMode NONE -> NONE
    org.OpenNI.SkeletonPoseProcessingMode ALL -> ALL
    int val -> val
    org.OpenNI.SkeletonPoseProcessingMode[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.SkeletonPoseProcessingMode fromNative(int) -> fromNative
    org.OpenNI.SkeletonPoseProcessingMode[] values() -> values
    org.OpenNI.SkeletonPoseProcessingMode valueOf(java.lang.String) -> valueOf
org.OpenNI.SkeletonProfile -> org.OpenNI.SkeletonProfile:
    org.OpenNI.SkeletonProfile NONE -> NONE
    org.OpenNI.SkeletonProfile ALL -> ALL
    org.OpenNI.SkeletonProfile UPPER_BODY -> UPPER_BODY
    org.OpenNI.SkeletonProfile LOWER_BODY -> LOWER_BODY
    org.OpenNI.SkeletonProfile HEAD_HANDS -> HEAD_HANDS
    int val -> val
    org.OpenNI.SkeletonProfile[] ENUM$VALUES -> ENUM$VALUES
    int toNative() -> toNative
    org.OpenNI.SkeletonProfile fromNative(int) -> fromNative
    org.OpenNI.SkeletonProfile[] values() -> values
    org.OpenNI.SkeletonProfile valueOf(java.lang.String) -> valueOf
org.OpenNI.StateChangedObservable -> org.OpenNI.StateChangedObservable:
    int registerNative(org.OpenNI.OutArg) -> registerNative
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void callback() -> callback
org.OpenNI.StatusException -> org.OpenNI.StatusException:
    long serialVersionUID -> serialVersionUID
org.OpenNI.UserEventArgs -> org.OpenNI.UserEventArgs:
    int id -> id
    int getId() -> getId
org.OpenNI.UserGenerator -> org.OpenNI.UserGenerator:
    org.OpenNI.Observable newUserEvent -> newUserEvent
    org.OpenNI.Observable lostUserEvent -> lostUserEvent
    org.OpenNI.Observable userExitEvent -> userExitEvent
    org.OpenNI.Observable userReenterEvent -> userReenterEvent
    org.OpenNI.UserGenerator create(org.OpenNI.Context,org.OpenNI.Query,org.OpenNI.EnumerationErrors) -> create
    org.OpenNI.UserGenerator create(org.OpenNI.Context,org.OpenNI.Query) -> create
    org.OpenNI.UserGenerator create(org.OpenNI.Context) -> create
    int getNumberOfUsers() -> getNumberOfUsers
    int[] getUsers() -> getUsers
    org.OpenNI.Point3D getUserCoM(int) -> getUserCoM
    void getUserPixels(int,org.OpenNI.SceneMetaData) -> getUserPixels
    org.OpenNI.SceneMetaData getUserPixels(int) -> getUserPixels
    org.OpenNI.PoseDetectionCapability getPoseDetectionCapability() -> getPoseDetectionCapability
    org.OpenNI.SkeletonCapability getSkeletonCapability() -> getSkeletonCapability
    org.OpenNI.IObservable getNewUserEvent() -> getNewUserEvent
    org.OpenNI.IObservable getLostUserEvent() -> getLostUserEvent
    org.OpenNI.IObservable getUserExitEvent() -> getUserExitEvent
    org.OpenNI.IObservable getUserReenterEvent() -> getUserReenterEvent
org.OpenNI.UserGenerator$1 -> org.OpenNI.UserGenerator$1:
    org.OpenNI.UserGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.UserGenerator$2 -> org.OpenNI.UserGenerator$2:
    org.OpenNI.UserGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.UserGenerator$3 -> org.OpenNI.UserGenerator$3:
    org.OpenNI.UserGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.UserGenerator$4 -> org.OpenNI.UserGenerator$4:
    org.OpenNI.UserGenerator this$0 -> this$0
    int registerNative(org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
    void callback(int) -> callback
org.OpenNI.UserPositionCapability -> org.OpenNI.UserPositionCapability:
    org.OpenNI.StateChangedObservable userPositionChanged -> userPositionChanged
    int getSupportedCount() -> getSupportedCount
    void setUserPosition(int,org.OpenNI.BoundingBox3D) -> setUserPosition
    org.OpenNI.BoundingBox3D getUserPosition(int) -> getUserPosition
    org.OpenNI.IStateChangedObservable getUserPositionChangedEvent() -> getUserPositionChangedEvent
org.OpenNI.UserPositionCapability$1 -> org.OpenNI.UserPositionCapability$1:
    org.OpenNI.UserPositionCapability this$0 -> this$0
    int registerNative(java.lang.String,org.OpenNI.OutArg) -> registerNative
    void unregisterNative(long) -> unregisterNative
org.OpenNI.Version -> org.OpenNI.Version:
    byte major -> major
    byte minor -> minor
    short maintenance -> maintenance
    int build -> build
    byte getMajor() -> getMajor
    byte getMinor() -> getMinor
    short getMaintenance() -> getMaintenance
    int getBuild() -> getBuild
org.OpenNI.WaveOutputMode -> org.OpenNI.WaveOutputMode:
    int sampleRate -> sampleRate
    short bitsPerSample -> bitsPerSample
    byte numberOfChannels -> numberOfChannels
    int getSampleRate() -> getSampleRate
    void setSampleRate(int) -> setSampleRate
    short getBitsPerSample() -> getBitsPerSample
    void setBitsPerSample(short) -> setBitsPerSample
    byte getNumberOfChannels() -> getNumberOfChannels
    void setNumberOfChannels(byte) -> setNumberOfChannels
org.OpenNI.WrapperUtils -> org.OpenNI.WrapperUtils:
    void throwOnError(int) -> throwOnError
    void checkEnumeration(int,org.OpenNI.EnumerationErrors) -> checkEnumeration
    java.lang.String getErrorMessage(int) -> getErrorMessage
org.apache.commons.math.ConvergenceException -> org.a.a.a.a:
org.apache.commons.math.ConvergingAlgorithm -> org.a.a.a.b:
    void setAbsoluteAccuracy(double) -> a
org.apache.commons.math.ConvergingAlgorithmImpl -> org.a.a.a.c:
    double absoluteAccuracy -> a
    double relativeAccuracy -> b
    int maximalIterationCount -> a
    double defaultAbsoluteAccuracy -> c
    double defaultRelativeAccuracy -> d
    int defaultMaximalIterationCount -> b
    int iterationCount -> c
    void setAbsoluteAccuracy(double) -> a
    void setMaximalIterationCount(int) -> a
    void setRelativeAccuracy(double) -> b
org.apache.commons.math.FunctionEvaluationException -> org.a.a.a.d:
    double[] argument -> a
org.apache.commons.math.MathException -> org.a.a.a.e:
    org.apache.commons.math.exception.util.Localizable pattern -> a
    java.lang.Object[] arguments -> a
    org.apache.commons.math.exception.util.Localizable getSpecificPattern() -> a
    org.apache.commons.math.exception.util.Localizable getGeneralPattern() -> b
    java.lang.Object[] getArguments() -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    void printStackTrace() -> printStackTrace
    void printStackTrace(java.io.PrintStream) -> printStackTrace
org.apache.commons.math.MathRuntimeException -> org.a.a.a.f:
    org.apache.commons.math.exception.util.Localizable pattern -> a
    java.lang.Object[] arguments -> a
    java.lang.String buildMessage(java.util.Locale,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> b
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
    void printStackTrace() -> printStackTrace
    void printStackTrace(java.io.PrintStream) -> printStackTrace
    java.lang.ArithmeticException createArithmeticException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.IllegalArgumentException createIllegalArgumentException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.IllegalStateException createIllegalStateException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.UnsupportedOperationException createUnsupportedOperationException(org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
    java.lang.String access$0(java.util.Locale,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
org.apache.commons.math.MathRuntimeException$1 -> org.a.a.a.g:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$4 -> org.a.a.a.h:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$5 -> org.a.a.a.i:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MathRuntimeException$8 -> org.a.a.a.j:
    org.apache.commons.math.exception.util.Localizable val$pattern -> a
    java.lang.Object[] val$arguments -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.MaxEvaluationsExceededException -> org.a.a.a.k:
    int maxEvaluations -> a
org.apache.commons.math.MaxIterationsExceededException -> org.a.a.a.l:
    int maxIterations -> a
org.apache.commons.math.analysis.BinaryFunction -> org.a.a.a.a.a:
    org.apache.commons.math.analysis.BinaryFunction ADD -> a
    org.apache.commons.math.analysis.BinaryFunction SUBTRACT -> b
    org.apache.commons.math.analysis.BinaryFunction MULTIPLY -> c
    org.apache.commons.math.analysis.BinaryFunction DIVIDE -> d
    org.apache.commons.math.analysis.BinaryFunction POW -> e
    org.apache.commons.math.analysis.BinaryFunction ATAN2 -> f
    double value(double,double) -> a
    org.apache.commons.math.analysis.ComposableFunction fix1stArgument(double) -> a
org.apache.commons.math.analysis.BinaryFunction$1 -> org.a.a.a.a.b:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$2 -> org.a.a.a.a.c:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$3 -> org.a.a.a.a.d:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$4 -> org.a.a.a.a.e:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$5 -> org.a.a.a.a.f:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$6 -> org.a.a.a.a.g:
    double value(double,double) -> a
org.apache.commons.math.analysis.BinaryFunction$7 -> org.a.a.a.a.h:
    org.apache.commons.math.analysis.BinaryFunction this$0 -> a
    double val$fixedX -> a
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction -> org.a.a.a.a.i:
    org.apache.commons.math.analysis.ComposableFunction ZERO -> a
    org.apache.commons.math.analysis.ComposableFunction ONE -> b
    org.apache.commons.math.analysis.ComposableFunction IDENTITY -> c
    org.apache.commons.math.analysis.ComposableFunction ABS -> d
    org.apache.commons.math.analysis.ComposableFunction NEGATE -> e
    org.apache.commons.math.analysis.ComposableFunction INVERT -> f
    org.apache.commons.math.analysis.ComposableFunction SIN -> g
    org.apache.commons.math.analysis.ComposableFunction SQRT -> h
    org.apache.commons.math.analysis.ComposableFunction SINH -> i
    org.apache.commons.math.analysis.ComposableFunction EXP -> j
    org.apache.commons.math.analysis.ComposableFunction EXPM1 -> k
    org.apache.commons.math.analysis.ComposableFunction ASIN -> l
    org.apache.commons.math.analysis.ComposableFunction ATAN -> m
    org.apache.commons.math.analysis.ComposableFunction TAN -> n
    org.apache.commons.math.analysis.ComposableFunction TANH -> o
    org.apache.commons.math.analysis.ComposableFunction CBRT -> p
    org.apache.commons.math.analysis.ComposableFunction CEIL -> q
    org.apache.commons.math.analysis.ComposableFunction FLOOR -> r
    org.apache.commons.math.analysis.ComposableFunction LOG -> s
    org.apache.commons.math.analysis.ComposableFunction LOG10 -> t
    org.apache.commons.math.analysis.ComposableFunction LOG1P -> u
    org.apache.commons.math.analysis.ComposableFunction COS -> v
    org.apache.commons.math.analysis.ComposableFunction ACOS -> w
    org.apache.commons.math.analysis.ComposableFunction COSH -> x
    org.apache.commons.math.analysis.ComposableFunction RINT -> y
    org.apache.commons.math.analysis.ComposableFunction SIGNUM -> z
    org.apache.commons.math.analysis.ComposableFunction ULP -> A
org.apache.commons.math.analysis.ComposableFunction$1 -> org.a.a.a.a.j:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$10 -> org.a.a.a.a.k:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$11 -> org.a.a.a.a.l:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$12 -> org.a.a.a.a.m:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$13 -> org.a.a.a.a.n:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$14 -> org.a.a.a.a.o:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$15 -> org.a.a.a.a.p:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$16 -> org.a.a.a.a.q:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$17 -> org.a.a.a.a.r:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$18 -> org.a.a.a.a.s:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$19 -> org.a.a.a.a.t:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$2 -> org.a.a.a.a.u:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$20 -> org.a.a.a.a.v:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$21 -> org.a.a.a.a.w:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$22 -> org.a.a.a.a.x:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$23 -> org.a.a.a.a.y:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$24 -> org.a.a.a.a.z:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$25 -> org.a.a.a.a.A:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$26 -> org.a.a.a.a.B:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$27 -> org.a.a.a.a.C:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$3 -> org.a.a.a.a.D:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$4 -> org.a.a.a.a.E:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$5 -> org.a.a.a.a.F:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$6 -> org.a.a.a.a.G:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$7 -> org.a.a.a.a.H:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$8 -> org.a.a.a.a.I:
    double value(double) -> a
org.apache.commons.math.analysis.ComposableFunction$9 -> org.a.a.a.a.J:
    double value(double) -> a
org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction -> org.a.a.a.a.K:
    org.apache.commons.math.analysis.MultivariateMatrixFunction jacobian() -> a
org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction -> org.a.a.a.a.L:
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
org.apache.commons.math.analysis.MultivariateMatrixFunction -> org.a.a.a.a.M:
    double[][] value(double[]) -> a
org.apache.commons.math.analysis.MultivariateVectorialFunction -> org.a.a.a.a.N:
    double[] value(double[]) -> a
org.apache.commons.math.analysis.UnivariateRealFunction -> org.a.a.a.a.O:
    double value(double) -> a
org.apache.commons.math.analysis.integration.LegendreGaussIntegrator -> org.a.a.a.a.a.a:
    double[] ABSCISSAS_2 -> a
    double[] WEIGHTS_2 -> b
    double[] ABSCISSAS_3 -> c
    double[] WEIGHTS_3 -> d
    double[] ABSCISSAS_4 -> e
    double[] WEIGHTS_4 -> f
    double[] ABSCISSAS_5 -> g
    double[] WEIGHTS_5 -> h
    double[] abscissas -> i
    double[] weights -> j
    double integrate(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double stage(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,int) -> a
org.apache.commons.math.analysis.integration.UnivariateRealIntegrator -> org.a.a.a.a.a.b:
org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl -> org.a.a.a.a.a.c:
    int minimalIterationCount -> d
    int defaultMinimalIterationCount -> e
    boolean resultComputed -> a
    double result -> e
    void setResult(double,int) -> a
    void clearResult() -> a
    void verifyInterval(double,double) -> a
    void verifyIterationCount() -> b
org.apache.commons.math.analysis.polynomials.PolynomialFunction -> org.a.a.a.a.b.a:
    double[] coefficients -> a
    double value(double) -> a
    int degree() -> a
    double[] getCoefficients() -> a
    double evaluate(double[],double) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction add(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction subtract(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> b
    org.apache.commons.math.analysis.polynomials.PolynomialFunction multiply(org.apache.commons.math.analysis.polynomials.PolynomialFunction) -> c
    double[] differentiate(double[]) -> a
    org.apache.commons.math.analysis.polynomials.PolynomialFunction polynomialDerivative() -> a
    org.apache.commons.math.analysis.UnivariateRealFunction derivative() -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math.analysis.solvers.BrentSolver -> org.a.a.a.a.c.a:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double,double,double,double) -> a
org.apache.commons.math.analysis.solvers.LaguerreSolver -> org.a.a.a.a.c.b:
    org.apache.commons.math.analysis.polynomials.PolynomialFunction p -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    boolean isRootOK(double,double,org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex[] solveAll(double[],double) -> a
    org.apache.commons.math.complex.Complex[] solveAll(org.apache.commons.math.complex.Complex[],org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex solve(org.apache.commons.math.complex.Complex[],org.apache.commons.math.complex.Complex) -> a
org.apache.commons.math.analysis.solvers.NewtonSolver -> org.a.a.a.a.c.c:
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolver -> org.a.a.a.a.c.d:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory -> org.a.a.a.a.c.e:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory newInstance() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newDefaultSolver() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newBrentSolver() -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newNewtonSolver() -> c
org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactoryImpl -> org.a.a.a.a.c.f:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newDefaultSolver() -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newBrentSolver() -> b
    org.apache.commons.math.analysis.solvers.UnivariateRealSolver newNewtonSolver() -> c
org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl -> org.a.a.a.a.c.g:
    double functionValueAccuracy -> e
    double defaultFunctionValueAccuracy -> f
    boolean resultComputed -> a
    double result -> g
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double) -> a
    double solve(int,org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    void setResult(double,int) -> a
    void clearResult() -> a
    boolean isBracketing(double,double,org.apache.commons.math.analysis.UnivariateRealFunction) -> a
    boolean isSequence(double,double,double) -> a
    void verifyInterval(double,double) -> a
    void verifySequence(double,double,double) -> a
    void verifyBracketing(double,double,org.apache.commons.math.analysis.UnivariateRealFunction) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils -> org.a.a.a.a.c.h:
    double solve(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double[] bracket(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double) -> a
    double[] bracket(org.apache.commons.math.analysis.UnivariateRealFunction,double,double,double,int) -> a
    double midpoint(double,double) -> a
    void setup(org.apache.commons.math.analysis.UnivariateRealFunction) -> a
org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils$LazyHolder -> org.a.a.a.a.c.h$a:
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory FACTORY -> a
    org.apache.commons.math.analysis.solvers.UnivariateRealSolverFactory access$0() -> a
org.apache.commons.math.complex.Complex -> org.a.a.a.b.a:
    org.apache.commons.math.complex.Complex I -> a
    org.apache.commons.math.complex.Complex NaN -> b
    org.apache.commons.math.complex.Complex INF -> c
    org.apache.commons.math.complex.Complex ONE -> d
    org.apache.commons.math.complex.Complex ZERO -> e
    double imaginary -> a
    double real -> b
    boolean isNaN -> a
    boolean isInfinite -> b
    double abs() -> a
    org.apache.commons.math.complex.Complex add(org.apache.commons.math.complex.Complex) -> a
    org.apache.commons.math.complex.Complex conjugate() -> a
    org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex) -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    double getImaginary() -> b
    double getReal() -> c
    boolean isNaN() -> a
    boolean isInfinite() -> b
    org.apache.commons.math.complex.Complex multiply(org.apache.commons.math.complex.Complex) -> c
    org.apache.commons.math.complex.Complex multiply(double) -> a
    org.apache.commons.math.complex.Complex subtract(org.apache.commons.math.complex.Complex) -> d
    org.apache.commons.math.complex.Complex exp() -> b
    org.apache.commons.math.complex.Complex log() -> c
    org.apache.commons.math.complex.Complex pow(org.apache.commons.math.complex.Complex) -> e
    org.apache.commons.math.complex.Complex sqrt() -> d
    org.apache.commons.math.complex.Complex createComplex(double,double) -> a
org.apache.commons.math.distribution.AbstractContinuousDistribution -> org.a.a.a.c.a:
    org.apache.commons.math.random.RandomDataImpl randomData -> a
    double solverAbsoluteAccuracy -> a
    double inverseCumulativeProbability(double) -> a_
    double getInitialDomain(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.AbstractContinuousDistribution$1 -> org.a.a.a.c.b:
    org.apache.commons.math.distribution.AbstractContinuousDistribution this$0 -> a
    double val$p -> a
    double value(double) -> a
org.apache.commons.math.distribution.AbstractDistribution -> org.a.a.a.c.c:
org.apache.commons.math.distribution.AbstractIntegerDistribution -> org.a.a.a.c.d:
    org.apache.commons.math.random.RandomDataImpl randomData -> a
    double cumulativeProbability(double) -> a
    double cumulativeProbability(int) -> a
    double probability(double) -> b
    int inverseCumulativeProbability(double) -> a
    double checkedCumulativeProbability(int) -> c
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
org.apache.commons.math.distribution.BinomialDistribution -> org.a.a.a.c.e:
    int getNumberOfTrials() -> a
    double getProbabilityOfSuccess() -> a
org.apache.commons.math.distribution.BinomialDistributionImpl -> org.a.a.a.c.f:
    int numberOfTrials -> a
    double probabilityOfSuccess -> a
    int getNumberOfTrials() -> a
    double getProbabilityOfSuccess() -> a
    void setNumberOfTrialsInternal(int) -> a
    void setProbabilityOfSuccessInternal(double) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double cumulativeProbability(int) -> a
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.CauchyDistribution -> org.a.a.a.c.g:
    double getMedian() -> b
    double getScale() -> c
org.apache.commons.math.distribution.CauchyDistributionImpl -> org.a.a.a.c.h:
    double median -> a
    double scale -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double getMedian() -> b
    double getScale() -> c
    double inverseCumulativeProbability(double) -> a_
    void setMedianInternal(double) -> a
    void setScaleInternal(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ChiSquaredDistribution -> org.a.a.a.c.i:
    double getDegreesOfFreedom() -> b
org.apache.commons.math.distribution.ChiSquaredDistributionImpl -> org.a.a.a.c.j:
    org.apache.commons.math.distribution.GammaDistribution gamma -> a
    double solverAbsoluteAccuracy -> a
    void setDegreesOfFreedomInternal(double) -> a
    double getDegreesOfFreedom() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    void setGammaInternal(org.apache.commons.math.distribution.GammaDistribution) -> a
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ContinuousDistribution -> org.a.a.a.c.k:
    double inverseCumulativeProbability(double) -> a_
org.apache.commons.math.distribution.DiscreteDistribution -> org.a.a.a.c.l:
    double probability(double) -> b
org.apache.commons.math.distribution.Distribution -> org.a.a.a.c.m:
    double cumulativeProbability(double) -> a
org.apache.commons.math.distribution.ExponentialDistribution -> org.a.a.a.c.n:
    double getMean() -> b
org.apache.commons.math.distribution.ExponentialDistributionImpl -> org.a.a.a.c.o:
    double mean -> a
    double solverAbsoluteAccuracy -> b
    void setMeanInternal(double) -> a
    double getMean() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.FDistribution -> org.a.a.a.c.p:
    double getNumeratorDegreesOfFreedom() -> b
    double getDenominatorDegreesOfFreedom() -> c
org.apache.commons.math.distribution.FDistributionImpl -> org.a.a.a.c.q:
    double numeratorDegreesOfFreedom -> a
    double denominatorDegreesOfFreedom -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    void setNumeratorDegreesOfFreedomInternal(double) -> a
    double getNumeratorDegreesOfFreedom() -> b
    void setDenominatorDegreesOfFreedomInternal(double) -> b
    double getDenominatorDegreesOfFreedom() -> c
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.GammaDistribution -> org.a.a.a.c.r:
    void setAlpha(double) -> a
    double getAlpha() -> b
    double getBeta() -> c
org.apache.commons.math.distribution.GammaDistributionImpl -> org.a.a.a.c.s:
    double alpha -> a
    double beta -> b
    double solverAbsoluteAccuracy -> c
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    void setAlpha(double) -> a
    void setAlphaInternal(double) -> b
    double getAlpha() -> b
    void setBetaInternal(double) -> c
    double getBeta() -> c
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.HypergeometricDistribution -> org.a.a.a.c.t:
    int getNumberOfSuccesses() -> a
    int getPopulationSize() -> b
    int getSampleSize() -> c
org.apache.commons.math.distribution.HypergeometricDistributionImpl -> org.a.a.a.c.u:
    int numberOfSuccesses -> a
    int populationSize -> b
    int sampleSize -> c
    double cumulativeProbability(int) -> a
    int[] getDomain(int,int,int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    int getLowerDomain(int,int,int) -> a
    int getNumberOfSuccesses() -> a
    int getPopulationSize() -> b
    int getSampleSize() -> c
    int getUpperDomain(int,int) -> a
    double probability(int) -> b
    double probability(int,int,int,int) -> a
    void setNumberOfSuccessesInternal(int) -> a
    void setPopulationSizeInternal(int) -> b
    void setSampleSizeInternal(int) -> c
    double innerCumulativeProbability(int,int,int,int,int,int) -> a
org.apache.commons.math.distribution.IntegerDistribution -> org.a.a.a.c.v:
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.NormalDistribution -> org.a.a.a.c.w:
    double getMean() -> b
    void setMean(double) -> a
    double getStandardDeviation() -> c
    void setStandardDeviation(double) -> b
org.apache.commons.math.distribution.NormalDistributionImpl -> org.a.a.a.c.x:
    double SQRT2PI -> a
    double mean -> b
    double standardDeviation -> c
    double solverAbsoluteAccuracy -> d
    double getMean() -> b
    void setMean(double) -> a
    void setMeanInternal(double) -> c
    double getStandardDeviation() -> c
    void setStandardDeviation(double) -> b
    void setStandardDeviationInternal(double) -> d
    double cumulativeProbability(double) -> a
    double getSolverAbsoluteAccuracy() -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
org.apache.commons.math.distribution.PascalDistribution -> org.a.a.a.c.y:
    int getNumberOfSuccesses() -> a
    double getProbabilityOfSuccess() -> a
org.apache.commons.math.distribution.PascalDistributionImpl -> org.a.a.a.c.z:
    int numberOfSuccesses -> a
    double probabilityOfSuccess -> a
    int getNumberOfSuccesses() -> a
    double getProbabilityOfSuccess() -> a
    void setNumberOfSuccessesInternal(int) -> a
    void setProbabilityOfSuccessInternal(double) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double cumulativeProbability(int) -> a
    double probability(int) -> b
    int inverseCumulativeProbability(double) -> a
org.apache.commons.math.distribution.PoissonDistribution -> org.a.a.a.c.A:
    double getMean() -> a
org.apache.commons.math.distribution.PoissonDistributionImpl -> org.a.a.a.c.B:
    org.apache.commons.math.distribution.NormalDistribution normal -> a
    double mean -> a
    int maxIterations -> a
    double epsilon -> b
    double getMean() -> a
    void setNormalAndMeanInternal(org.apache.commons.math.distribution.NormalDistribution,double) -> a
    double probability(int) -> b
    double cumulativeProbability(int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
org.apache.commons.math.distribution.SaddlePointExpansion -> org.a.a.a.c.C:
    double HALF_LOG_2_PI -> a
    double[] EXACT_STIRLING_ERRORS -> a
    double getStirlingError(double) -> a
    double getDeviancePart(double,double) -> a
    double logBinomialProbability(int,int,double,double) -> a
org.apache.commons.math.distribution.TDistribution -> org.a.a.a.c.D:
    void setDegreesOfFreedom(double) -> a
    double getDegreesOfFreedom() -> b
org.apache.commons.math.distribution.TDistributionImpl -> org.a.a.a.c.E:
    double degreesOfFreedom -> a
    double solverAbsoluteAccuracy -> b
    void setDegreesOfFreedom(double) -> a
    void setDegreesOfFreedomInternal(double) -> b
    double getDegreesOfFreedom() -> b
    double cumulativeProbability(double) -> a
    double inverseCumulativeProbability(double) -> a_
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.WeibullDistribution -> org.a.a.a.c.F:
    double getShape() -> b
    double getScale() -> c
org.apache.commons.math.distribution.WeibullDistributionImpl -> org.a.a.a.c.G:
    double shape -> a
    double scale -> b
    double solverAbsoluteAccuracy -> c
    double numericalMean -> d
    boolean numericalMeanIsCalculated -> a
    double numericalVariance -> e
    boolean numericalVarianceIsCalculated -> b
    double cumulativeProbability(double) -> a
    double getShape() -> b
    double getScale() -> c
    double inverseCumulativeProbability(double) -> a_
    void setShapeInternal(double) -> a
    void setScaleInternal(double) -> b
    double getDomainLowerBound(double) -> c
    double getDomainUpperBound(double) -> d
    double getInitialDomain(double) -> b
    double getSolverAbsoluteAccuracy() -> a
org.apache.commons.math.distribution.ZipfDistribution -> org.a.a.a.c.H:
    int getNumberOfElements() -> a
    double getExponent() -> a
org.apache.commons.math.distribution.ZipfDistributionImpl -> org.a.a.a.c.I:
    int numberOfElements -> a
    double exponent -> a
    int getNumberOfElements() -> a
    void setNumberOfElementsInternal(int) -> a
    double getExponent() -> a
    void setExponentInternal(double) -> a
    double probability(int) -> b
    double cumulativeProbability(int) -> a
    int getDomainLowerBound(double) -> b
    int getDomainUpperBound(double) -> c
    double generalizedHarmonic(int,double) -> a
org.apache.commons.math.exception.DimensionMismatchException -> org.a.a.a.d.a:
    int dimension -> a
org.apache.commons.math.exception.MathIllegalArgumentException -> org.a.a.a.d.b:
    org.apache.commons.math.exception.util.Localizable specific -> a
    org.apache.commons.math.exception.util.Localizable general -> b
    java.lang.Object[] arguments -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.exception.MathIllegalNumberException -> org.a.a.a.d.c:
    java.lang.Number argument -> a
org.apache.commons.math.exception.MathIllegalStateException -> org.a.a.a.d.d:
    org.apache.commons.math.exception.util.Localizable specific -> a
    org.apache.commons.math.exception.util.Localizable general -> b
    java.lang.Object[] arguments -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.exception.MathInternalError -> org.a.a.a.d.e:
org.apache.commons.math.exception.MathUnsupportedOperationException -> org.a.a.a.d.f:
    org.apache.commons.math.exception.util.Localizable specific -> a
    java.lang.Object[] arguments -> a
    java.lang.String getMessage(java.util.Locale) -> a
    java.lang.String getMessage() -> getMessage
    java.lang.String getLocalizedMessage() -> getLocalizedMessage
org.apache.commons.math.exception.NoDataException -> org.a.a.a.d.g:
org.apache.commons.math.exception.NotPositiveException -> org.a.a.a.d.h:
org.apache.commons.math.exception.NullArgumentException -> org.a.a.a.d.i:
org.apache.commons.math.exception.NumberIsTooLargeException -> org.a.a.a.d.j:
    java.lang.Number max -> a
    boolean boundIsAllowed -> a
org.apache.commons.math.exception.NumberIsTooSmallException -> org.a.a.a.d.k:
    java.lang.Number min -> a
    boolean boundIsAllowed -> a
org.apache.commons.math.exception.util.ArgUtils -> org.a.a.a.d.a.a:
    java.lang.Object[] flatten(java.lang.Object[]) -> a
org.apache.commons.math.exception.util.Localizable -> org.a.a.a.d.a.b:
    java.lang.String getLocalizedString(java.util.Locale) -> a
org.apache.commons.math.exception.util.LocalizedFormats -> org.a.a.a.d.a.c:
    org.apache.commons.math.exception.util.LocalizedFormats ARGUMENT_OUTSIDE_DOMAIN -> a
    org.apache.commons.math.exception.util.LocalizedFormats ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1 -> b
    org.apache.commons.math.exception.util.LocalizedFormats ARRAY_SUMS_TO_ZERO -> c
    org.apache.commons.math.exception.util.LocalizedFormats ASSYMETRIC_EIGEN_NOT_SUPPORTED -> d
    org.apache.commons.math.exception.util.LocalizedFormats AT_LEAST_ONE_COLUMN -> e
    org.apache.commons.math.exception.util.LocalizedFormats AT_LEAST_ONE_ROW -> f
    org.apache.commons.math.exception.util.LocalizedFormats BANDWIDTH_OUT_OF_INTERVAL -> g
    org.apache.commons.math.exception.util.LocalizedFormats BINOMIAL_INVALID_PARAMETERS_ORDER -> h
    org.apache.commons.math.exception.util.LocalizedFormats BINOMIAL_NEGATIVE_PARAMETER -> i
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> j
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_0TH_ROOT_OF_UNITY -> k
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA -> l
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA -> m
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N -> n
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_CONVERT_OBJECT_TO_FRACTION -> o
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS -> p
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR -> q
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_COMPLEX -> r
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR -> s
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_FORMAT_OBJECT_TO_FRACTION -> t
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS -> u
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR -> v
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_RETRIEVE_AT_NEGATIVE_INDEX -> w
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_SET_AT_NEGATIVE_INDEX -> x
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY -> y
    org.apache.commons.math.exception.util.LocalizedFormats CANNOT_TRANSFORM_TO_DOUBLE -> z
    org.apache.commons.math.exception.util.LocalizedFormats CARDAN_ANGLES_SINGULARITY -> A
    org.apache.commons.math.exception.util.LocalizedFormats CLASS_DOESNT_IMPLEMENT_COMPARABLE -> B
    org.apache.commons.math.exception.util.LocalizedFormats CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT -> C
    org.apache.commons.math.exception.util.LocalizedFormats COLUMN_INDEX_OUT_OF_RANGE -> D
    org.apache.commons.math.exception.util.LocalizedFormats CONTINUED_FRACTION_INFINITY_DIVERGENCE -> E
    org.apache.commons.math.exception.util.LocalizedFormats CONTINUED_FRACTION_NAN_DIVERGENCE -> F
    org.apache.commons.math.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR -> G
    org.apache.commons.math.exception.util.LocalizedFormats CONTRACTION_CRITERIA_SMALLER_THAN_ONE -> H
    org.apache.commons.math.exception.util.LocalizedFormats CONVERGENCE_FAILED -> I
    org.apache.commons.math.exception.util.LocalizedFormats CUMULATIVE_PROBABILITY_RETURNED_NAN -> J
    org.apache.commons.math.exception.util.LocalizedFormats DIFFERENT_ROWS_LENGTHS -> K
    org.apache.commons.math.exception.util.LocalizedFormats DIGEST_NOT_INITIALIZED -> L
    org.apache.commons.math.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_2x2 -> M
    org.apache.commons.math.exception.util.LocalizedFormats DIMENSIONS_MISMATCH_SIMPLE -> N
    org.apache.commons.math.exception.util.LocalizedFormats DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN -> O
    org.apache.commons.math.exception.util.LocalizedFormats DISTRIBUTION_NOT_LOADED -> P
    org.apache.commons.math.exception.util.LocalizedFormats DUPLICATED_ABSCISSA -> Q
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_CLUSTER_IN_K_MEANS -> R
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY -> S
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_SELECTED_COLUMN_INDEX_ARRAY -> T
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_SELECTED_ROW_INDEX_ARRAY -> U
    org.apache.commons.math.exception.util.LocalizedFormats EMPTY_STRING_FOR_IMAGINARY_CHARACTER -> V
    org.apache.commons.math.exception.util.LocalizedFormats ENDPOINTS_NOT_AN_INTERVAL -> W
    org.apache.commons.math.exception.util.LocalizedFormats EQUAL_VERTICES_IN_SIMPLEX -> X
    org.apache.commons.math.exception.util.LocalizedFormats EULER_ANGLES_SINGULARITY -> Y
    org.apache.commons.math.exception.util.LocalizedFormats EVALUATION_FAILED -> Z
    org.apache.commons.math.exception.util.LocalizedFormats EXPANSION_FACTOR_SMALLER_THAN_ONE -> aa
    org.apache.commons.math.exception.util.LocalizedFormats FACTORIAL_NEGATIVE_PARAMETER -> ab
    org.apache.commons.math.exception.util.LocalizedFormats FAILED_BRACKETING -> ac
    org.apache.commons.math.exception.util.LocalizedFormats FAILED_FRACTION_CONVERSION -> ad
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_COLUMNS_NOT_INITIALIZED_YET -> ae
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_ELEMENT_NOT_ZERO -> af
    org.apache.commons.math.exception.util.LocalizedFormats FIRST_ROWS_NOT_INITIALIZED_YET -> ag
    org.apache.commons.math.exception.util.LocalizedFormats FRACTION_CONVERSION_OVERFLOW -> ah
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION_NOT_DIFFERENTIABLE -> ai
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION_NOT_POLYNOMIAL -> aj
    org.apache.commons.math.exception.util.LocalizedFormats GCD_OVERFLOW_32_BITS -> ak
    org.apache.commons.math.exception.util.LocalizedFormats GCD_OVERFLOW_64_BITS -> al
    org.apache.commons.math.exception.util.LocalizedFormats HOLE_BETWEEN_MODELS_TIME_RANGES -> am
    org.apache.commons.math.exception.util.LocalizedFormats IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO -> an
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_LARGER_THAN_MAX -> ao
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_NOT_POSITIVE -> ap
    org.apache.commons.math.exception.util.LocalizedFormats INDEX_OUT_OF_RANGE -> aq
    org.apache.commons.math.exception.util.LocalizedFormats INFINITE_ARRAY_ELEMENT -> ar
    org.apache.commons.math.exception.util.LocalizedFormats INFINITE_VALUE_CONVERSION -> as
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_CAPACITY_NOT_POSITIVE -> at
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_COLUMN_AFTER_FINAL_COLUMN -> au
    org.apache.commons.math.exception.util.LocalizedFormats INITIAL_ROW_AFTER_FINAL_ROW -> av
    org.apache.commons.math.exception.util.LocalizedFormats INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE -> aw
    org.apache.commons.math.exception.util.LocalizedFormats INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES -> ax
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_DATA_FOR_T_STATISTIC -> ay
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_DIMENSION -> az
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE -> aA
    org.apache.commons.math.exception.util.LocalizedFormats INSUFFICIENT_ROWS_AND_COLUMNS -> aB
    org.apache.commons.math.exception.util.LocalizedFormats INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT -> aC
    org.apache.commons.math.exception.util.LocalizedFormats INTERNAL_ERROR -> aD
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_BRACKETING_PARAMETERS -> aE
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS -> aF
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_ITERATIONS_LIMITS -> aG
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_MAX_ITERATIONS -> aH
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_REGRESSION_ARRAY -> aI
    org.apache.commons.math.exception.util.LocalizedFormats INVALID_ROUNDING_METHOD -> aJ
    org.apache.commons.math.exception.util.LocalizedFormats ITERATOR_EXHAUSTED -> aK
    org.apache.commons.math.exception.util.LocalizedFormats LCM_OVERFLOW_32_BITS -> aL
    org.apache.commons.math.exception.util.LocalizedFormats LCM_OVERFLOW_64_BITS -> aM
    org.apache.commons.math.exception.util.LocalizedFormats LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE -> aN
    org.apache.commons.math.exception.util.LocalizedFormats LOESS_EXPECTS_AT_LEAST_ONE_POINT -> aO
    org.apache.commons.math.exception.util.LocalizedFormats LOWER_BOUND_NOT_BELOW_UPPER_BOUND -> aP
    org.apache.commons.math.exception.util.LocalizedFormats LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT -> aQ
    org.apache.commons.math.exception.util.LocalizedFormats MAP_MODIFIED_WHILE_ITERATING -> aR
    org.apache.commons.math.exception.util.LocalizedFormats MAX_EVALUATIONS_EXCEEDED -> aS
    org.apache.commons.math.exception.util.LocalizedFormats MAX_ITERATIONS_EXCEEDED -> aT
    org.apache.commons.math.exception.util.LocalizedFormats MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION -> aU
    org.apache.commons.math.exception.util.LocalizedFormats MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS -> aV
    org.apache.commons.math.exception.util.LocalizedFormats NAN_ELEMENT_AT_INDEX -> aW
    org.apache.commons.math.exception.util.LocalizedFormats NAN_VALUE_CONVERSION -> aX
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_BRIGHTNESS_EXPONENT -> aY
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_COMPLEX_MODULE -> aZ
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_2D_INDEX -> ba
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ELEMENT_AT_INDEX -> bb
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_SUCCESSES -> bc
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_NUMBER_OF_TRIALS -> bd
    org.apache.commons.math.exception.util.LocalizedFormats NEGATIVE_ROBUSTNESS_ITERATIONS -> be
    org.apache.commons.math.exception.util.LocalizedFormats START_POSITION -> bf
    org.apache.commons.math.exception.util.LocalizedFormats NON_CONVERGENT_CONTINUED_FRACTION -> bg
    org.apache.commons.math.exception.util.LocalizedFormats NON_POSITIVE_MICROSPHERE_ELEMENTS -> bh
    org.apache.commons.math.exception.util.LocalizedFormats NON_POSITIVE_POLYNOMIAL_DEGREE -> bi
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_ABSCISSA -> bj
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_ORDINATE -> bk
    org.apache.commons.math.exception.util.LocalizedFormats NON_REAL_FINITE_WEIGHT -> bl
    org.apache.commons.math.exception.util.LocalizedFormats NON_SQUARE_MATRIX -> bm
    org.apache.commons.math.exception.util.LocalizedFormats NORMALIZE_INFINITE -> bn
    org.apache.commons.math.exception.util.LocalizedFormats NORMALIZE_NAN -> bo
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ADDITION_COMPATIBLE_MATRICES -> bp
    org.apache.commons.math.exception.util.LocalizedFormats NOT_DECREASING_NUMBER_OF_POINTS -> bq
    org.apache.commons.math.exception.util.LocalizedFormats NOT_DECREASING_SEQUENCE -> br
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS -> bs
    org.apache.commons.math.exception.util.LocalizedFormats NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION -> bt
    org.apache.commons.math.exception.util.LocalizedFormats NOT_INCREASING_NUMBER_OF_POINTS -> bu
    org.apache.commons.math.exception.util.LocalizedFormats NOT_INCREASING_SEQUENCE -> bv
    org.apache.commons.math.exception.util.LocalizedFormats NOT_MULTIPLICATION_COMPATIBLE_MATRICES -> bw
    org.apache.commons.math.exception.util.LocalizedFormats NOT_OVERRIDEN -> bx
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ALPHA -> by
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_BETA -> bz
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_COLUMNDIMENSION -> bA
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_DEFINITE_MATRIX -> bB
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_DEGREES_OF_FREEDOM -> bC
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ELEMENT_AT_INDEX -> bD
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_EXPONENT -> bE
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_LENGTH -> bF
    org.apache.commons.math.exception.util.LocalizedFormats LENGTH -> bG
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_MEAN -> bH
    org.apache.commons.math.exception.util.LocalizedFormats MEAN -> bI
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_NUMBER_OF_SAMPLES -> bJ
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_SAMPLES -> bK
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_PERMUTATION -> bL
    org.apache.commons.math.exception.util.LocalizedFormats PERMUTATION_SIZE -> bM
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_POISSON_MEAN -> bN
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_POPULATION_SIZE -> bO
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_ROW_DIMENSION -> bP
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SAMPLE_SIZE -> bQ
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SCALE -> bR
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_SHAPE -> bS
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_STANDARD_DEVIATION -> bT
    org.apache.commons.math.exception.util.LocalizedFormats STANDARD_DEVIATION -> bU
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_UPPER_BOUND -> bV
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POSITIVE_WINDOW_SIZE -> bW
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO -> bX
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO_CONSIDER_PADDING -> bY
    org.apache.commons.math.exception.util.LocalizedFormats NOT_POWER_OF_TWO_PLUS_ONE -> bZ
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_NUMBER_OF_POINTS -> ca
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_DECREASING_SEQUENCE -> cb
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_KNOT_VALUES -> cc
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS -> cd
    org.apache.commons.math.exception.util.LocalizedFormats NOT_STRICTLY_INCREASING_SEQUENCE -> ce
    org.apache.commons.math.exception.util.LocalizedFormats NOT_SUBTRACTION_COMPATIBLE_MATRICES -> cf
    org.apache.commons.math.exception.util.LocalizedFormats NOT_SYMMETRIC_MATRIX -> cg
    org.apache.commons.math.exception.util.LocalizedFormats NO_BIN_SELECTED -> ch
    org.apache.commons.math.exception.util.LocalizedFormats NO_CONVERGENCE_WITH_ANY_START_POINT -> ci
    org.apache.commons.math.exception.util.LocalizedFormats NO_DATA -> cj
    org.apache.commons.math.exception.util.LocalizedFormats NO_DEGREES_OF_FREEDOM -> ck
    org.apache.commons.math.exception.util.LocalizedFormats NO_DENSITY_FOR_THIS_DISTRIBUTION -> cl
    org.apache.commons.math.exception.util.LocalizedFormats NO_FEASIBLE_SOLUTION -> cm
    org.apache.commons.math.exception.util.LocalizedFormats NO_OPTIMUM_COMPUTED_YET -> cn
    org.apache.commons.math.exception.util.LocalizedFormats NO_RESULT_AVAILABLE -> co
    org.apache.commons.math.exception.util.LocalizedFormats NO_SUCH_MATRIX_ENTRY -> cp
    org.apache.commons.math.exception.util.LocalizedFormats NULL_NOT_ALLOWED -> cq
    org.apache.commons.math.exception.util.LocalizedFormats COVARIANCE_MATRIX -> cr
    org.apache.commons.math.exception.util.LocalizedFormats DENOMINATOR -> cs
    org.apache.commons.math.exception.util.LocalizedFormats DENOMINATOR_FORMAT -> ct
    org.apache.commons.math.exception.util.LocalizedFormats FRACTION -> cu
    org.apache.commons.math.exception.util.LocalizedFormats FUNCTION -> cv
    org.apache.commons.math.exception.util.LocalizedFormats IMAGINARY_FORMAT -> cw
    org.apache.commons.math.exception.util.LocalizedFormats INPUT_ARRAY -> cx
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR -> cy
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR_FORMAT -> cz
    org.apache.commons.math.exception.util.LocalizedFormats OBJECT_TRANSFORMATION -> cA
    org.apache.commons.math.exception.util.LocalizedFormats REAL_FORMAT -> cB
    org.apache.commons.math.exception.util.LocalizedFormats WHOLE_FORMAT -> cC
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_LARGE -> cD
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_SMALL -> cE
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_LARGE_BOUND_EXCLUDED -> cF
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_TOO_SMALL_BOUND_EXCLUDED -> cG
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE -> cH
    org.apache.commons.math.exception.util.LocalizedFormats NUMERATOR_OVERFLOW_AFTER_MULTIPLY -> cI
    org.apache.commons.math.exception.util.LocalizedFormats N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED -> cJ
    org.apache.commons.math.exception.util.LocalizedFormats OBSERVED_COUNTS_ALL_ZERO -> cK
    org.apache.commons.math.exception.util.LocalizedFormats OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY -> cL
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_BOUNDS_QUANTILE_VALUE -> cM
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_BOUND_SIGNIFICANCE_LEVEL -> cN
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_ORDER_ABSCISSA_ARRAY -> cO
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_RANGE_ROOT_OF_UNITY_INDEX -> cP
    org.apache.commons.math.exception.util.LocalizedFormats OUT_OF_RANGE_SIMPLE -> cQ
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_FRACTION -> cR
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_ADDITION -> cS
    org.apache.commons.math.exception.util.LocalizedFormats OVERFLOW_IN_SUBTRACTION -> cT
    org.apache.commons.math.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD -> cU
    org.apache.commons.math.exception.util.LocalizedFormats PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD -> cV
    org.apache.commons.math.exception.util.LocalizedFormats PERMUTATION_EXCEEDS_N -> cW
    org.apache.commons.math.exception.util.LocalizedFormats POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS -> cX
    org.apache.commons.math.exception.util.LocalizedFormats POPULATION_LIMIT_NOT_POSITIVE -> cY
    org.apache.commons.math.exception.util.LocalizedFormats POSITION_SIZE_MISMATCH_INPUT_ARRAY -> cZ
    org.apache.commons.math.exception.util.LocalizedFormats POWER_NEGATIVE_PARAMETERS -> da
    org.apache.commons.math.exception.util.LocalizedFormats PROPAGATION_DIRECTION_MISMATCH -> db
    org.apache.commons.math.exception.util.LocalizedFormats RANDOMKEY_MUTATION_WRONG_CLASS -> dc
    org.apache.commons.math.exception.util.LocalizedFormats ROOTS_OF_UNITY_NOT_COMPUTED_YET -> dd
    org.apache.commons.math.exception.util.LocalizedFormats ROTATION_MATRIX_DIMENSIONS -> de
    org.apache.commons.math.exception.util.LocalizedFormats ROW_INDEX_OUT_OF_RANGE -> df
    org.apache.commons.math.exception.util.LocalizedFormats SAME_SIGN_AT_ENDPOINTS -> dg
    org.apache.commons.math.exception.util.LocalizedFormats SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE -> dh
    org.apache.commons.math.exception.util.LocalizedFormats SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE -> di
    org.apache.commons.math.exception.util.LocalizedFormats SIMPLEX_NEED_ONE_POINT -> dj
    org.apache.commons.math.exception.util.LocalizedFormats SIMPLE_MESSAGE -> dk
    org.apache.commons.math.exception.util.LocalizedFormats SINGULAR_MATRIX -> dl
    org.apache.commons.math.exception.util.LocalizedFormats SUBARRAY_ENDS_AFTER_ARRAY_END -> dm
    org.apache.commons.math.exception.util.LocalizedFormats TOO_LARGE_CUTOFF_SINGULAR_VALUE -> dn
    org.apache.commons.math.exception.util.LocalizedFormats TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY -> do
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_BANDWIDTH -> dp
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_COST_RELATIVE_TOLERANCE -> dq
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_INTEGRATION_INTERVAL -> dr
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_ORTHOGONALITY_TOLERANCE -> ds
    org.apache.commons.math.exception.util.LocalizedFormats TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE -> dt
    org.apache.commons.math.exception.util.LocalizedFormats TWO_OR_MORE_CATEGORIES_REQUIRED -> du
    org.apache.commons.math.exception.util.LocalizedFormats TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED -> dv
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH -> dw
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM -> dx
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS -> dy
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_ORTHOGONOLIZE_MATRIX -> dz
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN -> dA
    org.apache.commons.math.exception.util.LocalizedFormats UNABLE_TO_SOLVE_SINGULAR_PROBLEM -> dB
    org.apache.commons.math.exception.util.LocalizedFormats UNBOUNDED_SOLUTION -> dC
    org.apache.commons.math.exception.util.LocalizedFormats UNKNOWN_MODE -> dD
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_3D_VECTOR -> dE
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_COMPLEX_NUMBER -> dF
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_FRACTION_NUMBER -> dG
    org.apache.commons.math.exception.util.LocalizedFormats UNPARSEABLE_REAL_VECTOR -> dH
    org.apache.commons.math.exception.util.LocalizedFormats UNSUPPORTED_EXPANSION_MODE -> dI
    org.apache.commons.math.exception.util.LocalizedFormats UNSUPPORTED_OPERATION -> dJ
    org.apache.commons.math.exception.util.LocalizedFormats USER_EXCEPTION -> dK
    org.apache.commons.math.exception.util.LocalizedFormats URL_CONTAINS_NO_DATA -> dL
    org.apache.commons.math.exception.util.LocalizedFormats VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC -> dM
    org.apache.commons.math.exception.util.LocalizedFormats VECTOR_LENGTH_MISMATCH -> dN
    org.apache.commons.math.exception.util.LocalizedFormats VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT -> dO
    org.apache.commons.math.exception.util.LocalizedFormats WEIGHT_AT_LEAST_ONE_NON_ZERO -> dP
    org.apache.commons.math.exception.util.LocalizedFormats WRONG_BLOCK_LENGTH -> dQ
    org.apache.commons.math.exception.util.LocalizedFormats WRONG_NUMBER_OF_POINTS -> dR
    org.apache.commons.math.exception.util.LocalizedFormats NUMBER_OF_POINTS -> dS
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_DENOMINATOR -> dT
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_DENOMINATOR_IN_FRACTION -> dU
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_FRACTION_TO_DIVIDE_BY -> dV
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM -> dW
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_AXIS -> dX
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR -> dY
    org.apache.commons.math.exception.util.LocalizedFormats ZERO_NOT_ALLOWED -> dZ
    java.lang.String sourceFormat -> a
    org.apache.commons.math.exception.util.LocalizedFormats[] ENUM$VALUES -> a
    java.lang.String getLocalizedString(java.util.Locale) -> a
    org.apache.commons.math.exception.util.LocalizedFormats[] values() -> values
    org.apache.commons.math.exception.util.LocalizedFormats valueOf(java.lang.String) -> valueOf
org.apache.commons.math.exception.util.MessageFactory -> org.a.a.a.d.a.d:
    java.lang.String buildMessage(java.util.Locale,org.apache.commons.math.exception.util.Localizable,org.apache.commons.math.exception.util.Localizable,java.lang.Object[]) -> a
org.apache.commons.math.linear.AbstractRealMatrix -> org.a.a.a.e.a:
    org.apache.commons.math.linear.DecompositionSolver lu -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix subtract(org.apache.commons.math.linear.RealMatrix) -> b
    org.apache.commons.math.linear.RealMatrix scalarAdd(double) -> a
    org.apache.commons.math.linear.RealMatrix scalarMultiply(double) -> b
    org.apache.commons.math.linear.RealMatrix multiply(org.apache.commons.math.linear.RealMatrix) -> c
    double[][] getData() -> a
    double getNorm() -> b
    org.apache.commons.math.linear.RealMatrix getSubMatrix(int,int,int,int) -> a
    void copySubMatrix(int,int,int,int,double[][]) -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math.linear.RealVector getColumnVector(int) -> a
    void setColumnVector(int,org.apache.commons.math.linear.RealVector) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    org.apache.commons.math.linear.RealMatrix transpose() -> a
    boolean isSquare() -> c
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double getTrace() -> c
    double[] operate(double[]) -> a
    org.apache.commons.math.linear.RealVector operate(org.apache.commons.math.linear.RealVector) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> b
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> c
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.linear.AbstractRealMatrix$1 -> org.a.a.a.e.b:
    double endRow -> a
    double columnSum -> b
    double maxColSum -> c
    org.apache.commons.math.linear.AbstractRealMatrix this$0 -> a
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math.linear.AbstractRealMatrix$4 -> org.a.a.a.e.c:
    int startRow -> a
    int startColumn -> b
    org.apache.commons.math.linear.AbstractRealMatrix this$0 -> a
    double[][] val$destination -> a
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
org.apache.commons.math.linear.AbstractRealMatrix$5 -> org.a.a.a.e.d:
    org.apache.commons.math.linear.AbstractRealMatrix this$0 -> a
    org.apache.commons.math.linear.RealMatrix val$out -> a
    void visit(int,int,double) -> a
org.apache.commons.math.linear.AbstractRealVector -> org.a.a.a.e.e:
    void checkVectorDimensions(org.apache.commons.math.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    void checkIndex(int) -> b
    org.apache.commons.math.linear.RealVector add(double[]) -> a
    org.apache.commons.math.linear.RealVector add(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.RealVector subtract(double[]) -> b
    org.apache.commons.math.linear.RealVector subtract(org.apache.commons.math.linear.RealVector) -> b
    org.apache.commons.math.linear.AbstractRealVector copy() -> a
    double dotProduct(double[]) -> a
    double dotProduct(org.apache.commons.math.linear.RealVector) -> a
    double getNorm() -> a
    org.apache.commons.math.linear.RealVector mapMultiply(double) -> a
    org.apache.commons.math.linear.RealVector mapMultiplyToSelf(double) -> b
    double[] toArray() -> a
    double[] getData() -> b
    java.util.Iterator sparseIterator() -> a
    java.util.Iterator iterator() -> b
    org.apache.commons.math.linear.RealVector mapToSelf(org.apache.commons.math.analysis.UnivariateRealFunction) -> a
    org.apache.commons.math.linear.RealVector copy() -> a
org.apache.commons.math.linear.AbstractRealVector$1 -> org.a.a.a.e.f:
    int i -> a
    org.apache.commons.math.linear.AbstractRealVector$EntryImpl e -> a
    org.apache.commons.math.linear.AbstractRealVector this$0 -> a
    int val$dim -> b
    boolean hasNext() -> hasNext
    org.apache.commons.math.linear.RealVector$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math.linear.AbstractRealVector$EntryImpl -> org.a.a.a.e.e$a:
    org.apache.commons.math.linear.AbstractRealVector this$0 -> a
    double getValue() -> a
    void setValue(double) -> a
org.apache.commons.math.linear.AbstractRealVector$SparseEntryIterator -> org.a.a.a.e.e$b:
    int dim -> a
    org.apache.commons.math.linear.AbstractRealVector$EntryImpl current -> a
    org.apache.commons.math.linear.AbstractRealVector$EntryImpl next -> b
    org.apache.commons.math.linear.AbstractRealVector this$0 -> a
    void advance(org.apache.commons.math.linear.AbstractRealVector$EntryImpl) -> a
    boolean hasNext() -> hasNext
    org.apache.commons.math.linear.RealVector$Entry next() -> a
    void remove() -> remove
    java.lang.Object next() -> next
org.apache.commons.math.linear.AnyMatrix -> org.a.a.a.e.g:
    boolean isSquare() -> c
    int getRowDimension() -> a
    int getColumnDimension() -> b
org.apache.commons.math.linear.Array2DRowRealMatrix -> org.a.a.a.e.h:
    double[][] data -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.Array2DRowRealMatrix add(org.apache.commons.math.linear.Array2DRowRealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix subtract(org.apache.commons.math.linear.RealMatrix) -> b
    org.apache.commons.math.linear.Array2DRowRealMatrix subtract(org.apache.commons.math.linear.Array2DRowRealMatrix) -> b
    org.apache.commons.math.linear.RealMatrix multiply(org.apache.commons.math.linear.RealMatrix) -> c
    org.apache.commons.math.linear.Array2DRowRealMatrix multiply(org.apache.commons.math.linear.Array2DRowRealMatrix) -> c
    double[][] getData() -> a
    void setSubMatrix(double[][],int,int) -> a
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    void addToEntry(int,int,double) -> b
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double walkInColumnOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> b
    double[][] copyOut() -> b
    void copyIn(double[][]) -> a
org.apache.commons.math.linear.ArrayRealVector -> org.a.a.a.e.i:
    org.apache.commons.math.linear.RealVectorFormat DEFAULT_FORMAT -> a
    double[] data -> a
    org.apache.commons.math.linear.AbstractRealVector copy() -> a
    org.apache.commons.math.linear.RealVector add(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.RealVector add(double[]) -> a
    org.apache.commons.math.linear.ArrayRealVector add(org.apache.commons.math.linear.ArrayRealVector) -> a
    org.apache.commons.math.linear.RealVector subtract(org.apache.commons.math.linear.RealVector) -> b
    org.apache.commons.math.linear.RealVector subtract(double[]) -> b
    org.apache.commons.math.linear.ArrayRealVector subtract(org.apache.commons.math.linear.ArrayRealVector) -> b
    org.apache.commons.math.linear.RealVector mapMultiplyToSelf(double) -> b
    double[] getData() -> b
    double[] getDataRef() -> c
    double dotProduct(org.apache.commons.math.linear.RealVector) -> a
    double dotProduct(double[]) -> a
    double dotProduct(org.apache.commons.math.linear.ArrayRealVector) -> a
    double getNorm() -> a
    double getEntry(int) -> a
    int getDimension() -> a
    void setEntry(int,double) -> a
    double[] toArray() -> a
    java.lang.String toString() -> toString
    void checkVectorDimensions(org.apache.commons.math.linear.RealVector) -> a
    void checkVectorDimensions(int) -> a
    boolean isNaN() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    org.apache.commons.math.linear.RealVector copy() -> a
org.apache.commons.math.linear.BlockRealMatrix -> org.a.a.a.e.j:
    double[][] blocks -> a
    int rows -> a
    int columns -> b
    int blockRows -> c
    int blockColumns -> d
    double[][] createBlocksLayout(int,int) -> a
    org.apache.commons.math.linear.BlockRealMatrix createMatrix(int,int) -> a
    org.apache.commons.math.linear.BlockRealMatrix add(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.BlockRealMatrix add(org.apache.commons.math.linear.BlockRealMatrix) -> a
    org.apache.commons.math.linear.BlockRealMatrix subtract(org.apache.commons.math.linear.RealMatrix) -> b
    org.apache.commons.math.linear.BlockRealMatrix subtract(org.apache.commons.math.linear.BlockRealMatrix) -> b
    org.apache.commons.math.linear.BlockRealMatrix scalarAdd(double) -> a
    org.apache.commons.math.linear.RealMatrix scalarMultiply(double) -> b
    org.apache.commons.math.linear.BlockRealMatrix multiply(org.apache.commons.math.linear.RealMatrix) -> c
    org.apache.commons.math.linear.BlockRealMatrix multiply(org.apache.commons.math.linear.BlockRealMatrix) -> c
    double[][] getData() -> a
    double getNorm() -> b
    org.apache.commons.math.linear.BlockRealMatrix getSubMatrix(int,int,int,int) -> a
    void copyBlockPart(double[],int,int,int,int,int,double[],int,int,int) -> a
    void setSubMatrix(double[][],int,int) -> a
    org.apache.commons.math.linear.RealVector getColumnVector(int) -> a
    void setColumnVector(int,org.apache.commons.math.linear.RealVector) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    void addToEntry(int,int,double) -> b
    org.apache.commons.math.linear.BlockRealMatrix transpose() -> a
    int getRowDimension() -> a
    int getColumnDimension() -> b
    double[] operate(double[]) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> a
    double walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> a
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor) -> c
    double walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor,int,int,int,int) -> b
    int blockHeight(int) -> a
    int blockWidth(int) -> b
    org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix subtract(org.apache.commons.math.linear.RealMatrix) -> b
    org.apache.commons.math.linear.RealMatrix multiply(org.apache.commons.math.linear.RealMatrix) -> c
    org.apache.commons.math.linear.RealMatrix scalarAdd(double) -> a
    org.apache.commons.math.linear.RealMatrix transpose() -> a
    org.apache.commons.math.linear.RealMatrix createMatrix(int,int) -> a
    org.apache.commons.math.linear.RealMatrix getSubMatrix(int,int,int,int) -> a
org.apache.commons.math.linear.DecompositionSolver -> org.a.a.a.e.k:
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    boolean isNonSingular() -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor -> org.a.a.a.e.l:
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math.linear.EigenDecomposition -> org.a.a.a.e.m:
    org.apache.commons.math.linear.RealMatrix getV() -> a
    double[] getRealEigenvalues() -> a
org.apache.commons.math.linear.EigenDecompositionImpl -> org.a.a.a.e.n:
    byte maxIter -> a
    double[] main -> a
    double[] secondary -> b
    org.apache.commons.math.linear.TriDiagonalTransformer transformer -> a
    double[] realEigenvalues -> c
    double[] imagEigenvalues -> d
    org.apache.commons.math.linear.ArrayRealVector[] eigenvectors -> a
    org.apache.commons.math.linear.RealMatrix cachedV -> a
    boolean isSymmetric(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix getV() -> a
    double[] getRealEigenvalues() -> a
    void transformToTridiagonal(org.apache.commons.math.linear.RealMatrix) -> a
    void findEigenVectors(double[][]) -> a
org.apache.commons.math.linear.InvalidMatrixException -> org.a.a.a.e.o:
org.apache.commons.math.linear.LUDecompositionImpl -> org.a.a.a.e.p:
    double[][] lu -> a
    int[] pivot -> a
    boolean even -> a
    boolean singular -> b
    org.apache.commons.math.linear.RealMatrix cachedL -> a
    org.apache.commons.math.linear.RealMatrix cachedU -> b
    org.apache.commons.math.linear.RealMatrix cachedP -> c
    double getDeterminant() -> a
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.LUDecompositionImpl$Solver -> org.a.a.a.e.p$a:
    double[][] lu -> a
    int[] pivot -> a
    boolean singular -> a
    boolean isNonSingular() -> a
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.ArrayRealVector solve(org.apache.commons.math.linear.ArrayRealVector) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.MatrixIndexException -> org.a.a.a.e.q:
org.apache.commons.math.linear.MatrixUtils -> org.a.a.a.e.r:
    org.apache.commons.math.linear.RealMatrix createRealMatrix(int,int) -> a
    org.apache.commons.math.linear.RealMatrix createRealIdentityMatrix(int) -> a
    void checkRowIndex(org.apache.commons.math.linear.AnyMatrix,int) -> a
    void checkColumnIndex(org.apache.commons.math.linear.AnyMatrix,int) -> b
    void checkSubMatrixIndex(org.apache.commons.math.linear.AnyMatrix,int,int,int,int) -> a
    void checkAdditionCompatible(org.apache.commons.math.linear.AnyMatrix,org.apache.commons.math.linear.AnyMatrix) -> a
    void checkSubtractionCompatible(org.apache.commons.math.linear.AnyMatrix,org.apache.commons.math.linear.AnyMatrix) -> b
    void checkMultiplicationCompatible(org.apache.commons.math.linear.AnyMatrix,org.apache.commons.math.linear.AnyMatrix) -> c
org.apache.commons.math.linear.MatrixVisitorException -> org.a.a.a.e.s:
org.apache.commons.math.linear.NonSquareMatrixException -> org.a.a.a.e.t:
org.apache.commons.math.linear.QRDecompositionImpl -> org.a.a.a.e.u:
    double[][] qrt -> a
    double[] rDiag -> a
    org.apache.commons.math.linear.RealMatrix cachedQ -> a
    org.apache.commons.math.linear.RealMatrix cachedQT -> b
    org.apache.commons.math.linear.RealMatrix cachedR -> c
    org.apache.commons.math.linear.RealMatrix cachedH -> d
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.QRDecompositionImpl$Solver -> org.a.a.a.e.u$a:
    double[][] qrt -> a
    double[] rDiag -> a
    boolean isNonSingular() -> a
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.ArrayRealVector solve(org.apache.commons.math.linear.ArrayRealVector) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.RealMatrix -> org.a.a.a.e.v:
    org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix) -> a
    org.apache.commons.math.linear.RealMatrix subtract(org.apache.commons.math.linear.RealMatrix) -> b
    org.apache.commons.math.linear.RealMatrix scalarAdd(double) -> a
    org.apache.commons.math.linear.RealMatrix scalarMultiply(double) -> b
    org.apache.commons.math.linear.RealMatrix multiply(org.apache.commons.math.linear.RealMatrix) -> c
    double[][] getData() -> a
    double getNorm() -> b
    org.apache.commons.math.linear.RealMatrix getSubMatrix(int,int,int,int) -> a
    void copySubMatrix(int,int,int,int,double[][]) -> a
    org.apache.commons.math.linear.RealVector getColumnVector(int) -> a
    void setColumnVector(int,org.apache.commons.math.linear.RealVector) -> a
    void setRow(int,double[]) -> a
    double[] getColumn(int) -> a
    void setColumn(int,double[]) -> b
    double getEntry(int,int) -> a
    void setEntry(int,int,double) -> a
    void addToEntry(int,int,double) -> b
    org.apache.commons.math.linear.RealMatrix transpose() -> a
    double getTrace() -> c
    double[] operate(double[]) -> a
    org.apache.commons.math.linear.RealVector operate(org.apache.commons.math.linear.RealVector) -> a
org.apache.commons.math.linear.RealMatrixPreservingVisitor -> org.a.a.a.e.w:
    void start(int,int,int,int,int,int) -> a
    void visit(int,int,double) -> a
    double end() -> a
org.apache.commons.math.linear.RealVector -> org.a.a.a.e.x:
    java.util.Iterator sparseIterator() -> a
    org.apache.commons.math.linear.RealVector copy() -> a
    org.apache.commons.math.linear.RealVector add(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.RealVector subtract(org.apache.commons.math.linear.RealVector) -> b
    org.apache.commons.math.linear.RealVector mapMultiply(double) -> a
    double[] getData() -> b
    double dotProduct(org.apache.commons.math.linear.RealVector) -> a
    double getNorm() -> a
    double getEntry(int) -> a
    void setEntry(int,double) -> a
    int getDimension() -> a
    boolean isNaN() -> a
org.apache.commons.math.linear.RealVector$Entry -> org.a.a.a.e.x$a:
    int index -> a
    double getValue() -> a
    void setValue(double) -> a
    int getIndex() -> a
    void setIndex(int) -> a
org.apache.commons.math.linear.RealVectorFormat -> org.a.a.a.e.y:
    java.lang.String prefix -> a
    java.lang.String suffix -> b
    java.lang.String separator -> c
    java.lang.String trimmedPrefix -> d
    java.lang.String trimmedSuffix -> e
    java.lang.String trimmedSeparator -> f
    java.text.NumberFormat format -> a
    org.apache.commons.math.linear.RealVectorFormat getInstance() -> a
    org.apache.commons.math.linear.RealVectorFormat getInstance(java.util.Locale) -> a
    java.lang.StringBuffer format(org.apache.commons.math.linear.RealVector,java.lang.StringBuffer,java.text.FieldPosition) -> a
    java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition) -> format
    org.apache.commons.math.linear.ArrayRealVector parse(java.lang.String,java.text.ParsePosition) -> a
    java.lang.Object parseObject(java.lang.String,java.text.ParsePosition) -> parseObject
org.apache.commons.math.linear.SingularMatrixException -> org.a.a.a.e.z:
org.apache.commons.math.linear.SingularValueDecomposition -> org.a.a.a.e.A:
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.SingularValueDecompositionImpl -> org.a.a.a.e.B:
    int m -> a
    int n -> b
    org.apache.commons.math.linear.EigenDecomposition eigenDecomposition -> a
    double[] singularValues -> a
    org.apache.commons.math.linear.RealMatrix cachedU -> a
    org.apache.commons.math.linear.RealMatrix cachedUt -> b
    org.apache.commons.math.linear.RealMatrix cachedS -> c
    org.apache.commons.math.linear.RealMatrix cachedV -> d
    org.apache.commons.math.linear.RealMatrix cachedVt -> e
    org.apache.commons.math.linear.RealMatrix getU() -> a
    org.apache.commons.math.linear.RealMatrix getUT() -> b
    org.apache.commons.math.linear.RealMatrix getV() -> c
    int getRank() -> a
    org.apache.commons.math.linear.DecompositionSolver getSolver() -> a
org.apache.commons.math.linear.SingularValueDecompositionImpl$Solver -> org.a.a.a.e.B$a:
    org.apache.commons.math.linear.RealMatrix pseudoInverse -> a
    boolean nonSingular -> a
    double[] solve(double[]) -> a
    org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector) -> a
    org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix) -> a
    boolean isNonSingular() -> a
    org.apache.commons.math.linear.RealMatrix getInverse() -> a
org.apache.commons.math.linear.TriDiagonalTransformer -> org.a.a.a.e.C:
    double[][] householderVectors -> a
    double[] main -> a
    double[] secondary -> b
    org.apache.commons.math.linear.RealMatrix cachedQ -> a
    org.apache.commons.math.linear.RealMatrix cachedQt -> b
    org.apache.commons.math.linear.RealMatrix cachedT -> c
    org.apache.commons.math.linear.RealMatrix getQ() -> a
    org.apache.commons.math.linear.RealMatrix getQT() -> b
    double[] getMainDiagonalRef() -> a
    double[] getSecondaryDiagonalRef() -> b
    void transform() -> a
org.apache.commons.math.ode.AbstractIntegrator -> org.a.a.a.f.a:
    java.util.Collection stepHandlers -> a
    double stepStart -> a
    double stepSize -> b
    boolean isLastStep -> a
    boolean resetOccurred -> b
    java.util.Collection eventsStates -> b
    boolean statesInitialized -> c
    java.lang.String name -> a
    int maxEvaluations -> a
    int evaluations -> b
    org.apache.commons.math.ode.FirstOrderDifferentialEquations equations -> a
    void addStepHandler(org.apache.commons.math.ode.sampling.StepHandler) -> a
    boolean requiresDenseOutput() -> a
    void setMaxEvaluations(int) -> a
    void resetEvaluations() -> a
    void setEquations(org.apache.commons.math.ode.FirstOrderDifferentialEquations) -> a
    void computeDerivatives(double,double[],double[]) -> a
    void setStateInitialized(boolean) -> a
    double acceptStep(org.apache.commons.math.ode.sampling.AbstractStepInterpolator,double[],double[],double) -> a
    void sanityChecks(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.AbstractIntegrator$1 -> org.a.a.a.f.b:
    org.apache.commons.math.ode.AbstractIntegrator this$0 -> a
    int val$orderingSign -> a
    int compare(org.apache.commons.math.ode.events.EventState,org.apache.commons.math.ode.events.EventState) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.apache.commons.math.ode.DerivativeException -> org.a.a.a.f.c:
org.apache.commons.math.ode.FirstOrderDifferentialEquations -> org.a.a.a.f.d:
    int getDimension() -> a
    void computeDerivatives(double,double[],double[]) -> a
org.apache.commons.math.ode.FirstOrderIntegrator -> org.a.a.a.f.e:
    double integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.IntegratorException -> org.a.a.a.f.f:
org.apache.commons.math.ode.ODEIntegrator -> org.a.a.a.f.g:
    void addStepHandler(org.apache.commons.math.ode.sampling.StepHandler) -> a
org.apache.commons.math.ode.events.EventException -> org.a.a.a.f.a.a:
org.apache.commons.math.ode.events.EventHandler -> org.a.a.a.f.a.b:
    double g(double,double[]) -> a
    int eventOccurred(double,double[],boolean) -> a
    void resetState(double,double[]) -> a
org.apache.commons.math.ode.events.EventState -> org.a.a.a.f.a.c:
    org.apache.commons.math.ode.events.EventHandler handler -> a
    double maxCheckInterval -> a
    double convergence -> b
    int maxIterationCount -> a
    double t0 -> c
    double g0 -> d
    boolean g0Positive -> a
    boolean pendingEvent -> b
    double pendingEventTime -> e
    double previousEventTime -> f
    boolean forward -> c
    boolean increasing -> d
    int nextAction -> b
    double getConvergence() -> a
    void reinitializeBegin(org.apache.commons.math.ode.sampling.StepInterpolator) -> a
    boolean evaluateStep(org.apache.commons.math.ode.sampling.StepInterpolator) -> a
    double getEventTime() -> b
    void stepAccepted(double,double[]) -> a
    boolean stop() -> a
    boolean reset(double,double[]) -> a
    org.apache.commons.math.ode.events.EventHandler access$0(org.apache.commons.math.ode.events.EventState) -> a
org.apache.commons.math.ode.events.EventState$1 -> org.a.a.a.f.a.d:
    org.apache.commons.math.ode.events.EventState this$0 -> a
    org.apache.commons.math.ode.sampling.StepInterpolator val$interpolator -> a
    double value(double) -> a
org.apache.commons.math.ode.events.EventState$EmbeddedDerivativeException -> org.a.a.a.f.a.c$a:
    org.apache.commons.math.ode.DerivativeException derivativeException -> a
    org.apache.commons.math.ode.DerivativeException getDerivativeException() -> a
org.apache.commons.math.ode.events.EventState$EmbeddedEventException -> org.a.a.a.f.a.c$b:
    org.apache.commons.math.ode.events.EventException eventException -> a
    org.apache.commons.math.ode.events.EventException getEventException() -> a
org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator -> org.a.a.a.f.b.a:
    double[] STATIC_C -> a
    double[][] STATIC_A -> a
    double[] STATIC_B -> b
org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolator -> org.a.a.a.f.b.b:
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator -> org.a.a.a.f.b.c:
    double[] c -> a
    double[][] a -> a
    double[] b -> b
    org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator prototype -> a
    double step -> c
    double integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations,double,double[],double,double[]) -> a
org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator -> org.a.a.a.f.b.d:
    double[][] yDotK -> a
    org.apache.commons.math.ode.AbstractIntegrator integrator -> a
    void reinitialize(org.apache.commons.math.ode.AbstractIntegrator,double[],double[][],boolean) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
org.apache.commons.math.ode.sampling.AbstractStepInterpolator -> org.a.a.a.f.c.a:
    double h -> a
    double[] currentState -> a
    double interpolatedTime -> b
    double[] interpolatedState -> b
    double[] interpolatedDerivatives -> c
    double globalPreviousTime -> c
    double globalCurrentTime -> d
    double softPreviousTime -> e
    double softCurrentTime -> f
    boolean finalized -> a
    boolean forward -> b
    boolean dirtyState -> c
    void reinitialize(double[],boolean) -> a
    org.apache.commons.math.ode.sampling.StepInterpolator copy() -> b
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void shift() -> a
    void storeTime(double) -> a
    void setSoftPreviousTime(double) -> b
    void setSoftCurrentTime(double) -> c
    double getGlobalPreviousTime() -> a
    double getGlobalCurrentTime() -> b
    double getPreviousTime() -> c
    double getCurrentTime() -> d
    void setInterpolatedTime(double) -> d
    boolean isForward() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
    double[] getInterpolatedState() -> a
    void finalizeStep() -> b
    void doFinalize() -> c
    void writeBaseExternal(java.io.ObjectOutput) -> a
    double readBaseExternal(java.io.ObjectInput) -> a
org.apache.commons.math.ode.sampling.DummyStepInterpolator -> org.a.a.a.f.c.b:
    double[] currentDerivative -> d
    org.apache.commons.math.ode.sampling.StepInterpolator doCopy() -> a
    void computeInterpolatedStateAndDerivatives(double,double) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
org.apache.commons.math.ode.sampling.StepHandler -> org.a.a.a.f.c.c:
    boolean requiresDenseOutput() -> a
    void reset() -> a
    void handleStep(org.apache.commons.math.ode.sampling.StepInterpolator,boolean) -> a
org.apache.commons.math.ode.sampling.StepInterpolator -> org.a.a.a.f.c.d:
    double getPreviousTime() -> c
    double getCurrentTime() -> d
    void setInterpolatedTime(double) -> d
    double[] getInterpolatedState() -> a
    boolean isForward() -> a
org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer -> org.a.a.a.g.a:
    org.apache.commons.math.optimization.VectorialPointValuePair optimize(org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction,double[],double[],double[]) -> a
org.apache.commons.math.optimization.OptimizationException -> org.a.a.a.g.b:
org.apache.commons.math.optimization.SimpleVectorialValueChecker -> org.a.a.a.g.c:
    double relativeThreshold -> a
    double absoluteThreshold -> b
    boolean converged(int,org.apache.commons.math.optimization.VectorialPointValuePair,org.apache.commons.math.optimization.VectorialPointValuePair) -> a
org.apache.commons.math.optimization.VectorialConvergenceChecker -> org.a.a.a.g.d:
    boolean converged(int,org.apache.commons.math.optimization.VectorialPointValuePair,org.apache.commons.math.optimization.VectorialPointValuePair) -> a
org.apache.commons.math.optimization.VectorialPointValuePair -> org.a.a.a.g.e:
    double[] point -> a
    double[] value -> b
    double[] getPointRef() -> a
    double[] getValueRef() -> b
org.apache.commons.math.optimization.fitting.CurveFitter -> org.a.a.a.g.a.a:
    org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer optimizer -> a
    java.util.List observations -> a
    void addObservedPoint(double,double,double) -> a
    void clearObservations() -> a
    double[] fit(org.apache.commons.math.optimization.fitting.ParametricRealFunction,double[]) -> a
    java.util.List access$0(org.apache.commons.math.optimization.fitting.CurveFitter) -> a
org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction -> org.a.a.a.g.a.a$a:
    org.apache.commons.math.optimization.fitting.ParametricRealFunction f -> a
    org.apache.commons.math.optimization.fitting.CurveFitter this$0 -> a
    org.apache.commons.math.analysis.MultivariateMatrixFunction jacobian() -> a
    double[] value(double[]) -> a
    org.apache.commons.math.optimization.fitting.ParametricRealFunction access$0(org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction) -> a
    org.apache.commons.math.optimization.fitting.CurveFitter access$1(org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction) -> a
org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction$1 -> org.a.a.a.g.a.b:
    org.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction this$1 -> a
    double[][] value(double[]) -> a
org.apache.commons.math.optimization.fitting.ParametricRealFunction -> org.a.a.a.g.a.c:
    double value(double,double[]) -> a
    double[] gradient(double,double[]) -> a
org.apache.commons.math.optimization.fitting.WeightedObservedPoint -> org.a.a.a.g.a.d:
    double weight -> a
    double x -> b
    double y -> c
    double getWeight() -> a
    double getX() -> b
    double getY() -> c
org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer -> org.a.a.a.g.b.a:
    org.apache.commons.math.optimization.VectorialConvergenceChecker checker -> a
    double[][] jacobian -> a
    int cols -> a
    int rows -> b
    double[] targetValues -> a
    double[] residualsWeights -> b
    double[] point -> c
    double[] objective -> d
    double[] residuals -> e
    double[][] wjacobian -> b
    double[] wresiduals -> f
    double cost -> a
    int maxIterations -> c
    int iterations -> d
    int maxEvaluations -> e
    int objectiveEvaluations -> f
    int jacobianEvaluations -> g
    org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function -> a
    org.apache.commons.math.analysis.MultivariateMatrixFunction jF -> a
    void setMaxIterations(int) -> a
    int getIterations() -> a
    void setMaxEvaluations(int) -> b
    void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker) -> a
    void incrementIterationsCounter() -> a
    void updateJacobian() -> b
    void updateResidualsAndCost() -> c
    org.apache.commons.math.optimization.VectorialPointValuePair optimize(org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction,double[],double[],double[]) -> a
    org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() -> a
org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer -> org.a.a.a.g.b.b:
    int solvedCols -> c
    double[] diagR -> g
    double[] jacNorm -> h
    double[] beta -> i
    int[] permutation -> a
    int rank -> d
    double lmPar -> b
    double[] lmDir -> j
    double initialStepBoundFactor -> c
    double costRelativeTolerance -> d
    double parRelativeTolerance -> e
    double orthoTolerance -> f
    double qrRankingThreshold -> g
    void setInitialStepBoundFactor(double) -> a
    void setCostRelativeTolerance(double) -> b
    void setParRelativeTolerance(double) -> c
    void setOrthoTolerance(double) -> d
    void setQRRankingThreshold(double) -> e
    org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() -> a
    void determineLMParameter(double[],double,double[],double[],double[],double[]) -> a
    void determineLMDirection(double[],double[],double[],double[]) -> a
    void qrDecomposition() -> d
    void qTy(double[]) -> a
org.apache.commons.math.random.JDKRandomGenerator -> org.a.a.a.h.a:
org.apache.commons.math.random.RandomData -> org.a.a.a.h.b:
    long nextLong(long,long) -> a
org.apache.commons.math.random.RandomDataImpl -> org.a.a.a.h.c:
    org.apache.commons.math.random.RandomGenerator rand -> a
    java.security.SecureRandom secRand -> a
    long nextLong(long,long) -> a
    org.apache.commons.math.random.RandomGenerator getRan() -> a
org.apache.commons.math.random.RandomGenerator -> org.a.a.a.h.d:
    void setSeed(long) -> setSeed
    double nextDouble() -> nextDouble
org.apache.commons.math.special.Beta -> org.a.a.a.i.a:
    double regularizedBeta(double,double,double) -> a
    double regularizedBeta(double,double,double,double,int) -> a
    double logBeta(double,double) -> a
    double logBeta(double,double,double,int) -> a
org.apache.commons.math.special.Beta$1 -> org.a.a.a.i.b:
    double val$b -> a
    double val$a -> b
    double getB(int,double) -> a
    double getA(int,double) -> b
org.apache.commons.math.special.Erf -> org.a.a.a.i.c:
    double erf(double) -> a
org.apache.commons.math.special.Gamma -> org.a.a.a.i.d:
    double[] LANCZOS -> a
    double HALF_LOG_2_PI -> a
    double logGamma(double) -> a
    double regularizedGammaP(double,double) -> a
    double regularizedGammaP(double,double,double,int) -> a
    double regularizedGammaQ(double,double,double,int) -> b
    double digamma(double) -> b
    double trigamma(double) -> c
org.apache.commons.math.special.Gamma$1 -> org.a.a.a.i.e:
    double val$a -> a
    double getA(int,double) -> b
    double getB(int,double) -> a
org.apache.commons.math.stat.Frequency -> org.a.a.a.j.a:
    java.util.TreeMap freqTable -> a
    java.lang.String toString() -> toString
    void addValue(java.lang.Comparable) -> a
    void clear() -> a
    java.util.Iterator valuesIterator() -> a
    long getSumFreq() -> a
    long getCount(java.lang.Comparable) -> a
    long getCount(long) -> a
    double getPct(java.lang.Comparable) -> a
    long getCumFreq(java.lang.Comparable) -> b
    long getCumFreq(long) -> b
    double getCumPct(java.lang.Comparable) -> b
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.apache.commons.math.stat.Frequency$NaturalComparator -> org.a.a.a.j.a$a:
    int compare(java.lang.Comparable,java.lang.Comparable) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.apache.commons.math.stat.StatUtils -> org.a.a.a.j.b:
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM -> a
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM_OF_SQUARES -> b
    org.apache.commons.math.stat.descriptive.UnivariateStatistic PRODUCT -> c
    org.apache.commons.math.stat.descriptive.UnivariateStatistic SUM_OF_LOGS -> d
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MIN -> e
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MAX -> f
    org.apache.commons.math.stat.descriptive.UnivariateStatistic MEAN -> g
    org.apache.commons.math.stat.descriptive.moment.Variance VARIANCE -> a
    org.apache.commons.math.stat.descriptive.rank.Percentile PERCENTILE -> a
    org.apache.commons.math.stat.descriptive.moment.GeometricMean GEOMETRIC_MEAN -> a
    double mean(double[]) -> a
    double variance(double[]) -> b
    double sumDifference(double[],double[]) -> a
    double meanDifference(double[],double[]) -> b
    double varianceDifference(double[],double[],double) -> a
org.apache.commons.math.stat.correlation.PearsonsCorrelation -> org.a.a.a.j.a.a:
    org.apache.commons.math.linear.RealMatrix correlationMatrix -> a
    int nObs -> a
    double correlation(double[],double[]) -> a
org.apache.commons.math.stat.correlation.SpearmansCorrelation -> org.a.a.a.j.a.b:
    org.apache.commons.math.linear.RealMatrix data -> a
    org.apache.commons.math.stat.ranking.RankingAlgorithm rankingAlgorithm -> a
    org.apache.commons.math.stat.correlation.PearsonsCorrelation rankCorrelation -> a
    double correlation(double[],double[]) -> a
org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic -> org.a.a.a.j.b.a:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    void clear() -> a
    double getResult() -> a
    void increment(double) -> a
    void incrementAll(double[],int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic -> org.a.a.a.j.b.b:
    double[] storedData -> a
    void setData(double[]) -> a
    double[] getDataRef() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    boolean test(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.StatisticalSummary -> org.a.a.a.j.b.c:
    double getMean() -> a
    double getVariance() -> b
    long getN() -> a
org.apache.commons.math.stat.descriptive.StatisticalSummaryValues -> org.a.a.a.j.b.d:
    double mean -> a
    double variance -> b
    long n -> a
    double max -> c
    double min -> d
    double sum -> e
    double getMax() -> c
    double getMean() -> a
    double getMin() -> d
    long getN() -> a
    double getSum() -> e
    double getStandardDeviation() -> f
    double getVariance() -> b
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic -> org.a.a.a.j.b.e:
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
org.apache.commons.math.stat.descriptive.SummaryStatistics -> org.a.a.a.j.b.f:
    long n -> a
    org.apache.commons.math.stat.descriptive.moment.SecondMoment secondMoment -> a
    org.apache.commons.math.stat.descriptive.summary.Sum sum -> a
    org.apache.commons.math.stat.descriptive.summary.SumOfSquares sumsq -> a
    org.apache.commons.math.stat.descriptive.rank.Min min -> a
    org.apache.commons.math.stat.descriptive.rank.Max max -> a
    org.apache.commons.math.stat.descriptive.summary.SumOfLogs sumLog -> a
    org.apache.commons.math.stat.descriptive.moment.GeometricMean geoMean -> a
    org.apache.commons.math.stat.descriptive.moment.Mean mean -> a
    org.apache.commons.math.stat.descriptive.moment.Variance variance -> a
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumImpl -> a
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumsqImpl -> b
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic minImpl -> c
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic maxImpl -> d
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumLogImpl -> e
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic geoMeanImpl -> f
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic meanImpl -> g
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic varianceImpl -> h
    void addValue(double) -> a
    long getN() -> a
    double getSum() -> c
    double getSumsq() -> d
    double getMean() -> a
    double getStandardDeviation() -> e
    double getVariance() -> b
    double getMax() -> f
    double getMin() -> g
    double getGeometricMean() -> h
    double getSumOfLogs() -> i
    java.lang.String toString() -> toString
    void clear() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.apache.commons.math.stat.descriptive.UnivariateStatistic -> org.a.a.a.j.b.g:
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.moment.FirstMoment -> org.a.a.a.j.b.a.a:
    long n -> a
    double m1 -> a
    double dev -> b
    double nDev -> c
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
org.apache.commons.math.stat.descriptive.moment.GeometricMean -> org.a.a.a.j.b.a.b:
    org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic sumOfLogs -> a
    void increment(double) -> a
    double getResult() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
    long getN() -> a
org.apache.commons.math.stat.descriptive.moment.Mean -> org.a.a.a.j.b.a.c:
    org.apache.commons.math.stat.descriptive.moment.FirstMoment moment -> a
    boolean incMoment -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.moment.SecondMoment -> org.a.a.a.j.b.a.d:
    double m2 -> d
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
org.apache.commons.math.stat.descriptive.moment.Variance -> org.a.a.a.j.b.a.e:
    org.apache.commons.math.stat.descriptive.moment.SecondMoment moment -> a
    boolean incMoment -> a
    boolean isBiasCorrected -> b
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[]) -> a
    double evaluate(double[],int,int) -> a
    double evaluate(double[],double,int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Max -> org.a.a.a.j.b.b.a:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Min -> org.a.a.a.j.b.b.b:
    long n -> a
    double value -> a
    void increment(double) -> a
    void clear() -> a
    double getResult() -> a
    long getN() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.rank.Percentile -> org.a.a.a.j.b.b.c:
    double quantile -> a
    int[] cachedPivots -> a
    void setData(double[]) -> a
    double evaluate(double) -> a
    double evaluate(double[],double) -> a
    double evaluate(double[],int,int) -> a
    double evaluate(double[],int,int,double) -> a
    double select(double[],int[],int) -> a
    int medianOf3(double[],int,int) -> a
    int partition(double[],int,int,int) -> a
    void insertionSort(double[],int,int) -> a
    void setQuantile(double) -> a
org.apache.commons.math.stat.descriptive.summary.Product -> org.a.a.a.j.b.c.a:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.Sum -> org.a.a.a.j.b.c.b:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.SumOfLogs -> org.a.a.a.j.b.c.c:
    int n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.descriptive.summary.SumOfSquares -> org.a.a.a.j.b.c.d:
    long n -> a
    double value -> a
    void increment(double) -> a
    double getResult() -> a
    long getN() -> a
    void clear() -> a
    double evaluate(double[],int,int) -> a
org.apache.commons.math.stat.inference.OneWayAnovaImpl -> org.a.a.a.j.c.a:
    double anovaFValue(java.util.Collection) -> a
    double anovaPValue(java.util.Collection) -> b
    org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats anovaStats(java.util.Collection) -> a
org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats -> org.a.a.a.j.c.a$a:
    int dfbg -> a
    int dfwg -> b
    double F -> a
    double access$0(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> a
    int access$1(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> a
    int access$2(org.apache.commons.math.stat.inference.OneWayAnovaImpl$AnovaStats) -> b
org.apache.commons.math.stat.inference.TTestImpl -> org.a.a.a.j.c.b:
    org.apache.commons.math.distribution.TDistribution distribution -> a
    double pairedT(double[],double[]) -> a
    double pairedTTest(double[],double[]) -> b
    double t(double,double[]) -> a
    double t(double,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
    double homoscedasticT(double[],double[]) -> c
    double t(double[],double[]) -> d
    double t(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
    double homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> b
    double tTest(double,double[]) -> b
    double tTest(double,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> b
    double tTest(double[],double[]) -> e
    double homoscedasticTTest(double[],double[]) -> f
    double tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> c
    double homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary,org.apache.commons.math.stat.descriptive.StatisticalSummary) -> d
    double df(double,double,double,double) -> a
    double t(double,double,double,double) -> b
    double t(double,double,double,double,double,double) -> a
    double homoscedasticT(double,double,double,double,double,double) -> b
    double tTest(double,double,double,double) -> c
    double tTest(double,double,double,double,double,double) -> c
    double homoscedasticTTest(double,double,double,double,double,double) -> d
    void setDistribution(org.apache.commons.math.distribution.TDistribution) -> a
    void checkSampleData(double[]) -> a
    void checkSampleData(org.apache.commons.math.stat.descriptive.StatisticalSummary) -> a
org.apache.commons.math.stat.ranking.NaNStrategy -> org.a.a.a.j.d.a:
    org.apache.commons.math.stat.ranking.NaNStrategy MINIMAL -> a
    org.apache.commons.math.stat.ranking.NaNStrategy MAXIMAL -> b
    org.apache.commons.math.stat.ranking.NaNStrategy REMOVED -> c
    org.apache.commons.math.stat.ranking.NaNStrategy FIXED -> d
    org.apache.commons.math.stat.ranking.NaNStrategy[] ENUM$VALUES -> a
    org.apache.commons.math.stat.ranking.NaNStrategy[] values() -> values
    org.apache.commons.math.stat.ranking.NaNStrategy valueOf(java.lang.String) -> valueOf
org.apache.commons.math.stat.ranking.NaturalRanking -> org.a.a.a.j.d.b:
    org.apache.commons.math.stat.ranking.NaNStrategy DEFAULT_NAN_STRATEGY -> a
    org.apache.commons.math.stat.ranking.TiesStrategy DEFAULT_TIES_STRATEGY -> a
    org.apache.commons.math.stat.ranking.NaNStrategy nanStrategy -> b
    org.apache.commons.math.stat.ranking.TiesStrategy tiesStrategy -> b
    org.apache.commons.math.random.RandomData randomData -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$NaNStrategy -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$TiesStrategy -> b
    double[] rank(double[]) -> a
    org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[] removeNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    void recodeNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[],double) -> a
    boolean containsNaNs(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    void resolveTie(double[],java.util.List) -> a
    void fill(double[],java.util.List,double) -> a
    void restoreNaNs(double[],java.util.List) -> b
    java.util.List getNanPositions(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair[]) -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$NaNStrategy() -> a
    int[] $SWITCH_TABLE$org$apache$commons$math$stat$ranking$TiesStrategy() -> b
org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair -> org.a.a.a.j.d.b$a:
    double value -> a
    int position -> a
    int compareTo(org.apache.commons.math.stat.ranking.NaturalRanking$IntDoublePair) -> a
    double getValue() -> a
    int getPosition() -> a
    int compareTo(java.lang.Object) -> compareTo
org.apache.commons.math.stat.ranking.RankingAlgorithm -> org.a.a.a.j.d.c:
    double[] rank(double[]) -> a
org.apache.commons.math.stat.ranking.TiesStrategy -> org.a.a.a.j.d.d:
    org.apache.commons.math.stat.ranking.TiesStrategy SEQUENTIAL -> a
    org.apache.commons.math.stat.ranking.TiesStrategy MINIMUM -> b
    org.apache.commons.math.stat.ranking.TiesStrategy MAXIMUM -> c
    org.apache.commons.math.stat.ranking.TiesStrategy AVERAGE -> d
    org.apache.commons.math.stat.ranking.TiesStrategy RANDOM -> e
    org.apache.commons.math.stat.ranking.TiesStrategy[] ENUM$VALUES -> a
    org.apache.commons.math.stat.ranking.TiesStrategy[] values() -> values
    org.apache.commons.math.stat.ranking.TiesStrategy valueOf(java.lang.String) -> valueOf
org.apache.commons.math.stat.regression.SimpleRegression -> org.a.a.a.j.e.a:
    org.apache.commons.math.distribution.TDistribution distribution -> a
    double sumX -> a
    double sumXX -> b
    double sumY -> c
    double sumYY -> d
    double sumXY -> e
    long n -> a
    double xbar -> f
    double ybar -> g
    void addData(double,double) -> a
    double getSlope() -> a
    double getSumSquaredErrors() -> b
    double getTotalSumSquares() -> c
    double getR() -> d
    double getRSquare() -> e
    void setDistribution(org.apache.commons.math.distribution.TDistribution) -> a
org.apache.commons.math.util.CompositeFormat -> org.a.a.a.k.a:
    java.text.NumberFormat getDefaultNumberFormat() -> a
    java.text.NumberFormat getDefaultNumberFormat(java.util.Locale) -> a
    void parseAndIgnoreWhitespace(java.lang.String,java.text.ParsePosition) -> a
    char parseNextCharacter(java.lang.String,java.text.ParsePosition) -> a
    java.lang.Number parseNumber(java.lang.String,double,java.text.ParsePosition) -> a
    java.lang.Number parseNumber(java.lang.String,java.text.NumberFormat,java.text.ParsePosition) -> a
    boolean parseFixedstring(java.lang.String,java.lang.String,java.text.ParsePosition) -> a
    java.lang.StringBuffer formatDouble(double,java.text.NumberFormat,java.lang.StringBuffer,java.text.FieldPosition) -> a
org.apache.commons.math.util.ContinuedFraction -> org.a.a.a.k.b:
    double getA(int,double) -> b
    double getB(int,double) -> a
    double evaluate(double,double,int) -> a
org.apache.commons.math.util.FastMath -> org.a.a.a.k.c:
    double[] EXP_INT_TABLE_A -> a
    double[] EXP_INT_TABLE_B -> b
    double[] EXP_FRAC_TABLE_A -> c
    double[] EXP_FRAC_TABLE_B -> d
    double[] FACT -> e
    double[][] LN_MANT -> a
    double[][] LN_SPLIT_COEF -> b
    double[][] LN_QUICK_COEF -> c
    double[][] LN_HI_PREC_COEF -> d
    double[] SINE_TABLE_A -> f
    double[] SINE_TABLE_B -> g
    double[] COSINE_TABLE_A -> h
    double[] COSINE_TABLE_B -> i
    double[] TANGENT_TABLE_A -> j
    double[] TANGENT_TABLE_B -> k
    long[] RECIP_2PI -> a
    long[] PI_O_4_BITS -> b
    double[] EIGHTHS -> l
    double[] CBRTTWO -> m
    double doubleHighPart(double) -> w
    double sqrt(double) -> a
    double cosh(double) -> b
    double sinh(double) -> c
    double tanh(double) -> d
    double signum(double) -> e
    double exp(double) -> f
    double exp(double,double,double[]) -> a
    double expm1(double) -> g
    double expm1(double,double[]) -> a
    double slowexp(double,double[]) -> b
    void split(double,double[]) -> a
    void resplit(double[]) -> a
    void splitMult(double[],double[],double[]) -> a
    void splitAdd(double[],double[],double[]) -> b
    void splitReciprocal(double[],double[]) -> a
    void quadMult(double[],double[],double[]) -> c
    double expint(int,double[]) -> a
    double log(double) -> h
    double log(double,double[]) -> c
    double log1p(double) -> i
    double log10(double) -> j
    double pow(double,double) -> a
    double[] slowLog(double) -> a
    double slowSin(double,double[]) -> d
    double slowCos(double,double[]) -> e
    void buildSinCosTables() -> a
    double polySine(double) -> x
    double polyCosine(double) -> y
    double sinQ(double,double) -> f
    double cosQ(double,double) -> g
    double tanQ(double,double,boolean) -> a
    void reducePayneHanek(double,double[]) -> b
    double sin(double) -> k
    double cos(double) -> l
    double tan(double) -> m
    double atan(double) -> n
    double atan(double,double,boolean) -> b
    double atan2(double,double) -> b
    double asin(double) -> o
    double acos(double) -> p
    double cbrt(double) -> q
    int abs(int) -> a
    long abs(long) -> a
    double abs(double) -> r
    double ulp(double) -> s
    double floor(double) -> t
    double ceil(double) -> u
    double rint(double) -> v
    long round(double) -> a
    int min(int,int) -> a
    double min(double,double) -> c
    int max(int,int) -> b
    double max(double,double) -> d
    double copySign(double,double) -> e
org.apache.commons.math.util.MathUtils -> org.a.a.a.k.d:
    long[] FACTORIALS -> a
    boolean $assertionsDisabled -> a
    long binomialCoefficient(int,int) -> a
    double binomialCoefficientDouble(int,int) -> a
    double binomialCoefficientLog(int,int) -> b
    void checkBinomial(int,int) -> a
    boolean equalsIncludingNaN(float,float) -> a
    boolean equals(float,float,int) -> a
    boolean equalsIncludingNaN(double,double) -> a
    boolean equals(double,double,int) -> a
    int gcd(int,int) -> a
    int hash(double) -> a
    int hash(double[]) -> a
    double indicator(double) -> a
    long mulAndCheck(long,long) -> a
org.concord.framework.data.DataDimension -> org.concord.a.a.a:
    java.lang.String getDimension() -> a
org.concord.framework.data.stream.DataChannelDescription -> org.concord.a.a.a.a:
    java.lang.String name -> a
    org.concord.framework.data.DataDimension unit -> a
    float tuneValue -> a
    int precision -> a
    boolean usePrecision -> a
    float absoluteMin -> b
    float absoluteMax -> c
    float recommendMin -> d
    float recommendMax -> e
    boolean numericData -> b
    java.util.ArrayList possibleValues -> a
    void setUnit(org.concord.framework.data.DataDimension) -> a
    void setPrecision(int) -> a
    void setName(java.lang.String) -> a
    void setNumericData(boolean) -> a
    boolean equals(java.lang.Object) -> equals
    boolean floatEquals(float,float) -> a
    boolean stringEquals(java.lang.String,java.lang.String) -> a
    boolean unitEquals(org.concord.framework.data.DataDimension,org.concord.framework.data.DataDimension) -> a
org.concord.framework.data.stream.DataEvent -> org.concord.a.a.a.b:
    int type -> a
    org.concord.framework.data.stream.DataStreamDescription dataDesc -> a
    void setType(int) -> a
    int getType() -> a
org.concord.framework.data.stream.DataListener -> org.concord.a.a.a.c:
    void dataReceived(org.concord.framework.data.stream.DataStreamEvent) -> a
    void dataStreamEvent(org.concord.framework.data.stream.DataStreamEvent) -> b
org.concord.framework.data.stream.DataProducer -> org.concord.a.a.a.d:
    void addDataListener(org.concord.framework.data.stream.DataListener) -> a
org.concord.framework.data.stream.DataStreamDescription -> org.concord.a.a.a.e:
    int dataType -> a
    float dt -> a
    int dataOffset -> b
    int nextSampleOffset -> c
    org.concord.framework.data.stream.DataChannelDescription[] channelDescriptions -> a
    org.concord.framework.data.stream.DataChannelDescription dtChannelDescription -> a
    void setDt(float) -> a
    void setChannelsPerSample(int) -> a
    int getChannelsPerSample() -> a
    void setDataType(int) -> b
    int getDataType() -> b
    void setDataOffset(int) -> c
    int getDataOffset() -> c
    int getNextSampleOffset() -> d
    void setChannelDescription(org.concord.framework.data.stream.DataChannelDescription,int) -> a
    void setDtChannelDescription(org.concord.framework.data.stream.DataChannelDescription) -> a
    boolean equals(java.lang.Object) -> equals
    boolean floatEquals(float,float) -> a
org.concord.framework.data.stream.DataStreamEvent -> org.concord.a.a.a.f:
    float[] data -> a
    int numSamples -> b
    int[] intData -> a
    float refVal -> a
    java.lang.Object source -> a
    void setData(float[]) -> a
    float[] getData() -> a
    void setNumSamples(int) -> b
    int getNumSamples() -> b
    void setSource(java.lang.Object) -> a
org.concord.framework.data.stream.DefaultDataProducer -> org.concord.a.a.a.g:
    java.util.Vector dataListeners -> a
    float[] values -> a
    org.concord.framework.data.stream.DataStreamDescription dataDesc -> a
    org.concord.framework.data.stream.DataStreamEvent dataEvent -> a
    boolean running -> a
    void addDataListener(org.concord.framework.data.stream.DataListener) -> a
    void stop() -> a
    void start() -> b
    void notifyDataStreamEvent(int) -> a
    void notifyDataReceived() -> c
org.concord.framework.startable.AbstractStartable -> org.concord.a.b.a:
    java.util.ArrayList startableListeners -> a
    org.concord.framework.startable.StartableEvent startableEvent -> a
    boolean isInInitialState() -> a
    void notifyStarted(boolean) -> a
    void notifyStopped() -> d
    void notifyStartableListeners(org.concord.framework.startable.StartableEvent$StartableEventType) -> a
    void notifyStartableListeners(org.concord.framework.startable.StartableEvent) -> a
org.concord.framework.startable.Startable -> org.concord.a.b.b:
    void start() -> b
    void stop() -> a
org.concord.framework.startable.StartableEvent -> org.concord.a.b.c:
    org.concord.framework.startable.StartableEvent$StartableEventType type -> a
    org.concord.framework.startable.Startable startable -> a
    boolean wasInInitialState -> a
    void setType(org.concord.framework.startable.StartableEvent$StartableEventType) -> a
    void setStartable(org.concord.framework.startable.Startable) -> a
    void setWasInInitialState(boolean) -> a
    org.concord.framework.startable.StartableEvent clone() -> a
    java.lang.Object clone() -> clone
org.concord.framework.startable.StartableEvent$StartableEventType -> org.concord.a.b.c$a:
    org.concord.framework.startable.StartableEvent$StartableEventType STARTED -> a
    org.concord.framework.startable.StartableEvent$StartableEventType STOPPED -> b
    org.concord.framework.startable.StartableEvent$StartableEventType RESET -> c
    org.concord.framework.startable.StartableEvent$StartableEventType UPDATED -> d
    org.concord.framework.startable.StartableEvent$StartableEventType[] ENUM$VALUES -> a
    org.concord.framework.startable.StartableEvent$StartableEventType[] values() -> values
    org.concord.framework.startable.StartableEvent$StartableEventType valueOf(java.lang.String) -> valueOf
org.concord.framework.startable.StartableListener -> org.concord.a.b.d:
    void startableEvent(org.concord.framework.startable.StartableEvent) -> a
org.concord.framework.text.UserMessageHandler -> org.concord.a.c.a:
    int showOptionMessage(java.lang.String,java.lang.String,java.lang.String[],java.lang.String) -> a
    void showMessage(java.lang.String,java.lang.String) -> a
org.concord.framework.text.UserMessageHandlerExt1 -> org.concord.a.c.b:
    void showMessage(java.lang.String,java.lang.String,java.lang.String) -> a
org.concord.sensor.DeviceConfig -> org.concord.sensor.a:
    int getDeviceId() -> a
    java.lang.String getConfigString() -> a
org.concord.sensor.ExperimentConfig -> org.concord.sensor.b:
    boolean isValid() -> isValid
    java.lang.String getInvalidReason() -> getInvalidReason
    float getPeriod() -> getPeriod
    boolean getExactPeriod() -> getExactPeriod
    float getDataReadPeriod() -> getDataReadPeriod
    org.concord.sensor.SensorConfig[] getSensorConfigs() -> getSensorConfigs
    java.lang.String getDeviceName() -> getDeviceName
org.concord.sensor.ExperimentRequest -> org.concord.sensor.ExperimentRequest:
    float getPeriod() -> getPeriod
    int getNumberOfSamples() -> getNumberOfSamples
    org.concord.sensor.SensorRequest[] getSensorRequests() -> getSensorRequests
org.concord.sensor.SensorConfig -> org.concord.sensor.SensorConfig:
    boolean isConfirmed() -> isConfirmed
    int getType() -> getType
    float getStepSize() -> getStepSize
    int getPort() -> getPort
    java.lang.String getPortName() -> getPortName
    java.lang.String getName() -> getName
    org.concord.framework.data.DataDimension getUnit() -> getUnit
    java.lang.String getSensorParam(java.lang.String) -> getSensorParam
org.concord.sensor.SensorDataManager -> org.concord.sensor.c:
    org.concord.sensor.device.SensorDevice getSensorDevice() -> a
    org.concord.sensor.SensorDataProducer createDataProducer() -> a
org.concord.sensor.SensorDataProducer -> org.concord.sensor.d:
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> a
org.concord.sensor.SensorRequest -> org.concord.sensor.e:
    int getType() -> a
    float getStepSize() -> a
    float getRequiredMax() -> b
    float getRequiredMin() -> c
    int getDisplayPrecision() -> b
    int getPort() -> c
    org.concord.framework.data.DataDimension getUnit() -> a
    java.lang.String getSensorParam(java.lang.String) -> a
    java.lang.String[] getSensorParamKeys() -> a
org.concord.sensor.device.DeviceFactory -> org.concord.sensor.device.a:
    org.concord.sensor.device.SensorDevice createDevice(org.concord.sensor.DeviceConfig) -> a
    void destroyDevice(org.concord.sensor.device.SensorDevice) -> a
org.concord.sensor.device.DeviceIdAware -> org.concord.sensor.device.b:
    void setDeviceId(int) -> a
org.concord.sensor.device.DeviceReader -> org.concord.sensor.device.DeviceReader:
    int flushData(int) -> flushData
org.concord.sensor.device.DeviceService -> org.concord.sensor.device.c:
    void log(java.lang.String) -> a
    void sleep(int) -> a
    boolean isValidFloat(float) -> a
    org.concord.sensor.serial.SensorSerialPort getSerialPort(java.lang.String,org.concord.sensor.serial.SensorSerialPort) -> a
org.concord.sensor.device.DeviceServiceAware -> org.concord.sensor.device.d:
    void setDeviceService(org.concord.sensor.device.DeviceService) -> setDeviceService
org.concord.sensor.device.SensorDevice -> org.concord.sensor.device.e:
    java.lang.String getVendorName() -> getVendorName
    java.lang.String getDeviceName() -> getDeviceName
    void open(java.lang.String) -> open
    void close() -> close
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> configure
    boolean start() -> start
    int read(float[],int,int,org.concord.sensor.device.DeviceReader) -> read
    void stop(boolean) -> stop
    java.lang.String getErrorMessage(int) -> getErrorMessage
    boolean isAttached() -> isAttached
    boolean canDetectSensors() -> canDetectSensors
    org.concord.sensor.ExperimentConfig getCurrentConfig() -> getCurrentConfig
org.concord.sensor.device.impl.AbstractSensorDataManager -> org.concord.sensor.device.a.a:
    org.concord.sensor.device.DeviceFactory deviceFactory -> a
    org.concord.framework.text.UserMessageHandler messageHandler -> a
    org.concord.sensor.impl.Ticker ticker -> a
    org.concord.sensor.DeviceConfig[] deviceConfigs -> a
    org.concord.sensor.device.SensorDevice currentDevice -> a
    org.concord.sensor.device.SensorDevice getSensorDevice() -> a
    org.concord.sensor.DeviceConfig[] getDeviceConfigs() -> a
    void setDeviceConfigs(org.concord.sensor.DeviceConfig[]) -> a
    void log(java.lang.String) -> a
org.concord.sensor.device.impl.AbstractSensorDataManager$OpenAttempt -> org.concord.sensor.device.a.a$a:
    java.lang.String vendorName -> a
    java.lang.String deviceName -> b
    java.lang.String error -> c
    org.concord.sensor.DeviceConfig config -> a
    java.lang.String className -> d
    org.concord.sensor.device.impl.AbstractSensorDataManager this$0 -> a
org.concord.sensor.device.impl.AbstractSensorDevice -> org.concord.sensor.device.a.b:
    java.lang.String deviceLabel -> a
    org.concord.sensor.impl.ExperimentConfigImpl currentConfig -> a
    boolean attached -> a
    java.lang.String portName -> b
    org.concord.sensor.serial.SensorSerialPort port -> a
    int error -> a
    int portError -> b
    org.concord.sensor.device.DeviceService devService -> a
    boolean isRawType(int) -> isRawType
    boolean isAttached() -> isAttached
    void setDeviceService(org.concord.sensor.device.DeviceService) -> setDeviceService
    void open(java.lang.String) -> open
    void close() -> close
    void closePort() -> closePort
    boolean openPort() -> openPort
    boolean openAutoPort() -> openAutoPort
    boolean openPortName(java.lang.String) -> openPortName
    void log(java.lang.String) -> log
    org.concord.sensor.serial.SensorSerialPort getSensorSerialPort() -> getSensorSerialPort
    org.concord.sensor.impl.Vector getAvailablePortNames() -> getAvailablePortNames
    boolean isAttachedInternal(java.lang.String) -> isAttachedInternal
    boolean attemptToOpenPort(java.lang.String) -> attemptToOpenPort
    void portError(int) -> portError
    void deviceError(int,java.lang.String) -> deviceError
    int compareSensorConfigAndRequest(org.concord.sensor.SensorConfig,org.concord.sensor.SensorRequest) -> compareSensorConfigAndRequest
    boolean hasExactPeriod() -> hasExactPeriod
    void autoIdConfigureInternal(org.concord.sensor.impl.ExperimentConfigImpl,org.concord.sensor.ExperimentRequest) -> autoIdConfigureInternal
    org.concord.sensor.ExperimentConfig autoIdConfigure(org.concord.sensor.ExperimentRequest) -> autoIdConfigure
    void nonAutoIdConfigureInteral(org.concord.sensor.impl.ExperimentConfigImpl,org.concord.sensor.ExperimentRequest) -> nonAutoIdConfigureInteral
    org.concord.sensor.SensorConfig createSensorConfig(int,int) -> createSensorConfig
    boolean hasNonAutoIdSensors() -> hasNonAutoIdSensors
    boolean initializeOpenPort(java.lang.String) -> initializeOpenPort
    org.concord.sensor.device.impl.SerialPortParams getSerialPortParams() -> getSerialPortParams
org.concord.sensor.device.impl.AbstractStreamingSensorDevice -> org.concord.sensor.device.a.c:
    org.concord.sensor.device.impl.StreamingBuffer streamingBuffer -> a
    int readSize -> c
    boolean start() -> start
    int read(float[],int,int,org.concord.sensor.device.DeviceReader) -> read
    int streamRead(float[],int,int,org.concord.sensor.device.DeviceReader,org.concord.sensor.device.impl.StreamingBuffer) -> streamRead
    int getStreamBufferSize() -> getStreamBufferSize
org.concord.sensor.device.impl.DeviceConfigImpl -> org.concord.sensor.device.a.d:
    int deviceId -> a
    java.lang.String configString -> a
    int getDeviceId() -> a
    java.lang.String getConfigString() -> a
org.concord.sensor.device.impl.InterfaceManager -> org.concord.sensor.device.a.e:
    org.concord.sensor.SensorDataProducer createDataProducer() -> a
org.concord.sensor.device.impl.JavaDeviceFactory -> org.concord.sensor.device.a.f:
    java.util.logging.Logger logger -> a
    org.concord.sensor.impl.Ticker ticker -> a
    java.util.Hashtable deviceTable -> a
    java.util.Hashtable configTable -> b
    org.concord.sensor.device.SensorDevice createDevice(org.concord.sensor.DeviceConfig) -> a
    void destroyDevice(org.concord.sensor.device.SensorDevice) -> a
    org.concord.sensor.serial.SensorSerialPort getSerialPort(java.lang.String,org.concord.sensor.serial.SensorSerialPort) -> a
    void log(java.lang.String) -> a
    void sleep(int) -> a
    boolean isValidFloat(float) -> a
org.concord.sensor.device.impl.JavaTicker -> org.concord.sensor.device.a.g:
    int millis -> a
    boolean ticking -> a
    boolean started -> b
    org.concord.sensor.impl.TickListener tickListener -> a
    void startTicking(int,org.concord.sensor.impl.TickListener) -> a
    void stopTicking(org.concord.sensor.impl.TickListener) -> a
    boolean isTicking() -> a
    int currentTimeMillis() -> a
    void run() -> run
org.concord.sensor.device.impl.SensorConfigImpl -> org.concord.sensor.device.a.h:
    boolean confirmed -> a
    int port -> a
    int type -> b
    java.lang.String name -> a
    java.lang.String portName -> b
    float stepSize -> a
    org.concord.framework.data.DataDimension unit -> a
    org.concord.sensor.impl.Range valueRange -> a
    boolean isConfirmed() -> isConfirmed
    void setConfirmed(boolean) -> a
    int getType() -> getType
    void setType(int) -> a
    float getStepSize() -> getStepSize
    void setStepSize(float) -> a
    int getPort() -> getPort
    void setPort(int) -> b
    java.lang.String getPortName() -> getPortName
    java.lang.String getName() -> getName
    void setName(java.lang.String) -> a
    org.concord.framework.data.DataDimension getUnit() -> getUnit
    void setUnit(org.concord.framework.data.DataDimension) -> a
    java.lang.String getSensorParam(java.lang.String) -> getSensorParam
    org.concord.sensor.impl.Range getValueRange() -> a
    void setValueRange(org.concord.sensor.impl.Range) -> a
org.concord.sensor.device.impl.SerialPortParams -> org.concord.sensor.device.a.i:
    int flowControl -> a
    int baud -> b
    int data -> c
    int stop -> d
    int parity -> e
    void setupPort(org.concord.sensor.serial.SensorSerialPort) -> a
org.concord.sensor.device.impl.StreamingBuffer -> org.concord.sensor.device.a.j:
    byte[] buf -> a
    int totalBytes -> a
    int processedBytes -> b
    void shift() -> a
    void clear() -> b
org.concord.sensor.impl.DataStreamDescUtil -> org.concord.sensor.impl.a:
    void setupDescription(org.concord.framework.data.stream.DataStreamDescription,org.concord.sensor.ExperimentRequest,org.concord.sensor.ExperimentConfig) -> a
org.concord.sensor.impl.ExperimentConfigImpl -> org.concord.sensor.impl.ExperimentConfigImpl:
    org.concord.sensor.SensorConfig[] sensorConfigs -> a
    boolean valid -> a
    java.lang.String invalidReason -> a
    float period -> a
    boolean exactPeriod -> b
    java.lang.String deviceName -> b
    int deviceId -> a
    float dataReadPeriod -> b
    org.concord.sensor.impl.Range periodRange -> a
    boolean isValid() -> isValid
    void setValid(boolean) -> setValid
    java.lang.String getInvalidReason() -> getInvalidReason
    void setInvalidReason(java.lang.String) -> setInvalidReason
    float getPeriod() -> getPeriod
    void setPeriod(float) -> setPeriod
    boolean getExactPeriod() -> getExactPeriod
    void setExactPeriod(boolean) -> setExactPeriod
    org.concord.sensor.SensorConfig[] getSensorConfigs() -> getSensorConfigs
    void setSensorConfigs(org.concord.sensor.SensorConfig[]) -> setSensorConfigs
    java.lang.String getDeviceName() -> getDeviceName
    void setDeviceName(java.lang.String) -> setDeviceName
    int getDeviceId() -> getDeviceId
    void setDeviceId(int) -> setDeviceId
    float getDataReadPeriod() -> getDataReadPeriod
    void setDataReadPeriod(float) -> setDataReadPeriod
    java.lang.Object getCopy() -> getCopy
    org.concord.sensor.impl.Range getPeriodRange() -> getPeriodRange
    void setPeriodRange(org.concord.sensor.impl.Range) -> setPeriodRange
org.concord.sensor.impl.ExperimentRequestImpl -> org.concord.sensor.impl.b:
    float period -> a
    int numberOfSamples -> a
    org.concord.sensor.SensorRequest[] sensorRequests -> a
    float getPeriod() -> getPeriod
    void setPeriod(float) -> a
    int getNumberOfSamples() -> getNumberOfSamples
    void setNumberOfSamples(int) -> a
    org.concord.sensor.SensorRequest[] getSensorRequests() -> getSensorRequests
    void setSensorRequests(org.concord.sensor.SensorRequest[]) -> a
org.concord.sensor.impl.LinearCalibration -> org.concord.sensor.impl.c:
    float k0 -> a
    float k1 -> b
org.concord.sensor.impl.Range -> org.concord.sensor.impl.d:
    float minimum -> a
    float maximum -> b
org.concord.sensor.impl.SensorCalibration -> org.concord.sensor.impl.e:
org.concord.sensor.impl.SensorDataProducerImpl -> org.concord.sensor.impl.f:
    java.util.logging.Logger logger -> a
    int startTimer -> a
    org.concord.sensor.impl.Ticker ticker -> a
    org.concord.framework.text.UserMessageHandler messageHandler -> a
    float[] processedData -> b
    int timeWithoutData -> b
    java.lang.String[] okOptions -> a
    java.lang.String[] continueOptions -> b
    boolean inDeviceRead -> b
    int totalDataRead -> c
    org.concord.sensor.device.SensorDevice device -> a
    org.concord.sensor.ExperimentConfig experimentConfig -> a
    float dataTimeOffset -> a
    void tick() -> e
    void tickStopped() -> f
    int flushData(int) -> flushData
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> a
    java.lang.String getFullDeviceName() -> a
    void sendWrongSensorAttachedMessage(org.concord.sensor.ExperimentRequest,org.concord.sensor.ExperimentConfig) -> a
    void start() -> b
    void stop() -> a
    void deviceStop(boolean) -> b
    boolean isInInitialState() -> a
    void notifyDataReceived() -> c
org.concord.sensor.impl.SensorRequestImpl -> org.concord.sensor.impl.g:
    int type -> a
    float stepSize -> a
    float requiredMax -> b
    float requiredMin -> c
    int displayPrecision -> b
    int port -> c
    org.concord.framework.data.DataDimension unit -> a
    java.lang.String[] paramKeys -> a
    java.lang.String[] paramValues -> b
    int getType() -> a
    void setType(int) -> a
    float getStepSize() -> a
    void setStepSize(float) -> a
    float getRequiredMax() -> b
    void setRequiredMax(float) -> b
    float getRequiredMin() -> c
    void setRequiredMin(float) -> c
    int getDisplayPrecision() -> b
    void setDisplayPrecision(int) -> b
    int getPort() -> c
    void setPort(int) -> c
    org.concord.framework.data.DataDimension getUnit() -> a
    java.lang.String getSensorParam(java.lang.String) -> a
    java.lang.String[] getSensorParamKeys() -> a
org.concord.sensor.impl.SensorUnit -> org.concord.sensor.impl.h:
    java.lang.String unit -> a
    java.lang.String getDimension() -> a
org.concord.sensor.impl.SensorUtilJava -> org.concord.sensor.impl.i:
    java.lang.String getTypeConstantName(int) -> a
    java.lang.String experimentConfigToString(org.concord.sensor.ExperimentConfig) -> a
    java.lang.String experimentRequestToString(org.concord.sensor.ExperimentRequest) -> a
    float scoreSensorType(org.concord.sensor.SensorConfig,org.concord.sensor.SensorRequest) -> a
    float scoreValueRange(org.concord.sensor.SensorConfig,org.concord.sensor.SensorRequest) -> b
    float scoreStepSize(org.concord.sensor.SensorConfig,org.concord.sensor.SensorRequest) -> c
org.concord.sensor.impl.TickListener -> org.concord.sensor.impl.j:
    void tick() -> e
    void tickStopped() -> f
org.concord.sensor.impl.Ticker -> org.concord.sensor.impl.k:
    void startTicking(int,org.concord.sensor.impl.TickListener) -> a
    void stopTicking(org.concord.sensor.impl.TickListener) -> a
    boolean isTicking() -> a
    int currentTimeMillis() -> a
org.concord.sensor.impl.Vector -> org.concord.sensor.impl.l:
    java.lang.Object[] items -> a
    int count -> a
    void copyArray(java.lang.Object[],int,java.lang.Object[],int,int) -> a
    void add(java.lang.Object) -> a
    void insert(int,java.lang.Object) -> a
    java.lang.Object get(int) -> a
    int size() -> a
org.concord.sensor.nativelib.NativeTISensorDevice -> org.concord.sensor.nativelib.NativeTISensorDevice:
    ccsd.ti.SWIGTYPE_p_void deviceHandle -> a
    ccsd.ti.SWIGTYPE_p_float readValuesBuffer -> a
    ccsd.ti.SWIGTYPE_p_float readTimestampsBuffer -> b
    boolean open -> a
    boolean nativeLibAvailable -> b
    boolean useTimeStamps -> c
    int numberOfChannels -> a
    void open(java.lang.String) -> open
    void close() -> close
    java.lang.String getErrorMessage(int) -> getErrorMessage
    int getRightMilliseconds() -> getRightMilliseconds
    boolean isAttached() -> isAttached
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> configure
    org.concord.sensor.ExperimentConfig getCurrentConfig() -> getCurrentConfig
    boolean canDetectSensors() -> canDetectSensors
    void stop(boolean) -> stop
    boolean start() -> start
    int read(float[],int,int,org.concord.sensor.device.DeviceReader) -> read
    java.lang.String getVendorName() -> getVendorName
    java.lang.String getDeviceName() -> getDeviceName
org.concord.sensor.nativelib.NativeVernierSensorDevice -> org.concord.sensor.nativelib.NativeVernierSensorDevice:
    ccsd.vernier.SWIGTYPE_p_void deviceHandle -> a
    ccsd.vernier.SWIGTYPE_p_float readValuesBuffer -> a
    ccsd.vernier.SWIGTYPE_p_float readTimestampsBuffer -> b
    boolean open -> a
    boolean nativeLibAvailable -> b
    boolean useTimeStamps -> c
    int numberOfChannels -> a
    java.lang.String lastErrorMessage -> a
    void open(java.lang.String) -> open
    void close() -> close
    java.lang.String getErrorMessage(int) -> getErrorMessage
    int getRightMilliseconds() -> getRightMilliseconds
    boolean isAttached() -> isAttached
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> configure
    org.concord.sensor.ExperimentConfig getCurrentConfig() -> getCurrentConfig
    boolean canDetectSensors() -> canDetectSensors
    void stop(boolean) -> stop
    boolean start() -> start
    int read(float[],int,int,org.concord.sensor.device.DeviceReader) -> read
    java.lang.String getVendorName() -> getVendorName
    java.lang.String getDeviceName() -> getDeviceName
org.concord.sensor.pseudo.PseudoSensorConfig -> org.concord.sensor.pseudo.a:
    java.lang.String name -> a
    float sinOffset -> a
    float sinMagnitude -> b
    boolean isConfirmed() -> isConfirmed
    java.lang.String getPortName() -> getPortName
    java.lang.String getName() -> getName
    void setSinOffset(float) -> b
    float getSinOffset() -> a
    void setSinMagnitude(float) -> c
    float getSinMagnitude() -> b
org.concord.sensor.pseudo.PseudoSensorDevice -> org.concord.sensor.pseudo.PseudoSensorDevice:
    org.concord.sensor.pseudo.PseudoSensorConfig[] sensConfigs -> a
    float time -> a
    java.lang.String getVendorName() -> getVendorName
    java.lang.String getDeviceName() -> getDeviceName
    void open(java.lang.String) -> open
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> configure
    boolean start() -> start
    int read(float[],int,int,org.concord.sensor.device.DeviceReader) -> read
    void stop(boolean) -> stop
    java.lang.String getErrorMessage(int) -> getErrorMessage
    boolean isAttached() -> isAttached
    boolean canDetectSensors() -> canDetectSensors
    org.concord.sensor.ExperimentConfig getCurrentConfig() -> getCurrentConfig
    org.concord.sensor.device.impl.SerialPortParams getSerialPortParams() -> getSerialPortParams
    boolean initializeOpenPort(java.lang.String) -> initializeOpenPort
org.concord.sensor.serial.SensorSerialPort -> org.concord.sensor.a.a:
    org.concord.sensor.impl.Vector getAvailablePorts() -> a
    void open(java.lang.String) -> a
    void close() -> a
    boolean isOpen() -> a
    void setSerialPortParams(int,int,int,int) -> a
    void setFlowControlMode(int) -> a
    int readBytes(byte[],int,int,long) -> a
    void write(byte[]) -> a
    boolean isOpenFast() -> b
org.concord.sensor.serial.SerialException -> org.concord.sensor.a.b:
    java.lang.Throwable cause -> a
    int error -> a
    int getPortError() -> a
org.concord.sensor.state.PrintUserMessageHandler -> org.concord.sensor.b.a:
    int showOptionMessage(java.lang.String,java.lang.String,java.lang.String[],java.lang.String) -> a
    void showMessage(java.lang.String,java.lang.String) -> a
org.concord.sensor.vernier.VernierSensor -> org.concord.sensor.vernier.a:
    org.concord.sensor.vernier.VernierSensorDevice device -> a
    org.concord.sensor.impl.SensorCalibration calibrationEquation -> a
    int channelType -> a
    byte vernierProbeType -> a
    org.concord.sensor.impl.SensorCalibration rawVoltageCalibration -> b
    org.concord.sensor.impl.SensorCalibration rawDataCalibration -> c
    org.concord.sensor.impl.SensorCalibration temperatureCalibration -> d
    org.concord.sensor.impl.SensorCalibration lightCalibration -> e
    org.concord.sensor.impl.SensorCalibration relativeHumidityCalibration -> f
    org.concord.sensor.impl.SensorCalibration studentForceCalibration -> g
    org.concord.sensor.impl.SensorCalibration tiVoltageCalibration -> h
    org.concord.sensor.impl.SensorCalibration differentialVoltageCalibration -> i
    org.concord.sensor.impl.SensorCalibration co2GasCalibration -> j
    org.concord.sensor.impl.SensorCalibration oxygenGasCalibration -> k
    void setCalibration(org.concord.sensor.impl.SensorCalibration) -> a
    int setupSensor(int,org.concord.sensor.SensorRequest) -> a
org.concord.sensor.vernier.VernierSensor$1 -> org.concord.sensor.vernier.b:
org.concord.sensor.vernier.VernierSensor$2 -> org.concord.sensor.vernier.c:
org.concord.sensor.vernier.VernierSensorDevice -> org.concord.sensor.vernier.d:
    void log(java.lang.String) -> log
org.concord.sensor.vernier.labpro.LabProProtocol -> org.concord.sensor.vernier.labpro.a:
    org.concord.sensor.vernier.labpro.LabProSensorDevice labProDevice -> a
    byte[] wakeUpBytes -> a
    void sendCommand(int,java.lang.String) -> a
    void requestSystemStatus() -> a
    void requestChannelStatus(int,int) -> a
    void channelSetup(int,int) -> b
    void dataCollectionSetup(float,int,int) -> a
    void portPowerControl(int) -> a
    void reset() -> b
    void wakeUp() -> c
org.concord.sensor.vernier.labpro.LabProSensorDevice -> org.concord.sensor.vernier.labpro.LabProSensorDevice:
    org.concord.sensor.device.impl.SerialPortParams serialPortParams -> a
    int[] CHANNELS -> a
    byte[] buf -> a
    org.concord.sensor.vernier.labpro.LabProProtocol protocol -> a
    java.lang.String currentErrorMessage -> c
    float[] dataValues -> a
    org.concord.sensor.serial.SensorSerialPort usbSerialPort -> b
    org.concord.sensor.serial.SensorSerialPort osSerialPort -> c
    org.concord.sensor.device.impl.SerialPortParams getSerialPortParams() -> getSerialPortParams
    boolean initializeOpenPort(java.lang.String) -> initializeOpenPort
    boolean isAttachedInternal(java.lang.String) -> isAttachedInternal
    int round(float) -> round
    org.concord.sensor.ExperimentConfig configure(org.concord.sensor.ExperimentRequest) -> configure
    org.concord.sensor.ExperimentConfig getCurrentConfig() -> getCurrentConfig
    java.lang.String getErrorMessage(int) -> getErrorMessage
    int streamRead(float[],int,int,org.concord.sensor.device.DeviceReader,org.concord.sensor.device.impl.StreamingBuffer) -> streamRead
    boolean start() -> start
    void stop(boolean) -> stop
    int readValues(float[],org.concord.sensor.device.impl.StreamingBuffer) -> readValues
    int readValues(float[]) -> readValues
    int getStreamBufferSize() -> getStreamBufferSize
    org.concord.sensor.serial.SensorSerialPort getPort() -> getPort
    org.concord.sensor.device.DeviceService getDeviceService() -> getDeviceService
    org.concord.sensor.SensorConfig createSensorConfig(int,int) -> createSensorConfig
    org.concord.sensor.serial.SensorSerialPort getSensorSerialPort() -> getSensorSerialPort
    boolean openAutoPort() -> openAutoPort
    void log(java.lang.String) -> log
    boolean hasNonAutoIdSensors() -> hasNonAutoIdSensors
    boolean canDetectSensors() -> canDetectSensors
    java.lang.String getVendorName() -> getVendorName
    java.lang.String getDeviceName() -> getDeviceName
org.concord.sensor.vernier.labpro.LabProSensorDevice$1 -> org.concord.sensor.vernier.labpro.b:
    org.concord.sensor.vernier.labpro.LabProSensorDevice this$0 -> a
    void run() -> run
org.freehep.graphics2d.AbstractVectorGraphics -> org.freehep.a.a:
    org.freehep.util.UserProperties properties -> a
    java.lang.String creator -> a
    boolean isDeviceIndependent -> a
    org.freehep.graphics2d.SymbolShape cachedShape -> a
    int colorMode -> a
    java.awt.Color backgroundColor -> a
    java.awt.Color currentColor -> b
    java.awt.Paint currentPaint -> a
    java.awt.Font currentFont -> a
    void initProperties(java.util.Properties) -> a
    java.util.Properties getProperties() -> a
    java.lang.String getProperty(java.lang.String) -> a
    java.awt.Color getPropertyColor(java.lang.String) -> a
    java.awt.Insets getPropertyInsets(java.lang.String) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String) -> a
    boolean isProperty(java.lang.String) -> a
    java.lang.String getCreator() -> a
    boolean isDeviceIndependent() -> a
    java.awt.Font getFont() -> getFont
    void setFont(java.awt.Font) -> setFont
    void clearRect(int,int,int,int) -> clearRect
    void drawLine(int,int,int,int) -> drawLine
    void drawRect(int,int,int,int) -> drawRect
    void fillRect(int,int,int,int) -> fillRect
    void drawArc(int,int,int,int,int,int) -> drawArc
    void fillArc(int,int,int,int,int,int) -> fillArc
    void drawOval(int,int,int,int) -> drawOval
    void fillOval(int,int,int,int) -> fillOval
    void drawRoundRect(int,int,int,int,int,int) -> drawRoundRect
    void fillRoundRect(int,int,int,int,int,int) -> fillRoundRect
    void translate(int,int) -> translate
    void setLineWidth(double) -> a
    void drawString(java.lang.String,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    java.awt.geom.Point2D drawFrameAndBanner(java.awt.font.TextLayout,double,double,int,int,boolean,java.awt.Color,double,boolean,java.awt.Color) -> a
    void drawString(org.freehep.graphics2d.TagString,double,double,int,int,boolean,java.awt.Color,double,boolean,java.awt.Color) -> a
    void drawString(org.freehep.graphics2d.TagString,double,double,int,int) -> a
    java.awt.Color getBackground() -> getBackground
    void setBackground(java.awt.Color) -> setBackground
    void setColor(java.awt.Color) -> setColor
    java.awt.Color getColor() -> getColor
    void setPaint(java.awt.Paint) -> setPaint
    java.awt.Paint getPaint() -> getPaint
    java.awt.Color getPrintColor(java.awt.Color) -> a
    void rotate(double,double,double) -> rotate
    void drawArc(double,double,double,double,double,double) -> a
    void drawLine(double,double,double,double) -> a
    void drawOval(double,double,double,double) -> b
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawRect(double,double,double,double) -> c
    void drawRoundRect(double,double,double,double,double,double) -> b
    void fillArc(double,double,double,double,double,double) -> c
    void fillOval(double,double,double,double) -> d
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillRect(double,double,double,double) -> e
    void fillRoundRect(double,double,double,double,double,double) -> d
    java.awt.Shape createShape(int[],int[],int,boolean,boolean) -> a
org.freehep.graphics2d.GenericTagHandler -> org.freehep.a.b:
    java.lang.Integer UNDERLINE_OVERLINE -> a
    java.awt.Graphics2D graphics -> a
    java.lang.StringBuffer clearedText -> a
    java.util.Vector attributes -> a
    java.util.Hashtable tags -> a
    java.util.Stack fontFamilyStack -> a
    double superscriptCorrection -> a
    void print(org.freehep.graphics2d.TagString,double,double,double) -> a
    java.awt.font.TextLayout createTextLayout(org.freehep.graphics2d.TagString,double) -> a
    java.lang.String openTag(java.lang.String) -> a
    java.lang.String closeTag(java.lang.String) -> b
    java.lang.String text(java.lang.String) -> c
org.freehep.graphics2d.GenericTagHandler$AttributeEntry -> org.freehep.a.b$a:
    int begin -> a
    int end -> b
    java.awt.font.TextAttribute textAttribute -> a
    java.lang.Object value -> a
    org.freehep.graphics2d.GenericTagHandler this$0 -> a
    void apply(java.text.AttributedString) -> a
org.freehep.graphics2d.PixelGraphics2D -> org.freehep.a.c:
    java.awt.RenderingHints$Key KEY_SYMBOL_BLIT -> a
    java.lang.Object VALUE_SYMBOL_BLIT_ON -> a
    java.lang.Object VALUE_SYMBOL_BLIT_OFF -> b
    java.awt.Graphics2D hostGraphics -> a
    double lineWidth -> a
    int resolution -> a
    org.freehep.graphics2d.GenericTagHandler tagHandler -> a
    java.util.Map symbols -> a
    org.freehep.graphics2d.WebColor webColor -> a
    boolean displayX11 -> a
    boolean displayLocal -> b
    void setHostGraphics(java.awt.Graphics) -> a
    void startExport() -> a
    void endExport() -> b
    void clearRect(int,int,int,int) -> clearRect
    void clipRect(int,int,int,int) -> clipRect
    void copyArea(int,int,int,int,int,int) -> copyArea
    java.awt.Graphics create() -> create
    void dispose() -> dispose
    void drawArc(int,int,int,int,int,int) -> drawArc
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    void drawLine(int,int,int,int) -> drawLine
    void drawOval(int,int,int,int) -> drawOval
    void drawPolygon(int[],int[],int) -> drawPolygon
    void drawPolygon(java.awt.Polygon) -> drawPolygon
    void drawPolyline(int[],int[],int) -> drawPolyline
    void drawRect(int,int,int,int) -> drawRect
    void drawString(java.lang.String,int,int) -> drawString
    void fillArc(int,int,int,int,int,int) -> fillArc
    void fillOval(int,int,int,int) -> fillOval
    void fillPolygon(int[],int[],int) -> fillPolygon
    void fillPolygon(java.awt.Polygon) -> fillPolygon
    void fillRect(int,int,int,int) -> fillRect
    void setLineWidth(double) -> a
    java.awt.Shape getClip() -> getClip
    java.awt.Rectangle getClipBounds() -> getClipBounds
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    void setClip(int,int,int,int) -> setClip
    void setClip(java.awt.Shape) -> setClip
    void setFont(java.awt.Font) -> setFont
    void setColor(java.awt.Color) -> setColor
    void setPaint(java.awt.Paint) -> setPaint
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void translate(int,int) -> translate
    void addRenderingHints(java.util.Map) -> addRenderingHints
    void clip(java.awt.Shape) -> clip
    void draw(java.awt.Shape) -> draw
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void drawString(java.text.AttributedCharacterIterator,int,int) -> drawString
    void drawString(java.lang.String,float,float) -> drawString
    void fill(java.awt.Shape) -> fill
    java.awt.Composite getComposite() -> getComposite
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    java.awt.Stroke getStroke() -> getStroke
    java.awt.geom.AffineTransform getTransform() -> getTransform
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    void rotate(double) -> rotate
    void rotate(double,double,double) -> rotate
    void scale(double,double) -> scale
    void setBackground(java.awt.Color) -> setBackground
    void setComposite(java.awt.Composite) -> setComposite
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    void setRenderingHints(java.util.Map) -> setRenderingHints
    void setStroke(java.awt.Stroke) -> setStroke
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    void shear(double,double) -> shear
    void transform(java.awt.geom.AffineTransform) -> transform
    void translate(double,double) -> translate
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    java.lang.String toString() -> toString
org.freehep.graphics2d.PixelGraphics2D$SymbolBlitKey -> org.freehep.a.c$a:
    boolean isCompatibleValue(java.lang.Object) -> isCompatibleValue
    java.lang.String toString() -> toString
org.freehep.graphics2d.PrintColor -> org.freehep.a.d:
    java.awt.Color[] defaultColors -> a
    float asGray -> a
    boolean asBlack -> a
    void testColorValueRange(float) -> a
    float getAsGray() -> a
    boolean getAsBlack() -> a
    org.freehep.graphics2d.PrintColor getColor(int) -> a
    org.freehep.graphics2d.PrintColor createPrintColor(java.awt.Color) -> a
    java.awt.Color mixColor(java.awt.Color,java.awt.Color) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    org.freehep.graphics2d.PrintColor invert(java.awt.Color) -> b
org.freehep.graphics2d.SymbolShape -> org.freehep.a.e:
    double SQRT_2 -> a
    double SQRT_3 -> b
    double[] points -> a
    int[] type -> a
    org.freehep.graphics2d.SymbolShape$ArrayPathIterator pathIterator -> a
    double x -> c
    double y -> d
    double size -> e
    int symbol -> a
    boolean contains(double,double) -> contains
    boolean contains(double,double,double,double) -> contains
    boolean contains(java.awt.geom.Point2D) -> contains
    boolean contains(java.awt.geom.Rectangle2D) -> contains
    boolean intersects(double,double,double,double) -> intersects
    boolean intersects(java.awt.geom.Rectangle2D) -> intersects
    java.awt.geom.PathIterator getPathIterator(java.awt.geom.AffineTransform,double) -> getPathIterator
    java.awt.geom.Rectangle2D getBounds2D() -> getBounds2D
    java.awt.Rectangle getBounds() -> getBounds
    java.awt.geom.PathIterator getPathIterator(java.awt.geom.AffineTransform) -> getPathIterator
    java.lang.String toString() -> toString
    void ensureNumberOfPoints(int) -> a
org.freehep.graphics2d.SymbolShape$ArrayPathIterator -> org.freehep.a.e$a:
    int currentPoint -> a
    double[] points -> a
    int[] type -> a
    int numberOfPoints -> b
    org.freehep.graphics2d.SymbolShape this$0 -> a
    boolean isDone() -> isDone
    void next() -> next
    int currentSegment(double[]) -> currentSegment
    int currentSegment(float[]) -> currentSegment
    int getWindingRule() -> getWindingRule
    void reset() -> a
    double[] access$1(org.freehep.graphics2d.SymbolShape$ArrayPathIterator) -> a
    void access$2(org.freehep.graphics2d.SymbolShape$ArrayPathIterator) -> a
org.freehep.graphics2d.TagHandler -> org.freehep.a.f:
    java.lang.String parse(org.freehep.graphics2d.TagString) -> a
    java.lang.String defaultEntity(java.lang.String) -> d
    java.lang.String entity(java.lang.String) -> e
    java.lang.String openTag(java.lang.String) -> a
    java.lang.String closeTag(java.lang.String) -> b
    java.lang.String text(java.lang.String) -> c
org.freehep.graphics2d.TagString -> org.freehep.a.g:
    java.lang.String string -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
org.freehep.graphics2d.VectorGraphics -> org.freehep.a.h:
    java.util.Hashtable symbols -> a
    java.util.Hashtable alignments -> b
    java.awt.Graphics create(int,int,int,int) -> create
    void draw(java.awt.Shape) -> draw
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    void fill(java.awt.Shape) -> fill
    java.awt.Stroke getStroke() -> getStroke
    void rotate(double) -> rotate
    void setStroke(java.awt.Stroke) -> setStroke
    void translate(double,double) -> translate
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    void endExport() -> b
    void startExport() -> a
org.freehep.graphics2d.WebColor -> org.freehep.a.i:
    org.freehep.graphics2d.WebColor white -> a
    org.freehep.graphics2d.WebColor WHITE -> b
    org.freehep.graphics2d.WebColor lightGray -> c
    org.freehep.graphics2d.WebColor LIGHT_GRAY -> d
    org.freehep.graphics2d.WebColor gray -> e
    org.freehep.graphics2d.WebColor GRAY -> f
    org.freehep.graphics2d.WebColor darkGray -> g
    org.freehep.graphics2d.WebColor DARK_GRAY -> h
    org.freehep.graphics2d.WebColor black -> i
    org.freehep.graphics2d.WebColor BLACK -> j
    org.freehep.graphics2d.WebColor red -> k
    org.freehep.graphics2d.WebColor RED -> l
    org.freehep.graphics2d.WebColor pink -> m
    org.freehep.graphics2d.WebColor PINK -> n
    org.freehep.graphics2d.WebColor orange -> o
    org.freehep.graphics2d.WebColor ORANGE -> p
    org.freehep.graphics2d.WebColor yellow -> q
    org.freehep.graphics2d.WebColor YELLOW -> r
    org.freehep.graphics2d.WebColor green -> s
    org.freehep.graphics2d.WebColor GREEN -> t
    org.freehep.graphics2d.WebColor magenta -> u
    org.freehep.graphics2d.WebColor MAGENTA -> v
    org.freehep.graphics2d.WebColor cyan -> w
    org.freehep.graphics2d.WebColor CYAN -> x
    org.freehep.graphics2d.WebColor blue -> y
    org.freehep.graphics2d.WebColor BLUE -> z
    org.freehep.graphics2d.WebColor create(java.awt.Color) -> a
org.freehep.graphics2d.font.AbstractCharTable -> org.freehep.a.a.a:
    int toEncoding(char) -> a
    java.lang.String toName(char) -> a
org.freehep.graphics2d.font.CharTable -> org.freehep.a.a.b:
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    int toEncoding(char) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Expert -> org.freehep.a.a.c:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.FontEncoder -> org.freehep.a.a.d:
    java.lang.String getEncodedString(java.lang.String,java.lang.String) -> a
    java.lang.String getEncodedString(java.lang.String,org.freehep.graphics2d.font.CharTable) -> a
org.freehep.graphics2d.font.ISOLatin -> org.freehep.a.a.e:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Lookup -> org.freehep.a.a.f:
    org.freehep.graphics2d.font.Lookup instance -> a
    org.freehep.graphics2d.font.CharTable[] tables -> a
    int ntables -> a
    org.freehep.graphics2d.font.Lookup getInstance() -> a
    org.freehep.graphics2d.font.CharTable getTable(java.lang.String) -> a
org.freehep.graphics2d.font.MACLatin -> org.freehep.a.a.g:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.PDFLatin -> org.freehep.a.a.h:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.STDLatin -> org.freehep.a.a.i:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Symbol -> org.freehep.a.a.j:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.WINLatin -> org.freehep.a.a.k:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphics2d.font.Zapfdingbats -> org.freehep.a.a.l:
    java.util.Hashtable unicodeToName -> a
    java.util.Hashtable nameToUnicode -> b
    java.util.Hashtable nameToEnc -> c
    java.lang.String[] encToName -> a
    java.lang.String toName(java.lang.Character) -> a
    java.lang.String toName(int) -> a
    int toEncoding(java.lang.String) -> a
    char toUnicode(java.lang.String) -> a
    java.lang.String getName() -> a
    java.lang.String getEncoding() -> b
org.freehep.graphicsio.AbstractPathConstructor -> org.freehep.graphicsio.a:
    double currentX -> a
    double currentY -> b
    void flush() -> a
    boolean addPath(java.awt.Shape) -> a
    boolean addPath(java.awt.Shape,java.awt.geom.AffineTransform) -> a
    boolean addPath(org.freehep.graphicsio.PathConstructor,java.awt.Shape,java.awt.geom.AffineTransform) -> a
    boolean isEvenOdd(java.awt.Shape) -> b
org.freehep.graphicsio.AbstractVectorGraphicsIO -> org.freehep.graphicsio.b:
    java.lang.String rootKey -> e
    java.lang.String EMIT_WARNINGS -> a
    java.lang.String TEXT_AS_SHAPES -> b
    java.lang.String EMIT_ERRORS -> c
    java.lang.String CLIP -> d
    java.awt.Dimension size -> a
    java.awt.Component component -> a
    boolean doRestoreOnDispose -> a
    java.awt.Rectangle deviceClip -> a
    java.awt.geom.Area userClip -> a
    java.awt.geom.AffineTransform currentTransform -> a
    java.awt.geom.AffineTransform oldTransform -> b
    java.awt.Composite currentComposite -> a
    java.awt.Stroke currentStroke -> a
    java.awt.RenderingHints hints -> a
    java.awt.Dimension getSize() -> a
    java.awt.Component getComponent() -> a
    void startExport() -> a
    void endExport() -> b
    void writeHeader() -> c
    void writeGraphicsState() -> d
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    void resetClip(java.awt.Rectangle) -> a
    void dispose() -> dispose
    void writeGraphicsRestore() -> h
    boolean drawImage(java.awt.Image,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.image.ImageObserver) -> drawImage
    boolean drawImage(java.awt.Image,java.awt.geom.AffineTransform,java.awt.image.ImageObserver) -> drawImage
    void drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int) -> drawImage
    void drawRenderableImage(java.awt.image.renderable.RenderableImage,java.awt.geom.AffineTransform) -> drawRenderableImage
    boolean drawImage(java.awt.Image,int,int,int,int,int,int,int,int,java.awt.Color,java.awt.image.ImageObserver) -> drawImage
    void drawRenderedImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform) -> drawRenderedImage
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void clearRect(double,double,double,double) -> f
    void drawString(java.lang.String,double,double) -> a
    void writeString(java.lang.String,double,double) -> b
    void drawGlyphVector(java.awt.font.GlyphVector,float,float) -> drawGlyphVector
    void drawString(java.text.AttributedCharacterIterator,float,float) -> drawString
    java.awt.geom.AffineTransform getTransform() -> getTransform
    void setTransform(java.awt.geom.AffineTransform) -> setTransform
    void transform(java.awt.geom.AffineTransform) -> transform
    void translate(double,double) -> translate
    void rotate(double) -> rotate
    void scale(double,double) -> scale
    void shear(double,double) -> shear
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    java.awt.Shape getClip() -> getClip
    java.awt.Rectangle getClipBounds() -> getClipBounds
    java.awt.Rectangle getClipBounds(java.awt.Rectangle) -> getClipBounds
    void clipRect(int,int,int,int) -> clipRect
    void setClip(int,int,int,int) -> setClip
    void setClip(java.awt.Shape) -> setClip
    void clip(java.awt.Shape) -> clip
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    java.awt.Stroke getStroke() -> getStroke
    void setStroke(java.awt.Stroke) -> setStroke
    void writeStroke(java.awt.Stroke) -> a
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void writeDash(double[],double) -> a
    void setColor(java.awt.Color) -> setColor
    void setPaint(java.awt.Paint) -> setPaint
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    java.awt.FontMetrics getFontMetrics(java.awt.Font) -> getFontMetrics
    java.awt.RenderingHints getRenderingHints() -> getRenderingHints
    void addRenderingHints(java.util.Map) -> addRenderingHints
    void setRenderingHints(java.util.Map) -> setRenderingHints
    java.lang.Object getRenderingHint(java.awt.RenderingHints$Key) -> getRenderingHint
    void setRenderingHint(java.awt.RenderingHints$Key,java.lang.Object) -> setRenderingHint
    void setFont(java.awt.Font) -> setFont
    void writeFont(java.awt.Font) -> a
    java.awt.Composite getComposite() -> getComposite
    void setComposite(java.awt.Composite) -> setComposite
    void handleException(java.lang.Exception) -> a
    void writeWarning(java.lang.Exception) -> b
    void writeWarning(java.lang.String) -> c
    void writeError(java.lang.Exception) -> c
    java.awt.Shape transformShape(java.awt.geom.AffineTransform,java.awt.Shape) -> a
    java.awt.Shape transformShape(java.awt.Shape) -> a
    java.awt.Shape untransformShape(java.awt.Shape) -> b
org.freehep.graphicsio.ImageGraphics2D -> org.freehep.graphicsio.c:
    java.lang.String[] alwaysCompressedFormats -> a
    java.lang.String[] nonTransparentFormats -> b
    java.util.Map defaultProperties -> a
    java.io.OutputStream os -> a
    java.awt.image.BufferedImage image -> a
    java.lang.String format -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    void setHintsOnGraphics() -> e
    java.awt.Graphics create() -> create
    void startExport() -> a
    void endExport() -> b
    void write() -> c
    void closeStream() -> d
    void handleException(java.lang.Exception) -> a
    java.awt.image.BufferedImage generateThumbnail(java.awt.Component,java.awt.Dimension) -> a
    void writeImage(java.awt.image.RenderedImage,java.lang.String,java.util.Properties,java.io.OutputStream) -> a
    javax.imageio.ImageWriter getPreferredImageWriter(java.lang.String) -> a
    java.util.SortedSet getImageWriters(java.util.Iterator) -> a
    boolean canWriteUncompressed(java.lang.String) -> b
org.freehep.graphicsio.ImageGraphics2D$1 -> org.freehep.graphicsio.d:
    int order(java.lang.Object) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.freehep.graphicsio.ImageParamConverter -> org.freehep.graphicsio.e:
    javax.imageio.ImageWriteParam getWriteParam(java.util.Properties) -> a
org.freehep.graphicsio.MultiPageDocument -> org.freehep.graphicsio.f:
org.freehep.graphicsio.PageConstants -> org.freehep.graphicsio.g:
    java.util.Map sizeTable -> a
    java.util.Map marginTable -> b
    java.awt.Dimension getSize(java.lang.String,java.lang.String) -> a
    java.awt.Insets getMargins(java.lang.String) -> a
    java.awt.Insets getMargins(java.awt.Insets,java.lang.String) -> a
org.freehep.graphicsio.PathConstructor -> org.freehep.graphicsio.h:
    void move(double,double) -> a
    void line(double,double) -> b
    void quad(double,double,double,double) -> a
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void flush() -> a
org.freehep.graphicsio.QuadToCubicPathConstructor -> org.freehep.graphicsio.i:
    void move(double,double) -> a
    void line(double,double) -> b
    void quad(double,double,double,double) -> a
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
org.freehep.graphicsio.VectorGraphicsIO -> org.freehep.graphicsio.j:
org.freehep.graphicsio.emf.EMFGraphics2D -> org.freehep.graphicsio.a.a:
    org.freehep.graphicsio.emf.EMFHandleManager handleManager -> a
    int penHandle -> a
    int brushHandle -> b
    java.awt.Rectangle imageBounds -> a
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Color textColor -> b
    java.awt.Color penColor -> c
    java.awt.Color brushColor -> d
    java.util.Map fontTable -> a
    java.util.Map unitFontTable -> b
    org.freehep.graphicsio.emf.EMFPathConstructor pathConstructor -> a
    boolean evenOdd -> a
    java.awt.Rectangle dummy -> b
    java.lang.String rootKey -> h
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    org.freehep.util.UserProperties defaultProperties -> a
    java.awt.Point[] points -> a
    java.awt.Color invisible -> a
    java.util.Properties replaceFonts -> a
    void init(java.io.OutputStream) -> a
    void writeHeader() -> c
    void writeGraphicsState() -> d
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> i
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeSetClip(java.awt.Shape) -> b
    void writeClip(java.awt.Shape) -> a
    void writeStroke(java.awt.Stroke) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    boolean writePath(java.awt.Shape) -> a
    void writePen(java.awt.BasicStroke,java.awt.Color) -> a
    void writeBrush(java.awt.Color) -> b
    int toUnit(double) -> a
org.freehep.graphicsio.emf.EMFHandleManager -> org.freehep.graphicsio.a.b:
    java.util.BitSet handles -> a
    int maxHandle -> a
    int getHandle() -> a
    int freeHandle(int) -> a
    int nextClearBit() -> d
    int highestHandleInUse() -> b
    int maxHandlesUsed() -> c
org.freehep.graphicsio.emf.EMFHeader -> org.freehep.graphicsio.a.c:
    java.awt.Dimension screenMM -> a
    int type -> a
    java.awt.Rectangle bounds -> a
    java.awt.Rectangle frame -> b
    java.lang.String signature -> a
    int versionMajor -> b
    int versionMinor -> c
    int bytes -> d
    int records -> e
    int handles -> f
    java.lang.String description -> b
    int palEntries -> g
    java.awt.Dimension device -> b
    java.awt.Dimension millimeters -> c
    java.awt.Dimension micrometers -> d
    boolean openGL -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int size() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFInputStream -> org.freehep.graphicsio.a.d:
    int DEFAULT_VERSION -> a
    int readDWORD() -> a
    int[] readDWORD(int) -> a
    int readWORD() -> b
    int readLONG() -> c
    float readFLOAT() -> a
    int readUINT() -> d
    int readULONG() -> e
    java.awt.Color readCOLORREF() -> a
    java.awt.Color readCOLOR16() -> b
    java.awt.Color readCOLOR() -> c
    java.awt.geom.AffineTransform readXFORM() -> a
    java.awt.Rectangle readRECTL() -> a
    java.awt.Point readPOINTL() -> a
    java.awt.Point[] readPOINTL(int) -> a
    java.awt.Point readPOINTS() -> b
    java.awt.Point[] readPOINTS(int) -> b
    java.awt.Dimension readSIZEL() -> a
    int readBYTE() -> f
    byte[] readBYTE(int) -> a
    boolean readBOOLEAN() -> a
    java.lang.String readWCHAR(int) -> a
    org.freehep.util.io.TagHeader readTagHeader() -> a
org.freehep.graphicsio.emf.EMFOutputStream -> org.freehep.graphicsio.a.e:
    java.lang.String application -> a
    java.lang.String name -> b
    int recordCount -> b
    java.awt.Rectangle imageBounds -> a
    int version -> c
    org.freehep.graphicsio.emf.EMFHandleManager handles -> a
    java.awt.Dimension device -> a
    void close() -> close
    void writeDWORD(int) -> a
    void writeDWORD(int[]) -> a
    void writeWORD(int) -> b
    void writeFLOAT(float) -> a
    void writeCOLORREF(java.awt.Color) -> a
    void writeCOLOR16(java.awt.Color) -> b
    void writeCOLOR(java.awt.Color) -> c
    void writeXFORM(java.awt.geom.AffineTransform) -> a
    void writePOINTS(java.awt.Point[]) -> a
    void writePOINTS(int,java.awt.Point[]) -> a
    void writePOINTS(java.awt.Point) -> a
    void writePOINTL(java.awt.Point[]) -> b
    void writePOINTL(int,java.awt.Point[]) -> b
    void writePOINTL(java.awt.Point) -> b
    void writeRECTL(java.awt.Rectangle) -> a
    void writeSIZEL(java.awt.Dimension) -> a
    void writeUINT(int) -> c
    void writeULONG(int) -> d
    void writeLONG(int) -> e
    void writeSHORT(short) -> a
    void writeBYTE(byte[]) -> a
    void writeBYTE(int) -> f
    void writeBYTE(boolean) -> a
    void writeDWORD(boolean) -> b
    void writeWCHAR(java.lang.String) -> a
    void writeWCHAR(java.lang.String,int) -> a
    int getTagAlignment() -> a
    org.freehep.util.io.TagHeader createTagHeader(org.freehep.util.io.Tag,long) -> a
    void writeTagHeader(org.freehep.util.io.TagHeader) -> a
    void writeTag(org.freehep.util.io.Tag) -> a
    void writeTag(org.freehep.util.io.Tag,boolean) -> a
    void writeHeader(org.freehep.graphicsio.emf.EMFHeader) -> a
    int getVersion() -> b
org.freehep.graphicsio.emf.EMFPathConstructor -> org.freehep.graphicsio.a.f:
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Rectangle imageBounds -> a
    boolean curved -> a
    int pointIndex -> a
    boolean wide -> b
    java.awt.Point[] points -> a
    void move(double,double) -> a
    void addPoint(int,double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void flush() -> a
    int toUnit(double) -> a
org.freehep.graphicsio.emf.EMFPlusGraphics2D -> org.freehep.graphicsio.a.g:
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.emf.EMFOutputStream os -> a
    java.awt.Rectangle imageBounds -> a
    org.freehep.graphicsio.emf.EMFHandleManager handleManager -> a
    org.freehep.util.Value containerIndex -> a
    java.awt.Paint restorePaint -> a
    java.lang.String rootKey -> h
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    org.freehep.util.UserProperties defaultProperties -> a
    java.awt.font.FontRenderContext getFontRenderContext() -> getFontRenderContext
    void init(java.io.OutputStream) -> a
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> i
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    void writeWarning(java.lang.String) -> c
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFTag -> org.freehep.graphicsio.a.h:
    int flags -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int getFlags() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.EMFTagHeader -> org.freehep.graphicsio.a.i:
    int flags -> b
    int getFlags() -> a
org.freehep.graphicsio.emf.EMFTagSet -> org.freehep.graphicsio.a.j:
org.freehep.graphicsio.emf.gdi.AbortPath -> org.freehep.graphicsio.a.a.a:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.AlphaBlend -> org.freehep.graphicsio.a.a.b:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    org.freehep.graphicsio.emf.gdi.BlendFunction dwROP -> a
    int xSrc -> f
    int ySrc -> g
    java.awt.geom.AffineTransform transform -> a
    java.awt.Color bkg -> a
    int usage -> h
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.AngleArc -> org.freehep.graphicsio.a.a.c:
    java.awt.Point center -> a
    int radius -> b
    float startAngle -> a
    float sweepAngle -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Arc -> org.freehep.graphicsio.a.a.d:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ArcTo -> org.freehep.graphicsio.a.a.e:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BeginPath -> org.freehep.graphicsio.a.a.f:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.BitBlt -> org.freehep.graphicsio.a.a.g:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    int dwROP -> f
    int xSrc -> g
    int ySrc -> h
    java.awt.geom.AffineTransform transform -> a
    java.awt.Color bkg -> a
    int usage -> i
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BitmapInfo -> org.freehep.graphicsio.a.a.h:
    org.freehep.graphicsio.emf.gdi.BitmapInfoHeader header -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BitmapInfoHeader -> org.freehep.graphicsio.a.a.i:
    int width -> a
    int height -> b
    int planes -> c
    int bitCount -> d
    int compression -> e
    int sizeImage -> f
    int xPelsPerMeter -> g
    int yPelsPerMeter -> h
    int clrUsed -> i
    int clrImportant -> j
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.BlendFunction -> org.freehep.graphicsio.a.a.j:
    int blendOp -> a
    int blendFlags -> b
    int sourceConstantAlpha -> c
    int alphaFormat -> d
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Chord -> org.freehep.graphicsio.a.a.k:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.CloseFigure -> org.freehep.graphicsio.a.a.l:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.CreateBrushIndirect -> org.freehep.graphicsio.a.a.m:
    int index -> b
    org.freehep.graphicsio.emf.gdi.LogBrush32 brush -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.CreatePen -> org.freehep.graphicsio.a.a.n:
    int index -> b
    org.freehep.graphicsio.emf.gdi.LogPen pen -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.DeleteObject -> org.freehep.graphicsio.a.a.o:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EMFPolygon -> org.freehep.graphicsio.a.a.p:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EMFRectangle -> org.freehep.graphicsio.a.a.q:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EOF -> org.freehep.graphicsio.a.a.r:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdi.Ellipse -> org.freehep.graphicsio.a.a.s:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.EndPath -> org.freehep.graphicsio.a.a.t:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.ExcludeClipRect -> org.freehep.graphicsio.a.a.u:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtCreateFontIndirectW -> org.freehep.graphicsio.a.a.v:
    int index -> b
    org.freehep.graphicsio.emf.gdi.ExtLogFontW font -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtCreatePen -> org.freehep.graphicsio.a.a.w:
    int index -> b
    org.freehep.graphicsio.emf.gdi.ExtLogPen pen -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtFloodFill -> org.freehep.graphicsio.a.a.x:
    java.awt.Point start -> a
    java.awt.Color color -> a
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtLogFontW -> org.freehep.graphicsio.a.a.y:
    org.freehep.graphicsio.emf.gdi.LogFontW font -> a
    java.lang.String fullName -> a
    java.lang.String style -> b
    int version -> a
    int styleSize -> b
    int match -> c
    byte[] vendorID -> a
    int culture -> d
    org.freehep.graphicsio.emf.gdi.Panose panose -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtLogPen -> org.freehep.graphicsio.a.a.z:
    int penStyle -> a
    int width -> b
    int brushStyle -> c
    java.awt.Color color -> a
    int hatch -> d
    int[] style -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtSelectClipRgn -> org.freehep.graphicsio.a.a.A:
    int mode -> b
    org.freehep.graphicsio.emf.gdi.Region rgn -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtTextOutA -> org.freehep.graphicsio.a.a.B:
    java.awt.Rectangle bounds -> a
    int mode -> b
    float xScale -> a
    float yScale -> b
    org.freehep.graphicsio.emf.gdi.Text text -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ExtTextOutW -> org.freehep.graphicsio.a.a.C:
    java.awt.Rectangle bounds -> a
    int mode -> b
    float xScale -> a
    float yScale -> b
    org.freehep.graphicsio.emf.gdi.TextW text -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.FillPath -> org.freehep.graphicsio.a.a.D:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.FlattenPath -> org.freehep.graphicsio.a.a.E:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.GDIComment -> org.freehep.graphicsio.a.a.F:
    byte[] bytes -> a
    org.freehep.graphicsio.emf.EMFTag tag -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Gradient -> org.freehep.graphicsio.a.a.G:
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdi.GradientFill -> org.freehep.graphicsio.a.a.H:
    java.awt.Rectangle bounds -> a
    int mode -> b
    org.freehep.graphicsio.emf.gdi.TriVertex[] vertices -> a
    org.freehep.graphicsio.emf.gdi.Gradient[] gradients -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.GradientRectangle -> org.freehep.graphicsio.a.a.I:
    int upperLeft -> a
    int lowerRight -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.GradientTriangle -> org.freehep.graphicsio.a.a.J:
    int vertex1 -> a
    int vertex2 -> b
    int vertex3 -> c
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.IntersectClipRect -> org.freehep.graphicsio.a.a.K:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LineTo -> org.freehep.graphicsio.a.a.L:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogBrush32 -> org.freehep.graphicsio.a.a.M:
    int style -> a
    java.awt.Color color -> a
    int hatch -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogFontW -> org.freehep.graphicsio.a.a.N:
    int height -> a
    int width -> b
    int escapement -> c
    int orientation -> d
    int weight -> e
    boolean italic -> a
    boolean underline -> b
    boolean strikeout -> c
    int charSet -> f
    int outPrecision -> g
    int clipPrecision -> h
    int quality -> i
    int pitchAndFamily -> j
    java.lang.String faceFamily -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.LogPen -> org.freehep.graphicsio.a.a.O:
    int penStyle -> a
    int width -> b
    java.awt.Color color -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ModifyWorldTransform -> org.freehep.graphicsio.a.a.P:
    java.awt.geom.AffineTransform transform -> a
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.MoveToEx -> org.freehep.graphicsio.a.a.Q:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.OffsetClipRgn -> org.freehep.graphicsio.a.a.R:
    java.awt.Point offset -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Panose -> org.freehep.graphicsio.a.a.S:
    int familyType -> a
    int serifStyle -> b
    int weight -> c
    int proportion -> d
    int contrast -> e
    int strokeVariation -> f
    int armStyle -> g
    int letterForm -> h
    int midLine -> i
    int xHeight -> j
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Pie -> org.freehep.graphicsio.a.a.T:
    java.awt.Rectangle bounds -> a
    java.awt.Point start -> a
    java.awt.Point end -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezier -> org.freehep.graphicsio.a.a.U:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezier16 -> org.freehep.graphicsio.a.a.V:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezierTo -> org.freehep.graphicsio.a.a.W:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyBezierTo16 -> org.freehep.graphicsio.a.a.X:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyDraw -> org.freehep.graphicsio.a.a.Y:
    java.awt.Rectangle bounds -> a
    java.awt.Point[] points -> a
    byte[] types -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyDraw16 -> org.freehep.graphicsio.a.a.Z:
    java.awt.Rectangle bounds -> a
    java.awt.Point[] points -> a
    byte[] types -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolygon -> org.freehep.graphicsio.a.a.aa:
    java.awt.Rectangle bounds -> a
    int start -> b
    int end -> c
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolygon16 -> org.freehep.graphicsio.a.a.ab:
    java.awt.Rectangle bounds -> a
    int numberOfPolys -> b
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolyline -> org.freehep.graphicsio.a.a.ac:
    java.awt.Rectangle bounds -> a
    int start -> b
    int end -> c
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolyPolyline16 -> org.freehep.graphicsio.a.a.ad:
    java.awt.Rectangle bounds -> a
    int numberOfPolys -> b
    int[] numberOfPoints -> a
    java.awt.Point[][] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polygon16 -> org.freehep.graphicsio.a.a.ae:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polyline -> org.freehep.graphicsio.a.a.af:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Polyline16 -> org.freehep.graphicsio.a.a.ag:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolylineTo -> org.freehep.graphicsio.a.a.ah:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.PolylineTo16 -> org.freehep.graphicsio.a.a.ai:
    java.awt.Rectangle bounds -> a
    int numberOfPoints -> b
    java.awt.Point[] points -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RealizePalette -> org.freehep.graphicsio.a.a.aj:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.Region -> org.freehep.graphicsio.a.a.ak:
    java.awt.Rectangle bounds -> a
    java.awt.Rectangle region -> b
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    int length() -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ResizePalette -> org.freehep.graphicsio.a.a.al:
    int index -> b
    int entries -> c
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RestoreDC -> org.freehep.graphicsio.a.a.am:
    int savedDC -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.RoundRect -> org.freehep.graphicsio.a.a.an:
    java.awt.Rectangle bounds -> a
    java.awt.Dimension corner -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SaveDC -> org.freehep.graphicsio.a.a.ao:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.ScaleViewportExtEx -> org.freehep.graphicsio.a.a.ap:
    int xNum -> b
    int xDenom -> c
    int yNum -> d
    int yDenom -> e
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.ScaleWindowExtEx -> org.freehep.graphicsio.a.a.aq:
    int xNum -> b
    int xDenom -> c
    int yNum -> d
    int yDenom -> e
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectClipPath -> org.freehep.graphicsio.a.a.ar:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectObject -> org.freehep.graphicsio.a.a.as:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SelectPalette -> org.freehep.graphicsio.a.a.at:
    int index -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetArcDirection -> org.freehep.graphicsio.a.a.au:
    int direction -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBkColor -> org.freehep.graphicsio.a.a.av:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBkMode -> org.freehep.graphicsio.a.a.aw:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetBrushOrgEx -> org.freehep.graphicsio.a.a.ax:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetICMMode -> org.freehep.graphicsio.a.a.ay:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMapMode -> org.freehep.graphicsio.a.a.az:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMapperFlags -> org.freehep.graphicsio.a.a.aA:
    int flags -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetMetaRgn -> org.freehep.graphicsio.a.a.aB:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdi.SetMiterLimit -> org.freehep.graphicsio.a.a.aC:
    int limit -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetPixelV -> org.freehep.graphicsio.a.a.aD:
    java.awt.Point point -> a
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetPolyFillMode -> org.freehep.graphicsio.a.a.aE:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetROP2 -> org.freehep.graphicsio.a.a.aF:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetStretchBltMode -> org.freehep.graphicsio.a.a.aG:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetTextAlign -> org.freehep.graphicsio.a.a.aH:
    int mode -> b
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetTextColor -> org.freehep.graphicsio.a.a.aI:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetViewportExtEx -> org.freehep.graphicsio.a.a.aJ:
    java.awt.Dimension size -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetViewportOrgEx -> org.freehep.graphicsio.a.a.aK:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWindowExtEx -> org.freehep.graphicsio.a.a.aL:
    java.awt.Dimension size -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWindowOrgEx -> org.freehep.graphicsio.a.a.aM:
    java.awt.Point point -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.SetWorldTransform -> org.freehep.graphicsio.a.a.aN:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StretchDIBits -> org.freehep.graphicsio.a.a.aO:
    java.awt.Rectangle bounds -> a
    int x -> b
    int y -> c
    int width -> d
    int height -> e
    int xSrc -> f
    int ySrc -> g
    int widthSrc -> h
    int heightSrc -> i
    int usage -> j
    int dwROP -> k
    java.awt.Color bkg -> a
    org.freehep.graphicsio.emf.gdi.BitmapInfo bmi -> a
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StrokeAndFillPath -> org.freehep.graphicsio.a.a.aP:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.StrokePath -> org.freehep.graphicsio.a.a.aQ:
    java.awt.Rectangle bounds -> a
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.Text -> org.freehep.graphicsio.a.a.aR:
    java.awt.Point pos -> a
    java.lang.String string -> a
    int options -> a
    int[] widths -> a
    java.awt.Rectangle bounds -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.TextW -> org.freehep.graphicsio.a.a.aS:
    java.awt.Point pos -> a
    java.lang.String string -> a
    int options -> a
    int[] widths -> a
    java.awt.Rectangle bounds -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.TriVertex -> org.freehep.graphicsio.a.a.aT:
    int x -> a
    int y -> b
    java.awt.Color color -> a
    void write(org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdi.WidenPath -> org.freehep.graphicsio.a.a.aU:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
org.freehep.graphicsio.emf.gdiplus.Clear -> org.freehep.graphicsio.a.b.a:
    java.awt.Color color -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.DrawEllipse -> org.freehep.graphicsio.a.b.b:
    float x -> a
    float y -> b
    float w -> c
    float h -> d
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.DrawImage -> org.freehep.graphicsio.a.b.c:
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.DrawLines -> org.freehep.graphicsio.a.b.d:
    float[] x -> a
    float[] y -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.DrawPath -> org.freehep.graphicsio.a.b.e:
    int penIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.EMFPlusPathConstructor -> org.freehep.graphicsio.a.b.f:
    java.util.List path -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void reset() -> b
    org.freehep.graphicsio.emf.gdiplus.PathPoint[] getPath() -> a
org.freehep.graphicsio.emf.gdiplus.EMFPlusTag -> org.freehep.graphicsio.a.b.g:
    org.freehep.graphicsio.emf.EMFTag read(int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.EndOfFile -> org.freehep.graphicsio.a.b.h:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.FillEllipse -> org.freehep.graphicsio.a.b.i:
    int brushIndex -> b
    java.awt.Color brushColor -> a
    float x -> a
    float y -> b
    float w -> c
    float h -> d
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.FillPath -> org.freehep.graphicsio.a.b.j:
    java.awt.Color brushColor -> a
    int brushIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.GDIPlusObject -> org.freehep.graphicsio.a.b.k:
    java.awt.Paint brush -> a
    java.awt.BasicStroke stroke -> a
    org.freehep.graphicsio.emf.gdiplus.PathPoint[] path -> a
    int pathFillMode -> b
    java.awt.image.RenderedImage image -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
    java.awt.Paint readBrush(org.freehep.graphicsio.emf.EMFInputStream) -> a
    void writeBrush(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.Paint) -> a
    void writeTransform(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.geom.AffineTransform) -> a
    void writeImage(org.freehep.graphicsio.emf.EMFOutputStream,java.awt.image.RenderedImage) -> a
org.freehep.graphicsio.emf.gdiplus.Header -> org.freehep.graphicsio.a.b.l:
    int hDpi -> b
    int vDpi -> c
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.MultiplyWorldTransform -> org.freehep.graphicsio.a.b.m:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.PathPoint -> org.freehep.graphicsio.a.b.n:
    float x -> a
    float y -> b
    int type -> a
    void setType(int) -> a
    int getType() -> a
    void setX(float) -> a
    float getX() -> a
    void setY(float) -> b
    float getY() -> b
org.freehep.graphicsio.emf.gdiplus.ResetClip -> org.freehep.graphicsio.a.b.o:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.Restore -> org.freehep.graphicsio.a.b.p:
    int containerIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.Save -> org.freehep.graphicsio.a.b.q:
    int containerIndex -> b
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.emf.gdiplus.SetAntiAliasMode -> org.freehep.graphicsio.a.b.r:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.SetClipPath -> org.freehep.graphicsio.a.b.s:
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
org.freehep.graphicsio.emf.gdiplus.SetWorldTransform -> org.freehep.graphicsio.a.b.t:
    java.awt.geom.AffineTransform transform -> a
    org.freehep.graphicsio.emf.gdiplus.EMFPlusTag read(int,int,org.freehep.graphicsio.emf.EMFInputStream,int) -> a
    void write(int,int,org.freehep.graphicsio.emf.EMFOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.graphicsio.font.CharstringEncoder -> org.freehep.graphicsio.b.a:
    java.io.OutputStream out -> a
    int currentX -> a
    int currentY -> b
    int writeNumber(double) -> a
    void writeNumber(int) -> b
    void writeCommand(int) -> a
    void writePoint(double,double) -> e
    void writeX(double) -> a
    void writeY(double) -> b
    void startChar(double,double) -> d
    void endchar() -> b
    int to(double,double) -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
    void drawPath(java.awt.Shape) -> a
org.freehep.graphicsio.font.FontEmbedder -> org.freehep.graphicsio.b.b:
    double[] widths -> a
    java.awt.font.GlyphVector glyphs -> a
    java.awt.Font font -> a
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
    void writeWidths(double[]) -> a
    void openGlyphs() -> a
    void closeGlyphs() -> b
    void closeEmbedFont() -> c
    double[] getAdvanceWidths() -> a
    java.awt.Shape getGlyph(int) -> a
    java.awt.font.GlyphMetrics getGlyphMetrics(int) -> a
    void includeFont(java.awt.Font,org.freehep.graphics2d.font.CharTable,java.lang.String) -> a
    java.awt.Shape createUndefined() -> a
org.freehep.graphicsio.font.FontEmbedderType1 -> org.freehep.graphicsio.b.c:
    java.io.PrintStream fontFile -> a
    java.io.PrintStream encrypted -> b
    org.freehep.util.io.CountedByteOutputStream byteCounter -> a
    int asciiEnd -> a
    int encEnd -> b
    boolean addZeros -> a
    void writeWidths(double[]) -> a
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    void openIncludeFont() -> d
    void closeIncludeFont() -> e
    void openGlyphs() -> a
    void closeGlyphs() -> b
    void closeEmbedFont() -> c
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
    int getAsciiLength() -> a
    int getEncryptedLength() -> b
org.freehep.graphicsio.font.FontIncluder -> org.freehep.graphicsio.b.d:
    java.awt.font.FontRenderContext context -> a
    java.awt.geom.Rectangle2D fontBBox -> a
    java.awt.Font font -> a
    java.lang.String fontName -> a
    org.freehep.graphics2d.font.CharTable charTable -> a
    char[] unicode -> a
    java.lang.String[] charName -> a
    int noDefinedChars -> a
    void openIncludeFont() -> d
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    void closeIncludeFont() -> e
    java.awt.font.FontRenderContext getContext() -> a
    java.lang.String getFontName() -> a
    java.awt.Font getFont() -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    java.awt.geom.Rectangle2D getFontBBox() -> a
    java.lang.String getCharName(int) -> a
    char getUnicode(int) -> a
    char[] getUnicode() -> a
    int getNODefinedChars() -> c
    void includeFont(java.awt.Font,org.freehep.graphics2d.font.CharTable,java.lang.String) -> a
    double getUndefinedWidth() -> a
org.freehep.graphicsio.font.FontTable -> org.freehep.graphicsio.b.e:
    java.util.Hashtable table -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    void firstRequest(org.freehep.graphicsio.font.FontTable$Entry,boolean,java.lang.String) -> a
    java.lang.String createFontReference(java.awt.Font) -> a
    java.awt.Font substituteFont(java.awt.Font) -> a
    java.lang.String fontReference(java.awt.Font,boolean,java.lang.String) -> a
    java.lang.String getKey(java.awt.Font) -> b
    void normalize(java.util.Map) -> a
    java.util.Collection getEntries() -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable(java.awt.Font) -> a
org.freehep.graphicsio.font.FontTable$Entry -> org.freehep.graphicsio.b.e$a:
    java.awt.Font font -> a
    java.lang.String ref -> a
    org.freehep.graphics2d.font.CharTable encoding -> a
    boolean written -> a
    org.freehep.graphicsio.font.FontTable this$0 -> a
    java.awt.Font getFont() -> a
    java.lang.String getReference() -> a
    org.freehep.graphics2d.font.CharTable getEncoding() -> a
    void setWritten(boolean) -> a
    boolean isWritten() -> a
    java.lang.String toString() -> toString
    java.lang.String access$1(org.freehep.graphicsio.font.FontTable$Entry) -> a
org.freehep.graphicsio.font.FontUtilities -> org.freehep.graphicsio.b.f:
    java.util.Properties windowsFonts -> a
    org.freehep.graphics2d.font.CharTable[] STANDARD_CHAR_TABLES -> a
    java.awt.Font[] STANDARD_FONT -> a
    java.lang.String getWindowsFontName(java.lang.String) -> a
    void showString(java.awt.Font,java.lang.String,org.freehep.graphics2d.font.CharTable,org.freehep.graphicsio.font.FontUtilities$ShowString) -> a
org.freehep.graphicsio.font.FontUtilities$ShowString -> org.freehep.graphicsio.b.f$a:
    void showString(java.awt.Font,java.lang.String) -> a
org.freehep.graphicsio.pdf.PDF -> org.freehep.graphicsio.c.a:
    int generationNumber -> a
    java.util.Hashtable refsByName -> a
    java.util.Vector refsByNumber -> a
    java.util.Vector xrefsByNumber -> b
    int startXref -> b
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    org.freehep.graphicsio.pdf.PDFName name(java.lang.String) -> a
    org.freehep.graphicsio.pdf.PDFRef ref(java.lang.String) -> a
    void setXRef(int,int) -> a
    void xref() -> a
    void trailer(java.lang.String,java.lang.String) -> a
    void startxref() -> b
org.freehep.graphicsio.pdf.PDFByteWriter -> org.freehep.graphicsio.c.b:
    int indent -> a
    java.lang.String indentString -> b
    void write(java.lang.String) -> a
    void close() -> close
    void print(java.lang.String) -> b
    void printPlain(java.lang.String) -> c
    void println() -> a
    void indent() -> b
    void outdent() -> c
    void println(java.lang.String) -> d
    void print(int) -> a
    void println(int) -> b
    void printPlain(java.lang.Object) -> a
org.freehep.graphicsio.pdf.PDFCatalog -> org.freehep.graphicsio.c.c:
    void setViewerPreferences(java.lang.String) -> a
    void setPageMode(java.lang.String) -> b
    void setOutlines(java.lang.String) -> c
    void setOpenAction(java.lang.Object[]) -> a
org.freehep.graphicsio.pdf.PDFCharTableWriter -> org.freehep.graphicsio.c.d:
    org.freehep.graphicsio.pdf.PDFCharTableWriter ctw -> a
    org.freehep.graphicsio.pdf.PDFCharTableWriter getInstance() -> a
    void writeObject(java.lang.Object,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFWriter) -> a
org.freehep.graphicsio.pdf.PDFConstants -> org.freehep.graphicsio.c.e:
    java.lang.String EOL -> a
    java.text.SimpleDateFormat dateFormat -> a
org.freehep.graphicsio.pdf.PDFDictionary -> org.freehep.graphicsio.c.f:
    java.lang.String open -> b
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    boolean ok -> a
    org.freehep.graphicsio.pdf.PDFObject object -> a
    org.freehep.graphicsio.pdf.PDF pdf -> a
    void close() -> a
    void entry(java.lang.String,java.lang.String) -> a
    void entry(java.lang.String,org.freehep.graphicsio.pdf.PDFName) -> a
    void entry(java.lang.String,int) -> a
    void entry(java.lang.String,double) -> a
    void entry(java.lang.String,boolean) -> a
    void entry(java.lang.String,org.freehep.graphicsio.pdf.PDFRef) -> a
    void entry(java.lang.String,java.util.Calendar) -> a
    void entry(java.lang.String,java.lang.Object[]) -> a
    void entry(java.lang.String,double[]) -> a
    void entry(java.lang.String,boolean[]) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDictionary) -> a
org.freehep.graphicsio.pdf.PDFDocInfo -> org.freehep.graphicsio.c.g:
    void setTitle(java.lang.String) -> a
    void setAuthor(java.lang.String) -> b
    void setSubject(java.lang.String) -> c
    void setKeywords(java.lang.String) -> d
    void setCreator(java.lang.String) -> e
    void setProducer(java.lang.String) -> f
    void setCreationDate(java.util.Calendar) -> a
    void setModificationDate(java.util.Calendar) -> b
    void setTrapped(java.lang.String) -> g
org.freehep.graphicsio.pdf.PDFFontEmbedder -> org.freehep.graphicsio.c.h:
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFDictionary fontDict -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    java.lang.String getSubtype() -> b
    void addAdditionalEntries(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    void addAdditionalInitDicts() -> f
    java.lang.String getReference() -> c
    void openIncludeFont() -> d
    void closeEmbedFont() -> c
    void writeWidths(double[]) -> a
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    java.lang.String createCharacterReference(java.lang.String) -> a
org.freehep.graphicsio.pdf.PDFFontEmbedderType1 -> org.freehep.graphicsio.c.i:
    java.io.ByteArrayOutputStream byteBuffer -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFStream fontFile -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    org.freehep.graphicsio.pdf.PDFFontEmbedderType1 create(java.awt.font.FontRenderContext,org.freehep.graphicsio.pdf.PDFWriter,java.lang.String,org.freehep.graphicsio.pdf.PDFRedundanceTracker) -> a
    java.lang.String getReference() -> b
    void openIncludeFont() -> d
    void writeWidths(double[]) -> a
    void openGlyphs() -> a
    void closeEmbedFont() -> c
org.freehep.graphicsio.pdf.PDFFontEmbedderType3 -> org.freehep.graphicsio.c.j:
    java.lang.String getSubtype() -> b
    void addAdditionalEntries(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    void addAdditionalInitDicts() -> f
    void writeGlyph(java.lang.String,java.awt.Shape,java.awt.font.GlyphMetrics) -> a
org.freehep.graphicsio.pdf.PDFFontIncluder -> org.freehep.graphicsio.c.k:
    java.lang.String[][] STANDARD_FONT -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.lang.String reference -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker redundanceTracker -> a
    void openIncludeFont() -> d
    void writeEncoding(org.freehep.graphics2d.font.CharTable) -> a
    boolean isStandardFont(java.awt.Font) -> a
    int getFontBaseIndex(java.awt.Font) -> a
    int getFontStyle(java.awt.Font) -> b
org.freehep.graphicsio.pdf.PDFFontTable -> org.freehep.graphicsio.c.l:
    int currentFontIndex -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker tracker -> a
    java.util.Properties replaceFonts -> a
    int addFontDictionary() -> a
    void embedAll(java.awt.font.FontRenderContext,boolean,java.lang.String) -> a
    org.freehep.graphics2d.font.CharTable getEncodingTable() -> a
    void firstRequest(org.freehep.graphicsio.font.FontTable$Entry,boolean,java.lang.String) -> a
    java.awt.Font substituteFont(java.awt.Font) -> a
    java.lang.String createFontReference(java.awt.Font) -> a
org.freehep.graphicsio.pdf.PDFGraphics2D -> org.freehep.graphicsio.c.m:
    java.lang.String rootKey -> w
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    java.lang.String PAGE_SIZE -> h
    java.lang.String PAGE_MARGINS -> i
    java.lang.String ORIENTATION -> j
    java.lang.String FIT_TO_PAGE -> k
    java.lang.String EMBED_FONTS -> l
    java.lang.String EMBED_FONTS_AS -> m
    java.lang.String THUMBNAILS -> n
    java.lang.String THUMBNAIL_SIZE -> o
    java.lang.String COMPRESS -> p
    java.lang.String VERSION -> q
    java.lang.String WRITE_IMAGES_AS -> r
    java.lang.String AUTHOR -> s
    java.lang.String TITLE -> t
    java.lang.String SUBJECT -> u
    java.lang.String KEYWORDS -> v
    org.freehep.util.UserProperties defaultProperties -> a
    java.lang.String[] COMPRESS_FILTERS -> a
    java.lang.String[] NO_FILTERS -> b
    java.io.OutputStream ros -> a
    org.freehep.graphicsio.pdf.PDFWriter os -> a
    org.freehep.graphicsio.pdf.PDFStream pageStream -> a
    org.freehep.graphicsio.pdf.PDFFontTable fontTable -> a
    org.freehep.graphicsio.pdf.PDFImageDelayQueue delayImageQueue -> a
    org.freehep.graphicsio.pdf.PDFPaintDelayQueue delayPaintQueue -> a
    int currentPage -> b
    boolean multiPage -> a
    org.freehep.graphics2d.TagString[] headerText -> a
    int headerUnderline -> c
    java.awt.Font headerFont -> a
    org.freehep.graphics2d.TagString[] footerText -> b
    int footerUnderline -> d
    java.awt.Font footerFont -> b
    java.util.List titles -> a
    int alphaIndex -> a
    java.util.Map extGStates -> a
    java.util.Properties getDefaultProperties() -> b
    void setDefaultProperties(java.util.Properties) -> b
    void init(java.io.OutputStream) -> a
    boolean isMultiPage() -> b
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    void processDelayed() -> k
    void openPage(java.awt.Dimension,java.lang.String,java.awt.Component) -> a
    void closePage() -> i
    void writeHeadline(java.awt.geom.AffineTransform) -> c
    void writeFootline(java.awt.geom.AffineTransform) -> d
    void writeLine(java.awt.geom.AffineTransform,java.awt.Font,org.freehep.graphics2d.TagString[],double,int,double,int) -> a
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> j
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeClip(java.awt.Shape) -> a
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    void showString(java.awt.Font,java.lang.String) -> a
    void showCharacterCodes(java.lang.String) -> a
    double getWidth() -> a
    double getHeight() -> b
org.freehep.graphicsio.pdf.PDFImageDelayQueue -> org.freehep.graphicsio.c.n:
    int currentNumber -> a
    java.util.Map imageMap -> a
    java.util.List imageList -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    org.freehep.graphicsio.pdf.PDFName delayImage(java.awt.image.RenderedImage,java.awt.Color,java.lang.String) -> a
    void processAll() -> a
    int addXObjects() -> a
    int access$0(org.freehep.graphicsio.pdf.PDFImageDelayQueue) -> a
    void access$1(org.freehep.graphicsio.pdf.PDFImageDelayQueue,int) -> a
org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry -> org.freehep.graphicsio.c.n$a:
    java.awt.image.RenderedImage image -> a
    java.lang.String name -> a
    java.lang.String maskName -> b
    java.awt.Color bkg -> a
    java.lang.String writeAs -> c
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFImageDelayQueue this$0 -> a
    java.lang.String access$1(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    void access$3(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry,boolean) -> a
    java.lang.String access$4(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> b
    java.lang.String access$5(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> c
    java.awt.image.RenderedImage access$6(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
    java.awt.Color access$7(org.freehep.graphicsio.pdf.PDFImageDelayQueue$Entry) -> a
org.freehep.graphicsio.pdf.PDFName -> org.freehep.graphicsio.c.o:
    java.lang.String name -> b
    java.lang.String toString() -> toString
org.freehep.graphicsio.pdf.PDFObject -> org.freehep.graphicsio.c.p:
    org.freehep.graphicsio.pdf.PDF pdf -> a
    org.freehep.graphicsio.pdf.PDFByteWriter out -> a
    java.lang.String open -> b
    boolean ok -> a
    void close() -> a
    void entry(int) -> a
    void entry(java.lang.Object[]) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary() -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String,java.lang.String[]) -> a
    org.freehep.graphicsio.pdf.PDFDocInfo openDocInfo(org.freehep.graphicsio.pdf.PDF) -> a
    org.freehep.graphicsio.pdf.PDFCatalog openCatalog(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFPageTree openPageTree(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFPage openPage(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFViewerPreferences openViewerPreferences(org.freehep.graphicsio.pdf.PDF) -> a
    org.freehep.graphicsio.pdf.PDFOutlineList openOutlineList(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFRef) -> a
    org.freehep.graphicsio.pdf.PDFOutline openOutline(org.freehep.graphicsio.pdf.PDF,org.freehep.graphicsio.pdf.PDFRef,java.lang.String,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFRef) -> a
org.freehep.graphicsio.pdf.PDFOutline -> org.freehep.graphicsio.c.q:
    void setDest(java.lang.Object[]) -> a
org.freehep.graphicsio.pdf.PDFOutlineList -> org.freehep.graphicsio.c.r:
org.freehep.graphicsio.pdf.PDFPage -> org.freehep.graphicsio.c.s:
    void setContents(java.lang.String) -> a
    void setThumb(java.lang.String) -> b
org.freehep.graphicsio.pdf.PDFPageBase -> org.freehep.graphicsio.c.t:
    void setResources(java.lang.String) -> c
    void setMediaBox(double,double,double,double) -> a
org.freehep.graphicsio.pdf.PDFPageTree -> org.freehep.graphicsio.c.u:
    java.util.Vector pages -> a
    void addPage(java.lang.String) -> a
    void close() -> a
org.freehep.graphicsio.pdf.PDFPaintDelayQueue -> org.freehep.graphicsio.c.v:
    int currentNumber -> a
    java.util.List paintList -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.awt.geom.AffineTransform pageMatrix -> a
    void setPageMatrix(java.awt.geom.AffineTransform) -> a
    org.freehep.graphicsio.pdf.PDFName delayPaint(java.awt.Paint,java.awt.geom.AffineTransform,java.lang.String) -> a
    void processAll() -> a
    int addPatterns() -> a
    void addGradientPaint(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    void addLinearFunction(java.lang.String,double[],double[],double[]) -> a
    void addTexturePaint(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> b
    void setMatrix(org.freehep.graphicsio.pdf.PDFDictionary,org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry,double,double) -> a
    int access$0() -> b
    void access$1(int) -> a
org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry -> org.freehep.graphicsio.c.v$a:
    java.awt.Paint paint -> a
    java.lang.String name -> a
    java.awt.geom.AffineTransform trafo -> a
    java.lang.String writeAs -> b
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFPaintDelayQueue this$0 -> a
    java.lang.String access$1(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    void access$3(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry,boolean) -> a
    java.awt.Paint access$4(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
    java.lang.String access$5(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> b
    java.awt.geom.AffineTransform access$6(org.freehep.graphicsio.pdf.PDFPaintDelayQueue$Entry) -> a
org.freehep.graphicsio.pdf.PDFPathConstructor -> org.freehep.graphicsio.c.w:
    org.freehep.graphicsio.pdf.PDFStream stream -> a
    void move(double,double) -> a
    void line(double,double) -> b
    void cubic(double,double,double,double,double,double) -> a
    void closePath(double,double) -> c
org.freehep.graphicsio.pdf.PDFRedundanceTracker -> org.freehep.graphicsio.c.x:
    int refCount -> a
    org.freehep.graphicsio.pdf.PDFWriter pdf -> a
    java.util.Map objects -> a
    java.util.Vector orderedObjects -> a
    org.freehep.graphicsio.pdf.PDFRef getReference(java.lang.Object,java.lang.Object,org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer) -> a
    org.freehep.graphicsio.pdf.PDFRef getReference(java.lang.Object,org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer) -> a
    void writeAll() -> a
    org.freehep.graphicsio.pdf.PDFWriter access$0(org.freehep.graphicsio.pdf.PDFRedundanceTracker) -> a
    int access$1() -> a
    void access$2(int) -> a
org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry -> org.freehep.graphicsio.c.x$a:
    java.lang.Object object -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer writer -> a
    boolean written -> a
    org.freehep.graphicsio.pdf.PDFRef reference -> a
    java.lang.Object groupID -> b
    org.freehep.graphicsio.pdf.PDFRedundanceTracker this$0 -> a
    org.freehep.graphicsio.pdf.PDFRef access$0(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    boolean access$2(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer access$3(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    java.lang.Object access$4(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry) -> a
    void access$5(org.freehep.graphicsio.pdf.PDFRedundanceTracker$Entry,boolean) -> a
org.freehep.graphicsio.pdf.PDFRedundanceTracker$Writer -> org.freehep.graphicsio.c.x$b:
    void writeObject(java.lang.Object,org.freehep.graphicsio.pdf.PDFRef,org.freehep.graphicsio.pdf.PDFWriter) -> a
org.freehep.graphicsio.pdf.PDFRef -> org.freehep.graphicsio.c.y:
    java.lang.String name -> b
    int objectNumber -> a
    int generationNumber -> b
    java.lang.String getName() -> a
    int getObjectNumber() -> a
    int getGenerationNumber() -> b
    java.lang.String toString() -> toString
org.freehep.graphicsio.pdf.PDFStream -> org.freehep.graphicsio.c.z:
    java.lang.String name -> b
    org.freehep.graphicsio.pdf.PDFObject object -> a
    boolean dictionaryOpen -> a
    java.io.OutputStream[] stream -> a
    org.freehep.util.io.CountedByteOutputStream byteCountStream -> a
    java.lang.String[] encode -> a
    int gStates -> a
    boolean textOpen -> b
    boolean fontWasSet -> c
    boolean compatibilityOpen -> d
    void startStream() -> m
    void startStream(java.lang.String[]) -> a
    void write(int) -> c
    void write(byte[]) -> a
    org.freehep.graphicsio.pdf.PDFName[] decodeFilters(java.lang.String[]) -> a
    java.io.OutputStream[] openFilters(java.io.OutputStream,java.lang.String[]) -> a
    void closeFilters(java.io.OutputStream[]) -> a
    void write(java.lang.String) -> d
    void close() -> a
    java.lang.String getName() -> a
    int getLength() -> a
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void save() -> b
    void restore() -> c
    void matrix(java.awt.geom.AffineTransform) -> a
    void matrix(double,double,double,double,double,double) -> a
    void width(double) -> a
    void cap(int) -> a
    void join(int) -> b
    void mitterLimit(double) -> b
    void dash(float[],double) -> a
    void state(org.freehep.graphicsio.pdf.PDFName) -> a
    void cubic(double,double,double,double,double,double) -> b
    void move(double,double) -> a
    void line(double,double) -> b
    void closePath() -> d
    void stroke() -> e
    void fill() -> f
    void fillEvenOdd() -> g
    void endPath() -> h
    void clip() -> i
    void clipEvenOdd() -> j
    void beginText() -> k
    void endText() -> l
    void font(org.freehep.graphicsio.pdf.PDFName,double) -> a
    void text(double,double) -> c
    void show(java.lang.String) -> c
    void glyph(double,double,double,double,double,double) -> c
    void colorSpace(org.freehep.graphicsio.pdf.PDFName) -> b
    void colorSpaceStroke(org.freehep.graphicsio.pdf.PDFName) -> c
    void colorSpace(double[],org.freehep.graphicsio.pdf.PDFName) -> a
    void colorSpaceStroke(double[],org.freehep.graphicsio.pdf.PDFName) -> b
    void colorSpace(double,double,double) -> a
    void colorSpaceStroke(double,double,double) -> b
    void image(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> a
    void imageMask(java.awt.image.RenderedImage,java.lang.String[]) -> a
    void inlineImage(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> b
    byte[] imageToBytes(java.awt.image.RenderedImage,java.awt.Color,java.lang.String[]) -> a
    void imageInfo(java.lang.String,int) -> b
    void imageInfo(java.lang.String,org.freehep.graphicsio.pdf.PDFName) -> b
    void imageInfo(java.lang.String,java.lang.Object[]) -> b
    boolean drawPath(java.awt.Shape) -> a
    void xObject(org.freehep.graphicsio.pdf.PDFName) -> d
org.freehep.graphicsio.pdf.PDFUtil -> org.freehep.graphicsio.c.A:
    geogebra.util.ScientificFormat scientific -> a
    java.lang.String escape(java.lang.String) -> a
    java.lang.String date(java.util.Calendar) -> a
    java.lang.String fixedPrecision(double) -> a
org.freehep.graphicsio.pdf.PDFViewerPreferences -> org.freehep.graphicsio.c.B:
    void setFitWindow(boolean) -> a
    void setCenterWindow(boolean) -> b
org.freehep.graphicsio.pdf.PDFWriter -> org.freehep.graphicsio.c.C:
    java.lang.String open -> b
    java.lang.String catalogName -> c
    java.lang.String docInfoName -> d
    void close(java.lang.String,java.lang.String) -> b
    void object(java.lang.String,java.lang.Object[]) -> a
    void object(java.lang.String,int) -> a
    org.freehep.graphicsio.pdf.PDFObject openObject(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFObject) -> a
    org.freehep.graphicsio.pdf.PDFDictionary openDictionary(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDictionary) -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String) -> a
    org.freehep.graphicsio.pdf.PDFStream openStream(java.lang.String,java.lang.String[]) -> a
    void close(org.freehep.graphicsio.pdf.PDFStream) -> a
    void close() -> c
    org.freehep.graphicsio.pdf.PDFDocInfo openDocInfo(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFDocInfo) -> a
    org.freehep.graphicsio.pdf.PDFCatalog openCatalog(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFCatalog) -> a
    org.freehep.graphicsio.pdf.PDFPageTree openPageTree(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFPageTree) -> a
    org.freehep.graphicsio.pdf.PDFPage openPage(java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFPage) -> a
    org.freehep.graphicsio.pdf.PDFViewerPreferences openViewerPreferences(java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFViewerPreferences) -> a
    org.freehep.graphicsio.pdf.PDFOutlineList openOutlineList(java.lang.String,java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFOutlineList) -> a
    org.freehep.graphicsio.pdf.PDFOutline openOutline(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    void close(org.freehep.graphicsio.pdf.PDFOutline) -> a
org.freehep.graphicsio.raw.RawImageWriteParam -> org.freehep.graphicsio.raw.a:
    java.lang.String rootKey -> d
    java.lang.String BACKGROUND -> a
    java.lang.String CODE -> b
    java.lang.String PAD -> c
    java.awt.Color bkg -> a
    java.lang.String code -> e
    int pad -> a
    javax.imageio.ImageWriteParam getWriteParam(java.util.Properties) -> a
    java.awt.Color getBackground() -> a
    void setBackground(java.awt.Color) -> a
    java.lang.String getCode() -> a
    void setCode(java.lang.String) -> a
    int getPad() -> a
    void setPad(int) -> a
org.freehep.graphicsio.raw.RawImageWriter -> org.freehep.graphicsio.raw.b:
    void write(javax.imageio.metadata.IIOMetadata,javax.imageio.IIOImage,javax.imageio.ImageWriteParam) -> write
    javax.imageio.metadata.IIOMetadata convertStreamMetadata(javax.imageio.metadata.IIOMetadata,javax.imageio.ImageWriteParam) -> convertStreamMetadata
    javax.imageio.metadata.IIOMetadata convertImageMetadata(javax.imageio.metadata.IIOMetadata,javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam) -> convertImageMetadata
    javax.imageio.metadata.IIOMetadata getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam) -> getDefaultImageMetadata
    javax.imageio.metadata.IIOMetadata getDefaultStreamMetadata(javax.imageio.ImageWriteParam) -> getDefaultStreamMetadata
    javax.imageio.ImageWriteParam getDefaultWriteParam() -> getDefaultWriteParam
org.freehep.graphicsio.raw.RawImageWriterSpi -> org.freehep.graphicsio.raw.RawImageWriterSpi:
    java.lang.String getDescription(java.util.Locale) -> getDescription
    javax.imageio.ImageWriter createWriterInstance(java.lang.Object) -> createWriterInstance
    boolean canEncodeImage(javax.imageio.ImageTypeSpecifier) -> canEncodeImage
org.freehep.graphicsio.svg.SVGFontTable -> org.freehep.graphicsio.d.a:
    java.util.Hashtable glyphs -> a
    java.util.Properties replaceFonts -> a
    org.freehep.graphicsio.svg.SVGGlyph addGlyph(int,java.awt.Font) -> a
    org.freehep.graphicsio.svg.SVGGlyph createGlyph(int,java.awt.Font) -> b
    void addGlyphs(java.lang.String,java.awt.Font) -> a
    java.util.Hashtable getGlyphs(java.awt.Font) -> a
    java.lang.String toString() -> toString
    java.awt.Font untransform(java.awt.Font) -> a
    void normalize(java.util.Map) -> a
org.freehep.graphicsio.svg.SVGGlyph -> org.freehep.graphicsio.d.b:
    int FONT_SIZE -> a
    int UNITS_PER_EM -> b
    java.awt.Shape glyph -> a
    int unicode -> c
    java.awt.font.GlyphMetrics glyphMetrics -> a
    java.awt.geom.AffineTransform defaultTransform -> a
    java.lang.String toString() -> toString
    java.lang.String getPathString() -> a
    java.lang.String getHorizontalAdvanceXString() -> b
    java.lang.String getHorizontalAdvanceYString() -> c
org.freehep.graphicsio.svg.SVGGraphics2D -> org.freehep.graphicsio.d.c:
    java.lang.String rootKey -> r
    java.lang.String TRANSPARENT -> e
    java.lang.String BACKGROUND -> f
    java.lang.String BACKGROUND_COLOR -> g
    java.lang.String VERSION -> h
    java.lang.String COMPRESS -> i
    java.lang.String STYLABLE -> j
    java.lang.String IMAGE_SIZE -> k
    java.lang.String EXPORT_IMAGES -> l
    java.lang.String EXPORT_SUFFIX -> m
    java.lang.String WRITE_IMAGES_AS -> n
    java.lang.String FOR -> o
    java.lang.String TITLE -> p
    java.awt.BasicStroke defaultStroke -> a
    java.lang.String EMBED_FONTS -> q
    org.freehep.graphicsio.svg.SVGFontTable fontTable -> a
    org.freehep.util.UserProperties defaultProperties -> a
    java.lang.String filename -> s
    int bbx -> a
    int bby -> b
    int bbw -> c
    int bbh -> d
    java.io.OutputStream ros -> a
    java.io.PrintWriter os -> a
    java.util.Hashtable gradients -> a
    java.util.Hashtable textures -> b
    java.util.Stack closeTags -> a
    int imageNumber -> e
    org.freehep.util.Value clipNumber -> a
    int width -> f
    int height -> g
    geogebra.util.ScientificFormat scientific -> a
    java.util.Properties getDefaultProperties() -> b
    void setDefaultProperties(java.util.Properties) -> b
    void init(java.io.OutputStream) -> a
    void setBoundingBox() -> i
    void writeHeader() -> c
    void writeBackground() -> e
    void writeTrailer() -> f
    void closeStream() -> g
    java.awt.Graphics create() -> create
    void writeGraphicsSave() -> j
    void writeGraphicsRestore() -> h
    void draw(java.awt.Shape) -> draw
    void fill(java.awt.Shape) -> fill
    void writePathIterator(java.awt.geom.PathIterator,java.util.Properties) -> a
    void copyArea(int,int,int,int,int,int) -> copyArea
    void writeImage(java.awt.image.RenderedImage,java.awt.geom.AffineTransform,java.awt.Color) -> a
    void writeString(java.lang.String,double,double) -> b
    java.util.Properties getFontProperties(java.awt.Font) -> a
    void writeTransform(java.awt.geom.AffineTransform) -> a
    void writeSetTransform(java.awt.geom.AffineTransform) -> b
    void writeClip(java.awt.Shape) -> a
    void writeSetClip(java.awt.Shape) -> b
    void writeWidth(float) -> a
    void writeCap(int) -> a
    void writeJoin(int) -> b
    void writeMiterLimit(float) -> b
    void writeDash(float[],float) -> a
    java.util.Properties getStrokeProperties(java.awt.Stroke,boolean) -> a
    void setPaintMode() -> setPaintMode
    void setXORMode(java.awt.Color) -> setXORMode
    void writePaint(java.awt.Color) -> a
    void writePaint(java.awt.GradientPaint) -> a
    void writePaint(java.awt.TexturePaint) -> a
    void writePaint(java.awt.Paint) -> a
    void writeFont(java.awt.Font) -> a
    java.awt.GraphicsConfiguration getDeviceConfiguration() -> getDeviceConfiguration
    boolean hit(java.awt.Rectangle,java.awt.Shape,boolean) -> hit
    java.lang.String toString() -> toString
    java.lang.String getTransformedString(java.awt.geom.AffineTransform,java.lang.String) -> a
    java.lang.String getClippedString(java.lang.String) -> b
    float alphaColor(java.awt.Paint) -> a
    java.lang.String hexColor(java.awt.Paint) -> a
    java.lang.String hexColor(java.awt.Color) -> a
    java.lang.String hexColor(java.awt.GradientPaint) -> a
    java.lang.String hexColor(java.awt.TexturePaint) -> a
    java.lang.String getPathContent(java.awt.geom.PathIterator) -> a
    java.lang.String getPath(java.awt.geom.PathIterator) -> b
    java.lang.String style(java.util.Properties) -> a
    java.lang.String fixedPrecision(double) -> a
org.freehep.util.UserProperties -> org.freehep.b.a:
    java.util.Properties altDefaults -> a
    java.util.Enumeration propertyNames() -> propertyNames
    void setProperties(java.util.Properties) -> a
    java.lang.Object setProperty(java.lang.String,java.lang.String) -> setProperty
    java.lang.Object setProperty(java.lang.String,java.awt.Color) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Color) -> a
    java.lang.Object setProperty(java.lang.String,java.awt.Insets) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Insets) -> a
    java.lang.Object setProperty(java.lang.String,java.awt.Dimension) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,java.awt.Dimension) -> a
    java.lang.Object setProperty(java.lang.String,int) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,int) -> a
    java.lang.Object setProperty(java.lang.String,boolean) -> a
    java.lang.Object setProperty(java.util.Properties,java.lang.String,boolean) -> a
    java.lang.String getProperty(java.lang.String) -> getProperty
    java.lang.String getProperty(java.lang.String,java.lang.String) -> getProperty
    java.awt.Color getPropertyColor(java.lang.String) -> a
    java.awt.Color getPropertyColor(java.lang.String,java.awt.Color) -> a
    java.awt.Insets getPropertyInsets(java.lang.String) -> a
    java.awt.Insets getPropertyInsets(java.lang.String,java.awt.Insets) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String) -> a
    java.awt.Dimension getPropertyDimension(java.lang.String,java.awt.Dimension) -> a
    int getPropertyInt(java.lang.String,int) -> a
    float getPropertyFloat(java.lang.String) -> a
    float getPropertyFloat(java.lang.String,float) -> a
    boolean isProperty(java.lang.String) -> a
    boolean isProperty(java.lang.String,boolean) -> a
org.freehep.util.Value -> org.freehep.b.b:
    int intValue -> a
    short shortValue -> a
    long longValue -> a
    float floatValue -> a
    double doubleValue -> a
    boolean boolValue -> a
    byte byteValue -> a
    char charValue -> a
    java.lang.Object obj -> a
    java.lang.Class type -> k
    java.lang.Class TYPE_INTEGER -> a
    java.lang.Class TYPE_SHORT -> b
    java.lang.Class TYPE_LONG -> c
    java.lang.Class TYPE_FLOAT -> d
    java.lang.Class TYPE_DOUBLE -> e
    java.lang.Class TYPE_BOOLEAN -> f
    java.lang.Class TYPE_BYTE -> g
    java.lang.Class TYPE_CHAR -> h
    java.lang.Class TYPE_STRING -> i
    java.lang.Class TYPE_DATE -> j
    org.freehep.util.Value set(int) -> a
    int getInt() -> a
    java.lang.String getString() -> a
    java.lang.String toString() -> toString
org.freehep.util.images.ImageUtilities -> org.freehep.b.a.a:
    java.awt.image.RenderedImage createRenderedImage(java.awt.Image,java.awt.image.ImageObserver,java.awt.Color) -> a
    byte[] getBytes(java.awt.image.RenderedImage,java.awt.Color,java.lang.String,int) -> a
org.freehep.util.io.ASCII85OutputStream -> org.freehep.b.b.a:
    boolean end -> a
    int characters -> a
    int[] b -> a
    int bIndex -> b
    int[] c -> b
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeTuple() -> a
    void writeEOD() -> b
    void writeChar(int) -> a
    void writeNewLine() -> c
org.freehep.util.io.ASCIIHexOutputStream -> org.freehep.b.b.b:
    int characters -> a
    boolean end -> a
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeChar(int) -> a
    void writeNewLine() -> a
org.freehep.util.io.Action -> org.freehep.b.b.c:
    int code -> a
    java.lang.String name -> a
    int getCode() -> a
    java.lang.String getName() -> a
    java.lang.String toString() -> toString
org.freehep.util.io.Action$Unknown -> org.freehep.b.b.c$a:
    int[] data -> a
    java.lang.String toString() -> toString
org.freehep.util.io.ActionSet -> org.freehep.b.b.d:
    java.util.Map actions -> a
    org.freehep.util.io.Action defaultAction -> a
org.freehep.util.io.Base64OutputStream -> org.freehep.b.b.e:
    int MAX_LINE_LENGTH -> a
    int position -> b
    byte[] buffer -> a
    int lineLength -> c
    char[] intToBase64 -> a
    java.lang.String newline -> a
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void writeTuple() -> a
    void writeNewLine() -> b
org.freehep.util.io.BitInputStream -> org.freehep.b.b.f:
    int[] BIT_MASK -> a
    int[] FIELD_MASK -> b
    int bits -> a
    int validBits -> b
    void byteAlign() -> a
org.freehep.util.io.BitOutputStream -> org.freehep.b.b.g:
    int bits -> a
    int bitPos -> b
    void write(int) -> write
    void finish() -> finish
    void close() -> close
    void flushByte() -> a
    void byteAlign() -> b
org.freehep.util.io.ByteCountInputStream -> org.freehep.b.b.h:
    int index -> a
    int[] size -> c
    long len -> a
    int read() -> read
    void pushBuffer(int) -> a
    byte[] popBuffer() -> a
org.freehep.util.io.ByteCountOutputStream -> org.freehep.b.b.i:
    int currentBuffer -> b
    java.util.List bufferList -> a
    void write(int) -> write
    void pushBuffer() -> c
    int popBuffer() -> c
    int getBufferLength() -> d
    void append() -> d
    void close() -> close
org.freehep.util.io.ByteCountOutputStream$Buffer -> org.freehep.b.b.i$a:
    byte[] buffer -> a
    int len -> a
    void add(byte) -> a
    void add(org.freehep.util.io.ByteCountOutputStream$Buffer) -> a
    int getLength() -> a
    byte[] getBytes() -> a
org.freehep.util.io.ByteOrderInputStream -> org.freehep.b.b.j:
    boolean little -> a
    void readFully(byte[]) -> readFully
    void readFully(byte[],int,int) -> readFully
    int skipBytes(int) -> skipBytes
    boolean readBoolean() -> readBoolean
    char readChar() -> readChar
    byte readByte() -> readByte
    byte[] readByte(int) -> b
    int readUnsignedByte() -> readUnsignedByte
    int[] readUnsignedByte(int) -> b
    short readShort() -> readShort
    int readUnsignedShort() -> readUnsignedShort
    int readInt() -> readInt
    long readUnsignedInt() -> a
    long readLong() -> readLong
    float readFloat() -> readFloat
    double readDouble() -> readDouble
    java.lang.String readLine() -> readLine
    java.lang.String readUTF() -> readUTF
org.freehep.util.io.ByteOrderOutputStream -> org.freehep.b.b.k:
    boolean little -> a
    int written -> a
    void write(int) -> write
    void writeBoolean(boolean) -> writeBoolean
    void writeChar(int) -> writeChar
    void writeByte(int) -> writeByte
    void writeByte(byte[]) -> b
    void writeUnsignedByte(int) -> g
    void writeUnsignedByte(int[]) -> b
    void writeShort(int) -> writeShort
    void writeUnsignedShort(int) -> h
    void writeInt(int) -> writeInt
    void writeUnsignedInt(long) -> a
    void writeLong(long) -> writeLong
    void writeFloat(float) -> writeFloat
    void writeDouble(double) -> writeDouble
    void writeBytes(java.lang.String) -> writeBytes
    void writeChars(java.lang.String) -> writeChars
    void writeUTF(java.lang.String) -> writeUTF
    void writeUTF(java.lang.String,java.io.DataOutput) -> a
org.freehep.util.io.CompressableOutputStream -> org.freehep.b.b.l:
    boolean compress -> a
    java.util.zip.DeflaterOutputStream dos -> a
    void write(int) -> write
    void write(byte[],int,int) -> write
    void finish() -> finish
    void close() -> close
org.freehep.util.io.CountedByteOutputStream -> org.freehep.b.b.m:
    int count -> a
    void write(int) -> write
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    int getCount() -> a
org.freehep.util.io.DecompressableInputStream -> org.freehep.b.b.n:
    boolean decompress -> a
    java.util.zip.InflaterInputStream iis -> a
    java.io.InputStream in -> a
    int read() -> read
    long skip(long) -> skip
org.freehep.util.io.EEXECEncryption -> org.freehep.b.b.o:
    int n -> a
    int c1 -> b
    int c2 -> c
    int r -> d
    java.io.OutputStream out -> a
    boolean first -> a
    int encrypt(int) -> a
    void write(int) -> write
    void flush() -> flush
    void close() -> close
org.freehep.util.io.FinishableOutputStream -> org.freehep.b.b.p:
    void finish() -> finish
org.freehep.util.io.FlateOutputStream -> org.freehep.b.b.q:
    void finish() -> finish
org.freehep.util.io.IncompleteTagException -> org.freehep.b.b.r:
    org.freehep.util.io.Tag tag -> a
    byte[] rest -> a
org.freehep.util.io.NoCloseOutputStream -> org.freehep.b.b.s:
    void close() -> close
org.freehep.util.io.Tag -> org.freehep.b.b.t:
    int tagID -> a
    java.lang.String name -> a
    int version -> b
    int getTag() -> b
    java.lang.String getName() -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
org.freehep.util.io.TagHeader -> org.freehep.b.b.u:
    int tagID -> a
    long length -> a
    int getTag() -> b
    long getLength() -> a
org.freehep.util.io.TagSet -> org.freehep.b.b.v:
    java.util.Map tags -> a
    org.freehep.util.io.Tag defaultTag -> a
    void addTag(org.freehep.util.io.Tag) -> a
    org.freehep.util.io.Tag get(int) -> a
    boolean exists(int) -> a
org.freehep.util.io.TaggedInputStream -> org.freehep.b.b.w:
    org.freehep.util.io.TagSet tagSet -> a
    org.freehep.util.io.ActionSet actionSet -> a
    org.freehep.util.io.TagHeader tagHeader -> a
    org.freehep.util.io.TagHeader readTagHeader() -> a
    org.freehep.util.io.Tag readTag() -> a
    org.freehep.util.io.TagHeader getTagHeader() -> b
org.freehep.util.io.TaggedOutputStream -> org.freehep.b.b.x:
    org.freehep.util.io.TagSet tagSet -> a
    org.freehep.util.io.ActionSet actionSet -> a
    void writeTagHeader(org.freehep.util.io.TagHeader) -> a
    int getTagAlignment() -> a
    void writeTag(org.freehep.util.io.Tag) -> a
    org.freehep.util.io.TagHeader createTagHeader(org.freehep.util.io.Tag,long) -> a
org.freehep.util.io.UndefinedTag -> org.freehep.b.b.y:
    int[] bytes -> a
    org.freehep.util.io.Tag read(int,org.freehep.util.io.TaggedInputStream,int) -> a
    void write(int,org.freehep.util.io.TaggedOutputStream) -> a
    java.lang.String toString() -> toString
org.freehep.util.io.UndefinedTagException -> org.freehep.b.b.z:
org.freehep.util.io.WriterOutputStream -> org.freehep.b.b.A:
    java.io.Writer writer -> a
    void write(int) -> write
    void write(byte[]) -> write
    void write(byte[],int,int) -> write
    void close() -> close
    void flush() -> flush
org.freehep.xml.util.XMLWriter -> org.freehep.c.a.a:
    java.lang.String normalizeText(java.lang.String) -> a
org.jfugue.ChannelPressure -> org.b.a:
    byte pressure -> a
    void setPressure(byte) -> a
    byte getPressure() -> a
org.jfugue.Controller -> org.b.b:
    byte index -> a
    byte value -> b
    byte getIndex() -> a
    byte getValue() -> b
org.jfugue.Instrument -> org.b.c:
    byte instrument -> a
    java.lang.String[] INSTRUMENT_NAME -> a
    void setInstrument(byte) -> a
    byte getInstrument() -> a
org.jfugue.JFugueDefinitions -> org.b.d:
    void populateDictionary(java.util.Map) -> a
org.jfugue.JFugueElement -> org.b.e:
org.jfugue.JFugueException -> org.b.f:
org.jfugue.KeySignature -> org.b.g:
    byte keySig -> a
    byte scale -> b
    java.lang.String[] majorSigs -> a
    java.lang.String[] minorSigs -> b
    void setKeySig(byte) -> a
    void setScale(byte) -> b
    byte getKeySig() -> a
    byte getScale() -> b
org.jfugue.Layer -> org.b.h:
    byte layer -> a
    void setLayer(byte) -> a
    byte getLayer() -> a
org.jfugue.Measure -> org.b.i:
org.jfugue.MidiEventManager -> org.b.j:
    int CHANNELS -> a
    int LAYERS -> b
    byte currentTrack -> a
    byte[] currentLayer -> a
    long[][] time -> a
    javax.sound.midi.Sequence sequence -> a
    javax.sound.midi.Track[] track -> a
    void setCurrentTrack(byte) -> a
    void setCurrentLayer(byte) -> b
    void advanceTrackTimer(long) -> a
    void setTrackTimer(long) -> b
    long getTrackTimer() -> a
    void addMetaMessage(int,byte[]) -> a
    void addEvent(int,int) -> a
    void addEvent(int,int,int) -> a
    void addNoteEvent(int,int,int,long,boolean,boolean) -> a
    javax.sound.midi.Sequence getSequence() -> a
org.jfugue.MidiRenderer -> org.b.k:
    org.jfugue.MidiEventManager eventManager -> a
    long initialNoteTime -> a
    float sequenceTiming -> a
    int resolution -> a
    void reset(float,int) -> a
    void reset() -> a
    javax.sound.midi.Sequence getSequence() -> a
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void timeEvent(org.jfugue.Time) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.MusicStringParser -> org.b.l:
    java.util.Map dictionaryMap -> a
    byte keySig -> a
    void parse(org.jfugue.Pattern) -> a
    void parseToken(java.lang.String) -> a
    void parseVoiceElement(java.lang.String) -> b
    void parseTempoElement(java.lang.String) -> c
    void parseInstrumentElement(java.lang.String) -> d
    void parseLayerElement(java.lang.String) -> e
    void parseTimeElement(java.lang.String) -> f
    void parseKeySignatureElement(java.lang.String) -> g
    void parseMeasureElement(java.lang.String) -> h
    void parseControllerElement(java.lang.String) -> i
    void parseChannelPressureElement(java.lang.String) -> j
    void parsePolyPressureElement(java.lang.String) -> k
    void parsePitchBendElement(java.lang.String) -> l
    void parseDictionaryElement(java.lang.String) -> m
    void parseNoteElement(java.lang.String) -> n
    void decideSequentialOrParallel(org.jfugue.MusicStringParser$NoteContext) -> a
    int parseNoteRoot(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> a
    int parseNumericNote(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> b
    int parseRest(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> c
    int parseLetterNote(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> d
    int parseNoteOctave(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> e
    int parseNoteChord(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> f
    void computeNoteValue(org.jfugue.MusicStringParser$NoteContext) -> b
    int parseNoteChordInversion(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> g
    int parseNoteDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> h
    int parseLetterDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> i
    int parseNumericDuration(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> j
    int parseTuplet(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> k
    int parseNoteVelocity(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> l
    java.lang.String parseNoteConnector(java.lang.String,int,int,org.jfugue.MusicStringParser$NoteContext) -> a
    void fireNoteEvents(org.jfugue.MusicStringParser$NoteContext) -> c
    java.lang.String dictionaryLookup(java.lang.String) -> a
    byte getByteFromDictionary(java.lang.String) -> a
    long getLongFromDictionary(java.lang.String) -> a
    int getIntFromDictionary(java.lang.String) -> a
    double getDoubleFromDictionary(java.lang.String) -> a
org.jfugue.MusicStringParser$NoteContext -> org.b.l$a:
    boolean isRest -> a
    boolean isNumericNote -> b
    boolean isChord -> c
    boolean isFirstNote -> d
    boolean isSequentialNote -> e
    boolean isParallelNote -> f
    boolean isNatural -> g
    boolean existAnotherNote -> h
    boolean anotherNoteIsSequential -> i
    boolean anotherNoteIsParallel -> j
    boolean isStartOfTie -> k
    boolean isEndOfTie -> l
    byte[] halfsteps -> a
    byte numHalfsteps -> a
    byte noteNumber -> b
    int octaveNumber -> a
    double decimalDuration -> a
    long duration -> a
    byte attackVelocity -> c
    byte decayVelocity -> d
    org.jfugue.MusicStringParser this$0 -> a
org.jfugue.Note -> org.b.m:
    byte value -> a
    long duration -> a
    double decimalDuration -> a
    boolean isStartOfTie -> a
    boolean isEndOfTie -> b
    byte attackVelocity -> b
    byte decayVelocity -> c
    boolean rest -> c
    byte type -> d
    boolean accompanyingNotes -> d
    java.lang.String[] NOTES -> a
    void setRest(boolean) -> a
    boolean isRest() -> a
    void setValue(byte) -> a
    byte getValue() -> a
    void setDuration(long) -> a
    long getDuration() -> a
    void setDecimalDuration(double) -> a
    void setStartOfTie(boolean) -> b
    boolean isStartOfTie() -> b
    void setEndOfTie(boolean) -> c
    boolean isEndOfTie() -> c
    void setAttackVelocity(byte) -> b
    byte getAttackVelocity() -> b
    void setDecayVelocity(byte) -> c
    byte getDecayVelocity() -> c
    void setHasAccompanyingNotes(boolean) -> d
    void setType(byte) -> d
org.jfugue.Parser -> org.b.n:
    int tracing -> a
    javax.swing.event.EventListenerList progressListenerList -> a
    javax.swing.event.EventListenerList listenerList -> b
    int getTracing() -> a
    void trace(java.lang.Object[]) -> a
    void fireProgressReported(java.lang.String,long,long) -> a
    void addParserListener(org.jfugue.ParserListener) -> a
    void fireVoiceEvent(org.jfugue.Voice) -> a
    void fireTempoEvent(org.jfugue.Tempo) -> a
    void fireInstrumentEvent(org.jfugue.Instrument) -> a
    void fireLayerEvent(org.jfugue.Layer) -> a
    void fireTimeEvent(org.jfugue.Time) -> a
    void fireKeySignatureEvent(org.jfugue.KeySignature) -> a
    void fireMeasureEvent(org.jfugue.Measure) -> a
    void fireControllerEvent(org.jfugue.Controller) -> a
    void fireChannelPressureEvent(org.jfugue.ChannelPressure) -> a
    void firePolyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void firePitchBendEvent(org.jfugue.PitchBend) -> a
    void fireNoteEvent(org.jfugue.Note) -> a
    void fireSequentialNoteEvent(org.jfugue.Note) -> b
    void fireParallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserListener -> org.b.o:
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void timeEvent(org.jfugue.Time) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserListenerAdapter -> org.b.p:
    void voiceEvent(org.jfugue.Voice) -> a
    void tempoEvent(org.jfugue.Tempo) -> a
    void instrumentEvent(org.jfugue.Instrument) -> a
    void layerEvent(org.jfugue.Layer) -> a
    void measureEvent(org.jfugue.Measure) -> a
    void timeEvent(org.jfugue.Time) -> a
    void keySignatureEvent(org.jfugue.KeySignature) -> a
    void controllerEvent(org.jfugue.Controller) -> a
    void channelPressureEvent(org.jfugue.ChannelPressure) -> a
    void polyphonicPressureEvent(org.jfugue.PolyphonicPressure) -> a
    void pitchBendEvent(org.jfugue.PitchBend) -> a
    void noteEvent(org.jfugue.Note) -> a
    void sequentialNoteEvent(org.jfugue.Note) -> b
    void parallelNoteEvent(org.jfugue.Note) -> c
org.jfugue.ParserProgressListener -> org.b.q:
    void progressReported(java.lang.String,long,long) -> a
org.jfugue.Pattern -> org.b.r:
    java.lang.StringBuilder musicString -> a
    java.util.Map properties -> a
    javax.swing.event.EventListenerList listenerList -> a
    void setMusicString(java.lang.String) -> a
    java.lang.String getMusicString() -> a
    java.lang.String[] getTokens() -> a
    java.lang.String toString() -> toString
org.jfugue.PitchBend -> org.b.s:
    byte lsb -> a
    byte msb -> b
    void setPitchBend(byte,byte) -> a
    byte[] getBend() -> a
org.jfugue.Player -> org.b.t:
    javax.sound.midi.Sequencer sequencer -> a
    org.jfugue.MusicStringParser parser -> a
    org.jfugue.MidiRenderer renderer -> a
    float sequenceTiming -> a
    int resolution -> a
    boolean paused -> a
    boolean started -> b
    boolean finished -> c
    void initParser() -> b
    void initSequencer() -> c
    void openSequencer() -> d
    void play(org.jfugue.Pattern) -> a
    void play(javax.sound.midi.Sequence) -> a
    void close() -> a
    void setStarted(boolean) -> a
    void setFinished(boolean) -> b
    boolean isPlaying() -> a
    boolean isPaused() -> b
    javax.sound.midi.Sequencer getSequencer() -> a
    void setSequencer(javax.sound.midi.Sequencer) -> a
    javax.sound.midi.Sequence getSequence(org.jfugue.Pattern) -> a
org.jfugue.Player$1 -> org.b.u:
    org.jfugue.Player this$0 -> a
    void meta(javax.sound.midi.MetaMessage) -> meta
org.jfugue.PolyphonicPressure -> org.b.v:
    byte key -> a
    byte pressure -> b
    void setKey(byte) -> a
    void setPressure(byte) -> b
    byte getKey() -> a
    byte getPressure() -> b
org.jfugue.Tempo -> org.b.w:
    int tempo -> a
    void setTempo(int) -> a
    int getTempo() -> a
org.jfugue.Time -> org.b.x:
    long time -> a
    void setTime(long) -> a
    long getTime() -> a
org.jfugue.TimeFactor -> org.b.y:
    double DEFAULT_BPM -> a
    int QUARTER_DURATIONS_IN_WHOLE -> a
    byte[] convertToThreeTempoBytes(int) -> a
    double convertBPMToMicrosecondsPerBeat(int) -> a
org.jfugue.Voice -> org.b.z:
    byte voice -> a
    void setVoice(byte) -> a
    byte getVoice() -> a
org.mathpiper.mpreduce.Environment -> org.c.a.a:
    org.mathpiper.mpreduce.symbols.Symbol nil -> a
    org.mathpiper.mpreduce.symbols.Symbol lispTrue -> b
    org.mathpiper.mpreduce.LispObject[] lit -> a
    java.math.BigInteger bigModulus -> a
    int modulus -> a
    int printprec -> b
    boolean descendSymbols -> a
    boolean specialNil -> b
    org.mathpiper.mpreduce.functions.builtin.Fns1 fns1 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns2 fns2 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns3 fns3 -> a
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions mpreduceFunctions -> a
    org.mathpiper.mpreduce.special.Specfn specfn -> a
org.mathpiper.mpreduce.FlushOutputThread -> org.c.a.b:
    void run() -> run
org.mathpiper.mpreduce.Interpreter2 -> org.c.a.c:
    org.mathpiper.mpreduce.Jlisp jlisp -> a
    org.mathpiper.mpreduce.Interpreter2 JlispCASInstance -> a
    java.lang.String startMessage -> a
    java.lang.Thread reduceThread -> a
    java.lang.String sendString -> b
    java.lang.StringBuffer inputBuffer -> a
    java.lang.Object inputLock -> a
    java.lang.Object outputLock -> b
    java.io.Reader in -> a
    java.io.PrintWriter out -> a
    java.lang.String getStartMessage() -> a
    void initialize() -> a
    java.lang.String evaluate(java.lang.String) -> a
    java.lang.String evaluate(java.lang.String,long) -> a
    void interruptEvaluation() -> b
    void access$0(org.mathpiper.mpreduce.Interpreter2,java.lang.String) -> a
    java.lang.String access$1(org.mathpiper.mpreduce.Interpreter2) -> a
    java.lang.Object access$2(org.mathpiper.mpreduce.Interpreter2) -> a
    java.lang.Object access$3(org.mathpiper.mpreduce.Interpreter2) -> b
    java.lang.StringBuffer access$4(org.mathpiper.mpreduce.Interpreter2) -> a
org.mathpiper.mpreduce.Interpreter2$1 -> org.c.a.d:
    org.mathpiper.mpreduce.Interpreter2 this$0 -> a
    java.lang.String[] val$args -> a
    void run() -> run
org.mathpiper.mpreduce.Interpreter2$InterpreterReader -> org.c.a.c$a:
    org.mathpiper.mpreduce.Interpreter2 interpreter -> a
    int pos -> a
    java.lang.String tmp -> a
    org.mathpiper.mpreduce.Interpreter2 this$0 -> b
    void close() -> close
    boolean markSupported() -> markSupported
    int read() -> read
    int read(char[]) -> read
    int read(char[],int,int) -> read
org.mathpiper.mpreduce.Interpreter2$InterpreterWriter -> org.c.a.c$b:
    org.mathpiper.mpreduce.Interpreter2 this$0 -> a
    void close() -> close
    void flush() -> flush
org.mathpiper.mpreduce.Jlisp -> org.c.a.e:
    java.lang.String version -> d
    org.mathpiper.mpreduce.io.streams.LispStream lispIO -> a
    org.mathpiper.mpreduce.io.streams.LispStream lispErr -> b
    boolean interactivep -> c
    boolean debugFlag -> d
    boolean headline -> e
    boolean backtrace -> f
    org.mathpiper.mpreduce.LispObject errorCode -> a
    int verbosFlag -> c
    boolean trapExceptions -> g
    java.io.Writer transcript -> a
    boolean interruptEvaluation -> h
    org.mathpiper.mpreduce.packagedatastore.PDS[] images -> a
    int outputImagePos -> d
    int imageCount -> e
    java.lang.String[] imageFile -> a
    java.io.Reader in -> a
    java.io.PrintWriter out -> a
    boolean standAlone -> i
    java.util.Vector openOutputFiles -> a
    boolean restarting -> j
    java.lang.String restartModule -> a
    java.lang.String restartFn -> b
    java.lang.String restartArg -> c
    boolean finishingUp -> k
    java.io.OutputStream odump -> a
    java.io.InputStream idump -> a
    java.util.HashMap builtinFunctions -> a
    java.util.HashMap builtinSpecials -> b
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void println() -> a
    void errprint(java.lang.String) -> c
    void errprintln(java.lang.String) -> d
    void errprintln() -> b
    void traceprint(java.lang.String) -> e
    void traceprintln(java.lang.String) -> f
    void traceprintln() -> c
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String,org.mathpiper.mpreduce.LispObject) -> a
    void startup(java.lang.String[],java.io.Reader,java.io.PrintWriter,boolean) -> a
    void startup1(java.lang.String[]) -> a
    void standardStreams() -> d
    void preserve(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    void initfns(java.lang.Object[][]) -> a
    void initSymbols() -> e
    void readEvalPrintLoop(boolean) -> a
    void checkExit(java.lang.String) -> g
org.mathpiper.mpreduce.LispEqualObject -> org.c.a.f:
    org.mathpiper.mpreduce.LispObject value -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.mathpiper.mpreduce.LispObject -> org.c.a.g:
    boolean atom -> a
    org.mathpiper.mpreduce.LispObject car -> a
    org.mathpiper.mpreduce.LispObject cdr -> b
    org.mathpiper.mpreduce.io.streams.LispStream currentOutput -> a
    int currentFlags -> a
    void print() -> a
    void print(int) -> a
    void iprint() -> b
    void blankprint() -> c
    void errPrint() -> d
    void tracePrint() -> e
    void scan() -> f
    void dump() -> g
    void putSharedRef(java.lang.Object) -> a
    void putPrefix2(int,int,int) -> a
    void putPrefix(int,int) -> a
    boolean lispequals(java.lang.Object) -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    org.mathpiper.mpreduce.LispObject copy() -> b
    int lisphashCode() -> a
    double doubleValue() -> a
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject modMinus() -> y
    org.mathpiper.mpreduce.LispObject modRecip() -> z
    org.mathpiper.mpreduce.LispObject safeModRecip() -> A
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    org.mathpiper.mpreduce.LispObject modAdd(org.mathpiper.mpreduce.LispObject) -> p
    org.mathpiper.mpreduce.LispObject modSubtract(org.mathpiper.mpreduce.LispObject) -> q
    org.mathpiper.mpreduce.LispObject modMultiply(org.mathpiper.mpreduce.LispObject) -> r
    org.mathpiper.mpreduce.LispObject modDivide(org.mathpiper.mpreduce.LispObject) -> s
    org.mathpiper.mpreduce.LispObject modExpt(int) -> d
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    org.mathpiper.mpreduce.LispObject modAddSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> p
    org.mathpiper.mpreduce.LispObject modSubtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> q
    org.mathpiper.mpreduce.LispObject modMultiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> r
    org.mathpiper.mpreduce.LispObject modDivideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> s
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    java.lang.String toString() -> toString
org.mathpiper.mpreduce.LispReader -> org.c.a.h:
    int istacklimit -> a
    int[] istack -> a
    int sharedIndex -> b
    java.util.Stack stack -> a
    int sharedSize -> c
    org.mathpiper.mpreduce.LispObject[] shared -> a
    int oblistSize -> d
    int oblistCount -> e
    org.mathpiper.mpreduce.symbols.Symbol[] oblist -> a
    org.mathpiper.mpreduce.datatypes.LispVector obvector -> a
    org.mathpiper.mpreduce.symbols.Symbol[] chars -> b
    org.mathpiper.mpreduce.LispObject[] spine -> b
    int inputType -> f
    java.util.HashSet objects -> a
    java.util.HashMap repeatedObjects -> a
    org.mathpiper.mpreduce.io.streams.LispStream readIn -> a
    org.mathpiper.mpreduce.LispObject readObject() -> a
    org.mathpiper.mpreduce.LispObject read() -> b
    org.mathpiper.mpreduce.LispObject readTail() -> c
    org.mathpiper.mpreduce.LispObject expandBackquote(org.mathpiper.mpreduce.LispObject) -> a
    void preRestore() -> a
    void postRestore() -> b
    void restore(java.io.InputStream) -> a
    boolean isPrime(int) -> a
    void reHashOblist() -> c
    void scanObject(org.mathpiper.mpreduce.LispObject) -> a
    void writeObject(org.mathpiper.mpreduce.LispObject) -> b
    void preserve(java.io.OutputStream) -> a
    void dumpTree(org.mathpiper.mpreduce.LispObject,java.io.OutputStream) -> a
org.mathpiper.mpreduce.Lit -> org.c.a.i:
    java.lang.String[] names -> a
org.mathpiper.mpreduce.Spid -> org.c.a.j:
    int tag -> b
    int data -> c
    org.mathpiper.mpreduce.Spid fbind -> a
    org.mathpiper.mpreduce.Spid noarg -> b
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.Cons -> org.c.a.a.a:
    int consCount -> b
    int consCountDown -> c
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject copy() -> b
    boolean lispequals(java.lang.Object) -> a
    int lisphashCode() -> a
    int lisphashCode(org.mathpiper.mpreduce.LispObject,int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispEqualHash -> org.c.a.a.b:
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object remove(java.lang.Object) -> remove
org.mathpiper.mpreduce.datatypes.LispHash -> org.c.a.a.c:
    java.util.HashMap hash -> a
    int flavour -> b
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispString -> org.c.a.a.d:
    int stringCount -> b
    java.lang.String string -> a
    java.lang.StringBuffer sb -> a
    void iprint() -> b
    java.lang.String escapedPrint() -> a
    void blankprint() -> c
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.datatypes.LispVector -> org.c.a.a.e:
    org.mathpiper.mpreduce.LispObject[] vec -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    boolean lispequals(java.lang.Object) -> a
    int lisphashCode() -> a
    int lisphashCode(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.exceptions.EOFException -> org.c.a.b.a:
org.mathpiper.mpreduce.exceptions.LispException -> org.c.a.b.b:
    org.mathpiper.mpreduce.LispObject details -> a
    java.lang.String message -> a
org.mathpiper.mpreduce.exceptions.ProgEvent -> org.c.a.b.c:
    org.mathpiper.mpreduce.LispObject details -> b
    org.mathpiper.mpreduce.LispObject extras -> c
    java.lang.String message -> b
    int type -> a
org.mathpiper.mpreduce.exceptions.ResourceException -> org.c.a.b.d:
    int time_base -> a
    int space_base -> b
    int io_base -> c
    int errors_base -> d
    int time_now -> e
    int space_now -> f
    int io_now -> g
    int errors_now -> h
    int time_limit -> i
    int space_limit -> j
    int io_limit -> k
    int errors_limit -> l
org.mathpiper.mpreduce.functions.builtin.BuiltinFunction -> org.c.a.c.a.a:
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.builtin.Fns -> org.c.a.c.a.b:
    java.lang.String prompt -> a
    org.mathpiper.mpreduce.LispObject[] args -> a
    org.mathpiper.mpreduce.LispObject put(org.mathpiper.mpreduce.symbols.Symbol,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    void fluid(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject get(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject remprop(org.mathpiper.mpreduce.symbols.Symbol,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject reversip(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject lessp(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject apply0(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject apply1(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject apply2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject apply3(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject applyn(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject applyInner(org.mathpiper.mpreduce.LispObject,int) -> a
    java.lang.String explodeToString(org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1 -> org.c.a.c.a.c:
    java.lang.Object[][] builtins -> a
    org.mathpiper.mpreduce.LispObject lispZero -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AconsFn -> org.c.a.c.a.c$a:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AppendFn -> org.c.a.c.a.c$b:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply0Fn -> org.c.a.c.a.c$c:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply1Fn -> org.c.a.c.a.c$d:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply2Fn -> org.c.a.c.a.c$e:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Apply3Fn -> org.c.a.c.a.c$f:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ApplyFn -> org.c.a.c.a.c$g:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject applySub(org.mathpiper.mpreduce.LispObject,int,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AssocFn -> org.c.a.c.a.c$h:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AssocStarStarFn -> org.c.a.c.a.c$i:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$AtomFn -> org.c.a.c.a.c$j:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$AtsocFn -> org.c.a.c.a.c$k:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$BatchpFn -> org.c.a.c.a.c$l:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_close_inputFn -> org.c.a.c.a.c$m:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_close_outputFn -> org.c.a.c.a.c$n:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_open_inputFn -> org.c.a.c.a.c$o:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_open_outputFn -> org.c.a.c.a.c$p:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin1Fn -> org.c.a.c.a.c$q:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin2Fn -> org.c.a.c.a.c$r:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prin3Fn -> org.c.a.c.a.c$s:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prinbyteFn -> org.c.a.c.a.c$t:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_princFn -> org.c.a.c.a.c$u:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_prinfloatFn -> org.c.a.c.a.c$v:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read2Fn -> org.c.a.c.a.c$w:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read3Fn -> org.c.a.c.a.c$x:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_read4Fn -> org.c.a.c.a.c$y:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_readbyteFn -> org.c.a.c.a.c$z:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_readfloatFn -> org.c.a.c.a.c$A:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_select_inputFn -> org.c.a.c.a.c$B:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Binary_terpriFn -> org.c.a.c.a.c$C:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BinopenFn -> org.c.a.c.a.c$D:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BoundpFn -> org.c.a.c.a.c$E:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_getvFn -> org.c.a.c.a.c$F:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_putvFn -> org.c.a.c.a.c$G:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Bps_upbvFn -> org.c.a.c.a.c$H:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$BpspFn -> org.c.a.c.a.c$I:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Break_loopFn -> org.c.a.c.a.c$J:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Byte_getvFn -> org.c.a.c.a.c$K:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$BytecountsFn -> org.c.a.c.a.c$L:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$C_outFn -> org.c.a.c.a.c$M:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaaarFn -> org.c.a.c.a.c$N:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaadrFn -> org.c.a.c.a.c$O:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaarFn -> org.c.a.c.a.c$P:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaadarFn -> org.c.a.c.a.c$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaaddrFn -> org.c.a.c.a.c$R:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaadrFn -> org.c.a.c.a.c$S:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaarFn -> org.c.a.c.a.c$T:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadaarFn -> org.c.a.c.a.c$U:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadadrFn -> org.c.a.c.a.c$V:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadarFn -> org.c.a.c.a.c$W:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaddarFn -> org.c.a.c.a.c$X:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadddrFn -> org.c.a.c.a.c$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CaddrFn -> org.c.a.c.a.c$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CadrFn -> org.c.a.c.a.c$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarFn -> org.c.a.c.a.c$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarStarFn -> org.c.a.c.a.c$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CarcheckFn -> org.c.a.c.a.c$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CatchFn -> org.c.a.c.a.c$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CbrtFn -> org.c.a.c.a.c$af:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaaarFn -> org.c.a.c.a.c$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaadrFn -> org.c.a.c.a.c$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaarFn -> org.c.a.c.a.c$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdadarFn -> org.c.a.c.a.c$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdaddrFn -> org.c.a.c.a.c$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdadrFn -> org.c.a.c.a.c$al:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdarFn -> org.c.a.c.a.c$am:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddaarFn -> org.c.a.c.a.c$an:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddadrFn -> org.c.a.c.a.c$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddarFn -> org.c.a.c.a.c$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdddarFn -> org.c.a.c.a.c$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddddrFn -> org.c.a.c.a.c$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdddrFn -> org.c.a.c.a.c$as:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CddrFn -> org.c.a.c.a.c$at:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CdrFn -> org.c.a.c.a.c$au:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_codeFn -> org.c.a.c.a.c$av:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_downcaseFn -> org.c.a.c.a.c$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Char_upcaseFn -> org.c.a.c.a.c$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ChdirFn -> org.c.a.c.a.c$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CheckpointFn -> org.c.a.c.a.c$az:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Cl_equalFn -> org.c.a.c.a.c$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CloseFn -> org.c.a.c.a.c$aB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Close_libraryFn -> org.c.a.c.a.c$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ClrhashFn -> org.c.a.c.a.c$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Code_charFn -> org.c.a.c.a.c$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CodepFn -> org.c.a.c.a.c$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CompressFn -> org.c.a.c.a.c$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ConsFn -> org.c.a.c.a.c$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ConspFn -> org.c.a.c.a.c$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ConstantpFn -> org.c.a.c.a.c$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ContainedFn -> org.c.a.c.a.c$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Convert_to_evectorFn -> org.c.a.c.a.c$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$CopyFn -> org.c.a.c.a.c$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Copy_moduleFn -> org.c.a.c.a.c$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Create_directoryFn -> org.c.a.c.a.c$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DateFn -> org.c.a.c.a.c$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Dated_nameFn -> org.c.a.c.a.c$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DatelesspFn -> org.c.a.c.a.c$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$DatestampFn -> org.c.a.c.a.c$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Define_in_moduleFn -> org.c.a.c.a.c$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DeflistFn -> org.c.a.c.a.c$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DeleqFn -> org.c.a.c.a.c$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$DeleteFn -> org.c.a.c.a.c$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Delete_fileFn -> org.c.a.c.a.c$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Delete_moduleFn -> org.c.a.c.a.c$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Demo_modeFn -> org.c.a.c.a.c$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$DigitFn -> org.c.a.c.a.c$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DirectorypFn -> org.c.a.c.a.c$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DmFn -> org.c.a.c.a.c$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DoFn -> org.c.a.c.a.c$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DoStarFn -> org.c.a.c.a.c$be:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DolistFn -> org.c.a.c.a.c$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$DotimesFn -> org.c.a.c.a.c$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Double_executeFn -> org.c.a.c.a.c$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EgetvFn -> org.c.a.c.a.c$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EjectFn -> org.c.a.c.a.c$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Enable_backtraceFn -> org.c.a.c.a.c$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Enable_errorsetFn -> org.c.a.c.a.c$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EndpFn -> org.c.a.c.a.c$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EputvFn -> org.c.a.c.a.c$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqFn -> org.c.a.c.a.c$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqcarFn -> org.c.a.c.a.c$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqlFn -> org.c.a.c.a.c$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqlhashFn -> org.c.a.c.a.c$br:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualFn -> org.c.a.c.a.c$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualcarFn -> org.c.a.c.a.c$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EqualpFn -> org.c.a.c.a.c$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Error1Fn -> org.c.a.c.a.c$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ErrorFn -> org.c.a.c.a.c$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ErrorsetFn -> org.c.a.c.a.c$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$EupbvFn -> org.c.a.c.a.c$by:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvalFn -> org.c.a.c.a.c$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Eval_whenFn -> org.c.a.c.a.c$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvectorpFn -> org.c.a.c.a.c$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$EvlisFn -> org.c.a.c.a.c$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExpandFn -> org.c.a.c.a.c$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2Fn -> org.c.a.c.a.c$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2lcFn -> org.c.a.c.a.c$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2lcnFn -> org.c.a.c.a.c$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2nFn -> org.c.a.c.a.c$bH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2ucFn -> org.c.a.c.a.c$bI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Explode2ucnFn -> org.c.a.c.a.c$bJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodeFn -> org.c.a.c.a.c$bK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodebinaryFn -> org.c.a.c.a.c$bL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodecFn -> org.c.a.c.a.c$bM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodecnFn -> org.c.a.c.a.c$bN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodehexFn -> org.c.a.c.a.c$bO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodenFn -> org.c.a.c.a.c$bP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodeoctalFn -> org.c.a.c.a.c$bQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ExplodetostringFn -> org.c.a.c.a.c$bR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fetch_urlFn -> org.c.a.c.a.c$bS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fgetv32Fn -> org.c.a.c.a.c$bT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fgetv64Fn -> org.c.a.c.a.c$bU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$File_readablepFn -> org.c.a.c.a.c$bV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$File_writeablepFn -> org.c.a.c.a.c$bW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FiledateFn -> org.c.a.c.a.c$bX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FilepFn -> org.c.a.c.a.c$bY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagFn -> org.c.a.c.a.c$bZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpFn -> org.c.a.c.a.c$ca:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpStarStarFn -> org.c.a.c.a.c$cb:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FlagpcarFn -> org.c.a.c.a.c$cc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$FluidFn -> org.c.a.c.a.c$cd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FluidpFn -> org.c.a.c.a.c$ce:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FlushFn -> org.c.a.c.a.c$cf:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FormatFn -> org.c.a.c.a.c$cg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fp_evaluateFn -> org.c.a.c.a.c$ch:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fputv32Fn -> org.c.a.c.a.c$ci:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Fputv64Fn -> org.c.a.c.a.c$cj:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$FuncallFn -> org.c.a.c.a.c$ck:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GctimeFn -> org.c.a.c.a.c$cl:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Gensym1Fn -> org.c.a.c.a.c$cm:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Gensym2Fn -> org.c.a.c.a.c$cn:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GensymFn -> org.c.a.c.a.c$co:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$GensympFn -> org.c.a.c.a.c$cp:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetFn -> org.c.a.c.a.c$cq:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GetStarFn -> org.c.a.c.a.c$cr:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Get_current_directoryFn -> org.c.a.c.a.c$cs:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Get_lisp_directoryFn -> org.c.a.c.a.c$ct:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetdFn -> org.c.a.c.a.c$cu:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetenvFn -> org.c.a.c.a.c$cv:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GethashFn -> org.c.a.c.a.c$cw:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv16Fn -> org.c.a.c.a.c$cx:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv32Fn -> org.c.a.c.a.c$cy:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Getv8Fn -> org.c.a.c.a.c$cz:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GetvFn -> org.c.a.c.a.c$cA:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$GlobalFn -> org.c.a.c.a.c$cB:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$GlobalpFn -> org.c.a.c.a.c$cC:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Hash_table_pFn -> org.c.a.c.a.c$cD:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$HashcontentsFn -> org.c.a.c.a.c$cE:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Hashtagged_nameFn -> org.c.a.c.a.c$cF:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$HelpFn -> org.c.a.c.a.c$cG:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IdpFn -> org.c.a.c.a.c$cH:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IndirectFn -> org.c.a.c.a.c$cI:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$InormFn -> org.c.a.c.a.c$cJ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Input_librariesFn -> org.c.a.c.a.c$cK:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$InternFn -> org.c.a.c.a.c$cL:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$IntersectionFn -> org.c.a.c.a.c$cM:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$Is_consoleFn -> org.c.a.c.a.c$cN:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastFn -> org.c.a.c.a.c$cO:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastcarFn -> org.c.a.c.a.c$cP:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LastpairFn -> org.c.a.c.a.c$cQ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LengthFn -> org.c.a.c.a.c$cR:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LengthcFn -> org.c.a.c.a.c$cS:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$Library_membersFn -> org.c.a.c.a.c$cT:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$Library_nameFn -> org.c.a.c.a.c$cU:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$LinelengthFn -> org.c.a.c.a.c$cV:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List2Fn -> org.c.a.c.a.c$cW:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List2StarFn -> org.c.a.c.a.c$cX:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List3Fn -> org.c.a.c.a.c$cY:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ListFn -> org.c.a.c.a.c$cZ:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$ListStarFn -> org.c.a.c.a.c$da:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$List_directoryFn -> org.c.a.c.a.c$db:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_modulesFn -> org.c.a.c.a.c$dc:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_stringFn -> org.c.a.c.a.c$dd:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_symbolFn -> org.c.a.c.a.c$de:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$List_to_vectorFn -> org.c.a.c.a.c$df:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns1$ResourceExceededFn -> org.c.a.c.a.c$dg:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns1$ResourceLimitFn -> org.c.a.c.a.c$dh:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns1$TimeofdayFn -> org.c.a.c.a.c$di:
    org.mathpiper.mpreduce.functions.builtin.Fns1 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns2 -> org.c.a.c.a.d:
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AbsFn -> org.c.a.c.a.d$a:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcosFn -> org.c.a.c.a.d$b:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcosdFn -> org.c.a.c.a.d$c:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcoshFn -> org.c.a.c.a.d$d:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcotFn -> org.c.a.c.a.d$e:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcotdFn -> org.c.a.c.a.d$f:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcothFn -> org.c.a.c.a.d$g:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcscFn -> org.c.a.c.a.d$h:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcscdFn -> org.c.a.c.a.d$i:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AcschFn -> org.c.a.c.a.d$j:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Add1Fn -> org.c.a.c.a.d$k:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsecFn -> org.c.a.c.a.d$l:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsecdFn -> org.c.a.c.a.d$m:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsechFn -> org.c.a.c.a.d$n:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Ash1Fn -> org.c.a.c.a.d$o:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AshFn -> org.c.a.c.a.d$p:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AsinFn -> org.c.a.c.a.d$q:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsindFn -> org.c.a.c.a.d$r:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AsinhFn -> org.c.a.c.a.d$s:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Atan2Fn -> org.c.a.c.a.d$t:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Atan2dFn -> org.c.a.c.a.d$u:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$AtanFn -> org.c.a.c.a.d$v:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AtandFn -> org.c.a.c.a.d$w:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$AtanhFn -> org.c.a.c.a.d$x:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CeilingFn -> org.c.a.c.a.d$y:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CosFn -> org.c.a.c.a.d$z:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CosdFn -> org.c.a.c.a.d$A:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CoshFn -> org.c.a.c.a.d$B:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CotFn -> org.c.a.c.a.d$C:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CotdFn -> org.c.a.c.a.d$D:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CothFn -> org.c.a.c.a.d$E:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CscFn -> org.c.a.c.a.d$F:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CscdFn -> org.c.a.c.a.d$G:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$CschFn -> org.c.a.c.a.d$H:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$DifferenceFn -> org.c.a.c.a.d$I:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$DivideFn -> org.c.a.c.a.d$J:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$EqSafeFn -> org.c.a.c.a.d$K:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$EqnFn -> org.c.a.c.a.d$L:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$EvenpFn -> org.c.a.c.a.d$M:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ExpFn -> org.c.a.c.a.d$N:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ExptFn -> org.c.a.c.a.d$O:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$FixFn -> org.c.a.c.a.d$P:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FixpFn -> org.c.a.c.a.d$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloatFn -> org.c.a.c.a.d$R:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloatpFn -> org.c.a.c.a.d$S:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FloorFn -> org.c.a.c.a.d$T:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$FrexpFn -> org.c.a.c.a.d$U:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$GcdnFn -> org.c.a.c.a.d$V:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$GeqFn -> org.c.a.c.a.d$W:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$GreaterpFn -> org.c.a.c.a.d$X:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$HypotFn -> org.c.a.c.a.d$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Iadd1Fn -> org.c.a.c.a.d$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IdifferenceFn -> org.c.a.c.a.d$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IgeqFn -> org.c.a.c.a.d$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IgreaterpFn -> org.c.a.c.a.d$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IleqFn -> org.c.a.c.a.d$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlesspFn -> org.c.a.c.a.d$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogandFn -> org.c.a.c.a.d$af:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogorFn -> org.c.a.c.a.d$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IlogxorFn -> org.c.a.c.a.d$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ImaxFn -> org.c.a.c.a.d$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IminFn -> org.c.a.c.a.d$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IminusFn -> org.c.a.c.a.d$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IminuspFn -> org.c.a.c.a.d$al:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IntegerpFn -> org.c.a.c.a.d$am:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$IonepFn -> org.c.a.c.a.d$an:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Iplus2Fn -> org.c.a.c.a.d$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IplusFn -> org.c.a.c.a.d$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IquotientFn -> org.c.a.c.a.d$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IremainderFn -> org.c.a.c.a.d$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IrightshiftFn -> org.c.a.c.a.d$as:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Isub1Fn -> org.c.a.c.a.d$at:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Itimes2Fn -> org.c.a.c.a.d$au:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ItimesFn -> org.c.a.c.a.d$av:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$IzeropFn -> org.c.a.c.a.d$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LcmnFn -> org.c.a.c.a.d$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LeqFn -> org.c.a.c.a.d$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LesspFn -> org.c.a.c.a.d$az:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LnFn -> org.c.a.c.a.d$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Log10Fn -> org.c.a.c.a.d$aB:
    double log10 -> a
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LogFn -> org.c.a.c.a.d$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogandFn -> org.c.a.c.a.d$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogbFn -> org.c.a.c.a.d$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogeqvFn -> org.c.a.c.a.d$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LognotFn -> org.c.a.c.a.d$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LogorFn -> org.c.a.c.a.d$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$LogxorFn -> org.c.a.c.a.d$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Lose_precisionFn -> org.c.a.c.a.d$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$LsdFn -> org.c.a.c.a.d$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Max2Fn -> org.c.a.c.a.d$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MaxFn -> org.c.a.c.a.d$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Min2Fn -> org.c.a.c.a.d$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MinFn -> org.c.a.c.a.d$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MinusFn -> org.c.a.c.a.d$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$MinuspFn -> org.c.a.c.a.d$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$ModFn -> org.c.a.c.a.d$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_differenceFn -> org.c.a.c.a.d$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_exptFn -> org.c.a.c.a.d$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_minusFn -> org.c.a.c.a.d$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_numberFn -> org.c.a.c.a.d$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_plusFn -> org.c.a.c.a.d$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_quotientFn -> org.c.a.c.a.d$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_reciprocalFn -> org.c.a.c.a.d$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Modular_timesFn -> org.c.a.c.a.d$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$MsdFn -> org.c.a.c.a.d$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$NumberpFn -> org.c.a.c.a.d$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$OddpFn -> org.c.a.c.a.d$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$OnepFn -> org.c.a.c.a.d$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Plus2Fn -> org.c.a.c.a.d$be:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$PlusFn -> org.c.a.c.a.d$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$PluspFn -> org.c.a.c.a.d$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$QuotientFn -> org.c.a.c.a.d$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Random_fixnumFn -> org.c.a.c.a.d$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Random_numberFn -> org.c.a.c.a.d$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$RationalFn -> org.c.a.c.a.d$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$RemainderFn -> org.c.a.c.a.d$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$RoundFn -> org.c.a.c.a.d$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_plusFn -> org.c.a.c.a.d$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_quotFn -> org.c.a.c.a.d$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_fp_timesFn -> org.c.a.c.a.d$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$Safe_modular_reciprocalFn -> org.c.a.c.a.d$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SecFn -> org.c.a.c.a.d$br:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SecdFn -> org.c.a.c.a.d$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SechFn -> org.c.a.c.a.d$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Set_small_modulusFn -> org.c.a.c.a.d$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SinFn -> org.c.a.c.a.d$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SindFn -> org.c.a.c.a.d$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SinhFn -> org.c.a.c.a.d$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$SqrtFn -> org.c.a.c.a.d$by:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Sub1Fn -> org.c.a.c.a.d$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TanFn -> org.c.a.c.a.d$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TandFn -> org.c.a.c.a.d$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$TanhFn -> org.c.a.c.a.d$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns2$Times2Fn -> org.c.a.c.a.d$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$TimesFn -> org.c.a.c.a.d$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$TruncateFn -> org.c.a.c.a.d$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns2$ZeropFn -> org.c.a.c.a.d$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns2 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3 -> org.c.a.c.a.e:
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Get_print_precisionFn -> org.c.a.c.a.e$a:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$InternalOpenFn -> org.c.a.c.a.e$b:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject openPipe(java.lang.String,int) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$LiterFn -> org.c.a.c.a.e$c:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Load_moduleFn -> org.c.a.c.a.e$d:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$LposnFn -> org.c.a.c.a.e$e:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Macro_functionFn -> org.c.a.c.a.e$f:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MacroexpandFn -> org.c.a.c.a.e$g:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Macroexpand_1Fn -> org.c.a.c.a.e$h:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_bpsFn -> org.c.a.c.a.e$i:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_function_streamFn -> org.c.a.c.a.e$j:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_globalFn -> org.c.a.c.a.e$k:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_nativeFn -> org.c.a.c.a.e$l:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_random_stateFn -> org.c.a.c.a.e$m:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_simple_stringFn -> org.c.a.c.a.e$n:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Make_specialFn -> org.c.a.c.a.e$o:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapFn -> org.c.a.c.a.e$p:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcFn -> org.c.a.c.a.e$q:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcanFn -> org.c.a.c.a.e$r:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapcarFn -> org.c.a.c.a.e$s:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapconFn -> org.c.a.c.a.e$t:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MaphashFn -> org.c.a.c.a.e$u:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MaplistFn -> org.c.a.c.a.e$v:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MapstoreFn -> org.c.a.c.a.e$w:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Md5Fn -> org.c.a.c.a.e$x:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Md60Fn -> org.c.a.c.a.e$y:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MemberFn -> org.c.a.c.a.e$z:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MemberStarStarFn -> org.c.a.c.a.e$A:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MemqFn -> org.c.a.c.a.e$B:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MkevectFn -> org.c.a.c.a.e$C:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkfvect32Fn -> org.c.a.c.a.e$D:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkfvect64Fn -> org.c.a.c.a.e$E:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkhashFn -> org.c.a.c.a.e$F:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$MkquoteFn -> org.c.a.c.a.e$G:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect16Fn -> org.c.a.c.a.e$H:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect32Fn -> org.c.a.c.a.e$I:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Mkvect8Fn -> org.c.a.c.a.e$J:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkvectFn -> org.c.a.c.a.e$K:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$MkxvectFn -> org.c.a.c.a.e$L:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ModulepFn -> org.c.a.c.a.e$M:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_addressFn -> org.c.a.c.a.e$N:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_getvFn -> org.c.a.c.a.e$O:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_putvFn -> org.c.a.c.a.e$P:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Native_typeFn -> org.c.a.c.a.e$Q:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NconcFn -> org.c.a.c.a.e$R:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$NconsFn -> org.c.a.c.a.e$S:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NeqFn -> org.c.a.c.a.e$T:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Noisy_setqFn -> org.c.a.c.a.e$U:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NotFn -> org.c.a.c.a.e$V:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$NullFn -> org.c.a.c.a.e$W:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OblistFn -> org.c.a.c.a.e$X:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$Oem_supervisorFn -> org.c.a.c.a.e$Y:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OpenFn -> org.c.a.c.a.e$Z:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Open_libraryFn -> org.c.a.c.a.e$aa:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Open_urlFn -> org.c.a.c.a.e$ab:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$OrderpFn -> org.c.a.c.a.e$ac:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    boolean ordp(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    boolean ordv(org.mathpiper.mpreduce.datatypes.LispVector,org.mathpiper.mpreduce.datatypes.LispVector) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Output_libraryFn -> org.c.a.c.a.e$ad:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PagelengthFn -> org.c.a.c.a.e$ae:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PairFn -> org.c.a.c.a.e$af:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PairpFn -> org.c.a.c.a.e$ag:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PeekchFn -> org.c.a.c.a.e$ah:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Pipe_openFn -> org.c.a.c.a.e$ai:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PlistFn -> org.c.a.c.a.e$aj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PosnFn -> org.c.a.c.a.e$ak:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$PreserveFn -> org.c.a.c.a.e$al:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin1Fn -> org.c.a.c.a.e$am:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin2Fn -> org.c.a.c.a.e$an:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prin2aFn -> org.c.a.c.a.e$ao:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinFn -> org.c.a.c.a.e$ap:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinbinaryFn -> org.c.a.c.a.e$aq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrincFn -> org.c.a.c.a.e$ar:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Princ_downcaseFn -> org.c.a.c.a.e$as:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Princ_upcaseFn -> org.c.a.c.a.e$at:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinhexFn -> org.c.a.c.a.e$au:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrinoctalFn -> org.c.a.c.a.e$av:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintFn -> org.c.a.c.a.e$aw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintcFn -> org.c.a.c.a.e$ax:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PrintpromptFn -> org.c.a.c.a.e$ay:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Prog1Fn -> org.c.a.c.a.e$az:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Prog2Fn -> org.c.a.c.a.e$aA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PrognFn -> org.c.a.c.a.e$aB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PutFn -> org.c.a.c.a.e$aC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$PuthashFn -> org.c.a.c.a.e$aD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv16Fn -> org.c.a.c.a.e$aE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv32Fn -> org.c.a.c.a.e$aF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv8Fn -> org.c.a.c.a.e$aG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$PutvFn -> org.c.a.c.a.e$aH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Putv_charFn -> org.c.a.c.a.e$aI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$QcaarFn -> org.c.a.c.a.e$aJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcadrFn -> org.c.a.c.a.e$aK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcarFn -> org.c.a.c.a.e$aL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcdarFn -> org.c.a.c.a.e$aM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcddrFn -> org.c.a.c.a.e$aN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QcdrFn -> org.c.a.c.a.e$aO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$QgetvFn -> org.c.a.c.a.e$aP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$QputvFn -> org.c.a.c.a.e$aQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RassocFn -> org.c.a.c.a.e$aR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RdfFn -> org.c.a.c.a.e$aS:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RdsFn -> org.c.a.c.a.e$aT:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadFn -> org.c.a.c.a.e$aU:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadchFn -> org.c.a.c.a.e$aV:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ReadlineFn -> org.c.a.c.a.e$aW:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReclaimFn -> org.c.a.c.a.e$aX:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RemdFn -> org.c.a.c.a.e$aY:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RemflagFn -> org.c.a.c.a.e$aZ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RemhashFn -> org.c.a.c.a.e$ba:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RemobFn -> org.c.a.c.a.e$bb:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RempropFn -> org.c.a.c.a.e$bc:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Rename_fileFn -> org.c.a.c.a.e$bd:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RepresentationFn -> org.c.a.c.a.e$be:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RestartFn -> org.c.a.c.a.e$bf:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RestoreObjectFn -> org.c.a.c.a.e$bg:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$ReturnFn -> org.c.a.c.a.e$bh:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReverseFn -> org.c.a.c.a.e$bi:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ReversipFn -> org.c.a.c.a.e$bj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacaFn -> org.c.a.c.a.e$bk:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacdFn -> org.c.a.c.a.e$bl:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RplacwFn -> org.c.a.c.a.e$bm:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$RseekFn -> org.c.a.c.a.e$bn:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$RtellFn -> org.c.a.c.a.e$bo:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SampleFn -> org.c.a.c.a.e$bp:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SassocFn -> org.c.a.c.a.e$bq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SaveObjectFn -> org.c.a.c.a.e$br:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$ScharFn -> org.c.a.c.a.e$bs:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SeprpFn -> org.c.a.c.a.e$bt:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SetFn -> org.c.a.c.a.e$bu:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_autoloadFn -> org.c.a.c.a.e$bv:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_help_fileFn -> org.c.a.c.a.e$bw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Set_print_precisionFn -> org.c.a.c.a.e$bx:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SetpcharFn -> org.c.a.c.a.e$by:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Simple_string_pFn -> org.c.a.c.a.e$bz:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Simple_vector_pFn -> org.c.a.c.a.e$bA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SmemqFn -> org.c.a.c.a.e$bB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SpacesFn -> org.c.a.c.a.e$bC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Special_charFn -> org.c.a.c.a.e$bD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Special_form_pFn -> org.c.a.c.a.e$bE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SpoolFn -> org.c.a.c.a.e$bF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Start_moduleFn -> org.c.a.c.a.e$bG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Startup_bannerFn -> org.c.a.c.a.e$bH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StopFn -> org.c.a.c.a.e$bI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StreampFn -> org.c.a.c.a.e$bJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$StringpFn -> org.c.a.c.a.e$bK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Stub1Fn -> org.c.a.c.a.e$bL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Stub2Fn -> org.c.a.c.a.e$bM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SublaFn -> org.c.a.c.a.e$bN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SublisFn -> org.c.a.c.a.e$bO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SubstFn -> org.c.a.c.a.e$bP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject subst(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SubstqFn -> org.c.a.c.a.e$bQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject substq(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$SxhashFn -> org.c.a.c.a.e$bR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_argcountFn -> org.c.a.c.a.e$bS:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_envFn -> org.c.a.c.a.e$bT:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_fastgetsFn -> org.c.a.c.a.e$bU:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_fn_cellFn -> org.c.a.c.a.e$bV:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_functionFn -> org.c.a.c.a.e$bW:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_make_fastgetFn -> org.c.a.c.a.e$bX:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_nameFn -> org.c.a.c.a.e$bY:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_protectFn -> org.c.a.c.a.e$bZ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_definitionFn -> org.c.a.c.a.e$ca:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_envFn -> org.c.a.c.a.e$cb:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_set_nativeFn -> org.c.a.c.a.e$cc:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Symbol_valueFn -> org.c.a.c.a.e$cd:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SymbolpFn -> org.c.a.c.a.e$ce:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SymerrFn -> org.c.a.c.a.e$cf:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$SystemFn -> org.c.a.c.a.e$cg:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TagbodyFn -> org.c.a.c.a.e$ch:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TerpriFn -> org.c.a.c.a.e$ci:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$ThreevectorpFn -> org.c.a.c.a.e$cj:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$ThrowFn -> org.c.a.c.a.e$ck:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TimeFn -> org.c.a.c.a.e$cl:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$TmpnamFn -> org.c.a.c.a.e$cm:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TraceFn -> org.c.a.c.a.e$cn:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Traceset1Fn -> org.c.a.c.a.e$co:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TracesetFn -> org.c.a.c.a.e$cp:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TtabFn -> org.c.a.c.a.e$cq:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TyiFn -> org.c.a.c.a.e$cr:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$TyoFn -> org.c.a.c.a.e$cs:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Undouble_executeFn -> org.c.a.c.a.e$ct:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnfluidFn -> org.c.a.c.a.e$cu:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnglobalFn -> org.c.a.c.a.e$cv:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnionFn -> org.c.a.c.a.e$cw:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$Unmake_globalFn -> org.c.a.c.a.e$cx:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Unmake_specialFn -> org.c.a.c.a.e$cy:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UnreadchFn -> org.c.a.c.a.e$cz:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UntraceFn -> org.c.a.c.a.e$cA:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Untraceset1Fn -> org.c.a.c.a.e$cB:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UntracesetFn -> org.c.a.c.a.e$cC:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Unwind_protectFn -> org.c.a.c.a.e$cD:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$UpbvFn -> org.c.a.c.a.e$cE:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$User_homedir_pathnameFn -> org.c.a.c.a.e$cF:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$VectorpFn -> org.c.a.c.a.e$cG:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$VerbosFn -> org.c.a.c.a.e$cH:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Where_was_thatFn -> org.c.a.c.a.e$cI:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.Fns3$Window_headingFn -> org.c.a.c.a.e$cJ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Writable_librarypFn -> org.c.a.c.a.e$cK:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Write_help_moduleFn -> org.c.a.c.a.e$cL:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$Write_moduleFn -> org.c.a.c.a.e$cM:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$WrsFn -> org.c.a.c.a.e$cN:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XassocFn -> org.c.a.c.a.e$cO:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XconsFn -> org.c.a.c.a.e$cP:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.builtin.Fns3$XdifferenceFn -> org.c.a.c.a.e$cQ:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.Fns3$XtabFn -> org.c.a.c.a.e$cR:
    org.mathpiper.mpreduce.functions.builtin.Fns3 this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions -> org.c.a.c.a.f:
    boolean inEvaluationMode -> a
    java.lang.Object[][] builtins -> a
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions$EvaluatingClearFn -> org.c.a.c.a.f$a:
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions this$0 -> a
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions$EvaluatingSetFn -> org.c.a.c.a.f$b:
    org.mathpiper.mpreduce.functions.builtin.MPReduceFunctions this$0 -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
org.mathpiper.mpreduce.functions.builtin.MyMath -> org.c.a.c.a.g:
    double acosh(double) -> a
    double acoth(double) -> b
    double acsch(double) -> c
    double asech(double) -> d
    double asinh(double) -> e
    double atanh(double) -> f
    double cosh(double) -> g
    double coth(double) -> h
    double csch(double) -> i
    double sech(double) -> j
    double sinh(double) -> k
    double tanh(double) -> l
org.mathpiper.mpreduce.functions.functionwithenvironment.ByteOpt -> org.c.a.c.b.a:
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.functionwithenvironment.Bytecode -> org.c.a.c.b.b:
    java.lang.StringBuffer sb -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin0 -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin1 -> b
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin2 -> c
    org.mathpiper.mpreduce.functions.lisp.LispFunction[] builtin3 -> d
    int BIbatchp -> b
    int BIdate -> c
    int BIeject -> d
    int BIerror1 -> e
    int BIgctime -> f
    int BIgensym -> g
    int BIlposn -> h
    int BIposn -> i
    int BIread -> j
    int BIreadch -> k
    int BIterpri -> l
    int BItime -> m
    int BIabs -> n
    int BIadd1 -> o
    int BIatan -> p
    int BIapply0 -> q
    int BIatom -> r
    int BIboundp -> s
    int BIchar_code -> t
    int BIclose -> u
    int BIcodep -> v
    int BIcompress -> w
    int BIconstantp -> x
    int BIdigit -> y
    int BIendp -> z
    int BIeval -> A
    int BIevenp -> B
    int BIevlis -> C
    int BIexplode -> D
    int BIexplode2lc -> E
    int BIexplode2 -> F
    int BIexplodec -> G
    int BIfixp -> H
    int BIfloat -> I
    int BIfloatp -> J
    int BIgensym1 -> K
    int BIgetenv -> L
    int BIiadd1 -> M
    int BIsymbolp -> N
    int BIiminus -> O
    int BIiminusp -> P
    int BIindirect -> Q
    int BIintegerp -> R
    int BIintern -> S
    int BIisub1 -> T
    int BIlength -> U
    int BIlengthc -> V
    int BIlinelength -> W
    int BIliter -> X
    int BIload_module -> Y
    int BIlognot -> Z
    int BImacroexpand -> aa
    int BImacroexpand_1 -> ab
    int BImacro_function -> ac
    int BImake_bps -> ad
    int BImake_global -> ae
    int BImake_simple_string -> af
    int BImake_special -> ag
    int BIminus -> ah
    int BIminusp -> ai
    int BImkvect -> aj
    int BImodular_minus -> ak
    int BImodular_number -> al
    int BImodular_reciprocal -> am
    int BInull -> an
    int BIoddp -> ao
    int BIonep -> ap
    int BIpagelength -> aq
    int BIpairp -> ar
    int BIplist -> as
    int BIplusp -> at
    int BIprin -> au
    int BIprinc -> av
    int BIprint -> aw
    int BIprintc -> ax
    int BIrational -> ay
    int BIrds -> az
    int BIremd -> aA
    int BIreverse -> aB
    int BIreversip -> aC
    int BIreversip2 -> aD
    int BIseprp -> aE
    int BIset_small_modulus -> aF
    int BIspaces -> aG
    int BIxtab -> aH
    int BIspecial_char -> aI
    int BIspecial_form_p -> aJ
    int BIspool -> aK
    int BIstop -> aL
    int BIstringp -> aM
    int BIsub1 -> aN
    int BIsymbol_env -> aO
    int BIsymbol_function -> aP
    int BIsymbol_name -> aQ
    int BIsymbol_value -> aR
    int BIsystem -> aS
    int BIfix -> aT
    int BIttab -> aU
    int BItyo -> aV
    int BIremob -> aW
    int BIunmake_global -> aX
    int BIunmake_special -> aY
    int BIupbv -> aZ
    int BIvectorp -> ba
    int BIverbos -> bb
    int BIwrs -> bc
    int BIzerop -> bd
    int BIcar -> be
    int BIcdr -> bf
    int BIcaar -> bg
    int BIcadr -> bh
    int BIcdar -> bi
    int BIcddr -> bj
    int BIqcar -> bk
    int BIqcdr -> bl
    int BIqcaar -> bm
    int BIqcadr -> bn
    int BIqcdar -> bo
    int BIqcddr -> bp
    int BIncons -> bq
    int BInumberp -> br
    int BIappend -> bs
    int BIash -> bt
    int BIassoc -> bu
    int BIatsoc -> bv
    int BIdeleq -> bw
    int BIdelete -> bx
    int BIdivide -> by
    int BIeqcar -> bz
    int BIeql -> bA
    int BIeqn -> bB
    int BIexpt -> bC
    int BIflag -> bD
    int BIflagpcar -> bE
    int BIgcdn -> bF
    int BIgeq -> bG
    int BIgetv -> bH
    int BIgreaterp -> bI
    int BIidifference -> bJ
    int BIigreaterp -> bK
    int BIilessp -> bL
    int BIimax -> bM
    int BIimin -> bN
    int BIiplus2 -> bO
    int BIiquotient -> bP
    int BIiremainder -> bQ
    int BIirightshift -> bR
    int BIitimes2 -> bS
    int BIleq -> bT
    int BIlessp -> bU
    int BImake_random_state -> bV
    int BImax2 -> bW
    int BImember -> bX
    int BImemq -> bY
    int BImin2 -> bZ
    int BImod -> ca
    int BImodular_difference -> cb
    int BImodular_expt -> cc
    int BImodular_plus -> cd
    int BImodular_quotient -> ce
    int BImodular_times -> cf
    int BInconc -> cg
    int BIneq -> ch
    int BIorderp -> ci
    int BIordp -> cj
    int BIquotient -> ck
    int BIremainder -> cl
    int BIremflag -> cm
    int BIremprop -> cn
    int BIrplaca -> co
    int BIrplacd -> cp
    int BIschar -> cq
    int BIset -> cr
    int BIsmemq -> cs
    int BIsubla -> ct
    int BIsublis -> cu
    int BIsymbol_set_definition -> cv
    int BIsymbol_set_env -> cw
    int BIxcons -> cx
    int BIequal -> cy
    int BIeq -> cz
    int BIcons -> cA
    int BIlist2 -> cB
    int BIget -> cC
    int BIqgetv -> cD
    int BIflagp -> cE
    int BIapply1 -> cF
    int BIdifference -> cG
    int BIplus2 -> cH
    int BItimes2 -> cI
    int BIequalcar -> cJ
    int BIiequal -> cK
    int BIbps_putv -> cL
    int BIerrorset -> cM
    int BIlist2STAR -> cN
    int BIlist3 -> cO
    int BIputv -> cP
    int BIputv_char -> cQ
    int BIsubst -> cR
    int BIapply2 -> cS
    int BIacons -> cT
    int stack_size -> cU
    org.mathpiper.mpreduce.LispObject[] stack -> a
    int sp -> cV
    int poll_time_countdown -> cW
    long last_clock -> a
    void handleInterrupt() -> i
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction lookupBuiltin(java.lang.String) -> a
    void setupBuiltins() -> h
    org.mathpiper.mpreduce.LispObject interpret(int) -> e
org.mathpiper.mpreduce.functions.functionwithenvironment.FnWithEnv -> org.c.a.c.b.c:
    int nargs -> cX
    byte[] bytecodes -> a
    org.mathpiper.mpreduce.LispObject[] env -> b
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.AutoLoad -> org.c.a.c.c.a:
    org.mathpiper.mpreduce.symbols.Symbol name -> a
    org.mathpiper.mpreduce.LispObject data -> c
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void print() -> a
    void print(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.CallAs -> org.c.a.c.c.b:
    org.mathpiper.mpreduce.LispObject body -> c
    int nargs -> b
    void print() -> a
    void print(int) -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.Interpreted -> org.c.a.c.c.c:
    org.mathpiper.mpreduce.LispObject body -> c
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
org.mathpiper.mpreduce.functions.lisp.LispFunction -> org.c.a.c.c.d:
    java.lang.String name -> a
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject error(java.lang.String,org.mathpiper.mpreduce.LispObject) -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
org.mathpiper.mpreduce.functions.lisp.Macro -> org.c.a.c.c.e:
    org.mathpiper.mpreduce.LispObject body -> c
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
org.mathpiper.mpreduce.functions.lisp.TracedFunction -> org.c.a.c.c.f:
    org.mathpiper.mpreduce.symbols.Symbol name -> a
    org.mathpiper.mpreduce.functions.lisp.LispFunction fn -> a
    int traceDepth -> b
    void indent() -> h
    org.mathpiper.mpreduce.LispObject op0() -> C
    org.mathpiper.mpreduce.LispObject op1(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject op2(org.mathpiper.mpreduce.LispObject,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject opn(org.mathpiper.mpreduce.LispObject[]) -> a
    void print() -> a
    void print(int) -> a
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.functions.lisp.Undefined -> org.c.a.c.c.g:
    void dump() -> g
org.mathpiper.mpreduce.io.Fasl -> org.c.a.d.a:
    java.io.OutputStream writer -> a
    java.io.InputStream reader -> a
    org.mathpiper.mpreduce.LispObject[] recent -> a
    int recentp -> a
    int recentn -> b
    java.lang.String moduleName -> a
    java.lang.String name -> b
    org.mathpiper.mpreduce.LispObject startModule(org.mathpiper.mpreduce.LispObject) -> a
    void defineInModule(int) -> a
    void faslWrite(org.mathpiper.mpreduce.LispObject) -> a
    boolean openModule(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject loadModule(org.mathpiper.mpreduce.LispObject) -> b
    void readByteDef(int,org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject faslRead() -> a
org.mathpiper.mpreduce.io.streams.DoubleWriter -> org.c.a.d.a.a:
    java.io.Writer log -> a
    boolean closeMe -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispCounter -> org.c.a.d.a.b:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispDigester -> org.c.a.d.a.c:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispExploder -> org.c.a.d.a.d:
    boolean asSymbols -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispOutputStream -> org.c.a.d.a.e:
    boolean closeMe -> b
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
org.mathpiper.mpreduce.io.streams.LispOutputString -> org.c.a.d.a.f:
    void flush() -> h
    void close() -> i
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    java.lang.String toString() -> toString
org.mathpiper.mpreduce.io.streams.LispStream -> org.c.a.d.a.g:
    java.lang.String name -> a
    int lineLength -> b
    int column -> c
    java.lang.String eol -> b
    org.mathpiper.mpreduce.LispObject exploded -> c
    java.lang.StringBuffer sb -> a
    java.security.MessageDigest md -> a
    java.io.Writer wr -> b
    boolean inputValid -> c
    org.mathpiper.mpreduce.LispObject inputData -> d
    java.lang.String stringData -> c
    java.io.Reader reader -> a
    org.mathpiper.mpreduce.LispObject value -> e
    int nextChar -> d
    int prevChar -> e
    java.lang.StringBuffer s -> b
    boolean needsPrompt -> d
    boolean escaped -> e
    boolean allowOctal -> f
    java.math.BigInteger[] digits -> a
    java.text.SimpleDateFormat dFormat -> a
    void print(java.lang.String) -> a
    void println(java.lang.String) -> b
    void println() -> j
    void flush() -> h
    void close() -> i
    void setReader(java.lang.String,java.io.Reader,boolean,boolean) -> a
    void prompt() -> k
    int read() -> c
    void getNext() -> l
    int readChar() -> d
    int nextToken() -> e
    void tidyup(org.mathpiper.mpreduce.LispObject) -> a
    void iprint() -> b
    void blankprint() -> c
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String nameConvert(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject fileDate(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject fileDelete(java.lang.String) -> b
    org.mathpiper.mpreduce.LispObject fileRename(java.lang.String,java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject listDirectory(java.lang.String) -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.io.streams.LispStringReader -> org.c.a.d.a.h:
    int pos -> f
    int read() -> c
    void close() -> i
org.mathpiper.mpreduce.io.streams.ListReader -> org.c.a.d.a.i:
    int read() -> c
    void close() -> i
org.mathpiper.mpreduce.io.streams.WriterToLisp -> org.c.a.d.a.j:
    org.mathpiper.mpreduce.io.streams.LispStream stream -> a
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
org.mathpiper.mpreduce.numbers.LispBigInteger -> org.c.a.e.a:
    java.math.BigInteger value -> a
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    java.math.BigInteger biglcm(java.math.BigInteger,java.math.BigInteger) -> a
org.mathpiper.mpreduce.numbers.LispFloat -> org.c.a.e.b:
    double value -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    void iprint() -> b
    void blankprint() -> c
    java.lang.String trimTo(int) -> a
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
org.mathpiper.mpreduce.numbers.LispInteger -> org.c.a.e.c:
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(int) -> a
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(long) -> a
    org.mathpiper.mpreduce.numbers.LispInteger valueOf(java.math.BigInteger) -> a
org.mathpiper.mpreduce.numbers.LispNumber -> org.c.a.e.d:
org.mathpiper.mpreduce.numbers.LispSmallInteger -> org.c.a.e.e:
    int value -> b
    org.mathpiper.mpreduce.numbers.LispSmallInteger[] preAllocated -> a
    void preAllocate() -> h
    int intValue() -> b
    java.math.BigInteger bigIntValue() -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String printAs() -> a
    void iprint() -> b
    void blankprint() -> c
    double doubleValue() -> a
    boolean lispequals(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int lisphashCode() -> a
    int hashCode() -> hashCode
    void scan() -> f
    void dump() -> g
    org.mathpiper.mpreduce.LispObject negate() -> c
    org.mathpiper.mpreduce.LispObject abs() -> u
    org.mathpiper.mpreduce.LispObject add1() -> d
    org.mathpiper.mpreduce.LispObject sub1() -> e
    org.mathpiper.mpreduce.LispObject msd() -> v
    org.mathpiper.mpreduce.LispObject lsd() -> w
    org.mathpiper.mpreduce.LispObject not() -> x
    org.mathpiper.mpreduce.LispObject modMinus() -> y
    org.mathpiper.mpreduce.LispObject modRecip() -> z
    org.mathpiper.mpreduce.LispObject safeModRecip() -> A
    org.mathpiper.mpreduce.LispObject reduceMod() -> B
    org.mathpiper.mpreduce.LispObject floor() -> f
    org.mathpiper.mpreduce.LispObject ceiling() -> g
    org.mathpiper.mpreduce.LispObject round() -> h
    org.mathpiper.mpreduce.LispObject truncate() -> i
    org.mathpiper.mpreduce.LispObject ash(int) -> a
    org.mathpiper.mpreduce.LispObject ash1(int) -> b
    org.mathpiper.mpreduce.LispObject rightshift(int) -> c
    org.mathpiper.mpreduce.LispObject evenp() -> j
    org.mathpiper.mpreduce.LispObject oddp() -> k
    org.mathpiper.mpreduce.LispObject fix() -> l
    org.mathpiper.mpreduce.LispObject fixp() -> m
    org.mathpiper.mpreduce.LispObject integerp() -> n
    org.mathpiper.mpreduce.LispObject jfloat() -> o
    org.mathpiper.mpreduce.LispObject floatp() -> p
    org.mathpiper.mpreduce.LispObject minusp() -> q
    org.mathpiper.mpreduce.LispObject plusp() -> r
    org.mathpiper.mpreduce.LispObject zerop() -> s
    org.mathpiper.mpreduce.LispObject onep() -> t
    org.mathpiper.mpreduce.LispObject add(org.mathpiper.mpreduce.LispObject) -> a
    org.mathpiper.mpreduce.LispObject subtract(org.mathpiper.mpreduce.LispObject) -> b
    org.mathpiper.mpreduce.LispObject multiply(org.mathpiper.mpreduce.LispObject) -> c
    org.mathpiper.mpreduce.LispObject expt(org.mathpiper.mpreduce.LispObject) -> h
    org.mathpiper.mpreduce.LispObject divide(org.mathpiper.mpreduce.LispObject) -> d
    org.mathpiper.mpreduce.LispObject remainder(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainder(org.mathpiper.mpreduce.LispObject) -> f
    org.mathpiper.mpreduce.LispObject mod(org.mathpiper.mpreduce.LispObject) -> g
    org.mathpiper.mpreduce.LispObject max(org.mathpiper.mpreduce.LispObject) -> i
    org.mathpiper.mpreduce.LispObject min(org.mathpiper.mpreduce.LispObject) -> j
    org.mathpiper.mpreduce.LispObject and(org.mathpiper.mpreduce.LispObject) -> k
    org.mathpiper.mpreduce.LispObject or(org.mathpiper.mpreduce.LispObject) -> l
    org.mathpiper.mpreduce.LispObject xor(org.mathpiper.mpreduce.LispObject) -> m
    org.mathpiper.mpreduce.LispObject gcd(org.mathpiper.mpreduce.LispObject) -> n
    org.mathpiper.mpreduce.LispObject lcm(org.mathpiper.mpreduce.LispObject) -> o
    org.mathpiper.mpreduce.LispObject modAdd(org.mathpiper.mpreduce.LispObject) -> p
    org.mathpiper.mpreduce.LispObject modSubtract(org.mathpiper.mpreduce.LispObject) -> q
    org.mathpiper.mpreduce.LispObject modMultiply(org.mathpiper.mpreduce.LispObject) -> r
    org.mathpiper.mpreduce.LispObject modDivide(org.mathpiper.mpreduce.LispObject) -> s
    org.mathpiper.mpreduce.LispObject modExpt(int) -> d
    boolean eqn(org.mathpiper.mpreduce.LispObject) -> a
    boolean ge(org.mathpiper.mpreduce.LispObject) -> b
    boolean geq(org.mathpiper.mpreduce.LispObject) -> c
    boolean le(org.mathpiper.mpreduce.LispObject) -> d
    boolean leq(org.mathpiper.mpreduce.LispObject) -> e
    org.mathpiper.mpreduce.LispObject addInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplyInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    org.mathpiper.mpreduce.LispObject divideInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> f
    org.mathpiper.mpreduce.LispObject modInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> g
    org.mathpiper.mpreduce.LispObject exptInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> h
    org.mathpiper.mpreduce.LispObject maxInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> i
    org.mathpiper.mpreduce.LispObject minInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> j
    org.mathpiper.mpreduce.LispObject andInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> k
    org.mathpiper.mpreduce.LispObject orInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> l
    org.mathpiper.mpreduce.LispObject xorInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> o
    boolean eqnInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> a
    boolean geInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> b
    boolean geqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> c
    boolean leInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> d
    boolean leqInteger(org.mathpiper.mpreduce.numbers.LispBigInteger) -> e
    org.mathpiper.mpreduce.LispObject addSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    org.mathpiper.mpreduce.LispObject subtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    org.mathpiper.mpreduce.LispObject multiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    org.mathpiper.mpreduce.LispObject divideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    org.mathpiper.mpreduce.LispObject remainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
    org.mathpiper.mpreduce.LispObject quotientAndRemainderSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> f
    org.mathpiper.mpreduce.LispObject modSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> g
    org.mathpiper.mpreduce.LispObject exptSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> h
    org.mathpiper.mpreduce.LispObject maxSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> i
    org.mathpiper.mpreduce.LispObject minSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> j
    org.mathpiper.mpreduce.LispObject andSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> k
    org.mathpiper.mpreduce.LispObject orSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> l
    org.mathpiper.mpreduce.LispObject xorSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> m
    org.mathpiper.mpreduce.LispObject gcdSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> n
    org.mathpiper.mpreduce.LispObject lcmSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> o
    org.mathpiper.mpreduce.LispObject modAddSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> p
    org.mathpiper.mpreduce.LispObject modSubtractSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> q
    org.mathpiper.mpreduce.LispObject modMultiplySmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> r
    org.mathpiper.mpreduce.LispObject modDivideSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> s
    boolean eqnSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> a
    boolean geSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> b
    boolean geqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> c
    boolean leSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> d
    boolean leqSmallInteger(org.mathpiper.mpreduce.numbers.LispSmallInteger) -> e
org.mathpiper.mpreduce.packagedatastore.PDS -> org.c.a.f.a:
    java.lang.String name -> a
    boolean writeable -> a
    boolean untidy -> b
    java.io.RandomAccessFile f -> a
    java.util.Vector data -> a
    java.util.HashMap directory -> a
    byte[] buffer -> a
    long bufferPos -> a
    long pos -> b
    boolean bufferValid -> c
    int readCount -> a
    int memberData -> b
    int memberStart -> c
    void seek(long) -> a
    int read() -> a
    int read(byte[],int,int) -> a
    long getFilePointer() -> a
    long length() -> b
    void print() -> a
    org.mathpiper.mpreduce.LispObject members() -> a
    void readDirectory() -> b
    void addToDirectory(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject modulep(java.lang.String) -> a
org.mathpiper.mpreduce.packagedatastore.PDSEntry -> org.c.a.f.b:
    java.lang.String name -> a
    int loc -> a
    int len -> b
    long date -> a
    int ordering -> c
    int compareTo(java.lang.Object) -> compareTo
org.mathpiper.mpreduce.packagedatastore.PDSInputStream -> org.c.a.f.c:
    org.mathpiper.mpreduce.packagedatastore.PDS pds -> a
    long savedPosition -> a
    int left -> a
    int available() -> available
    void close() -> close
    boolean markSupported() -> markSupported
    int read() -> read
    int read(byte[]) -> read
    int read(byte[],int,int) -> read
org.mathpiper.mpreduce.packagedatastore.PDSOutputStream -> org.c.a.f.d:
    org.mathpiper.mpreduce.packagedatastore.PDS pds -> a
    java.lang.String member -> a
    int length -> a
    long savedPosition -> a
    void close() -> close
    void write(int) -> write
org.mathpiper.mpreduce.special.Specfn -> org.c.a.g.a:
    int progEvent -> a
    org.mathpiper.mpreduce.LispObject progData -> a
    java.lang.Object[][] specials -> a
org.mathpiper.mpreduce.special.Specfn$AndSpecial -> org.c.a.g.a$a:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$BlockSpecial -> org.c.a.g.a$b:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$CondSpecial -> org.c.a.g.a$c:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DeclareSpecial -> org.c.a.g.a$d:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DefunSpecial -> org.c.a.g.a$e:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$DmSpecial -> org.c.a.g.a$f:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$FunctionSpecial -> org.c.a.g.a$g:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$GoSpecial -> org.c.a.g.a$h:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$IfSpecial -> org.c.a.g.a$i:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LambdaSpecial -> org.c.a.g.a$j:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LetSpecial -> org.c.a.g.a$k:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$LetStarSpecial -> org.c.a.g.a$l:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ListSpecial -> org.c.a.g.a$m:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ListStarSpecial -> org.c.a.g.a$n:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$OrSpecial -> org.c.a.g.a$o:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$PlusSpecial -> org.c.a.g.a$p:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$ProgSpecial -> org.c.a.g.a$q:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$QuoteSpecial -> org.c.a.g.a$r:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$SetqSpecial -> org.c.a.g.a$s:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$TimesSpecial -> org.c.a.g.a$t:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$UnlessSpecial -> org.c.a.g.a$u:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.Specfn$WhenSpecial -> org.c.a.g.a$v:
    org.mathpiper.mpreduce.special.Specfn this$0 -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
org.mathpiper.mpreduce.special.SpecialFunction -> org.c.a.g.b:
    java.lang.String name -> a
    org.mathpiper.mpreduce.LispObject op(org.mathpiper.mpreduce.LispObject) -> t
    org.mathpiper.mpreduce.LispObject error(java.lang.String) -> a
    void iprint() -> b
    void blankprint() -> c
    void scan() -> f
    void dump() -> g
org.mathpiper.mpreduce.symbols.Gensym -> org.c.a.h.a:
    java.lang.String nameBase -> a
    int gensymCounter -> b
    int myNumber -> c
    void completeName() -> h
    void dump() -> g
org.mathpiper.mpreduce.symbols.Symbol -> org.c.a.h.b:
    int symbolCount -> d
    java.lang.String pname -> b
    int cacheFlags -> e
    java.lang.String cacheString -> c
    org.mathpiper.mpreduce.functions.lisp.LispFunction fn -> a
    org.mathpiper.mpreduce.special.SpecialFunction special -> a
    java.lang.StringBuffer cache -> a
    void completeName() -> h
    org.mathpiper.mpreduce.symbols.Symbol intern(java.lang.String,org.mathpiper.mpreduce.functions.lisp.LispFunction,org.mathpiper.mpreduce.special.SpecialFunction) -> a
    void remob(org.mathpiper.mpreduce.symbols.Symbol) -> a
    org.mathpiper.mpreduce.symbols.Symbol intern(java.lang.String) -> a
    org.mathpiper.mpreduce.LispObject eval() -> a
    java.lang.String toPrint() -> a
    void iprint() -> b
    void blankprint() -> c
    int lisphashCode() -> a
    void scan() -> f
    void dump() -> g
org.scilab.forge.jlatexmath.AccentedAtom -> org.scilab.forge.jlatexmath.AccentedAtom:
    org.scilab.forge.jlatexmath.SymbolAtom accent -> a
    boolean acc -> a
    boolean changeSize -> b
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom underbase -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.AlphabetRegistration -> org.scilab.forge.jlatexmath.AlphabetRegistration:
    java.lang.Character$UnicodeBlock[] JLM_GREEK -> a
    java.lang.Character$UnicodeBlock[] JLM_CYRILLIC -> b
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.AlphabetRegistrationException -> org.scilab.forge.jlatexmath.AlphabetRegistrationException:
org.scilab.forge.jlatexmath.ArrayOfAtoms -> org.scilab.forge.jlatexmath.ArrayOfAtoms:
    java.util.LinkedList array -> a
    int col -> a
    int row -> b
    void addCol() -> addCol
    void addCol(int) -> addCol
    void addRow() -> addRow
    void checkDimensions() -> checkDimensions
org.scilab.forge.jlatexmath.Atom -> org.scilab.forge.jlatexmath.Atom:
    int type -> a
    int type_limits -> b
    int alignment -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Atom clone() -> clone
    java.lang.Object clone() -> clone
org.scilab.forge.jlatexmath.BigDelimiterAtom -> org.scilab.forge.jlatexmath.BigDelimiterAtom:
    org.scilab.forge.jlatexmath.SymbolAtom delim -> a
    int size -> d
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.BigOperatorAtom -> org.scilab.forge.jlatexmath.BigOperatorAtom:
    org.scilab.forge.jlatexmath.Atom under -> b
    org.scilab.forge.jlatexmath.Atom over -> c
    org.scilab.forge.jlatexmath.Atom base -> a
    boolean limitsSet -> a
    boolean limits -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box changeWidth(org.scilab.forge.jlatexmath.Box,float) -> changeWidth
org.scilab.forge.jlatexmath.BoldAtom -> org.scilab.forge.jlatexmath.BoldAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Box -> org.scilab.forge.jlatexmath.Box:
    boolean DEBUG -> a
    java.awt.Color foreground -> a
    java.awt.Color background -> b
    java.awt.Color prevColor -> d
    float width -> a
    float height -> b
    float depth -> c
    float shift -> d
    int type -> a
    java.util.LinkedList children -> a
    org.scilab.forge.jlatexmath.Box parent -> a
    org.scilab.forge.jlatexmath.Box elderParent -> b
    java.awt.Color markForDEBUG -> c
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void setParent(org.scilab.forge.jlatexmath.Box) -> setParent
    org.scilab.forge.jlatexmath.Box getParent() -> getParent
    void setElderParent(org.scilab.forge.jlatexmath.Box) -> setElderParent
    org.scilab.forge.jlatexmath.Box getElderParent() -> getElderParent
    float getWidth() -> getWidth
    void negWidth() -> negWidth
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    float getShift() -> getShift
    void setWidth(float) -> setWidth
    void setDepth(float) -> setDepth
    void setHeight(float) -> setHeight
    void setShift(float) -> setShift
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
    void startDraw(java.awt.Graphics2D,float,float) -> startDraw
    void drawDebug(java.awt.Graphics2D,float,float,boolean) -> drawDebug
    void drawDebug(java.awt.Graphics2D,float,float) -> drawDebug
    void endDraw(java.awt.Graphics2D) -> endDraw
org.scilab.forge.jlatexmath.BreakFormula -> org.scilab.forge.jlatexmath.BreakFormula:
    org.scilab.forge.jlatexmath.Box split(org.scilab.forge.jlatexmath.Box,float,float) -> split
    float canBreak(java.util.Stack,org.scilab.forge.jlatexmath.HorizontalBox,float) -> canBreak
    int getBreakPosition(org.scilab.forge.jlatexmath.HorizontalBox,int) -> getBreakPosition
org.scilab.forge.jlatexmath.BreakFormula$Position -> org.scilab.forge.jlatexmath.BreakFormula$Position:
    int index -> a
    org.scilab.forge.jlatexmath.HorizontalBox hbox -> a
org.scilab.forge.jlatexmath.BreakMarkAtom -> org.scilab.forge.jlatexmath.BreakMarkAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.CedillaAtom -> org.scilab.forge.jlatexmath.CedillaAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Char -> org.scilab.forge.jlatexmath.Char:
    char c -> a
    java.awt.Font font -> a
    org.scilab.forge.jlatexmath.Metrics m -> a
    int fontCode -> a
    org.scilab.forge.jlatexmath.CharFont getCharFont() -> getCharFont
    char getChar() -> getChar
    java.awt.Font getFont() -> getFont
    int getFontCode() -> getFontCode
    float getWidth() -> getWidth
    float getItalic() -> getItalic
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    org.scilab.forge.jlatexmath.Metrics getMetrics() -> getMetrics
org.scilab.forge.jlatexmath.CharAtom -> org.scilab.forge.jlatexmath.CharAtom:
    char c -> a
    java.lang.String textStyle -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    char getCharacter() -> getCharacter
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.TeXFont,int,boolean) -> getChar
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
org.scilab.forge.jlatexmath.CharBox -> org.scilab.forge.jlatexmath.CharBox:
    org.scilab.forge.jlatexmath.CharFont cf -> a
    float size -> e
    char[] arr -> a
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
    java.lang.String toString() -> toString
org.scilab.forge.jlatexmath.CharFont -> org.scilab.forge.jlatexmath.CharFont:
    char c -> a
    int fontId -> a
    int boldFontId -> b
org.scilab.forge.jlatexmath.CharSymbol -> org.scilab.forge.jlatexmath.CharSymbol:
    boolean textSymbol -> a
    void markAsTextSymbol() -> markAsTextSymbol
    void removeMark() -> removeMark
    boolean isMarkedAsTextSymbol() -> isMarkedAsTextSymbol
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
org.scilab.forge.jlatexmath.ColorAtom -> org.scilab.forge.jlatexmath.ColorAtom:
    java.util.Map Colors -> a
    java.awt.Color background -> a
    java.awt.Color color -> b
    org.scilab.forge.jlatexmath.RowAtom elements -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
    java.awt.Color getColor(java.lang.String) -> getColor
    void initColors() -> initColors
    java.awt.Color convColor(float,float,float,float) -> convColor
org.scilab.forge.jlatexmath.CumulativeScriptsAtom -> org.scilab.forge.jlatexmath.CumulativeScriptsAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.RowAtom sup -> a
    org.scilab.forge.jlatexmath.RowAtom sub -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.DdotsAtom -> org.scilab.forge.jlatexmath.DdotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.DefaultTeXFont -> org.scilab.forge.jlatexmath.DefaultTeXFont:
    java.lang.String[] defaultTextStyleMappings -> a
    java.util.Map textStyleMappings -> b
    java.util.Map symbolMappings -> c
    org.scilab.forge.jlatexmath.FontInfo[] fontInfo -> a
    java.util.Map parameters -> d
    java.util.Map generalSettings -> e
    boolean magnificationEnable -> f
    java.util.List loadedAlphabets -> a
    java.util.Map registeredAlphabets -> a
    float factor -> a
    boolean isBold -> a
    boolean isRoman -> b
    boolean isSs -> c
    boolean isTt -> d
    boolean isIt -> e
    float size -> b
    void addTeXFontDescription(java.lang.String) -> addTeXFontDescription
    void addTeXFontDescription(java.io.InputStream,java.lang.String) -> addTeXFontDescription
    void addTeXFontDescription(java.lang.Object,java.io.InputStream,java.lang.String) -> addTeXFontDescription
    void addAlphabet(java.lang.Character$UnicodeBlock,java.io.InputStream,java.lang.String,java.io.InputStream,java.lang.String,java.io.InputStream,java.lang.String) -> addAlphabet
    void addAlphabet(java.lang.Object,java.lang.Character$UnicodeBlock[],java.lang.String) -> addAlphabet
    void addAlphabet(java.lang.Character$UnicodeBlock,java.lang.String) -> addAlphabet
    void addAlphabet(org.scilab.forge.jlatexmath.AlphabetRegistration) -> addAlphabet
    void registerAlphabet(org.scilab.forge.jlatexmath.AlphabetRegistration) -> registerAlphabet
    org.scilab.forge.jlatexmath.TeXFont copy() -> copy
    org.scilab.forge.jlatexmath.TeXFont deriveFont(float) -> deriveFont
    org.scilab.forge.jlatexmath.TeXFont scaleFont(float) -> scaleFont
    float getScaleFactor() -> getScaleFactor
    float getAxisHeight(int) -> getAxisHeight
    float getBigOpSpacing1(int) -> getBigOpSpacing1
    float getBigOpSpacing2(int) -> getBigOpSpacing2
    float getBigOpSpacing3(int) -> getBigOpSpacing3
    float getBigOpSpacing4(int) -> getBigOpSpacing4
    float getBigOpSpacing5(int) -> getBigOpSpacing5
    org.scilab.forge.jlatexmath.Char getChar(char,org.scilab.forge.jlatexmath.CharFont[],int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(char,java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.CharFont,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getDefaultChar(char,int) -> getDefaultChar
    float getDefaultRuleThickness(int) -> getDefaultRuleThickness
    float getDenom1(int) -> getDenom1
    float getDenom2(int) -> getDenom2
    org.scilab.forge.jlatexmath.Extension getExtension(org.scilab.forge.jlatexmath.Char,int) -> getExtension
    float getKern(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont,int) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont) -> getLigature
    org.scilab.forge.jlatexmath.Metrics getMetrics(org.scilab.forge.jlatexmath.CharFont,float) -> getMetrics
    int getMuFontId() -> getMuFontId
    org.scilab.forge.jlatexmath.Char getNextLarger(org.scilab.forge.jlatexmath.Char,int) -> getNextLarger
    float getNum1(int) -> getNum1
    float getNum2(int) -> getNum2
    float getNum3(int) -> getNum3
    float getQuad(int,int) -> getQuad
    float getSize() -> getSize
    float getSkew(org.scilab.forge.jlatexmath.CharFont,int) -> getSkew
    float getSpace(int) -> getSpace
    float getSub1(int) -> getSub1
    float getSub2(int) -> getSub2
    float getSubDrop(int) -> getSubDrop
    float getSup1(int) -> getSup1
    float getSup2(int) -> getSup2
    float getSup3(int) -> getSup3
    float getSupDrop(int) -> getSupDrop
    float getXHeight(int,int) -> getXHeight
    boolean hasNextLarger(org.scilab.forge.jlatexmath.Char) -> hasNextLarger
    void setBold(boolean) -> setBold
    boolean getBold() -> getBold
    void setRoman(boolean) -> setRoman
    boolean getRoman() -> getRoman
    void setTt(boolean) -> setTt
    boolean getTt() -> getTt
    void setIt(boolean) -> setIt
    boolean getIt() -> getIt
    void setSs(boolean) -> setSs
    boolean getSs() -> getSs
    boolean hasSpace(int) -> hasSpace
    boolean isExtensionChar(org.scilab.forge.jlatexmath.Char) -> isExtensionChar
    void setMathSizes(float,float,float,float) -> setMathSizes
    void setMagnification(float) -> setMagnification
    void enableMagnification(boolean) -> enableMagnification
    float getParameter(java.lang.String) -> getParameter
    float getSizeFactor(int) -> getSizeFactor
org.scilab.forge.jlatexmath.DefaultTeXFontParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser:
    boolean registerFontExceptionDisplayed -> a
    boolean shouldRegisterFonts -> b
    javax.xml.parsers.DocumentBuilderFactory factory -> a
    java.util.ArrayList Font_ID -> a
    java.util.Map rangeTypeMappings -> a
    java.util.Map charChildParsers -> b
    java.util.Map parsedTextStyles -> c
    org.w3c.dom.Element root -> a
    java.lang.Object base -> a
    void setCharChildParsers() -> setCharChildParsers
    org.scilab.forge.jlatexmath.FontInfo[] parseFontDescriptions(org.scilab.forge.jlatexmath.FontInfo[],java.io.InputStream,java.lang.String) -> parseFontDescriptions
    org.scilab.forge.jlatexmath.FontInfo[] parseFontDescriptions(org.scilab.forge.jlatexmath.FontInfo[]) -> parseFontDescriptions
    void parseExtraPath() -> parseExtraPath
    void processCharElement(org.w3c.dom.Element,org.scilab.forge.jlatexmath.FontInfo) -> processCharElement
    void registerFonts(boolean) -> registerFonts
    java.awt.Font createFont(java.lang.String) -> createFont
    java.awt.Font createFont(java.io.InputStream,java.lang.String) -> createFont
    java.util.Map parseSymbolMappings() -> parseSymbolMappings
    java.lang.String[] parseDefaultTextStyleMappings() -> parseDefaultTextStyleMappings
    java.util.Map parseParameters() -> parseParameters
    java.util.Map parseGeneralSettings() -> parseGeneralSettings
    java.util.Map parseTextStyleMappings() -> parseTextStyleMappings
    java.util.Map parseStyleMappings() -> parseStyleMappings
    void setRangeTypeMappings() -> setRangeTypeMappings
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
    float getFloatAndCheck(java.lang.String,org.w3c.dom.Element) -> getFloatAndCheck
    int getIntAndCheck(java.lang.String,org.w3c.dom.Element) -> getIntAndCheck
    int getOptionalInt(java.lang.String,org.w3c.dom.Element,int) -> getOptionalInt
    float getOptionalFloat(java.lang.String,org.w3c.dom.Element,float) -> getOptionalFloat
    java.lang.String access$000(java.lang.String,org.w3c.dom.Element) -> access$000
org.scilab.forge.jlatexmath.DefaultTeXFontParser$CharChildParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$CharChildParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$ExtensionParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$ExtensionParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$KernParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$KernParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$LigParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$LigParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DefaultTeXFontParser$NextLargerParser -> org.scilab.forge.jlatexmath.DefaultTeXFontParser$NextLargerParser:
    void parse(org.w3c.dom.Element,char,org.scilab.forge.jlatexmath.FontInfo) -> parse
org.scilab.forge.jlatexmath.DelimiterFactory -> org.scilab.forge.jlatexmath.DelimiterFactory:
    org.scilab.forge.jlatexmath.Box create(org.scilab.forge.jlatexmath.SymbolAtom,org.scilab.forge.jlatexmath.TeXEnvironment,int) -> create
    org.scilab.forge.jlatexmath.Box create(java.lang.String,org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
org.scilab.forge.jlatexmath.DelimiterMappingNotFoundException -> org.scilab.forge.jlatexmath.DelimiterMappingNotFoundException:
org.scilab.forge.jlatexmath.DoubleFramedAtom -> org.scilab.forge.jlatexmath.DoubleFramedAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.Dummy -> org.scilab.forge.jlatexmath.Dummy:
    org.scilab.forge.jlatexmath.Atom el -> a
    boolean textSymbol -> a
    int type -> a
    void setType(int) -> setType
    int getType() -> getType
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    boolean isCharSymbol() -> isCharSymbol
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
    void changeAtom(org.scilab.forge.jlatexmath.FixedCharAtom) -> changeAtom
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    void markAsTextSymbol() -> markAsTextSymbol
    boolean isKern() -> isKern
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.EmptyAtom -> org.scilab.forge.jlatexmath.EmptyAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.EmptyFormulaException -> org.scilab.forge.jlatexmath.EmptyFormulaException:
org.scilab.forge.jlatexmath.Extension -> org.scilab.forge.jlatexmath.Extension:
    org.scilab.forge.jlatexmath.Char top -> a
    org.scilab.forge.jlatexmath.Char middle -> b
    org.scilab.forge.jlatexmath.Char bottom -> c
    org.scilab.forge.jlatexmath.Char repeat -> d
    boolean hasTop() -> hasTop
    boolean hasMiddle() -> hasMiddle
    boolean hasBottom() -> hasBottom
    org.scilab.forge.jlatexmath.Char getTop() -> getTop
    org.scilab.forge.jlatexmath.Char getMiddle() -> getMiddle
    org.scilab.forge.jlatexmath.Char getRepeat() -> getRepeat
    org.scilab.forge.jlatexmath.Char getBottom() -> getBottom
org.scilab.forge.jlatexmath.FBoxAtom -> org.scilab.forge.jlatexmath.FBoxAtom:
    float INTERSPACE -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    java.awt.Color bg -> a
    java.awt.Color line -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FencedAtom -> org.scilab.forge.jlatexmath.FencedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.SymbolAtom left -> a
    org.scilab.forge.jlatexmath.SymbolAtom right -> b
    java.util.List middle -> a
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void center(org.scilab.forge.jlatexmath.Box,float) -> center
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FixedCharAtom -> org.scilab.forge.jlatexmath.FixedCharAtom:
    org.scilab.forge.jlatexmath.CharFont cf -> a
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FontAlreadyLoadedException -> org.scilab.forge.jlatexmath.FontAlreadyLoadedException:
org.scilab.forge.jlatexmath.FontInfo -> org.scilab.forge.jlatexmath.FontInfo:
    java.util.Map fonts -> a
    int fontId -> a
    java.awt.Font font -> a
    java.lang.Object base -> a
    java.lang.String path -> f
    java.lang.String fontName -> g
    java.util.Map lig -> b
    java.util.Map kern -> c
    float[][] metrics -> a
    org.scilab.forge.jlatexmath.CharFont[] nextLarger -> a
    int[][] extensions -> a
    java.util.HashMap unicode -> a
    char skewChar -> a
    float xHeight -> a
    float space -> b
    float quad -> c
    int boldId -> b
    int romanId -> c
    int ssId -> d
    int ttId -> e
    int itId -> f
    java.lang.String boldVersion -> a
    java.lang.String romanVersion -> b
    java.lang.String ssVersion -> c
    java.lang.String ttVersion -> d
    java.lang.String itVersion -> e
    void addKern(char,char,float) -> addKern
    void addLigature(char,char,char) -> addLigature
    int[] getExtension(char) -> getExtension
    float getKern(char,char,float) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(char,char) -> getLigature
    float[] getMetrics(char) -> getMetrics
    org.scilab.forge.jlatexmath.CharFont getNextLarger(char) -> getNextLarger
    float getQuad(float) -> getQuad
    char getSkewChar() -> getSkewChar
    float getSpace(float) -> getSpace
    float getXHeight(float) -> getXHeight
    boolean hasSpace() -> hasSpace
    void setExtension(char,int[]) -> setExtension
    void setMetrics(char,float[]) -> setMetrics
    void setNextLarger(char,char,int) -> setNextLarger
    void setSkewChar(char) -> setSkewChar
    int getId() -> getId
    int getBoldId() -> getBoldId
    int getRomanId() -> getRomanId
    int getTtId() -> getTtId
    int getItId() -> getItId
    int getSsId() -> getSsId
    void setSsId(int) -> setSsId
    void setTtId(int) -> setTtId
    void setItId(int) -> setItId
    void setRomanId(int) -> setRomanId
    void setBoldId(int) -> setBoldId
    java.awt.Font getFont() -> getFont
    java.awt.Font getFont(int) -> getFont
org.scilab.forge.jlatexmath.FontInfo$CharCouple -> org.scilab.forge.jlatexmath.FontInfo$CharCouple:
    char left -> a
    char right -> b
    org.scilab.forge.jlatexmath.FontInfo this$0 -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.scilab.forge.jlatexmath.FormulaNotFoundException -> org.scilab.forge.jlatexmath.FormulaNotFoundException:
org.scilab.forge.jlatexmath.FractionAtom -> org.scilab.forge.jlatexmath.FractionAtom:
    boolean noDefault -> a
    int unit -> d
    int numAlign -> e
    int denomAlign -> f
    org.scilab.forge.jlatexmath.Atom numerator -> a
    org.scilab.forge.jlatexmath.Atom denominator -> b
    float thickness -> a
    float defFactor -> b
    boolean defFactorSet -> b
    int checkAlignment(int) -> checkAlignment
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.FramedBox -> org.scilab.forge.jlatexmath.FramedBox:
    org.scilab.forge.jlatexmath.Box box -> c
    float thickness -> e
    float space -> f
    java.awt.Color line -> d
    java.awt.Color bg -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.GeoGebraLogoAtom -> org.scilab.forge.jlatexmath.GeoGebraLogoAtom:
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GeoGebraLogoBox -> org.scilab.forge.jlatexmath.GeoGebraLogoBox:
    java.awt.Color gray -> d
    java.awt.Color blue -> e
    java.awt.BasicStroke st -> a
    java.awt.BasicStroke stC -> b
    void draw(java.awt.Graphics2D,float,float) -> draw
    void drawCircle(java.awt.Graphics2D,float,float) -> drawCircle
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.Glue -> org.scilab.forge.jlatexmath.Glue:
    float space -> a
    float stretch -> b
    float shrink -> c
    java.lang.String name -> a
    org.scilab.forge.jlatexmath.Glue[] glueTypes -> a
    int[][][] glueTable -> a
    java.lang.String getName() -> getName
    org.scilab.forge.jlatexmath.Box get(int,int,org.scilab.forge.jlatexmath.TeXEnvironment) -> get
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GlueBox -> org.scilab.forge.jlatexmath.GlueBox:
    float stretch -> e
    float shrink -> f
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.GlueSettingsParser -> org.scilab.forge.jlatexmath.GlueSettingsParser:
    java.util.Map typeMappings -> a
    java.util.Map glueTypeMappings -> b
    org.scilab.forge.jlatexmath.Glue[] glueTypes -> a
    java.util.Map styleMappings -> c
    org.w3c.dom.Element root -> a
    void setStyleMappings() -> setStyleMappings
    void parseGlueTypes() -> parseGlueTypes
    org.scilab.forge.jlatexmath.Glue createGlue(org.w3c.dom.Element,java.lang.String) -> createGlue
    void setTypeMappings() -> setTypeMappings
    org.scilab.forge.jlatexmath.Glue[] getGlueTypes() -> getGlueTypes
    int[][][] createGlueTable() -> createGlueTable
    void checkMapping(java.lang.Object,java.lang.String,java.lang.String,java.lang.String) -> checkMapping
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.GraphicsAtom -> org.scilab.forge.jlatexmath.GraphicsAtom:
    java.awt.Image image -> a
    java.awt.image.BufferedImage bimage -> a
    java.awt.Label c -> a
    int w -> d
    int h -> e
    org.scilab.forge.jlatexmath.Atom base -> a
    boolean first -> a
    int interp -> f
    void buildAtom(java.lang.String) -> buildAtom
    void draw() -> draw
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.GraphicsBox -> org.scilab.forge.jlatexmath.GraphicsBox:
    java.awt.image.BufferedImage image -> a
    float scl -> e
    java.lang.Object interp -> a
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.HdotsforAtom -> org.scilab.forge.jlatexmath.HdotsforAtom:
    org.scilab.forge.jlatexmath.Atom ldotp -> b
    org.scilab.forge.jlatexmath.Atom thin -> c
    float coeff -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.HlineAtom -> org.scilab.forge.jlatexmath.HlineAtom:
    float width -> a
    float shift -> b
    void setWidth(float) -> setWidth
    void setShift(float) -> setShift
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.HorizontalBox -> org.scilab.forge.jlatexmath.HorizontalBox:
    float curPos -> e
    java.util.List breakPositions -> a
    org.scilab.forge.jlatexmath.HorizontalBox cloneBox() -> cloneBox
    void draw(java.awt.Graphics2D,float,float) -> draw
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void recalculate(org.scilab.forge.jlatexmath.Box) -> recalculate
    int getLastFontId() -> getLastFontId
    void addBreakPosition(int) -> addBreakPosition
    org.scilab.forge.jlatexmath.HorizontalBox[] split(int) -> split
    org.scilab.forge.jlatexmath.HorizontalBox[] splitRemove(int) -> splitRemove
    org.scilab.forge.jlatexmath.HorizontalBox[] split(int,int) -> split
org.scilab.forge.jlatexmath.HorizontalRule -> org.scilab.forge.jlatexmath.HorizontalRule:
    java.awt.Color color -> d
    float speShift -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.IJAtom -> org.scilab.forge.jlatexmath.IJAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.IddotsAtom -> org.scilab.forge.jlatexmath.IddotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.InvalidAtomTypeException -> org.scilab.forge.jlatexmath.InvalidAtomTypeException:
org.scilab.forge.jlatexmath.InvalidDelimiterException -> org.scilab.forge.jlatexmath.InvalidDelimiterException:
org.scilab.forge.jlatexmath.InvalidDelimiterTypeException -> org.scilab.forge.jlatexmath.InvalidDelimiterTypeException:
org.scilab.forge.jlatexmath.InvalidMatrixException -> org.scilab.forge.jlatexmath.InvalidMatrixException:
org.scilab.forge.jlatexmath.InvalidSymbolTypeException -> org.scilab.forge.jlatexmath.InvalidSymbolTypeException:
org.scilab.forge.jlatexmath.InvalidTeXFormulaException -> org.scilab.forge.jlatexmath.InvalidTeXFormulaException:
org.scilab.forge.jlatexmath.InvalidUnitException -> org.scilab.forge.jlatexmath.InvalidUnitException:
org.scilab.forge.jlatexmath.ItAtom -> org.scilab.forge.jlatexmath.ItAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.JMathTeXException -> org.scilab.forge.jlatexmath.JMathTeXException:
org.scilab.forge.jlatexmath.JavaFontRenderingAtom -> org.scilab.forge.jlatexmath.JavaFontRenderingAtom:
    java.lang.String str -> a
    int type -> d
    org.scilab.forge.jlatexmath.TeXFormula$FontInfos fontInfos -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.JavaFontRenderingBox -> org.scilab.forge.jlatexmath.JavaFontRenderingBox:
    java.awt.Graphics2D TEMPGRAPHIC -> a
    java.awt.Font font -> a
    java.lang.String str -> a
    java.awt.font.TextLayout text -> a
    float size -> e
    java.awt.font.TextAttribute KERNING -> a
    java.lang.Integer KERNING_ON -> a
    java.awt.font.TextAttribute LIGATURES -> b
    java.lang.Integer LIGATURES_ON -> b
    void setFont(java.lang.String) -> setFont
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.LCaronAtom -> org.scilab.forge.jlatexmath.LCaronAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.LaTeXAtom -> org.scilab.forge.jlatexmath.LaTeXAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.LapedAtom -> org.scilab.forge.jlatexmath.LapedAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    char type -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MacroInfo -> org.scilab.forge.jlatexmath.MacroInfo:
    java.util.HashMap Commands -> a
    java.util.HashMap Packages -> b
    java.lang.Object pack -> a
    java.lang.reflect.Method macro -> a
    int nbArgs -> a
    boolean hasOptions -> a
    int posOpts -> b
    java.lang.Object invoke(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invoke
org.scilab.forge.jlatexmath.MathAtom -> org.scilab.forge.jlatexmath.MathAtom:
    int style -> d
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MatrixAtom -> org.scilab.forge.jlatexmath.MatrixAtom:
    org.scilab.forge.jlatexmath.SpaceAtom hsep -> a
    org.scilab.forge.jlatexmath.SpaceAtom semihsep -> b
    org.scilab.forge.jlatexmath.SpaceAtom vsep_in -> c
    org.scilab.forge.jlatexmath.SpaceAtom vsep_ext_top -> d
    org.scilab.forge.jlatexmath.SpaceAtom vsep_ext_bot -> e
    org.scilab.forge.jlatexmath.Box nullBox -> a
    org.scilab.forge.jlatexmath.ArrayOfAtoms matrix -> a
    int[] position -> a
    java.util.Map vlines -> a
    int type -> d
    boolean isPartial -> a
    org.scilab.forge.jlatexmath.SpaceAtom align -> f
    void parsePositions(java.lang.StringBuffer) -> parsePositions
    org.scilab.forge.jlatexmath.Box[] getColumnSep(org.scilab.forge.jlatexmath.TeXEnvironment,float) -> getColumnSep
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box generateMulticolumn(org.scilab.forge.jlatexmath.TeXEnvironment,org.scilab.forge.jlatexmath.Box[],float[],int,int) -> generateMulticolumn
org.scilab.forge.jlatexmath.Metrics -> org.scilab.forge.jlatexmath.Metrics:
    float w -> a
    float h -> b
    float d -> c
    float i -> d
    float s -> e
    float getWidth() -> getWidth
    float getHeight() -> getHeight
    float getDepth() -> getDepth
    float getItalic() -> getItalic
    float getSize() -> getSize
org.scilab.forge.jlatexmath.MiddleAtom -> org.scilab.forge.jlatexmath.MiddleAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box box -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MonoScaleAtom -> org.scilab.forge.jlatexmath.MonoScaleAtom:
    float factor -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MulticolumnAtom -> org.scilab.forge.jlatexmath.MulticolumnAtom:
    int n -> d
    int align -> e
    float w -> a
    org.scilab.forge.jlatexmath.Atom cols -> a
    int beforeVlines -> f
    int afterVlines -> g
    int row -> h
    int col -> i
    void setWidth(float) -> setWidth
    int getSkipped() -> getSkipped
    boolean hasRightVline() -> hasRightVline
    void setRowColumn(int,int) -> setRowColumn
    int getRow() -> getRow
    int getCol() -> getCol
    int parseAlign(java.lang.String) -> parseAlign
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.MultlineAtom -> org.scilab.forge.jlatexmath.MultlineAtom:
    org.scilab.forge.jlatexmath.SpaceAtom vsep_in -> a
    org.scilab.forge.jlatexmath.ArrayOfAtoms column -> a
    int type -> d
    boolean isPartial -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.NewCommandMacro -> org.scilab.forge.jlatexmath.NewCommandMacro:
    java.util.HashMap macrocode -> a
    java.util.HashMap macroreplacement -> b
    void addNewCommand(java.lang.String,java.lang.String,int) -> addNewCommand
    void addNewCommand(java.lang.String,java.lang.String,int,java.lang.String) -> addNewCommand
    boolean isMacro(java.lang.String) -> isMacro
    void addReNewCommand(java.lang.String,java.lang.String,int) -> addReNewCommand
    java.lang.String executeMacro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> executeMacro
org.scilab.forge.jlatexmath.NewEnvironmentMacro -> org.scilab.forge.jlatexmath.NewEnvironmentMacro:
    void addNewEnvironment(java.lang.String,java.lang.String,java.lang.String,int) -> addNewEnvironment
    void addReNewEnvironment(java.lang.String,java.lang.String,java.lang.String,int) -> addReNewEnvironment
org.scilab.forge.jlatexmath.NthRoot -> org.scilab.forge.jlatexmath.NthRoot:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom root -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OgonekAtom -> org.scilab.forge.jlatexmath.OgonekAtom:
    org.scilab.forge.jlatexmath.SymbolAtom ogonek -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OvalAtom -> org.scilab.forge.jlatexmath.OvalAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.OvalBox -> org.scilab.forge.jlatexmath.OvalBox:
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.OverBar -> org.scilab.forge.jlatexmath.OverBar:
org.scilab.forge.jlatexmath.OverUnderBox -> org.scilab.forge.jlatexmath.OverUnderBox:
    org.scilab.forge.jlatexmath.Box base -> c
    org.scilab.forge.jlatexmath.Box del -> d
    org.scilab.forge.jlatexmath.Box script -> e
    float kern -> e
    boolean over -> b
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.OverUnderDelimiter -> org.scilab.forge.jlatexmath.OverUnderDelimiter:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom script -> b
    org.scilab.forge.jlatexmath.SymbolAtom symbol -> a
    org.scilab.forge.jlatexmath.SpaceAtom kern -> a
    boolean over -> a
    void addScript(org.scilab.forge.jlatexmath.Atom) -> addScript
    boolean isOver() -> isOver
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    float getMaxWidth(org.scilab.forge.jlatexmath.Box,org.scilab.forge.jlatexmath.Box,org.scilab.forge.jlatexmath.Box) -> getMaxWidth
org.scilab.forge.jlatexmath.OverlinedAtom -> org.scilab.forge.jlatexmath.OverlinedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ParseException -> org.scilab.forge.jlatexmath.ParseException:
org.scilab.forge.jlatexmath.ParseOption -> org.scilab.forge.jlatexmath.ParseOption:
    java.util.Map parseMap(java.lang.String) -> parseMap
org.scilab.forge.jlatexmath.PhantomAtom -> org.scilab.forge.jlatexmath.PhantomAtom:
    org.scilab.forge.jlatexmath.RowAtom elements -> a
    boolean w -> a
    boolean h -> b
    boolean d -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.PredefMacroInfo -> org.scilab.forge.jlatexmath.PredefMacroInfo:
    int id -> c
    java.lang.Object invoke(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invoke
    java.lang.Object invokeID(int,org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> invokeID
org.scilab.forge.jlatexmath.PredefMacros -> org.scilab.forge.jlatexmath.PredefMacros:
    org.scilab.forge.jlatexmath.Atom Braket_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Braket_macro
    org.scilab.forge.jlatexmath.Atom Set_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Set_macro
    org.scilab.forge.jlatexmath.Atom spATbreve_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> spATbreve_macro
    org.scilab.forge.jlatexmath.Atom spAThat_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> spAThat_macro
    org.scilab.forge.jlatexmath.Atom hvspace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hvspace_macro
    org.scilab.forge.jlatexmath.Atom clrlap_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> clrlap_macro
    org.scilab.forge.jlatexmath.Atom mathclrlap_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathclrlap_macro
    org.scilab.forge.jlatexmath.Atom includegraphics_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> includegraphics_macro
    org.scilab.forge.jlatexmath.Atom rule_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rule_macro
    org.scilab.forge.jlatexmath.Atom cfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cfrac_macro
    org.scilab.forge.jlatexmath.Atom frac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> frac_macro
    org.scilab.forge.jlatexmath.Atom sfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sfrac_macro
    org.scilab.forge.jlatexmath.Atom genfrac_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> genfrac_macro
    org.scilab.forge.jlatexmath.Atom over_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> over_macro
    org.scilab.forge.jlatexmath.Atom overwithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overwithdelims_macro
    org.scilab.forge.jlatexmath.Atom atop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> atop_macro
    org.scilab.forge.jlatexmath.Atom atopwithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> atopwithdelims_macro
    org.scilab.forge.jlatexmath.Atom choose_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> choose_macro
    org.scilab.forge.jlatexmath.Atom binom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> binom_macro
    org.scilab.forge.jlatexmath.Atom above_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> above_macro
    org.scilab.forge.jlatexmath.Atom abovewithdelims_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> abovewithdelims_macro
    org.scilab.forge.jlatexmath.Atom textstyle_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textstyle_macros
    org.scilab.forge.jlatexmath.Atom mbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mbox_macro
    org.scilab.forge.jlatexmath.Atom text_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> text_macro
    org.scilab.forge.jlatexmath.Atom underscore_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underscore_macro
    org.scilab.forge.jlatexmath.Atom accent_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accent_macros
    org.scilab.forge.jlatexmath.Atom grkaccent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> grkaccent_macro
    org.scilab.forge.jlatexmath.Atom accent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accent_macro
    org.scilab.forge.jlatexmath.Atom accentbis_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accentbis_macros
    org.scilab.forge.jlatexmath.Atom cedilla_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cedilla_macro
    org.scilab.forge.jlatexmath.Atom IJ_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> IJ_macro
    org.scilab.forge.jlatexmath.Atom TStroke_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> TStroke_macro
    org.scilab.forge.jlatexmath.Atom LCaron_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> LCaron_macro
    org.scilab.forge.jlatexmath.Atom tcaron_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> tcaron_macro
    org.scilab.forge.jlatexmath.Atom ogonek_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ogonek_macro
    org.scilab.forge.jlatexmath.Atom nbsp_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> nbsp_macro
    org.scilab.forge.jlatexmath.Atom sqrt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sqrt_macro
    org.scilab.forge.jlatexmath.Atom overrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overrightarrow_macro
    org.scilab.forge.jlatexmath.Atom overleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overleftarrow_macro
    org.scilab.forge.jlatexmath.Atom overleftrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overleftrightarrow_macro
    org.scilab.forge.jlatexmath.Atom underrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underrightarrow_macro
    org.scilab.forge.jlatexmath.Atom underleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underleftarrow_macro
    org.scilab.forge.jlatexmath.Atom underleftrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underleftrightarrow_macro
    org.scilab.forge.jlatexmath.Atom xleftarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> xleftarrow_macro
    org.scilab.forge.jlatexmath.Atom xrightarrow_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> xrightarrow_macro
    org.scilab.forge.jlatexmath.Atom sideset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sideset_macro
    org.scilab.forge.jlatexmath.Atom prescript_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> prescript_macro
    org.scilab.forge.jlatexmath.Atom underbrace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underbrace_macro
    org.scilab.forge.jlatexmath.Atom overbrace_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overbrace_macro
    org.scilab.forge.jlatexmath.Atom underbrack_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underbrack_macro
    org.scilab.forge.jlatexmath.Atom overbrack_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overbrack_macro
    org.scilab.forge.jlatexmath.Atom underparen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underparen_macro
    org.scilab.forge.jlatexmath.Atom overparen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overparen_macro
    org.scilab.forge.jlatexmath.Atom overline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overline_macro
    org.scilab.forge.jlatexmath.Atom underline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underline_macro
    org.scilab.forge.jlatexmath.Atom mathop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathop_macro
    org.scilab.forge.jlatexmath.Atom mathpunct_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathpunct_macro
    org.scilab.forge.jlatexmath.Atom mathord_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathord_macro
    org.scilab.forge.jlatexmath.Atom mathrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathrel_macro
    org.scilab.forge.jlatexmath.Atom mathinner_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathinner_macro
    org.scilab.forge.jlatexmath.Atom mathbin_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathbin_macro
    org.scilab.forge.jlatexmath.Atom mathopen_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathopen_macro
    org.scilab.forge.jlatexmath.Atom mathclose_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathclose_macro
    org.scilab.forge.jlatexmath.Atom joinrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> joinrel_macro
    org.scilab.forge.jlatexmath.Atom smash_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smash_macro
    org.scilab.forge.jlatexmath.Atom vdots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> vdots_macro
    org.scilab.forge.jlatexmath.Atom ddots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ddots_macro
    org.scilab.forge.jlatexmath.Atom iddots_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iddots_macro
    org.scilab.forge.jlatexmath.Atom nolimits_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> nolimits_macro
    org.scilab.forge.jlatexmath.Atom limits_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> limits_macro
    org.scilab.forge.jlatexmath.Atom normal_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> normal_macro
    org.scilab.forge.jlatexmath.Atom left_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> left_macro
    org.scilab.forge.jlatexmath.Atom leftparenthesis_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> leftparenthesis_macro
    org.scilab.forge.jlatexmath.Atom leftbracket_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> leftbracket_macro
    org.scilab.forge.jlatexmath.Atom middle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> middle_macro
    org.scilab.forge.jlatexmath.Atom cr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cr_macro
    org.scilab.forge.jlatexmath.Atom backslashcr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> backslashcr_macro
    org.scilab.forge.jlatexmath.Atom intertext_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> intertext_macro
    org.scilab.forge.jlatexmath.Atom smallmatrixATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smallmatrixATATenv_macro
    org.scilab.forge.jlatexmath.Atom matrixATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> matrixATATenv_macro
    org.scilab.forge.jlatexmath.Atom multicolumn_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> multicolumn_macro
    org.scilab.forge.jlatexmath.Atom hdotsfor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hdotsfor_macro
    org.scilab.forge.jlatexmath.Atom arrayATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> arrayATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignATATenv_macro
    org.scilab.forge.jlatexmath.Atom flalignATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> flalignATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignatATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignatATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignedATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignedATATenv_macro
    org.scilab.forge.jlatexmath.Atom alignedatATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> alignedatATATenv_macro
    org.scilab.forge.jlatexmath.Atom multlineATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> multlineATATenv_macro
    org.scilab.forge.jlatexmath.Atom gatherATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> gatherATATenv_macro
    org.scilab.forge.jlatexmath.Atom gatheredATATenv_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> gatheredATATenv_macro
    org.scilab.forge.jlatexmath.Atom shoveright_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shoveright_macro
    org.scilab.forge.jlatexmath.Atom shoveleft_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shoveleft_macro
    org.scilab.forge.jlatexmath.Atom newcommand_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> newcommand_macro
    org.scilab.forge.jlatexmath.Atom renewcommand_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> renewcommand_macro
    org.scilab.forge.jlatexmath.Atom makeatletter_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> makeatletter_macro
    org.scilab.forge.jlatexmath.Atom makeatother_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> makeatother_macro
    org.scilab.forge.jlatexmath.Atom newenvironment_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> newenvironment_macro
    org.scilab.forge.jlatexmath.Atom renewenvironment_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> renewenvironment_macro
    org.scilab.forge.jlatexmath.Atom fbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fbox_macro
    org.scilab.forge.jlatexmath.Atom stackrel_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> stackrel_macro
    org.scilab.forge.jlatexmath.Atom stackbin_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> stackbin_macro
    org.scilab.forge.jlatexmath.Atom overset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> overset_macro
    org.scilab.forge.jlatexmath.Atom underset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underset_macro
    org.scilab.forge.jlatexmath.Atom accentset_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> accentset_macro
    org.scilab.forge.jlatexmath.Atom underaccent_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> underaccent_macro
    org.scilab.forge.jlatexmath.Atom undertilde_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> undertilde_macro
    org.scilab.forge.jlatexmath.Atom boldsymbol_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> boldsymbol_macro
    org.scilab.forge.jlatexmath.Atom mathrm_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathrm_macro
    org.scilab.forge.jlatexmath.Atom rm_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rm_macro
    org.scilab.forge.jlatexmath.Atom mathbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathbf_macro
    org.scilab.forge.jlatexmath.Atom bf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bf_macro
    org.scilab.forge.jlatexmath.Atom mathtt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathtt_macro
    org.scilab.forge.jlatexmath.Atom tt_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> tt_macro
    org.scilab.forge.jlatexmath.Atom mathit_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathit_macro
    org.scilab.forge.jlatexmath.Atom it_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> it_macro
    org.scilab.forge.jlatexmath.Atom mathsf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> mathsf_macro
    org.scilab.forge.jlatexmath.Atom sf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sf_macro
    org.scilab.forge.jlatexmath.Atom LaTeX_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> LaTeX_macro
    org.scilab.forge.jlatexmath.Atom GeoGebra_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> GeoGebra_macro
    org.scilab.forge.jlatexmath.Atom hphantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hphantom_macro
    org.scilab.forge.jlatexmath.Atom vphantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> vphantom_macro
    org.scilab.forge.jlatexmath.Atom phantom_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> phantom_macro
    org.scilab.forge.jlatexmath.Atom big_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> big_macro
    org.scilab.forge.jlatexmath.Atom Big_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Big_macro
    org.scilab.forge.jlatexmath.Atom bigg_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigg_macro
    org.scilab.forge.jlatexmath.Atom Bigg_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigg_macro
    org.scilab.forge.jlatexmath.Atom bigl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigl_macro
    org.scilab.forge.jlatexmath.Atom Bigl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigl_macro
    org.scilab.forge.jlatexmath.Atom biggl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> biggl_macro
    org.scilab.forge.jlatexmath.Atom Biggl_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Biggl_macro
    org.scilab.forge.jlatexmath.Atom bigr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bigr_macro
    org.scilab.forge.jlatexmath.Atom Bigr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Bigr_macro
    org.scilab.forge.jlatexmath.Atom biggr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> biggr_macro
    org.scilab.forge.jlatexmath.Atom Biggr_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Biggr_macro
    org.scilab.forge.jlatexmath.Atom displaystyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> displaystyle_macro
    org.scilab.forge.jlatexmath.Atom scriptstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scriptstyle_macro
    org.scilab.forge.jlatexmath.Atom textstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textstyle_macro
    org.scilab.forge.jlatexmath.Atom scriptscriptstyle_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scriptscriptstyle_macro
    org.scilab.forge.jlatexmath.Atom rotatebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rotatebox_macro
    org.scilab.forge.jlatexmath.Atom reflectbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> reflectbox_macro
    org.scilab.forge.jlatexmath.Atom scalebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> scalebox_macro
    org.scilab.forge.jlatexmath.Atom resizebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> resizebox_macro
    org.scilab.forge.jlatexmath.Atom raisebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> raisebox_macro
    org.scilab.forge.jlatexmath.Atom shadowbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> shadowbox_macro
    org.scilab.forge.jlatexmath.Atom ovalbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ovalbox_macro
    org.scilab.forge.jlatexmath.Atom doublebox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> doublebox_macro
    org.scilab.forge.jlatexmath.Atom definecolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> definecolor_macro
    org.scilab.forge.jlatexmath.Atom fgcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fgcolor_macro
    org.scilab.forge.jlatexmath.Atom bgcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> bgcolor_macro
    org.scilab.forge.jlatexmath.Atom textcolor_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textcolor_macro
    org.scilab.forge.jlatexmath.Atom colorbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colorbox_macro
    org.scilab.forge.jlatexmath.Atom fcolorbox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> fcolorbox_macro
    org.scilab.forge.jlatexmath.Atom cong_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> cong_macro
    org.scilab.forge.jlatexmath.Atom doteq_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> doteq_macro
    org.scilab.forge.jlatexmath.Atom jlmDynamic_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmDynamic_macro
    org.scilab.forge.jlatexmath.Atom jlmExternalFont_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmExternalFont_macro
    org.scilab.forge.jlatexmath.Atom jlmText_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmText_macro
    org.scilab.forge.jlatexmath.Atom jlmTextit_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextit_macro
    org.scilab.forge.jlatexmath.Atom jlmTextbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextbf_macro
    org.scilab.forge.jlatexmath.Atom jlmTextitbf_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmTextitbf_macro
    org.scilab.forge.jlatexmath.Atom DeclareMathSizes_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> DeclareMathSizes_macro
    org.scilab.forge.jlatexmath.Atom magnification_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> magnification_macro
    org.scilab.forge.jlatexmath.Atom hline_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hline_macro
    org.scilab.forge.jlatexmath.Atom size_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> size_macros
    org.scilab.forge.jlatexmath.Atom jlatexmathcumsup_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlatexmathcumsup_macro
    org.scilab.forge.jlatexmath.Atom jlatexmathcumsub_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlatexmathcumsub_macro
    org.scilab.forge.jlatexmath.Atom dotminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> dotminus_macro
    org.scilab.forge.jlatexmath.Atom ratio_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> ratio_macro
    org.scilab.forge.jlatexmath.Atom geoprop_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> geoprop_macro
    org.scilab.forge.jlatexmath.Atom minuscolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> minuscolon_macro
    org.scilab.forge.jlatexmath.Atom minuscoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> minuscoloncolon_macro
    org.scilab.forge.jlatexmath.Atom simcolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> simcolon_macro
    org.scilab.forge.jlatexmath.Atom simcoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> simcoloncolon_macro
    org.scilab.forge.jlatexmath.Atom approxcolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> approxcolon_macro
    org.scilab.forge.jlatexmath.Atom approxcoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> approxcoloncolon_macro
    org.scilab.forge.jlatexmath.Atom equalscolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> equalscolon_macro
    org.scilab.forge.jlatexmath.Atom equalscoloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> equalscoloncolon_macro
    org.scilab.forge.jlatexmath.Atom colonminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonminus_macro
    org.scilab.forge.jlatexmath.Atom coloncolonminus_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonminus_macro
    org.scilab.forge.jlatexmath.Atom colonequals_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonequals_macro
    org.scilab.forge.jlatexmath.Atom coloncolonequals_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonequals_macro
    org.scilab.forge.jlatexmath.Atom coloncolon_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolon_macro
    org.scilab.forge.jlatexmath.Atom colonsim_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonsim_macro
    org.scilab.forge.jlatexmath.Atom coloncolonsim_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonsim_macro
    org.scilab.forge.jlatexmath.Atom colonapprox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> colonapprox_macro
    org.scilab.forge.jlatexmath.Atom coloncolonapprox_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> coloncolonapprox_macro
    org.scilab.forge.jlatexmath.Atom smallfrowneq_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> smallfrowneq_macro
    org.scilab.forge.jlatexmath.Atom hstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> hstrok_macro
    org.scilab.forge.jlatexmath.Atom Hstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Hstrok_macro
    org.scilab.forge.jlatexmath.Atom dstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> dstrok_macro
    org.scilab.forge.jlatexmath.Atom Dstrok_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> Dstrok_macro
    org.scilab.forge.jlatexmath.Atom kern_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> kern_macro
    org.scilab.forge.jlatexmath.Atom char_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> char_macro
    org.scilab.forge.jlatexmath.Atom T_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> T_macro
    org.scilab.forge.jlatexmath.Atom romannumeral_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> romannumeral_macro
    org.scilab.forge.jlatexmath.Atom textcircled_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textcircled_macro
    org.scilab.forge.jlatexmath.Atom textsc_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> textsc_macro
    org.scilab.forge.jlatexmath.Atom sc_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> sc_macro
    org.scilab.forge.jlatexmath.Atom quad_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> quad_macro
    org.scilab.forge.jlatexmath.Atom muskip_macros(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> muskip_macros
    org.scilab.forge.jlatexmath.Atom surd_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> surd_macro
    org.scilab.forge.jlatexmath.Atom int_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> int_macro
    org.scilab.forge.jlatexmath.Atom oint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> oint_macro
    org.scilab.forge.jlatexmath.Atom iint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iint_macro
    org.scilab.forge.jlatexmath.Atom iiint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iiint_macro
    org.scilab.forge.jlatexmath.Atom iiiint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> iiiint_macro
    org.scilab.forge.jlatexmath.Atom idotsint_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> idotsint_macro
    org.scilab.forge.jlatexmath.Atom lmoustache_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> lmoustache_macro
    org.scilab.forge.jlatexmath.Atom rmoustache_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> rmoustache_macro
    org.scilab.forge.jlatexmath.Atom insertBreakMark_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> insertBreakMark_macro
    org.scilab.forge.jlatexmath.Atom jlmXML_macro(org.scilab.forge.jlatexmath.TeXParser,java.lang.String[]) -> jlmXML_macro
org.scilab.forge.jlatexmath.PredefinedCommands -> org.scilab.forge.jlatexmath.PredefinedCommands:
org.scilab.forge.jlatexmath.PredefinedTeXFormulaParser -> org.scilab.forge.jlatexmath.PredefinedTeXFormulaParser:
    org.w3c.dom.Element root -> a
    java.lang.String type -> a
    void parse(java.util.Map) -> parse
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.PredefinedTeXFormulas -> org.scilab.forge.jlatexmath.PredefinedTeXFormulas:
org.scilab.forge.jlatexmath.RaiseAtom -> org.scilab.forge.jlatexmath.RaiseAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    int runit -> d
    int hunit -> e
    int dunit -> f
    float r -> a
    float h -> b
    float d -> c
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ReflectAtom -> org.scilab.forge.jlatexmath.ReflectAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ReflectBox -> org.scilab.forge.jlatexmath.ReflectBox:
    org.scilab.forge.jlatexmath.Box box -> c
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.ResizeAtom -> org.scilab.forge.jlatexmath.ResizeAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    int wunit -> d
    int hunit -> e
    float w -> a
    float h -> b
    boolean keepaspectratio -> a
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ResourceParseException -> org.scilab.forge.jlatexmath.ResourceParseException:
org.scilab.forge.jlatexmath.RomanAtom -> org.scilab.forge.jlatexmath.RomanAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.RotateAtom -> org.scilab.forge.jlatexmath.RotateAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    double angle -> a
    int option -> d
    int xunit -> e
    int yunit -> f
    float x -> a
    float y -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.RotateBox -> org.scilab.forge.jlatexmath.RotateBox:
    double angle -> a
    org.scilab.forge.jlatexmath.Box box -> c
    float xmax -> e
    float xmin -> f
    float ymax -> g
    float ymin -> h
    float shiftX -> i
    float shiftY -> j
    int getOrigin(java.lang.String) -> getOrigin
    java.awt.geom.Point2D$Float calculateShift(org.scilab.forge.jlatexmath.Box,int) -> calculateShift
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.Row -> org.scilab.forge.jlatexmath.Row:
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
org.scilab.forge.jlatexmath.RowAtom -> org.scilab.forge.jlatexmath.RowAtom:
    java.util.LinkedList elements -> a
    boolean lookAtLastAtom -> a
    org.scilab.forge.jlatexmath.Dummy previousAtom -> a
    java.util.BitSet binSet -> a
    java.util.BitSet ligKernSet -> b
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    void add(org.scilab.forge.jlatexmath.Atom) -> add
    void changeToOrd(org.scilab.forge.jlatexmath.Dummy,org.scilab.forge.jlatexmath.Dummy,org.scilab.forge.jlatexmath.Atom) -> changeToOrd
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    void setPreviousAtom(org.scilab.forge.jlatexmath.Dummy) -> setPreviousAtom
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.RuleAtom -> org.scilab.forge.jlatexmath.RuleAtom:
    int wunit -> d
    int hunit -> e
    int runit -> f
    float w -> a
    float h -> b
    float r -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ScaleAtom -> org.scilab.forge.jlatexmath.ScaleAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    double xscl -> a
    double yscl -> b
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ScaleBox -> org.scilab.forge.jlatexmath.ScaleBox:
    org.scilab.forge.jlatexmath.Box box -> c
    double xscl -> a
    double yscl -> b
    float factor -> e
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.ScriptsAtom -> org.scilab.forge.jlatexmath.ScriptsAtom:
    org.scilab.forge.jlatexmath.SpaceAtom SCRIPT_SPACE -> a
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom subscript -> b
    org.scilab.forge.jlatexmath.Atom superscript -> c
    int align -> d
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.ShadowAtom -> org.scilab.forge.jlatexmath.ShadowAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.ShadowBox -> org.scilab.forge.jlatexmath.ShadowBox:
    float shadowRule -> g
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.SmallCapAtom -> org.scilab.forge.jlatexmath.SmallCapAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SmashedAtom -> org.scilab.forge.jlatexmath.SmashedAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    boolean h -> a
    boolean d -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SpaceAtom -> org.scilab.forge.jlatexmath.SpaceAtom:
    java.util.Map units -> a
    org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion[] unitConversions -> a
    boolean blankSpace -> a
    int blankType -> d
    float width -> a
    float height -> b
    float depth -> c
    int wUnit -> e
    int hUnit -> f
    int dUnit -> g
    void checkUnit(int) -> checkUnit
    int getUnit(java.lang.String) -> getUnit
    float[] getLength(java.lang.String) -> getLength
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    float getFactor(int,org.scilab.forge.jlatexmath.TeXEnvironment) -> getFactor
org.scilab.forge.jlatexmath.SpaceAtom$1 -> org.scilab.forge.jlatexmath.SpaceAtom$1:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$10 -> org.scilab.forge.jlatexmath.SpaceAtom$10:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$11 -> org.scilab.forge.jlatexmath.SpaceAtom$11:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$12 -> org.scilab.forge.jlatexmath.SpaceAtom$12:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$13 -> org.scilab.forge.jlatexmath.SpaceAtom$13:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$2 -> org.scilab.forge.jlatexmath.SpaceAtom$2:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$3 -> org.scilab.forge.jlatexmath.SpaceAtom$3:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$4 -> org.scilab.forge.jlatexmath.SpaceAtom$4:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$5 -> org.scilab.forge.jlatexmath.SpaceAtom$5:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$6 -> org.scilab.forge.jlatexmath.SpaceAtom$6:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$7 -> org.scilab.forge.jlatexmath.SpaceAtom$7:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$8 -> org.scilab.forge.jlatexmath.SpaceAtom$8:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$9 -> org.scilab.forge.jlatexmath.SpaceAtom$9:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion -> org.scilab.forge.jlatexmath.SpaceAtom$UnitConversion:
    float getPixelConversion(org.scilab.forge.jlatexmath.TeXEnvironment) -> getPixelConversion
org.scilab.forge.jlatexmath.SsAtom -> org.scilab.forge.jlatexmath.SsAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.StrutBox -> org.scilab.forge.jlatexmath.StrutBox:
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.StyleAtom -> org.scilab.forge.jlatexmath.StyleAtom:
    int style -> d
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.SymbolAtom -> org.scilab.forge.jlatexmath.SymbolAtom:
    boolean delimiter -> a
    java.lang.String name -> a
    java.util.Map symbols -> a
    java.util.BitSet validSymbolTypes -> a
    char unicode -> a
    org.scilab.forge.jlatexmath.SymbolAtom setUnicode(char) -> setUnicode
    char getUnicode() -> getUnicode
    void addSymbolAtom(java.lang.String) -> addSymbolAtom
    void addSymbolAtom(java.io.InputStream,java.lang.String) -> addSymbolAtom
    void addSymbolAtom(org.scilab.forge.jlatexmath.SymbolAtom) -> addSymbolAtom
    org.scilab.forge.jlatexmath.SymbolAtom get(java.lang.String) -> get
    boolean isDelimiter() -> isDelimiter
    java.lang.String getName() -> getName
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.CharFont getCharFont(org.scilab.forge.jlatexmath.TeXFont) -> getCharFont
org.scilab.forge.jlatexmath.SymbolMappingNotFoundException -> org.scilab.forge.jlatexmath.SymbolMappingNotFoundException:
org.scilab.forge.jlatexmath.SymbolNotFoundException -> org.scilab.forge.jlatexmath.SymbolNotFoundException:
org.scilab.forge.jlatexmath.TStrokeAtom -> org.scilab.forge.jlatexmath.TStrokeAtom:
    boolean upper -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TeXConstants -> org.scilab.forge.jlatexmath.TeXConstants:
org.scilab.forge.jlatexmath.TeXEnvironment -> org.scilab.forge.jlatexmath.TeXEnvironment:
    java.awt.Color background -> a
    java.awt.Color color -> b
    int style -> a
    org.scilab.forge.jlatexmath.TeXFont tf -> a
    int lastFontId -> b
    float textwidth -> a
    java.lang.String textStyle -> a
    boolean smallCap -> b
    float scaleFactor -> b
    boolean isColored -> a
    void setTextwidth(int,float) -> setTextwidth
    float getTextwidth() -> getTextwidth
    void setScaleFactor(float) -> setScaleFactor
    float getScaleFactor() -> getScaleFactor
    org.scilab.forge.jlatexmath.TeXEnvironment copy() -> copy
    org.scilab.forge.jlatexmath.TeXEnvironment copy(org.scilab.forge.jlatexmath.TeXFont) -> copy
    org.scilab.forge.jlatexmath.TeXEnvironment crampStyle() -> crampStyle
    org.scilab.forge.jlatexmath.TeXEnvironment denomStyle() -> denomStyle
    java.awt.Color getBackground() -> getBackground
    java.awt.Color getColor() -> getColor
    float getSize() -> getSize
    int getStyle() -> getStyle
    void setStyle(int) -> setStyle
    java.lang.String getTextStyle() -> getTextStyle
    void setTextStyle(java.lang.String) -> setTextStyle
    boolean getSmallCap() -> getSmallCap
    void setSmallCap(boolean) -> setSmallCap
    org.scilab.forge.jlatexmath.TeXFont getTeXFont() -> getTeXFont
    org.scilab.forge.jlatexmath.TeXEnvironment numStyle() -> numStyle
    void reset() -> reset
    org.scilab.forge.jlatexmath.TeXEnvironment rootStyle() -> rootStyle
    void setBackground(java.awt.Color) -> setBackground
    void setColor(java.awt.Color) -> setColor
    org.scilab.forge.jlatexmath.TeXEnvironment subStyle() -> subStyle
    org.scilab.forge.jlatexmath.TeXEnvironment supStyle() -> supStyle
    float getSpace() -> getSpace
    void setLastFontId(int) -> setLastFontId
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.TeXFont -> org.scilab.forge.jlatexmath.TeXFont:
    org.scilab.forge.jlatexmath.TeXFont deriveFont(float) -> deriveFont
    org.scilab.forge.jlatexmath.TeXFont scaleFont(float) -> scaleFont
    float getScaleFactor() -> getScaleFactor
    float getAxisHeight(int) -> getAxisHeight
    float getBigOpSpacing1(int) -> getBigOpSpacing1
    float getBigOpSpacing2(int) -> getBigOpSpacing2
    float getBigOpSpacing3(int) -> getBigOpSpacing3
    float getBigOpSpacing4(int) -> getBigOpSpacing4
    float getBigOpSpacing5(int) -> getBigOpSpacing5
    org.scilab.forge.jlatexmath.Char getChar(char,java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(org.scilab.forge.jlatexmath.CharFont,int) -> getChar
    org.scilab.forge.jlatexmath.Char getChar(java.lang.String,int) -> getChar
    org.scilab.forge.jlatexmath.Char getDefaultChar(char,int) -> getDefaultChar
    float getDefaultRuleThickness(int) -> getDefaultRuleThickness
    float getDenom1(int) -> getDenom1
    float getDenom2(int) -> getDenom2
    org.scilab.forge.jlatexmath.Extension getExtension(org.scilab.forge.jlatexmath.Char,int) -> getExtension
    float getKern(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont,int) -> getKern
    org.scilab.forge.jlatexmath.CharFont getLigature(org.scilab.forge.jlatexmath.CharFont,org.scilab.forge.jlatexmath.CharFont) -> getLigature
    int getMuFontId() -> getMuFontId
    org.scilab.forge.jlatexmath.Char getNextLarger(org.scilab.forge.jlatexmath.Char,int) -> getNextLarger
    float getNum1(int) -> getNum1
    float getNum2(int) -> getNum2
    float getNum3(int) -> getNum3
    float getQuad(int,int) -> getQuad
    float getSize() -> getSize
    float getSkew(org.scilab.forge.jlatexmath.CharFont,int) -> getSkew
    float getSpace(int) -> getSpace
    float getSub1(int) -> getSub1
    float getSub2(int) -> getSub2
    float getSubDrop(int) -> getSubDrop
    float getSup1(int) -> getSup1
    float getSup2(int) -> getSup2
    float getSup3(int) -> getSup3
    float getSupDrop(int) -> getSupDrop
    float getXHeight(int,int) -> getXHeight
    boolean hasNextLarger(org.scilab.forge.jlatexmath.Char) -> hasNextLarger
    boolean hasSpace(int) -> hasSpace
    void setBold(boolean) -> setBold
    boolean getBold() -> getBold
    void setRoman(boolean) -> setRoman
    boolean getRoman() -> getRoman
    void setTt(boolean) -> setTt
    boolean getTt() -> getTt
    void setIt(boolean) -> setIt
    boolean getIt() -> getIt
    void setSs(boolean) -> setSs
    boolean getSs() -> getSs
    boolean isExtensionChar(org.scilab.forge.jlatexmath.Char) -> isExtensionChar
    org.scilab.forge.jlatexmath.TeXFont copy() -> copy
org.scilab.forge.jlatexmath.TeXFormula -> org.scilab.forge.jlatexmath.TeXFormula:
    java.lang.String[][] delimiterNames -> a
    float PIXELS_PER_POINT -> a
    java.util.Map predefinedTeXFormulas -> a
    java.util.Map predefinedTeXFormulasAsString -> b
    java.lang.String[] symbolMappings -> a
    java.lang.String[] symbolTextMappings -> b
    java.lang.String[] symbolFormulaMappings -> c
    java.util.Map externalFontMap -> c
    java.util.List middle -> a
    java.util.Map jlmXMLMap -> d
    org.scilab.forge.jlatexmath.TeXParser parser -> a
    org.scilab.forge.jlatexmath.Atom root -> a
    java.lang.String textStyle -> a
    boolean isColored -> a
    void addSymbolMappings(java.lang.String) -> addSymbolMappings
    void addSymbolMappings(java.io.InputStream,java.lang.String) -> addSymbolMappings
    void registerExternalFont(java.lang.Character$UnicodeBlock,java.lang.String,java.lang.String) -> registerExternalFont
    void registerExternalFont(java.lang.Character$UnicodeBlock,java.lang.String) -> registerExternalFont
    void setDPITarget(float) -> setDPITarget
    void setDefaultDPI() -> setDefaultDPI
    org.scilab.forge.jlatexmath.TeXFormula getPartialTeXFormula(java.lang.String) -> getPartialTeXFormula
    void registerFonts(boolean) -> registerFonts
    void setLaTeX(java.lang.String) -> setLaTeX
    org.scilab.forge.jlatexmath.TeXFormula add(org.scilab.forge.jlatexmath.Atom) -> add
    org.scilab.forge.jlatexmath.TeXFormula add(java.lang.String) -> add
    org.scilab.forge.jlatexmath.TeXFormula append(java.lang.String) -> append
    org.scilab.forge.jlatexmath.TeXFormula append(boolean,java.lang.String) -> append
    org.scilab.forge.jlatexmath.TeXFormula add(org.scilab.forge.jlatexmath.TeXFormula) -> add
    void addImpl(org.scilab.forge.jlatexmath.TeXFormula) -> addImpl
    void setLookAtLastAtom(boolean) -> setLookAtLastAtom
    boolean getLookAtLastAtom() -> getLookAtLastAtom
    org.scilab.forge.jlatexmath.TeXFormula centerOnAxis() -> centerOnAxis
    void addPredefinedTeXFormula(java.io.InputStream) -> addPredefinedTeXFormula
    void addPredefinedCommands(java.io.InputStream) -> addPredefinedCommands
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int,float,float,float) -> addStrut
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int) -> addStrut
    org.scilab.forge.jlatexmath.TeXFormula addStrut(int,float,int,float,int,float) -> addStrut
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.DefaultTeXFont createFont(float,int) -> createFont
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,java.awt.Color) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,boolean) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,int,float,int) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,float,int,int,float) -> createTeXIcon
    org.scilab.forge.jlatexmath.TeXIcon createTeXIcon(int,float,int,int,float,int,int,float) -> createTeXIcon
    void createImage(java.lang.String,int,float,java.lang.String,java.awt.Color,java.awt.Color,boolean) -> createImage
    void createPNG(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createPNG
    void createGIF(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createGIF
    void createJPEG(int,float,java.lang.String,java.awt.Color,java.awt.Color) -> createJPEG
    java.awt.Image createBufferedImage(java.lang.String,int,float,java.awt.Color,java.awt.Color) -> createBufferedImage
    java.awt.Image createBufferedImage(int,float,java.awt.Color,java.awt.Color) -> createBufferedImage
    void setDEBUG(boolean) -> setDEBUG
    org.scilab.forge.jlatexmath.TeXFormula setBackground(java.awt.Color) -> setBackground
    org.scilab.forge.jlatexmath.TeXFormula setColor(java.awt.Color) -> setColor
    org.scilab.forge.jlatexmath.TeXFormula setFixedTypes(int,int) -> setFixedTypes
    org.scilab.forge.jlatexmath.TeXFormula get(java.lang.String) -> get
org.scilab.forge.jlatexmath.TeXFormula$FontInfos -> org.scilab.forge.jlatexmath.TeXFormula$FontInfos:
    java.lang.String sansserif -> a
    java.lang.String serif -> b
org.scilab.forge.jlatexmath.TeXFormulaParser -> org.scilab.forge.jlatexmath.TeXFormulaParser:
    java.util.Map classMappings -> a
    java.util.Map argValueParsers -> b
    java.util.Map actionParsers -> c
    java.util.Map tempFormulas -> d
    java.util.Map tempCommands -> e
    java.lang.Object result -> a
    java.lang.String formulaName -> a
    org.w3c.dom.Element formula -> a
    int type -> a
    java.lang.Object parse() -> parse
    java.lang.Object[] getArgumentValues(org.w3c.dom.NodeList) -> getArgumentValues
    java.lang.Class[] getArgumentClasses(org.w3c.dom.NodeList) -> getArgumentClasses
    void checkNullValue(java.lang.String,java.lang.String) -> checkNullValue
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
    java.lang.String access$000(java.lang.String,org.w3c.dom.Element) -> access$000
    java.util.Map access$100(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$100
    java.lang.Class[] access$200(org.w3c.dom.NodeList) -> access$200
    java.lang.Object[] access$300(org.scilab.forge.jlatexmath.TeXFormulaParser,org.w3c.dom.NodeList) -> access$300
    java.lang.String access$400(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$400
    java.util.Map access$500(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$500
    void access$600(java.lang.String,java.lang.String) -> access$600
    int access$700(org.scilab.forge.jlatexmath.TeXFormulaParser) -> access$700
    java.lang.Object access$802(org.scilab.forge.jlatexmath.TeXFormulaParser,java.lang.Object) -> access$802
org.scilab.forge.jlatexmath.TeXFormulaParser$ActionParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ActionParser:
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$ArgumentValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ArgumentValueParser:
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$BooleanValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$BooleanValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$CharValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CharValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$ColorConstantValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ColorConstantValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$CreateCommandParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CreateCommandParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$CreateTeXFormulaParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$CreateTeXFormulaParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$FloatValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$FloatValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$IntValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$IntValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$MethodInvocationParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$MethodInvocationParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$ReturnParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$ReturnParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    void parse(org.w3c.dom.Element) -> parse
org.scilab.forge.jlatexmath.TeXFormulaParser$StringValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$StringValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$TeXConstantsValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$TeXConstantsValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaParser$TeXFormulaValueParser -> org.scilab.forge.jlatexmath.TeXFormulaParser$TeXFormulaValueParser:
    org.scilab.forge.jlatexmath.TeXFormulaParser this$0 -> a
    java.lang.Object parseValue(java.lang.String,java.lang.String) -> parseValue
org.scilab.forge.jlatexmath.TeXFormulaSettingsParser -> org.scilab.forge.jlatexmath.TeXFormulaSettingsParser:
    org.w3c.dom.Element root -> a
    void parseSymbolToFormulaMappings(java.lang.String[],java.lang.String[]) -> parseSymbolToFormulaMappings
    void parseSymbolMappings(java.lang.String[],java.lang.String[]) -> parseSymbolMappings
    void addToMap(org.w3c.dom.NodeList,java.lang.String[],java.lang.String[]) -> addToMap
    void addFormulaToMap(org.w3c.dom.NodeList,java.lang.String[],java.lang.String[]) -> addFormulaToMap
org.scilab.forge.jlatexmath.TeXIcon -> org.scilab.forge.jlatexmath.TeXIcon:
    java.awt.Color defaultColor -> a
    float defaultSize -> a
    float magFactor -> b
    org.scilab.forge.jlatexmath.Box box -> a
    float size -> c
    java.awt.Insets insets -> a
    java.awt.Color fg -> b
    boolean isColored -> a
    void setForeground(java.awt.Color) -> setForeground
    java.awt.Insets getInsets() -> getInsets
    void setInsets(java.awt.Insets,boolean) -> setInsets
    void setInsets(java.awt.Insets) -> setInsets
    void setIconWidth(int,int) -> setIconWidth
    void setIconHeight(int,int) -> setIconHeight
    int getIconHeight() -> getIconHeight
    int getIconDepth() -> getIconDepth
    int getIconWidth() -> getIconWidth
    float getTrueIconHeight() -> getTrueIconHeight
    float getTrueIconDepth() -> getTrueIconDepth
    float getTrueIconWidth() -> getTrueIconWidth
    float getBaseLine() -> getBaseLine
    org.scilab.forge.jlatexmath.Box getBox() -> getBox
    void paintIcon(java.awt.Component,java.awt.Graphics,int,int) -> paintIcon
org.scilab.forge.jlatexmath.TeXParser -> org.scilab.forge.jlatexmath.TeXParser:
    org.scilab.forge.jlatexmath.TeXFormula formula -> a
    java.lang.StringBuffer parseString -> a
    int pos -> a
    int spos -> b
    int line -> c
    int col -> d
    int len -> e
    int group -> f
    boolean insertion -> b
    int atIsLetter -> g
    boolean arrayMode -> c
    boolean ignoreWhiteSpace -> d
    boolean isPartial -> e
    boolean isLoading -> a
    java.util.Set unparsedContents -> a
    void reset(java.lang.String) -> reset
    boolean getIsPartial() -> getIsPartial
    int getLine() -> getLine
    int getCol() -> getCol
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    org.scilab.forge.jlatexmath.Atom getFormulaAtom() -> getFormulaAtom
    void addAtom(org.scilab.forge.jlatexmath.Atom) -> addAtom
    void makeAtLetter() -> makeAtLetter
    void makeAtOther() -> makeAtOther
    boolean isAtLetter() -> isAtLetter
    boolean isArrayMode() -> isArrayMode
    boolean isIgnoreWhiteSpace() -> isIgnoreWhiteSpace
    boolean isMathMode() -> isMathMode
    int getPos() -> getPos
    int rewind(int) -> rewind
    void addRow() -> addRow
    void firstpass() -> firstpass
    void parse() -> parse
    org.scilab.forge.jlatexmath.Atom getScripts(char) -> getScripts
    java.lang.String getDollarGroup(char) -> getDollarGroup
    java.lang.String getGroup(char,char) -> getGroup
    java.lang.String getGroup(java.lang.String,java.lang.String) -> getGroup
    org.scilab.forge.jlatexmath.Atom getArgument() -> getArgument
    java.lang.String getOverArgument() -> getOverArgument
    float[] getLength() -> getLength
    org.scilab.forge.jlatexmath.Atom convertCharacter(char,boolean) -> convertCharacter
    java.lang.String getCommand() -> getCommand
    org.scilab.forge.jlatexmath.Atom processEscape() -> processEscape
    void insert(int,int,java.lang.String) -> insert
    java.lang.String[] getOptsArgs(int,int) -> getOptsArgs
    java.lang.String getCommandWithArgs(java.lang.String) -> getCommandWithArgs
    org.scilab.forge.jlatexmath.Atom processCommands(java.lang.String) -> processCommands
    boolean isValidName(java.lang.String) -> isValidName
    boolean isValidCharacterInCommand(char) -> isValidCharacterInCommand
    void skipWhiteSpace() -> skipWhiteSpace
    char convertToRomanNumber(char) -> convertToRomanNumber
org.scilab.forge.jlatexmath.TeXSymbolParser -> org.scilab.forge.jlatexmath.TeXSymbolParser:
    java.util.Map typeMappings -> a
    org.w3c.dom.Element root -> a
    java.util.Map readSymbols() -> readSymbols
    void setTypeMappings() -> setTypeMappings
    java.lang.String getAttrValueAndCheckIfNotNull(java.lang.String,org.w3c.dom.Element) -> getAttrValueAndCheckIfNotNull
org.scilab.forge.jlatexmath.TextCircledAtom -> org.scilab.forge.jlatexmath.TextCircledAtom:
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TextStyleAtom -> org.scilab.forge.jlatexmath.TextStyleAtom:
    java.lang.String style -> a
    org.scilab.forge.jlatexmath.Atom at -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TextStyleMappingNotFoundException -> org.scilab.forge.jlatexmath.TextStyleMappingNotFoundException:
org.scilab.forge.jlatexmath.TtAtom -> org.scilab.forge.jlatexmath.TtAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.TypedAtom -> org.scilab.forge.jlatexmath.TypedAtom:
    int leftType -> d
    int rightType -> e
    org.scilab.forge.jlatexmath.Atom atom -> a
    org.scilab.forge.jlatexmath.Atom getBase() -> getBase
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.URLAlphabetRegistration -> org.scilab.forge.jlatexmath.URLAlphabetRegistration:
    java.net.URL url -> a
    java.lang.String language -> a
    org.scilab.forge.jlatexmath.AlphabetRegistration pack -> a
    java.lang.Character$UnicodeBlock[] blocks -> c
    void register(java.net.URL,java.lang.String,java.lang.Character$UnicodeBlock[]) -> register
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.UnderOverArrowAtom -> org.scilab.forge.jlatexmath.UnderOverArrowAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    java.lang.String arrow -> a
    boolean over -> a
    boolean left -> b
    boolean dble -> c
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.UnderOverAtom -> org.scilab.forge.jlatexmath.UnderOverAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Atom under -> b
    org.scilab.forge.jlatexmath.Atom over -> c
    float underSpace -> a
    float overSpace -> b
    int underUnit -> d
    int overUnit -> e
    boolean underScriptSize -> a
    boolean overScriptSize -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
    org.scilab.forge.jlatexmath.Box changeWidth(org.scilab.forge.jlatexmath.Box,float) -> changeWidth
    int getLeftType() -> getLeftType
    int getRightType() -> getRightType
org.scilab.forge.jlatexmath.UnderlinedAtom -> org.scilab.forge.jlatexmath.UnderlinedAtom:
    org.scilab.forge.jlatexmath.Atom base -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.UnderscoreAtom -> org.scilab.forge.jlatexmath.UnderscoreAtom:
    org.scilab.forge.jlatexmath.SpaceAtom w -> a
    org.scilab.forge.jlatexmath.SpaceAtom s -> b
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VCenteredAtom -> org.scilab.forge.jlatexmath.VCenteredAtom:
    org.scilab.forge.jlatexmath.Atom atom -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VRowAtom -> org.scilab.forge.jlatexmath.VRowAtom:
    java.util.LinkedList elements -> a
    org.scilab.forge.jlatexmath.SpaceAtom raise -> a
    void setRaise(int,float) -> setRaise
    org.scilab.forge.jlatexmath.Atom getLastAtom() -> getLastAtom
    void add(org.scilab.forge.jlatexmath.Atom) -> add
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VdotsAtom -> org.scilab.forge.jlatexmath.VdotsAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.VerticalBox -> org.scilab.forge.jlatexmath.VerticalBox:
    float leftMostPos -> e
    float rightMostPos -> f
    void add(org.scilab.forge.jlatexmath.Box) -> add
    void add(org.scilab.forge.jlatexmath.Box,float) -> add
    void recalculateWidth(org.scilab.forge.jlatexmath.Box) -> recalculateWidth
    void add(int,org.scilab.forge.jlatexmath.Box) -> add
    void draw(java.awt.Graphics2D,float,float) -> draw
    int getSize() -> getSize
    int getLastFontId() -> getLastFontId
org.scilab.forge.jlatexmath.VlineAtom -> org.scilab.forge.jlatexmath.VlineAtom:
    float height -> a
    float shift -> b
    int n -> d
    void setHeight(float) -> setHeight
    void setShift(float) -> setShift
    float getWidth(org.scilab.forge.jlatexmath.TeXEnvironment) -> getWidth
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.WebStartAlphabetRegistration -> org.scilab.forge.jlatexmath.WebStartAlphabetRegistration:
    java.lang.Character$UnicodeBlock[] blocks -> c
    org.scilab.forge.jlatexmath.AlphabetRegistration reg -> a
    void register(java.lang.Character$UnicodeBlock[]) -> register
    java.lang.Character$UnicodeBlock[] getUnicodeBlock() -> getUnicodeBlock
    java.lang.Object getPackage() -> getPackage
    java.lang.String getTeXFontFileName() -> getTeXFontFileName
org.scilab.forge.jlatexmath.XArrowAtom -> org.scilab.forge.jlatexmath.XArrowAtom:
    org.scilab.forge.jlatexmath.Atom over -> a
    org.scilab.forge.jlatexmath.Atom under -> b
    boolean left -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.XLeftRightArrowFactory -> org.scilab.forge.jlatexmath.XLeftRightArrowFactory:
    org.scilab.forge.jlatexmath.Atom MINUS -> a
    org.scilab.forge.jlatexmath.Atom LEFT -> b
    org.scilab.forge.jlatexmath.Atom RIGHT -> c
    org.scilab.forge.jlatexmath.Box create(boolean,org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
    org.scilab.forge.jlatexmath.Box create(org.scilab.forge.jlatexmath.TeXEnvironment,float) -> create
org.scilab.forge.jlatexmath.XMLResourceParseException -> org.scilab.forge.jlatexmath.XMLResourceParseException:
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache -> org.scilab.forge.jlatexmath.a.a:
    java.awt.geom.AffineTransform identity -> a
    java.util.concurrent.ConcurrentMap cache -> a
    int max -> a
    java.lang.ref.ReferenceQueue queue -> a
    void setMaxCachedObjects(int) -> a
    int[] getCachedTeXFormulaDimensions(java.lang.Object) -> a
    java.lang.Object getCachedTeXFormula(java.lang.String,int,int,int,int,java.awt.Color) -> a
    void clearCache() -> a
    void removeCachedTeXFormula(java.lang.Object) -> a
    java.awt.Image getCachedTeXFormulaImage(java.lang.Object) -> a
    java.lang.ref.SoftReference makeImage(org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula) -> a
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedImage -> org.scilab.forge.jlatexmath.a.a$a:
    java.awt.Image image -> a
    org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula cachedTf -> a
org.scilab.forge.jlatexmath.cache.JLaTeXMathCache$CachedTeXFormula -> org.scilab.forge.jlatexmath.a.a$b:
    java.lang.String f -> a
    int style -> a
    int type -> b
    int size -> c
    int inset -> d
    int width -> e
    int height -> f
    int depth -> g
    java.awt.Color fgcolor -> a
    void setDimensions(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.scilab.forge.jlatexmath.dynamic.DynamicAtom -> org.scilab.forge.jlatexmath.b.a:
    org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory ecFactory -> a
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter converter -> a
    org.scilab.forge.jlatexmath.TeXFormula formula -> a
    java.lang.String externalCode -> a
    boolean insert -> a
    boolean refreshed -> b
    boolean hasAnExternalConverterFactory() -> a
    void setExternalConverterFactory(org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory) -> a
    boolean getInsertMode() -> b
    org.scilab.forge.jlatexmath.Atom getAtom() -> a
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
org.scilab.forge.jlatexmath.dynamic.ExternalConverter -> org.scilab.forge.jlatexmath.b.b:
    java.lang.String getLaTeXString(java.lang.String) -> a
org.scilab.forge.jlatexmath.dynamic.ExternalConverterFactory -> org.scilab.forge.jlatexmath.b.c:
    org.scilab.forge.jlatexmath.dynamic.ExternalConverter getExternalConverter() -> a
org.scilab.forge.jlatexmath.tcaronAtom -> org.scilab.forge.jlatexmath.tcaronAtom:
    org.scilab.forge.jlatexmath.Box createBox(org.scilab.forge.jlatexmath.TeXEnvironment) -> createBox
